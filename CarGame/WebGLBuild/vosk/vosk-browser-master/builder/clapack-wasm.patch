diff --git a/.gitignore b/.gitignore
index eae2c3c..c5874f1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,15 +2,9 @@
 *.f
 *.o
 **/*.rej
-CBLAS/**/*.c
 CLAPACK-3.2.1/INSTALL/test*
-CLAPACK-3.2.1/make.inc
-Makefile.in
-f2c_BLAS-3.8.0/*.c
-f2c_BLAS-3.8.0/make.inc
 libf2c/*.js
 libf2c/*.wasm
-libf2c/Makefile
 libf2c/arith.h
 libf2c/f2c.h
 libf2c/signal1.h
diff --git a/CBLAS/Makefile.in.WASM b/CBLAS/Makefile.in
similarity index 100%
rename from CBLAS/Makefile.in.WASM
rename to CBLAS/Makefile.in
diff --git a/CBLAS/include/cblas.h b/CBLAS/include/cblas.h
index f91557e..80385c1 100644
--- a/CBLAS/include/cblas.h
+++ b/CBLAS/include/cblas.h
@@ -38,12 +38,13 @@ void   cblas_cdotu_sub(const int N, const void *X, const int incX,
                        const void *Y, const int incY, void *dotu);
 void   cblas_cdotc_sub(const int N, const void *X, const int incX,
                        const void *Y, const int incY, void *dotc);
+void   cblas_crotg(void *a, void *b, void *c, void *s);
 
 void   cblas_zdotu_sub(const int N, const void *X, const int incX,
                        const void *Y, const int incY, void *dotu);
 void   cblas_zdotc_sub(const int N, const void *X, const int incX,
                        const void *Y, const int incY, void *dotc);
-
+void   cblas_zrotg(void *a, void *b, void *c, void *s);
 
 /*
  * Functions having prefixes S D SC DZ
diff --git a/CBLAS/include/cblas_f77.h b/CBLAS/include/cblas_f77.h
index 18435cd..7d2c9b6 100644
--- a/CBLAS/include/cblas_f77.h
+++ b/CBLAS/include/cblas_f77.h
@@ -698,4 +698,12 @@ extern "C" {
 }
 #endif
 
+#ifndef doublecomplex
+   typedef struct { double r, i; } doublecomplex;
+#endif
+
+#ifndef complex
+   typedef struct { float r, i; } complex;
+#endif
+
 #endif /*  CBLAS_F77_H */
diff --git a/CBLAS/lib/.empty b/CBLAS/lib/.empty
new file mode 100644
index 0000000..e69de29
diff --git a/CBLAS/src/cblas_cdotc_sub.c b/CBLAS/src/cblas_cdotc_sub.c
index d608681..1f0ec14 100644
--- a/CBLAS/src/cblas_cdotc_sub.c
+++ b/CBLAS/src/cblas_cdotc_sub.c
@@ -9,9 +9,13 @@
  */
 #include "cblas.h"
 #include "cblas_f77.h"
+
 void cblas_cdotc_sub( const int N, const void *X, const int incX,
                     const void *Y, const int incY,void *dotc)
 {
+   extern void cdotc_(complex * ret_val, const int *n, complex *cx,
+      const int *incx, complex *cy, const int *incy);
+
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX, F77_incY=incY;
 #else 
@@ -19,5 +23,6 @@ void cblas_cdotc_sub( const int N, const void *X, const int incX,
    #define F77_incX incX
    #define F77_incY incY
 #endif
-   F77_cdotc_sub( &F77_N, X, &F77_incX, Y, &F77_incY, dotc);
+
+   cdotc_(dotc, &F77_N, X, &F77_incX, Y, &F77_incY);
 }
diff --git a/CBLAS/src/cblas_cdotu_sub.c b/CBLAS/src/cblas_cdotu_sub.c
index d06e4e5..102d2fd 100644
--- a/CBLAS/src/cblas_cdotu_sub.c
+++ b/CBLAS/src/cblas_cdotu_sub.c
@@ -9,9 +9,12 @@
  */
 #include "cblas.h"
 #include "cblas_f77.h"
+
 void cblas_cdotu_sub( const int N, const void *X,
                      const int incX, const void *Y, const int incY,void *dotu)
 {
+   extern void cdotu_(complex * ret_val, const int *n, complex *cx,
+      const int *incx, complex *cy, const int *incy);
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX, F77_incY=incY;
 #else 
@@ -19,5 +22,5 @@ void cblas_cdotu_sub( const int N, const void *X,
    #define F77_incX incX
    #define F77_incY incY
 #endif
-   F77_cdotu_sub( &F77_N, X, &F77_incX, Y, &F77_incY, dotu);
+   cdotu_(dotu, &F77_N, X, &F77_incX, Y, &F77_incY);
 }
diff --git a/CBLAS/src/cblas_crotg.c b/CBLAS/src/cblas_crotg.c
new file mode 100644
index 0000000..bd6ea48
--- /dev/null
+++ b/CBLAS/src/cblas_crotg.c
@@ -0,0 +1,10 @@
+/* Missing cblas_crotg wrapper
+ * author: Mhu
+ */
+
+#include "cblas.h"
+#include "cblas_f77.h"
+void cblas_crotg(void *a, void *b, void *c, void *s) {
+   extern void crotg_(complex *ca, complex *cb, float *C, complex *S);
+   crotg_(a, b, c, s); 
+}
diff --git a/CBLAS/src/cblas_dasum.c b/CBLAS/src/cblas_dasum.c
index 1a3667f..4bb77e2 100644
--- a/CBLAS/src/cblas_dasum.c
+++ b/CBLAS/src/cblas_dasum.c
@@ -9,15 +9,17 @@
  */
 #include "cblas.h"
 #include "cblas_f77.h"
+
 double cblas_dasum( const int N, const double *X, const int incX) 
 {
-   double asum;
+   extern double dasum_(const int *n, const double *dx, const int *incx);
+
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX;
 #else 
    #define F77_N N
    #define F77_incX incX
 #endif
-   F77_dasum_sub( &F77_N, X, &F77_incX, &asum);
-   return asum;
+
+   return dasum_(&F77_N, X, &F77_incX);
 }
diff --git a/CBLAS/src/cblas_ddot.c b/CBLAS/src/cblas_ddot.c
index d773434..9f0d961 100644
--- a/CBLAS/src/cblas_ddot.c
+++ b/CBLAS/src/cblas_ddot.c
@@ -12,7 +12,8 @@
 double cblas_ddot( const int N, const double *X,
                       const int incX, const double *Y, const int incY)
 {
-   double dot;
+   extern double ddot_(const int *n, const double *dx, const int *incx, const double *dy, const int *incy);
+
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX, F77_incY=incY;
 #else 
@@ -20,6 +21,6 @@ double cblas_ddot( const int N, const double *X,
    #define F77_incX incX
    #define F77_incY incY
 #endif
-   F77_ddot_sub( &F77_N, X, &F77_incX, Y, &F77_incY, &dot);
-   return dot;
+
+   return ddot_( &F77_N, X, &F77_incX, Y, &F77_incY);
 }   
diff --git a/CBLAS/src/cblas_dnrm2.c b/CBLAS/src/cblas_dnrm2.c
index fe46ad4..f5b187c 100644
--- a/CBLAS/src/cblas_dnrm2.c
+++ b/CBLAS/src/cblas_dnrm2.c
@@ -11,13 +11,14 @@
 #include "cblas_f77.h"
 double cblas_dnrm2( const int N, const double *X, const int incX) 
 {
-   double nrm2;
+   extern double dnrm2_(const int *n, const double *x, const int *incx);
+
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX;
 #else 
    #define F77_N N
    #define F77_incX incX
 #endif
-   F77_dnrm2_sub( &F77_N, X, &F77_incX, &nrm2);
-   return nrm2;
+
+   return dnrm2_(&F77_N, X, &F77_incX);
 }
diff --git a/CBLAS/src/cblas_dsdot.c b/CBLAS/src/cblas_dsdot.c
index 52cd877..7c886fe 100644
--- a/CBLAS/src/cblas_dsdot.c
+++ b/CBLAS/src/cblas_dsdot.c
@@ -12,7 +12,9 @@
 double  cblas_dsdot( const int N, const float *X,
                       const int incX, const float *Y, const int incY)
 {
-   double dot;
+   extern double dsdot_(const int *n, const float *sx, const int *incx,
+      const float *sy, const int *incy);
+   // double dot;
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX, F77_incY=incY;
 #else 
@@ -20,6 +22,7 @@ double  cblas_dsdot( const int N, const float *X,
    #define F77_incX incX
    #define F77_incY incY
 #endif
-   F77_dsdot_sub( &F77_N, X, &F77_incX, Y, &F77_incY, &dot);
-   return dot;
+   // F77_dsdot_sub( &F77_N, X, &F77_incX, Y, &F77_incY, &dot);
+   // return dot;
+   return dsdot_(&F77_N, X, &F77_incX, Y, &F77_incY);
 }   
diff --git a/CBLAS/src/cblas_dzasum.c b/CBLAS/src/cblas_dzasum.c
index b32f573..f486093 100644
--- a/CBLAS/src/cblas_dzasum.c
+++ b/CBLAS/src/cblas_dzasum.c
@@ -9,15 +9,15 @@
  */
 #include "cblas.h"
 #include "cblas_f77.h"
+
 double cblas_dzasum( const int N, const void *X, const int incX) 
 {
-   double asum;
+   extern double dzasum_(const int *n, doublecomplex *zx, const int *incx);
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX;
 #else 
    #define F77_N N
    #define F77_incX incX
 #endif
-   F77_dzasum_sub( &F77_N, X, &F77_incX, &asum);
-   return asum;
+   return dzasum_(&F77_N, X, &F77_incX);
 }
diff --git a/CBLAS/src/cblas_dznrm2.c b/CBLAS/src/cblas_dznrm2.c
index dfa2bfc..e4f50a0 100644
--- a/CBLAS/src/cblas_dznrm2.c
+++ b/CBLAS/src/cblas_dznrm2.c
@@ -11,13 +11,14 @@
 #include "cblas_f77.h"
 double cblas_dznrm2( const int N, const void *X, const int incX) 
 {
-   double nrm2;
+   extern double dznrm2_(const int *n, doublecomplex *x, const int *incx);
+
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX;
 #else 
    #define F77_N N
    #define F77_incX incX
 #endif
-   F77_dznrm2_sub( &F77_N, X, &F77_incX, &nrm2);
-   return nrm2;
+ 
+   return dznrm2_( &F77_N, X, &F77_incX);
 }
diff --git a/CBLAS/src/cblas_icamax.c b/CBLAS/src/cblas_icamax.c
index f0cdbdb..6ab0aae 100644
--- a/CBLAS/src/cblas_icamax.c
+++ b/CBLAS/src/cblas_icamax.c
@@ -11,13 +11,15 @@
 #include "cblas_f77.h"
 CBLAS_INDEX cblas_icamax( const int N, const void *X, const int incX)
 {
-   int iamax;
+   extern int icamax_(const int *n, complex *cx, const int *incx);
+   
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX;
 #else 
    #define F77_N N
    #define F77_incX incX
 #endif
-   F77_icamax_sub( &F77_N, X, &F77_incX, &iamax);
+
+   int iamax = icamax_(&F77_N, X, &F77_incX);
    return iamax ? iamax-1 : 0;
 }
diff --git a/CBLAS/src/cblas_idamax.c b/CBLAS/src/cblas_idamax.c
index abb70b5..17ebeff 100644
--- a/CBLAS/src/cblas_idamax.c
+++ b/CBLAS/src/cblas_idamax.c
@@ -11,13 +11,13 @@
 #include "cblas_f77.h"
 CBLAS_INDEX cblas_idamax( const int N, const double *X, const int incX)
 {
-   int iamax;
+   extern int idamax_(const int *n, const double *dx, const int *incx);
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX;
 #else 
    #define F77_N N
    #define F77_incX incX
 #endif
-   F77_idamax_sub( &F77_N, X, &F77_incX, &iamax);
+   int iamax = idamax_(&F77_N, X, &F77_incX);
    return iamax ? iamax-1 : 0;
 }
diff --git a/CBLAS/src/cblas_isamax.c b/CBLAS/src/cblas_isamax.c
index bfd74e8..1675b48 100644
--- a/CBLAS/src/cblas_isamax.c
+++ b/CBLAS/src/cblas_isamax.c
@@ -11,13 +11,15 @@
 #include "cblas_f77.h"
 CBLAS_INDEX cblas_isamax( const int N, const float *X, const int incX)
 {
-   int iamax;
+   extern int isamax_(const int *n, const float *sx, const int *incx);
+
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX;
 #else 
    #define F77_N N
    #define F77_incX incX
 #endif
-   F77_isamax_sub( &F77_N, X, &F77_incX, &iamax);
+
+   int iamax = isamax_(&F77_N, X, &F77_incX);
    return iamax ? iamax-1 : 0;
 }
diff --git a/CBLAS/src/cblas_izamax.c b/CBLAS/src/cblas_izamax.c
index 21fdc39..15265ce 100644
--- a/CBLAS/src/cblas_izamax.c
+++ b/CBLAS/src/cblas_izamax.c
@@ -11,13 +11,13 @@
 #include "cblas_f77.h"
 CBLAS_INDEX cblas_izamax( const int N, const void *X, const int incX)
 {
-   int iamax;
+   extern int izamax_(const int *n, doublecomplex *zx, const int *incx);
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX;
 #else 
    #define F77_N N
    #define F77_incX incX
 #endif
-   F77_izamax_sub( &F77_N, X, &F77_incX, &iamax);
+   int iamax = izamax_(&F77_N, X, &F77_incX);
    return (iamax ? iamax-1 : 0);
 }
diff --git a/CBLAS/src/cblas_sasum.c b/CBLAS/src/cblas_sasum.c
index 7d4c32c..8cc0f32 100644
--- a/CBLAS/src/cblas_sasum.c
+++ b/CBLAS/src/cblas_sasum.c
@@ -11,13 +11,13 @@
 #include "cblas_f77.h"
 float cblas_sasum( const int N, const float *X, const int incX) 
 {
-   float asum;
+   extern float sasum_(const int *n, const float *sx, const int *incx);
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX;
 #else 
    #define F77_N N
    #define F77_incX incX
 #endif
-   F77_sasum_sub( &F77_N, X, &F77_incX, &asum);
+   float asum = sasum_(&F77_N, X, &F77_incX);
    return asum;
 }
diff --git a/CBLAS/src/cblas_scasum.c b/CBLAS/src/cblas_scasum.c
index e1fa530..078b81b 100644
--- a/CBLAS/src/cblas_scasum.c
+++ b/CBLAS/src/cblas_scasum.c
@@ -11,13 +11,14 @@
 #include "cblas_f77.h"
 float cblas_scasum( const int N, const void *X, const int incX) 
 {
-   float asum;
+   extern float scasum_(const int *n, complex *cx, const int *incx);
+
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX;
 #else 
    #define F77_N N
    #define F77_incX incX
 #endif
-   F77_scasum_sub( &F77_N, X, &F77_incX, &asum);
-   return asum;
+
+   return scasum_(&F77_N, X, &F77_incX);
 }
diff --git a/CBLAS/src/cblas_scnrm2.c b/CBLAS/src/cblas_scnrm2.c
index fa48454..05818cf 100644
--- a/CBLAS/src/cblas_scnrm2.c
+++ b/CBLAS/src/cblas_scnrm2.c
@@ -11,13 +11,14 @@
 #include "cblas_f77.h"
 float cblas_scnrm2( const int N, const void *X, const int incX) 
 {
-   float nrm2;
+   extern float scnrm2_(const int *n, complex *x, const int *incx);
+
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX;
 #else 
    #define F77_N N
    #define F77_incX incX
 #endif
-   F77_scnrm2_sub( &F77_N, X, &F77_incX, &nrm2);
-   return nrm2;
+   
+   return scnrm2_(&F77_N, X, &F77_incX);
 }
diff --git a/CBLAS/src/cblas_sdot.c b/CBLAS/src/cblas_sdot.c
index baf8592..15305e3 100644
--- a/CBLAS/src/cblas_sdot.c
+++ b/CBLAS/src/cblas_sdot.c
@@ -12,7 +12,8 @@
 float cblas_sdot( const int N, const float *X,
                       const int incX, const float *Y, const int incY)
 {
-   float dot;
+   extern float sdot_(const int *n, const float *sx, const int *incx,
+      const float *sy, const int *incy);
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX, F77_incY=incY;
 #else 
@@ -20,6 +21,5 @@ float cblas_sdot( const int N, const float *X,
    #define F77_incX incX
    #define F77_incY incY
 #endif
-   F77_sdot_sub( &F77_N, X, &F77_incX, Y, &F77_incY, &dot);
-   return dot;
+   return sdot_(&F77_N, X, &F77_incX, Y, &F77_incY);
 }   
diff --git a/CBLAS/src/cblas_sdsdot.c b/CBLAS/src/cblas_sdsdot.c
index b824849..2bac234 100644
--- a/CBLAS/src/cblas_sdsdot.c
+++ b/CBLAS/src/cblas_sdsdot.c
@@ -12,7 +12,9 @@
 float cblas_sdsdot( const int N, const float alpha, const float *X,
                       const int incX, const float *Y, const int incY)
 {
-   float dot;
+   extern float sdsdot_(const int *n, const float *sb, const float *sx,
+      const int *incx, const float *sy, const int *incy);
+
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX, F77_incY=incY;
 #else 
@@ -20,6 +22,6 @@ float cblas_sdsdot( const int N, const float alpha, const float *X,
    #define F77_incX incX
    #define F77_incY incY
 #endif
-   F77_sdsdot_sub( &F77_N, &alpha, X, &F77_incX, Y, &F77_incY, &dot);
-   return dot;
+
+   return sdsdot_(&F77_N, &alpha, X, &F77_incX, Y, &F77_incY);
 }   
diff --git a/CBLAS/src/cblas_snrm2.c b/CBLAS/src/cblas_snrm2.c
index 18161b4..9b50487 100644
--- a/CBLAS/src/cblas_snrm2.c
+++ b/CBLAS/src/cblas_snrm2.c
@@ -11,13 +11,14 @@
 #include "cblas_f77.h"
 float cblas_snrm2( const int N, const float *X, const int incX) 
 {
-   float nrm2;
+   extern float snrm2_(const int *n, const float *x, const int *incx);
+
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX;
 #else 
    #define F77_N N
    #define F77_incX incX
 #endif
-   F77_snrm2_sub( &F77_N, X, &F77_incX, &nrm2);
-   return nrm2;
+
+   return snrm2_( &F77_N, X, &F77_incX);
 }
diff --git a/CBLAS/src/cblas_zdotc_sub.c b/CBLAS/src/cblas_zdotc_sub.c
index 29dec6c..67c1b99 100644
--- a/CBLAS/src/cblas_zdotc_sub.c
+++ b/CBLAS/src/cblas_zdotc_sub.c
@@ -9,9 +9,13 @@
  */
 #include "cblas.h"
 #include "cblas_f77.h"
+
 void cblas_zdotc_sub( const int N, const void *X, const int incX,
                     const void *Y, const int incY, void *dotc)
 {
+   extern void zdotc_(doublecomplex *ret_val, const int *n, doublecomplex *zx,
+      const int *incx, doublecomplex *zy, const int *incy);
+
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX, F77_incY=incY;
 #else 
@@ -19,6 +23,7 @@ void cblas_zdotc_sub( const int N, const void *X, const int incX,
    #define F77_incX incX
    #define F77_incY incY
 #endif
-   F77_zdotc_sub( &F77_N, X, &F77_incX, Y, &F77_incY, dotc);
+
+   zdotc_(dotc, &F77_N, X, &F77_incX, Y, &F77_incY);
    return;
 }
diff --git a/CBLAS/src/cblas_zdotu_sub.c b/CBLAS/src/cblas_zdotu_sub.c
index 48a14bf..a1267f3 100644
--- a/CBLAS/src/cblas_zdotu_sub.c
+++ b/CBLAS/src/cblas_zdotu_sub.c
@@ -9,9 +9,13 @@
  */
 #include "cblas.h"
 #include "cblas_f77.h"
+
 void cblas_zdotu_sub( const int N, const void *X, const int incX,
                       const void *Y, const int incY, void *dotu)
 {
+   extern void zdotu_(doublecomplex * ret_val, const int *n, doublecomplex *zx,
+      const int *incx, doublecomplex *zy, const int *incy);
+
 #ifdef F77_INT
    F77_INT F77_N=N, F77_incX=incX, F77_incY=incY;
 #else 
@@ -19,6 +23,7 @@ void cblas_zdotu_sub( const int N, const void *X, const int incX,
    #define F77_incX incX
    #define F77_incY incY
 #endif
-   F77_zdotu_sub( &F77_N, X, &F77_incX, Y, &F77_incY, dotu);
+
+   zdotu_(dotu, &F77_N, X, &F77_incX, Y, &F77_incY);
    return;
 }
diff --git a/CBLAS/src/cblas_zrotg.c b/CBLAS/src/cblas_zrotg.c
new file mode 100644
index 0000000..d75c540
--- /dev/null
+++ b/CBLAS/src/cblas_zrotg.c
@@ -0,0 +1,10 @@
+/* Missing cblas_crotg wrapper
+ * author: Mhu
+ */
+
+#include "cblas.h"
+#include "cblas_f77.h"
+void cblas_zrotg(void *a, void *b, void *c, void *s) {
+   extern void zrotg_(complex *ca, complex *cb, float *C, complex *S);
+   zrotg_(a, b, c, s); 
+}
diff --git a/CBLAS/testing/c_cblat1.c b/CBLAS/testing/c_cblat1.c
new file mode 100644
index 0000000..1e5a598
--- /dev/null
+++ b/CBLAS/testing/c_cblat1.c
@@ -0,0 +1,792 @@
+/* testing/c_cblat1.f -- translated by f2c (version 20191129).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+#include "f2c.h"
+
+/* Common Block Declarations */
+
+struct {
+    integer icase, n, incx, incy, mode;
+    logical pass;
+} combla_;
+
+#define combla_1 combla_
+
+/* Table of constant values */
+
+static integer c__1 = 1;
+static integer c__9 = 9;
+static integer c__5 = 5;
+static real c_b43 = 1.f;
+
+/* Main program */ int MAIN__(void)
+{
+    /* Initialized data */
+
+    static real sfac = 9.765625e-4f;
+
+    /* Format strings */
+    static char fmt_99999[] = "(\002 Complex CBLAS Test Program Results\002,"
+	    "/1x)";
+    static char fmt_99998[] = "(\002                                    ----"
+	    "- PASS -----\002)";
+
+    /* Builtin functions */
+    integer s_wsfe(cilist *), e_wsfe(void);
+    /* Subroutine */ int s_stop(char *, ftnlen);
+
+    /* Local variables */
+    integer ic;
+    extern /* Subroutine */ int check1_(real *), check2_(real *), header_(
+	    void);
+
+    /* Fortran I/O blocks */
+    static cilist io___2 = { 0, 6, 0, fmt_99999, 0 };
+    static cilist io___4 = { 0, 6, 0, fmt_99998, 0 };
+
+
+/*     Test program for the COMPLEX    Level 1 CBLAS. */
+/*     Based upon the original CBLAS test routine together with: */
+/*     F06GAF Example Program Text */
+/*     .. Parameters .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. External Subroutines .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+    s_wsfe(&io___2);
+    e_wsfe();
+    for (ic = 1; ic <= 10; ++ic) {
+	combla_1.icase = ic;
+	header_();
+
+/*        Initialize PASS, INCX, INCY, and MODE for a new case. */
+/*        The value 9999 for INCX, INCY or MODE will appear in the */
+/*        detailed  output, if any, for cases that do not involve */
+/*        these parameters. */
+
+	combla_1.pass = TRUE_;
+	combla_1.incx = 9999;
+	combla_1.incy = 9999;
+	combla_1.mode = 9999;
+	if (combla_1.icase <= 5) {
+	    check2_(&sfac);
+	} else if (combla_1.icase >= 6) {
+	    check1_(&sfac);
+	}
+/*        -- Print */
+	if (combla_1.pass) {
+	    s_wsfe(&io___4);
+	    e_wsfe();
+	}
+/* L20: */
+    }
+    s_stop("", (ftnlen)0);
+
+    return 0;
+} /* MAIN__ */
+
+/* Subroutine */ int header_(void)
+{
+    /* Initialized data */
+
+    static char l[15*10] = "CBLAS_CDOTC    " "CBLAS_CDOTU    " "CBLAS_CAXPY "
+	    "   " "CBLAS_CCOPY    " "CBLAS_CSWAP    " "CBLAS_SCNRM2   " "CBLA"
+	    "S_SCASUM   " "CBLAS_CSCAL    " "CBLAS_CSSCAL   " "CBLAS_ICAMAX   "
+	    ;
+
+    /* Format strings */
+    static char fmt_99999[] = "(/\002 Test of subprogram number\002,i3,9x,a1"
+	    "5)";
+
+    /* Builtin functions */
+    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+    /* Fortran I/O blocks */
+    static cilist io___6 = { 0, 6, 0, fmt_99999, 0 };
+
+
+/*     .. Parameters .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Arrays .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+    s_wsfe(&io___6);
+    do_fio(&c__1, (char *)&combla_1.icase, (ftnlen)sizeof(integer));
+    do_fio(&c__1, l + (0 + (0 + (combla_1.icase - 1) * 15)), (ftnlen)15);
+    e_wsfe();
+    return 0;
+
+} /* header_ */
+
+/* Subroutine */ int check1_(real *sfac)
+{
+    /* Initialized data */
+
+    static real strue2[5] = { 0.f,.5f,.6f,.7f,.7f };
+    static real strue4[5] = { 0.f,.7f,1.f,1.3f,1.7f };
+    static complex ctrue5[80]	/* was [8][5][2] */ = { {.1f,.1f},{1.f,2.f},{
+	    1.f,2.f},{1.f,2.f},{1.f,2.f},{1.f,2.f},{1.f,2.f},{1.f,2.f},{-.16f,
+	    -.37f},{3.f,4.f},{3.f,4.f},{3.f,4.f},{3.f,4.f},{3.f,4.f},{3.f,4.f}
+	    ,{3.f,4.f},{-.17f,-.19f},{.13f,-.39f},{5.f,6.f},{5.f,6.f},{5.f,
+	    6.f},{5.f,6.f},{5.f,6.f},{5.f,6.f},{.11f,-.03f},{-.17f,.46f},{
+	    -.17f,-.19f},{7.f,8.f},{7.f,8.f},{7.f,8.f},{7.f,8.f},{7.f,8.f},{
+	    .19f,-.17f},{.32f,.09f},{.23f,-.24f},{.18f,.01f},{2.f,3.f},{2.f,
+	    3.f},{2.f,3.f},{2.f,3.f},{.1f,.1f},{4.f,5.f},{4.f,5.f},{4.f,5.f},{
+	    4.f,5.f},{4.f,5.f},{4.f,5.f},{4.f,5.f},{-.16f,-.37f},{6.f,7.f},{
+	    6.f,7.f},{6.f,7.f},{6.f,7.f},{6.f,7.f},{6.f,7.f},{6.f,7.f},{-.17f,
+	    -.19f},{8.f,9.f},{.13f,-.39f},{2.f,5.f},{2.f,5.f},{2.f,5.f},{2.f,
+	    5.f},{2.f,5.f},{.11f,-.03f},{3.f,6.f},{-.17f,.46f},{4.f,7.f},{
+	    -.17f,-.19f},{7.f,2.f},{7.f,2.f},{7.f,2.f},{.19f,-.17f},{5.f,8.f},
+	    {.32f,.09f},{6.f,9.f},{.23f,-.24f},{8.f,3.f},{.18f,.01f},{9.f,4.f}
+	     };
+    static complex ctrue6[80]	/* was [8][5][2] */ = { {.1f,.1f},{1.f,2.f},{
+	    1.f,2.f},{1.f,2.f},{1.f,2.f},{1.f,2.f},{1.f,2.f},{1.f,2.f},{.09f,
+	    -.12f},{3.f,4.f},{3.f,4.f},{3.f,4.f},{3.f,4.f},{3.f,4.f},{3.f,4.f}
+	    ,{3.f,4.f},{.03f,-.09f},{.15f,-.03f},{5.f,6.f},{5.f,6.f},{5.f,6.f}
+	    ,{5.f,6.f},{5.f,6.f},{5.f,6.f},{.03f,.03f},{-.18f,.03f},{.03f,
+	    -.09f},{7.f,8.f},{7.f,8.f},{7.f,8.f},{7.f,8.f},{7.f,8.f},{.09f,
+	    .03f},{.03f,.12f},{.12f,.03f},{.03f,.06f},{2.f,3.f},{2.f,3.f},{
+	    2.f,3.f},{2.f,3.f},{.1f,.1f},{4.f,5.f},{4.f,5.f},{4.f,5.f},{4.f,
+	    5.f},{4.f,5.f},{4.f,5.f},{4.f,5.f},{.09f,-.12f},{6.f,7.f},{6.f,
+	    7.f},{6.f,7.f},{6.f,7.f},{6.f,7.f},{6.f,7.f},{6.f,7.f},{.03f,
+	    -.09f},{8.f,9.f},{.15f,-.03f},{2.f,5.f},{2.f,5.f},{2.f,5.f},{2.f,
+	    5.f},{2.f,5.f},{.03f,.03f},{3.f,6.f},{-.18f,.03f},{4.f,7.f},{.03f,
+	    -.09f},{7.f,2.f},{7.f,2.f},{7.f,2.f},{.09f,.03f},{5.f,8.f},{.03f,
+	    .12f},{6.f,9.f},{.12f,.03f},{8.f,3.f},{.03f,.06f},{9.f,4.f} };
+    static integer itrue3[5] = { 0,1,2,2,2 };
+    static real sa = .3f;
+    static complex ca = {.4f,-.7f};
+    static complex cv[80]	/* was [8][5][2] */ = { {.1f,.1f},{1.f,2.f},{
+	    1.f,2.f},{1.f,2.f},{1.f,2.f},{1.f,2.f},{1.f,2.f},{1.f,2.f},{.3f,
+	    -.4f},{3.f,4.f},{3.f,4.f},{3.f,4.f},{3.f,4.f},{3.f,4.f},{3.f,4.f},
+	    {3.f,4.f},{.1f,-.3f},{.5f,-.1f},{5.f,6.f},{5.f,6.f},{5.f,6.f},{
+	    5.f,6.f},{5.f,6.f},{5.f,6.f},{.1f,.1f},{-.6f,.1f},{.1f,-.3f},{7.f,
+	    8.f},{7.f,8.f},{7.f,8.f},{7.f,8.f},{7.f,8.f},{.3f,.1f},{.1f,.4f},{
+	    .4f,.1f},{.1f,.2f},{2.f,3.f},{2.f,3.f},{2.f,3.f},{2.f,3.f},{.1f,
+	    .1f},{4.f,5.f},{4.f,5.f},{4.f,5.f},{4.f,5.f},{4.f,5.f},{4.f,5.f},{
+	    4.f,5.f},{.3f,-.4f},{6.f,7.f},{6.f,7.f},{6.f,7.f},{6.f,7.f},{6.f,
+	    7.f},{6.f,7.f},{6.f,7.f},{.1f,-.3f},{8.f,9.f},{.5f,-.1f},{2.f,5.f}
+	    ,{2.f,5.f},{2.f,5.f},{2.f,5.f},{2.f,5.f},{.1f,.1f},{3.f,6.f},{
+	    -.6f,.1f},{4.f,7.f},{.1f,-.3f},{7.f,2.f},{7.f,2.f},{7.f,2.f},{.3f,
+	    .1f},{5.f,8.f},{.1f,.4f},{6.f,9.f},{.4f,.1f},{8.f,3.f},{.1f,.2f},{
+	    9.f,4.f} };
+
+    /* System generated locals */
+    integer i__1, i__2, i__3;
+    real r__1;
+    complex q__1;
+
+    /* Builtin functions */
+    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
+	    e_wsle(void);
+    /* Subroutine */ int s_stop(char *, ftnlen);
+
+    /* Local variables */
+    integer i__;
+    complex cx[8];
+    extern real scnrm2test_(integer *, complex *, integer *);
+    integer np1;
+    extern integer icamaxtest_(integer *, complex *, integer *);
+    extern /* Subroutine */ void csscaltest_(integer *, real *, complex *, 
+	    integer *);
+    extern real scasumtest_(integer *, complex *, integer *);
+    integer len;
+    extern /* Subroutine */ void cscal_(integer *, complex *, complex *, 
+	    integer *);
+    extern int ctest_(integer *, complex *, complex *, complex *, 
+	    real *);
+    complex mwpcs[5], mwpct[5];
+    extern /* Subroutine */ int itest1_(integer *, integer *), stest1_(real *,
+	     real *, real *, real *);
+
+    /* Fortran I/O blocks */
+    static cilist io___19 = { 0, 6, 0, 0, 0 };
+
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+    for (combla_1.incx = 1; combla_1.incx <= 2; ++combla_1.incx) {
+	for (np1 = 1; np1 <= 5; ++np1) {
+	    combla_1.n = np1 - 1;
+	    len = max(combla_1.n,1) << 1;
+/*           .. Set vector arguments .. */
+	    i__1 = len;
+	    for (i__ = 1; i__ <= i__1; ++i__) {
+		i__2 = i__ - 1;
+		i__3 = i__ + (np1 + combla_1.incx * 5 << 3) - 49;
+		cx[i__2].r = cv[i__3].r, cx[i__2].i = cv[i__3].i;
+/* L20: */
+	    }
+	    if (combla_1.icase == 6) {
+/*              .. SCNRM2TEST .. */
+		r__1 = scnrm2test_(&combla_1.n, cx, &combla_1.incx);
+		stest1_(&r__1, &strue2[np1 - 1], &strue2[np1 - 1], sfac);
+	    } else if (combla_1.icase == 7) {
+/*              .. SCASUMTEST .. */
+		r__1 = scasumtest_(&combla_1.n, cx, &combla_1.incx);
+		stest1_(&r__1, &strue4[np1 - 1], &strue4[np1 - 1], sfac);
+	    } else if (combla_1.icase == 8) {
+/*              .. CSCAL .. */
+		cscal_(&combla_1.n, &ca, cx, &combla_1.incx);
+		ctest_(&len, cx, &ctrue5[(np1 + combla_1.incx * 5 << 3) - 48],
+			 &ctrue5[(np1 + combla_1.incx * 5 << 3) - 48], sfac);
+	    } else if (combla_1.icase == 9) {
+/*              .. CSSCALTEST .. */
+		csscaltest_(&combla_1.n, &sa, cx, &combla_1.incx);
+		ctest_(&len, cx, &ctrue6[(np1 + combla_1.incx * 5 << 3) - 48],
+			 &ctrue6[(np1 + combla_1.incx * 5 << 3) - 48], sfac);
+	    } else if (combla_1.icase == 10) {
+/*              .. ICAMAXTEST .. */
+		i__1 = icamaxtest_(&combla_1.n, cx, &combla_1.incx);
+		itest1_(&i__1, &itrue3[np1 - 1]);
+	    } else {
+		s_wsle(&io___19);
+		do_lio(&c__9, &c__1, " Shouldn't be here in CHECK1", (ftnlen)
+			28);
+		e_wsle();
+		s_stop("", (ftnlen)0);
+	    }
+
+/* L40: */
+	}
+/* L60: */
+    }
+
+    combla_1.incx = 1;
+    if (combla_1.icase == 8) {
+/*        CSCAL */
+/*        Add a test for alpha equal to zero. */
+	ca.r = 0.f, ca.i = 0.f;
+	for (i__ = 1; i__ <= 5; ++i__) {
+	    i__1 = i__ - 1;
+	    mwpct[i__1].r = 0.f, mwpct[i__1].i = 0.f;
+	    i__1 = i__ - 1;
+	    mwpcs[i__1].r = 1.f, mwpcs[i__1].i = 1.f;
+/* L80: */
+	}
+	cscal_(&c__5, &ca, cx, &combla_1.incx);
+	ctest_(&c__5, cx, mwpct, mwpcs, sfac);
+    } else if (combla_1.icase == 9) {
+/*        CSSCALTEST */
+/*        Add a test for alpha equal to zero. */
+	sa = 0.f;
+	for (i__ = 1; i__ <= 5; ++i__) {
+	    i__1 = i__ - 1;
+	    mwpct[i__1].r = 0.f, mwpct[i__1].i = 0.f;
+	    i__1 = i__ - 1;
+	    mwpcs[i__1].r = 1.f, mwpcs[i__1].i = 1.f;
+/* L100: */
+	}
+	csscaltest_(&c__5, &sa, cx, &combla_1.incx);
+	ctest_(&c__5, cx, mwpct, mwpcs, sfac);
+/*        Add a test for alpha equal to one. */
+	sa = 1.f;
+	for (i__ = 1; i__ <= 5; ++i__) {
+	    i__1 = i__ - 1;
+	    i__2 = i__ - 1;
+	    mwpct[i__1].r = cx[i__2].r, mwpct[i__1].i = cx[i__2].i;
+	    i__1 = i__ - 1;
+	    i__2 = i__ - 1;
+	    mwpcs[i__1].r = cx[i__2].r, mwpcs[i__1].i = cx[i__2].i;
+/* L120: */
+	}
+	csscaltest_(&c__5, &sa, cx, &combla_1.incx);
+	ctest_(&c__5, cx, mwpct, mwpcs, sfac);
+/*        Add a test for alpha equal to minus one. */
+	sa = -1.f;
+	for (i__ = 1; i__ <= 5; ++i__) {
+	    i__1 = i__ - 1;
+	    i__2 = i__ - 1;
+	    q__1.r = -cx[i__2].r, q__1.i = -cx[i__2].i;
+	    mwpct[i__1].r = q__1.r, mwpct[i__1].i = q__1.i;
+	    i__1 = i__ - 1;
+	    i__2 = i__ - 1;
+	    q__1.r = -cx[i__2].r, q__1.i = -cx[i__2].i;
+	    mwpcs[i__1].r = q__1.r, mwpcs[i__1].i = q__1.i;
+/* L140: */
+	}
+	csscaltest_(&c__5, &sa, cx, &combla_1.incx);
+	ctest_(&c__5, cx, mwpct, mwpcs, sfac);
+    }
+    return 0;
+} /* check1_ */
+
+/* Subroutine */ int check2_(real *sfac)
+{
+    /* Initialized data */
+
+    static complex ca = {.4f,-.7f};
+    static integer incxs[4] = { 1,2,-2,-1 };
+    static integer incys[4] = { 1,-2,1,-2 };
+    static integer lens[8]	/* was [4][2] */ = { 1,1,2,4,1,1,3,7 };
+    static integer ns[4] = { 0,1,2,4 };
+    static complex cx1[7] = { {.7f,-.8f},{-.4f,-.7f},{-.1f,-.9f},{.2f,-.8f},{
+	    -.9f,-.4f},{.1f,.4f},{-.6f,.6f} };
+    static complex cy1[7] = { {.6f,-.6f},{-.9f,.5f},{.7f,-.6f},{.1f,-.5f},{
+	    -.1f,-.2f},{-.5f,-.3f},{.8f,-.7f} };
+    static complex ct8[112]	/* was [7][4][4] */ = { {.6f,-.6f},{0.f,0.f},{
+	    0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{.32f,-1.41f},{
+	    0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{.32f,
+	    -1.41f},{-1.55f,.5f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,
+	    0.f},{.32f,-1.41f},{-1.55f,.5f},{.03f,-.89f},{-.38f,-.96f},{0.f,
+	    0.f},{0.f,0.f},{0.f,0.f},{.6f,-.6f},{0.f,0.f},{0.f,0.f},{0.f,0.f},
+	    {0.f,0.f},{0.f,0.f},{0.f,0.f},{.32f,-1.41f},{0.f,0.f},{0.f,0.f},{
+	    0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{-.07f,-.89f},{-.9f,.5f},{
+	    .42f,-1.41f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{.78f,.06f},{
+	    -.9f,.5f},{.06f,-.13f},{.1f,-.5f},{-.77f,-.49f},{-.5f,-.3f},{.52f,
+	    -1.51f},{.6f,-.6f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,
+	    0.f},{0.f,0.f},{.32f,-1.41f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,
+	    0.f},{0.f,0.f},{0.f,0.f},{-.07f,-.89f},{-1.18f,-.31f},{0.f,0.f},{
+	    0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{.78f,.06f},{-1.54f,.97f},{
+	    .03f,-.89f},{-.18f,-1.31f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{.6f,
+	    -.6f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},
+	    {.32f,-1.41f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{
+	    0.f,0.f},{.32f,-1.41f},{-.9f,.5f},{.05f,-.6f},{0.f,0.f},{0.f,0.f},
+	    {0.f,0.f},{0.f,0.f},{.32f,-1.41f},{-.9f,.5f},{.05f,-.6f},{.1f,
+	    -.5f},{-.77f,-.49f},{-.5f,-.3f},{.32f,-1.16f} };
+    static complex ct7[16]	/* was [4][4] */ = { {0.f,0.f},{-.06f,-.9f},{
+	    .65f,-.47f},{-.34f,-1.22f},{0.f,0.f},{-.06f,-.9f},{-.59f,-1.46f},{
+	    -1.04f,-.04f},{0.f,0.f},{-.06f,-.9f},{-.83f,.59f},{.07f,-.37f},{
+	    0.f,0.f},{-.06f,-.9f},{-.76f,-1.15f},{-1.33f,-1.82f} };
+    static complex ct6[16]	/* was [4][4] */ = { {0.f,0.f},{.9f,.06f},{
+	    .91f,-.77f},{1.8f,-.1f},{0.f,0.f},{.9f,.06f},{1.45f,.74f},{.2f,
+	    .9f},{0.f,0.f},{.9f,.06f},{-.55f,.23f},{.83f,-.39f},{0.f,0.f},{
+	    .9f,.06f},{1.04f,.79f},{1.95f,1.22f} };
+    static complex ct10x[112]	/* was [7][4][4] */ = { {.7f,-.8f},{0.f,0.f},{
+	    0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{.6f,-.6f},{0.f,
+	    0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{.6f,-.6f},
+	    {-.9f,.5f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{.6f,
+	    -.6f},{-.9f,.5f},{.7f,-.6f},{.1f,-.5f},{0.f,0.f},{0.f,0.f},{0.f,
+	    0.f},{.7f,-.8f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},
+	    {0.f,0.f},{.6f,-.6f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,
+	    0.f},{0.f,0.f},{.7f,-.6f},{-.4f,-.7f},{.6f,-.6f},{0.f,0.f},{0.f,
+	    0.f},{0.f,0.f},{0.f,0.f},{.8f,-.7f},{-.4f,-.7f},{-.1f,-.2f},{.2f,
+	    -.8f},{.7f,-.6f},{.1f,.4f},{.6f,-.6f},{.7f,-.8f},{0.f,0.f},{0.f,
+	    0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{.6f,-.6f},{0.f,0.f},
+	    {0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{-.9f,.5f},{
+	    -.4f,-.7f},{.6f,-.6f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{
+	    .1f,-.5f},{-.4f,-.7f},{.7f,-.6f},{.2f,-.8f},{-.9f,.5f},{.1f,.4f},{
+	    .6f,-.6f},{.7f,-.8f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,
+	    0.f},{0.f,0.f},{.6f,-.6f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},
+	    {0.f,0.f},{0.f,0.f},{.6f,-.6f},{.7f,-.6f},{0.f,0.f},{0.f,0.f},{
+	    0.f,0.f},{0.f,0.f},{0.f,0.f},{.6f,-.6f},{.7f,-.6f},{-.1f,-.2f},{
+	    .8f,-.7f},{0.f,0.f},{0.f,0.f},{0.f,0.f} };
+    static complex ct10y[112]	/* was [7][4][4] */ = { {.6f,-.6f},{0.f,0.f},{
+	    0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{.7f,-.8f},{0.f,
+	    0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{.7f,-.8f},
+	    {-.4f,-.7f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{
+	    .7f,-.8f},{-.4f,-.7f},{-.1f,-.9f},{.2f,-.8f},{0.f,0.f},{0.f,0.f},{
+	    0.f,0.f},{.6f,-.6f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,
+	    0.f},{0.f,0.f},{.7f,-.8f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},
+	    {0.f,0.f},{0.f,0.f},{-.1f,-.9f},{-.9f,.5f},{.7f,-.8f},{0.f,0.f},{
+	    0.f,0.f},{0.f,0.f},{0.f,0.f},{-.6f,.6f},{-.9f,.5f},{-.9f,-.4f},{
+	    .1f,-.5f},{-.1f,-.9f},{-.5f,-.3f},{.7f,-.8f},{.6f,-.6f},{0.f,0.f},
+	    {0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{.7f,-.8f},{0.f,
+	    0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{-.1f,-.9f}
+	    ,{.7f,-.8f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{
+	    -.6f,.6f},{-.9f,-.4f},{-.1f,-.9f},{.7f,-.8f},{0.f,0.f},{0.f,0.f},{
+	    0.f,0.f},{.6f,-.6f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,
+	    0.f},{0.f,0.f},{.7f,-.8f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},
+	    {0.f,0.f},{0.f,0.f},{.7f,-.8f},{-.9f,.5f},{-.4f,-.7f},{0.f,0.f},{
+	    0.f,0.f},{0.f,0.f},{0.f,0.f},{.7f,-.8f},{-.9f,.5f},{-.4f,-.7f},{
+	    .1f,-.5f},{-.1f,-.9f},{-.5f,-.3f},{.2f,-.8f} };
+    static complex csize1[4] = { {0.f,0.f},{.9f,.9f},{1.63f,1.73f},{2.9f,
+	    2.78f} };
+    static complex csize3[14] = { {0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{
+	    0.f,0.f},{0.f,0.f},{0.f,0.f},{1.17f,1.17f},{1.17f,1.17f},{1.17f,
+	    1.17f},{1.17f,1.17f},{1.17f,1.17f},{1.17f,1.17f},{1.17f,1.17f} };
+    static complex csize2[14]	/* was [7][2] */ = { {0.f,0.f},{0.f,0.f},{0.f,
+	    0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{0.f,0.f},{1.54f,1.54f},{1.54f,
+	    1.54f},{1.54f,1.54f},{1.54f,1.54f},{1.54f,1.54f},{1.54f,1.54f},{
+	    1.54f,1.54f} };
+
+    /* System generated locals */
+    integer i__1, i__2;
+
+    /* Builtin functions */
+    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
+	    e_wsle(void);
+    /* Subroutine */ int s_stop(char *, ftnlen);
+
+    /* Local variables */
+    integer i__;
+    extern /* Subroutine */ void cdotctest_(integer *, complex *, integer *, 
+	    complex *, integer *, complex *), ccopytest_(integer *, complex *,
+	     integer *, complex *, integer *), cdotutest_(integer *, complex *
+	    , integer *, complex *, integer *, complex *), cswaptest_(integer 
+	    *, complex *, integer *, complex *, integer *), caxpytest_(
+	    integer *, complex *, complex *, integer *, complex *, integer *);
+    integer ki, kn;
+    complex cx[7], cy[7];
+    integer mx, my;
+    complex cdot[1];
+    integer lenx, leny;
+    complex ctemp;
+    extern /* Subroutine */ int ctest_(integer *, complex *, complex *, 
+	    complex *, real *);
+    integer ksize;
+
+    /* Fortran I/O blocks */
+    static cilist io___49 = { 0, 6, 0, 0, 0 };
+
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+    for (ki = 1; ki <= 4; ++ki) {
+	combla_1.incx = incxs[ki - 1];
+	combla_1.incy = incys[ki - 1];
+	mx = abs(combla_1.incx);
+	my = abs(combla_1.incy);
+
+	for (kn = 1; kn <= 4; ++kn) {
+	    combla_1.n = ns[kn - 1];
+	    ksize = min(2,kn);
+	    lenx = lens[kn + (mx << 2) - 5];
+	    leny = lens[kn + (my << 2) - 5];
+/*           .. initialize all argument arrays .. */
+	    for (i__ = 1; i__ <= 7; ++i__) {
+		i__1 = i__ - 1;
+		i__2 = i__ - 1;
+		cx[i__1].r = cx1[i__2].r, cx[i__1].i = cx1[i__2].i;
+		i__1 = i__ - 1;
+		i__2 = i__ - 1;
+		cy[i__1].r = cy1[i__2].r, cy[i__1].i = cy1[i__2].i;
+/* L20: */
+	    }
+	    if (combla_1.icase == 1) {
+/*              .. CDOTCTEST .. */
+		cdotctest_(&combla_1.n, cx, &combla_1.incx, cy, &
+			combla_1.incy, &ctemp);
+		cdot[0].r = ctemp.r, cdot[0].i = ctemp.i;
+		ctest_(&c__1, cdot, &ct6[kn + (ki << 2) - 5], &csize1[kn - 1],
+			 sfac);
+	    } else if (combla_1.icase == 2) {
+/*              .. CDOTUTEST .. */
+		cdotutest_(&combla_1.n, cx, &combla_1.incx, cy, &
+			combla_1.incy, &ctemp);
+		cdot[0].r = ctemp.r, cdot[0].i = ctemp.i;
+		ctest_(&c__1, cdot, &ct7[kn + (ki << 2) - 5], &csize1[kn - 1],
+			 sfac);
+	    } else if (combla_1.icase == 3) {
+/*              .. CAXPYTEST .. */
+		caxpytest_(&combla_1.n, &ca, cx, &combla_1.incx, cy, &
+			combla_1.incy);
+		ctest_(&leny, cy, &ct8[(kn + (ki << 2)) * 7 - 35], &csize2[
+			ksize * 7 - 7], sfac);
+	    } else if (combla_1.icase == 4) {
+/*              .. CCOPYTEST .. */
+		ccopytest_(&combla_1.n, cx, &combla_1.incx, cy, &
+			combla_1.incy);
+		ctest_(&leny, cy, &ct10y[(kn + (ki << 2)) * 7 - 35], csize3, &
+			c_b43);
+	    } else if (combla_1.icase == 5) {
+/*              .. CSWAPTEST .. */
+		cswaptest_(&combla_1.n, cx, &combla_1.incx, cy, &
+			combla_1.incy);
+		ctest_(&lenx, cx, &ct10x[(kn + (ki << 2)) * 7 - 35], csize3, &
+			c_b43);
+		ctest_(&leny, cy, &ct10y[(kn + (ki << 2)) * 7 - 35], csize3, &
+			c_b43);
+	    } else {
+		s_wsle(&io___49);
+		do_lio(&c__9, &c__1, " Shouldn't be here in CHECK2", (ftnlen)
+			28);
+		e_wsle();
+		s_stop("", (ftnlen)0);
+	    }
+
+/* L40: */
+	}
+/* L60: */
+    }
+    return 0;
+} /* check2_ */
+
+/* Subroutine */ int stest_(integer *len, real *scomp, real *strue, real *
+	ssize, real *sfac)
+{
+    /* Format strings */
+    static char fmt_99999[] = "(\002                                       F"
+	    "AIL\002)";
+    static char fmt_99998[] = "(/\002 CASE  N INCX INCY MODE  I             "
+	    "               \002,\002 COMP(I)                             TRU"
+	    "E(I)  DIFFERENCE\002,\002     SIZE(I)\002,/1x)";
+    static char fmt_99997[] = "(1x,i4,i3,3i5,i3,2e36.8,2e12.4)";
+
+    /* System generated locals */
+    integer i__1;
+    real r__1, r__2, r__3, r__4, r__5;
+
+    /* Builtin functions */
+    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+    /* Local variables */
+    integer i__;
+    real sd;
+    extern real sdiff_(real *, real *);
+
+    /* Fortran I/O blocks */
+    static cilist io___52 = { 0, 6, 0, fmt_99999, 0 };
+    static cilist io___53 = { 0, 6, 0, fmt_99998, 0 };
+    static cilist io___54 = { 0, 6, 0, fmt_99997, 0 };
+
+
+/*     ********************************* STEST ************************** */
+
+/*     THIS SUBR COMPARES ARRAYS  SCOMP() AND STRUE() OF LENGTH LEN TO */
+/*     SEE IF THE TERM BY TERM DIFFERENCES, MULTIPLIED BY SFAC, ARE */
+/*     NEGLIGIBLE. */
+
+/*     C. L. LAWSON, JPL, 1974 DEC 10 */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. External Functions .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Common blocks .. */
+/*     .. Executable Statements .. */
+
+    /* Parameter adjustments */
+    --ssize;
+    --strue;
+    --scomp;
+
+    /* Function Body */
+    i__1 = *len;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	sd = scomp[i__] - strue[i__];
+	r__4 = (r__1 = ssize[i__], abs(r__1)) + (r__2 = *sfac * sd, abs(r__2))
+		;
+	r__5 = (r__3 = ssize[i__], abs(r__3));
+	if (sdiff_(&r__4, &r__5) == 0.f) {
+	    goto L40;
+	}
+
+/*                             HERE    SCOMP(I) IS NOT CLOSE TO STRUE(I). */
+
+	if (! combla_1.pass) {
+	    goto L20;
+	}
+/*                             PRINT FAIL MESSAGE AND HEADER. */
+	combla_1.pass = FALSE_;
+	s_wsfe(&io___52);
+	e_wsfe();
+	s_wsfe(&io___53);
+	e_wsfe();
+L20:
+	s_wsfe(&io___54);
+	do_fio(&c__1, (char *)&combla_1.icase, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&combla_1.n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&combla_1.incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&combla_1.incy, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&combla_1.mode, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&scomp[i__], (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&strue[i__], (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&sd, (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&ssize[i__], (ftnlen)sizeof(real));
+	e_wsfe();
+L40:
+	;
+    }
+    return 0;
+
+} /* stest_ */
+
+/* Subroutine */ int stest1_(real *scomp1, real *strue1, real *ssize, real *
+	sfac)
+{
+    real scomp[1], strue[1];
+    extern /* Subroutine */ int stest_(integer *, real *, real *, real *, 
+	    real *);
+
+/*     ************************* STEST1 ***************************** */
+
+/*     THIS IS AN INTERFACE SUBROUTINE TO ACCOMODATE THE FORTRAN */
+/*     REQUIREMENT THAT WHEN A DUMMY ARGUMENT IS AN ARRAY, THE */
+/*     ACTUAL ARGUMENT MUST ALSO BE AN ARRAY OR AN ARRAY ELEMENT. */
+
+/*     C.L. LAWSON, JPL, 1978 DEC 6 */
+
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Arrays .. */
+/*     .. External Subroutines .. */
+/*     .. Executable Statements .. */
+
+    /* Parameter adjustments */
+    --ssize;
+
+    /* Function Body */
+    scomp[0] = *scomp1;
+    strue[0] = *strue1;
+    stest_(&c__1, scomp, strue, &ssize[1], sfac);
+
+    return 0;
+} /* stest1_ */
+
+real sdiff_(real *sa, real *sb)
+{
+    /* System generated locals */
+    real ret_val;
+
+/*     ********************************* SDIFF ************************** */
+/*     COMPUTES DIFFERENCE OF TWO NUMBERS.  C. L. LAWSON, JPL 1974 FEB 15 */
+
+/*     .. Scalar Arguments .. */
+/*     .. Executable Statements .. */
+    ret_val = *sa - *sb;
+    return ret_val;
+} /* sdiff_ */
+
+/* Subroutine */ int ctest_(integer *len, complex *ccomp, complex *ctrue, 
+	complex *csize, real *sfac)
+{
+    /* System generated locals */
+    integer i__1, i__2;
+
+    /* Builtin functions */
+    double r_imag(complex *);
+
+    /* Local variables */
+    integer i__;
+    real scomp[20], ssize[20], strue[20];
+    extern /* Subroutine */ int stest_(integer *, real *, real *, real *, 
+	    real *);
+
+/*     **************************** CTEST ***************************** */
+
+/*     C.L. LAWSON, JPL, 1978 DEC 6 */
+
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Executable Statements .. */
+    /* Parameter adjustments */
+    --csize;
+    --ctrue;
+    --ccomp;
+
+    /* Function Body */
+    i__1 = *len;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	i__2 = i__;
+	scomp[(i__ << 1) - 2] = ccomp[i__2].r;
+	scomp[(i__ << 1) - 1] = r_imag(&ccomp[i__]);
+	i__2 = i__;
+	strue[(i__ << 1) - 2] = ctrue[i__2].r;
+	strue[(i__ << 1) - 1] = r_imag(&ctrue[i__]);
+	i__2 = i__;
+	ssize[(i__ << 1) - 2] = csize[i__2].r;
+	ssize[(i__ << 1) - 1] = r_imag(&csize[i__]);
+/* L20: */
+    }
+
+    i__1 = *len << 1;
+    stest_(&i__1, scomp, strue, ssize, sfac);
+    return 0;
+} /* ctest_ */
+
+/* Subroutine */ int itest1_(integer *icomp, integer *itrue)
+{
+    /* Format strings */
+    static char fmt_99999[] = "(\002                                       F"
+	    "AIL\002)";
+    static char fmt_99998[] = "(/\002 CASE  N INCX INCY MODE                "
+	    "               \002,\002 COMP                                TRU"
+	    "E     DIFFERENCE\002,/1x)";
+    static char fmt_99997[] = "(1x,i4,i3,3i5,2i36,i12)";
+
+    /* Builtin functions */
+    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+    /* Local variables */
+    integer id;
+
+    /* Fortran I/O blocks */
+    static cilist io___61 = { 0, 6, 0, fmt_99999, 0 };
+    static cilist io___62 = { 0, 6, 0, fmt_99998, 0 };
+    static cilist io___64 = { 0, 6, 0, fmt_99997, 0 };
+
+
+/*     ********************************* ITEST1 ************************* */
+
+/*     THIS SUBROUTINE COMPARES THE VARIABLES ICOMP AND ITRUE FOR */
+/*     EQUALITY. */
+/*     C. L. LAWSON, JPL, 1974 DEC 10 */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. Common blocks .. */
+/*     .. Executable Statements .. */
+    if (*icomp == *itrue) {
+	goto L40;
+    }
+
+/*                            HERE ICOMP IS NOT EQUAL TO ITRUE. */
+
+    if (! combla_1.pass) {
+	goto L20;
+    }
+/*                             PRINT FAIL MESSAGE AND HEADER. */
+    combla_1.pass = FALSE_;
+    s_wsfe(&io___61);
+    e_wsfe();
+    s_wsfe(&io___62);
+    e_wsfe();
+L20:
+    id = *icomp - *itrue;
+    s_wsfe(&io___64);
+    do_fio(&c__1, (char *)&combla_1.icase, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&combla_1.n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&combla_1.incx, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&combla_1.incy, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&combla_1.mode, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&(*icomp), (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&(*itrue), (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&id, (ftnlen)sizeof(integer));
+    e_wsfe();
+L40:
+    return 0;
+
+} /* itest1_ */
+
+/* Main program alias */ int ccblat1_ () { MAIN__ (); return 0; }
diff --git a/CBLAS/testing/c_cblat2.c b/CBLAS/testing/c_cblat2.c
new file mode 100644
index 0000000..d88f7f7
--- /dev/null
+++ b/CBLAS/testing/c_cblat2.c
@@ -0,0 +1,4746 @@
+/* testing/c_cblat2.f -- translated by f2c (version 20191129).
+   You must link the resulting object file with libf2c:
+        on Microsoft Windows system, link with libf2c.lib;
+        on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+        or, if you install libf2c.a in a standard place, with -lf2c -lm
+        -- in that order, at the end of the command line, as in
+                cc *.o -lf2c -lm
+        Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+                http://www.netlib.org/f2c/libf2c.zip
+*/
+
+#include "f2c.h"
+
+/* Common Block Declarations */
+
+struct {
+  integer infot, noutc;
+  logical ok;
+} infoc_;
+
+#define infoc_1 infoc_
+
+struct {
+  char srnamt[12];
+} srnamc_;
+
+#define srnamc_1 srnamc_
+
+/* Table of constant values */
+
+static complex c_b1 = {0.f, 0.f};
+static complex c_b2 = {1.f, 0.f};
+static integer c__9 = 9;
+static integer c__1 = 1;
+static integer c__3 = 3;
+static integer c__8 = 8;
+static integer c__4 = 4;
+static integer c__65 = 65;
+static integer c__7 = 7;
+static integer c__2 = 2;
+static integer c__6 = 6;
+static real c_b125 = 1.f;
+static logical c_true = TRUE_;
+static integer c_n1 = -1;
+static integer c__0 = 0;
+static logical c_false = FALSE_;
+
+/* Main program */ int MAIN__(void) {
+  /* Initialized data */
+
+  static char snames[12 * 17] = "cblas_cgemv "
+                                "cblas_cgbmv "
+                                "cblas_chemv "
+                                "cblas_chbmv "
+                                "cblas_chpmv "
+                                "cblas_ctrmv "
+                                "cblas_ctbmv "
+                                "cbl"
+                                "as_ctpmv "
+                                "cblas_ctrsv "
+                                "cblas_ctbsv "
+                                "cblas_ctpsv "
+                                "cblas_c"
+                                "gerc "
+                                "cblas_cgeru "
+                                "cblas_cher  "
+                                "cblas_chpr  "
+                                "cblas_cher2 "
+                                "cblas_chpr2 ";
+
+  /* Format strings */
+  static char fmt_9997[] = "(\002 NUMBER OF VALUES OF \002,a,\002 IS LESS "
+                           "THAN 1 OR GREATER \002,\002THAN \002,i2)";
+  static char fmt_9996[] = "(\002 VALUE OF N IS LESS THAN 0 OR GREATER THA"
+                           "N \002,i2)";
+  static char fmt_9995[] = "(\002 VALUE OF K IS LESS THAN 0\002)";
+  static char fmt_9994[] = "(\002 ABSOLUTE VALUE OF INCX OR INCY IS 0 OR G"
+                           "REATER THAN \002,i2)";
+  static char fmt_9993[] =
+      "(\002 TESTS OF THE COMPLEX          LEVEL 2 BL"
+      "AS\002,//\002 THE F\002,\002OLLOWING PARAMETER VALUES WILL BE US"
+      "ED:\002)";
+  static char fmt_9992[] = "(\002   FOR N              \002,9i6)";
+  static char fmt_9991[] = "(\002   FOR K              \002,7i6)";
+  static char fmt_9990[] = "(\002   FOR INCX AND INCY  \002,7i6)";
+  static char fmt_9989[] = "(\002   FOR ALPHA          \002,7(\002(\002,f4"
+                           ".1,\002,\002,f4.1,\002)  \002,:))";
+  static char fmt_9988[] = "(\002   FOR BETA           \002,7(\002(\002,f4"
+                           ".1,\002,\002,f4.1,\002)  \002,:))";
+  static char fmt_9980[] = "(\002 ERROR-EXITS WILL NOT BE TESTED\002)";
+  static char fmt_9999[] = "(\002 ROUTINES PASS COMPUTATIONAL TESTS IF TES"
+                           "T RATIO IS LES\002,\002S THAN\002,f8.2)";
+  static char fmt_10002[] = "(\002 COLUMN-MAJOR AND ROW-MAJOR DATA LAYOUTS"
+                            " ARE TESTED\002)";
+  static char fmt_10001[] = "(\002 ROW-MAJOR DATA LAYOUT IS TESTED\002)";
+  static char fmt_10000[] = "(\002 COLUMN-MAJOR DATA LAYOUT IS TESTED\002)";
+  static char fmt_9984[] = "(a12,l2)";
+  static char fmt_9986[] =
+      "(\002 SUBPROGRAM NAME \002,a12,\002 NOT RECOGN"
+      "IZED\002,/\002 ******* T\002,\002ESTS ABANDONED *******\002)";
+  static char fmt_9998[] = "(\002 RELATIVE MACHINE PRECISION IS TAKEN TO"
+                           " BE\002,1p,e9.1)";
+  static char fmt_9985[] =
+      "(\002 ERROR IN CMVCH -  IN-LINE DOT PRODUCTS A"
+      "RE BEING EVALU\002,\002ATED WRONGLY.\002,/\002 CMVCH WAS CALLED "
+      "WITH TRANS = \002,a1,\002 AND RETURNED SAME = \002,l1,\002 AND E"
+      "RR = \002,f12.3,\002.\002,/\002 THIS MAY BE DUE TO FAULTS IN THE"
+      " ARITHMETIC OR THE COMPILER.\002,/\002 ******* TESTS ABANDONED *"
+      "******\002)";
+  static char fmt_9983[] = "(1x,a12,\002 WAS NOT TESTED\002)";
+  static char fmt_9982[] = "(/\002 END OF TESTS\002)";
+  static char fmt_9981[] = "(/\002 ******* FATAL ERROR - TESTS ABANDONED *"
+                           "******\002)";
+  static char fmt_9987[] =
+      "(\002 AMEND DATA FILE OR INCREASE ARRAY SIZES "
+      "IN PROGRAM\002,/\002 ******* TESTS ABANDONED *******\002)";
+
+  /* System generated locals */
+  integer i__1, i__2, i__3, i__4, i__5;
+  real r__1;
+  olist o__1;
+  cllist cl__1;
+
+  /* Builtin functions */
+  integer s_rsle(cilist *), do_lio(integer *, integer *, char *, ftnlen),
+      e_rsle(void), f_open(olist *), s_wsfe(cilist *),
+      do_fio(integer *, char *, ftnlen), e_wsfe(void), s_wsle(cilist *),
+      e_wsle(void), s_rsfe(cilist *), e_rsfe(void),
+      s_cmp(char *, char *, ftnlen, ftnlen);
+  /* Subroutine */ int s_stop(char *, ftnlen);
+  integer f_clos(cllist *);
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+
+  /* Local variables */
+  complex a[4225] /* was [65][65] */;
+  real g[65];
+  integer i__, j, n;
+  complex x[65], y[65], z__[130], aa[4225];
+  integer kb[7];
+  complex as[4225], xs[130], ys[130], yt[65], xx[130], yy[130], alf[7];
+  extern logical lce_(complex *, complex *, integer *);
+  integer inc[7], nkb;
+  complex bet[7];
+  real eps, err;
+  integer nalf, idim[9];
+  logical same;
+  integer ninc, nbet, ntra;
+  logical rewi;
+  extern /* Subroutine */ int cchk1_(
+      char *, real *, real *, integer *, integer *, logical *, logical *,
+      logical *, integer *, integer *, integer *, integer *, integer *,
+      complex *, integer *, complex *, integer *, integer *, integer *,
+      integer *, complex *, complex *, complex *, complex *, complex *,
+      complex *, complex *, complex *, complex *, complex *, real *, integer *,
+      ftnlen),
+      cchk2_(char *, real *, real *, integer *, integer *, logical *, logical *,
+             logical *, integer *, integer *, integer *, integer *, integer *,
+             complex *, integer *, complex *, integer *, integer *, integer *,
+             integer *, complex *, complex *, complex *, complex *, complex *,
+             complex *, complex *, complex *, complex *, complex *, real *,
+             integer *, ftnlen),
+      cchk3_(char *, real *, real *, integer *, integer *, logical *, logical *,
+             logical *, integer *, integer *, integer *, integer *, integer *,
+             integer *, integer *, integer *, complex *, complex *, complex *,
+             complex *, complex *, complex *, complex *, real *, complex *,
+             integer *, ftnlen),
+      cchk4_(char *, real *, real *, integer *, integer *, logical *, logical *,
+             logical *, integer *, integer *, integer *, complex *, integer *,
+             integer *, integer *, integer *, complex *, complex *, complex *,
+             complex *, complex *, complex *, complex *, complex *, complex *,
+             complex *, real *, complex *, integer *, ftnlen),
+      cchk5_(char *, real *, real *, integer *, integer *, logical *, logical *,
+             logical *, integer *, integer *, integer *, complex *, integer *,
+             integer *, integer *, integer *, complex *, complex *, complex *,
+             complex *, complex *, complex *, complex *, complex *, complex *,
+             complex *, real *, complex *, integer *, ftnlen),
+      cchk6_(char *, real *, real *, integer *, integer *, logical *, logical *,
+             logical *, integer *, integer *, integer *, complex *, integer *,
+             integer *, integer *, integer *, complex *, complex *, complex *,
+             complex *, complex *, complex *, complex *, complex *, complex *,
+             complex *, real *, complex *, integer *, ftnlen);
+  logical fatal;
+  extern real sdiff_(real *, real *);
+  logical trace;
+  integer nidim;
+  extern /* Subroutine */ int cmvch_(
+      char *, integer *, integer *, complex *, complex *, integer *, complex *,
+      integer *, complex *, complex *, integer *, complex *, real *, complex *,
+      real *, real *, logical *, integer *, logical *, ftnlen);
+  char snaps[32], trans[1];
+  integer isnum;
+  logical ltest[17], sfatal, corder;
+  char snamet[12];
+  real thresh;
+  logical rorder;
+  extern /* Subroutine */ void cc2chke_(char *);
+  integer layout;
+  logical ltestt, tsterr;
+
+  /* Fortran I/O blocks */
+  static cilist io___2 = {0, 5, 0, 0, 0};
+  static cilist io___4 = {0, 5, 0, 0, 0};
+  static cilist io___7 = {0, 5, 0, 0, 0};
+  static cilist io___9 = {0, 5, 0, 0, 0};
+  static cilist io___11 = {0, 5, 0, 0, 0};
+  static cilist io___13 = {0, 5, 0, 0, 0};
+  static cilist io___15 = {0, 5, 0, 0, 0};
+  static cilist io___17 = {0, 5, 0, 0, 0};
+  static cilist io___19 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___20 = {0, 5, 0, 0, 0};
+  static cilist io___23 = {0, 6, 0, fmt_9996, 0};
+  static cilist io___24 = {0, 5, 0, 0, 0};
+  static cilist io___26 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___27 = {0, 5, 0, 0, 0};
+  static cilist io___29 = {0, 6, 0, fmt_9995, 0};
+  static cilist io___30 = {0, 5, 0, 0, 0};
+  static cilist io___32 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___33 = {0, 5, 0, 0, 0};
+  static cilist io___35 = {0, 6, 0, fmt_9994, 0};
+  static cilist io___36 = {0, 5, 0, 0, 0};
+  static cilist io___38 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___39 = {0, 5, 0, 0, 0};
+  static cilist io___41 = {0, 5, 0, 0, 0};
+  static cilist io___43 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___44 = {0, 5, 0, 0, 0};
+  static cilist io___46 = {0, 6, 0, fmt_9993, 0};
+  static cilist io___47 = {0, 6, 0, fmt_9992, 0};
+  static cilist io___48 = {0, 6, 0, fmt_9991, 0};
+  static cilist io___49 = {0, 6, 0, fmt_9990, 0};
+  static cilist io___50 = {0, 6, 0, fmt_9989, 0};
+  static cilist io___51 = {0, 6, 0, fmt_9988, 0};
+  static cilist io___52 = {0, 6, 0, 0, 0};
+  static cilist io___53 = {0, 6, 0, fmt_9980, 0};
+  static cilist io___54 = {0, 6, 0, 0, 0};
+  static cilist io___55 = {0, 6, 0, fmt_9999, 0};
+  static cilist io___56 = {0, 6, 0, 0, 0};
+  static cilist io___59 = {0, 6, 0, fmt_10002, 0};
+  static cilist io___60 = {0, 6, 0, fmt_10001, 0};
+  static cilist io___61 = {0, 6, 0, fmt_10000, 0};
+  static cilist io___62 = {0, 6, 0, 0, 0};
+  static cilist io___64 = {0, 5, 1, fmt_9984, 0};
+  static cilist io___67 = {0, 6, 0, fmt_9986, 0};
+  static cilist io___69 = {0, 6, 0, fmt_9998, 0};
+  static cilist io___82 = {0, 6, 0, fmt_9985, 0};
+  static cilist io___83 = {0, 6, 0, fmt_9985, 0};
+  static cilist io___85 = {0, 6, 0, 0, 0};
+  static cilist io___86 = {0, 6, 0, fmt_9983, 0};
+  static cilist io___87 = {0, 6, 0, 0, 0};
+  static cilist io___94 = {0, 6, 0, fmt_9982, 0};
+  static cilist io___95 = {0, 6, 0, fmt_9981, 0};
+  static cilist io___96 = {0, 6, 0, fmt_9987, 0};
+
+  /*  Test program for the COMPLEX          Level 2 Blas. */
+
+  /*  The program must be driven by a short data file. The first 17 records */
+  /*  of the file are read using list-directed input, the last 17 records */
+  /*  are read using the format ( A12, L2 ). An annotated example of a data */
+  /*  file can be obtained by deleting the first 3 characters from the */
+  /*  following 34 lines: */
+  /*  'CBLAT2.SNAP'     NAME OF SNAPSHOT OUTPUT FILE */
+  /*  -1                UNIT NUMBER OF SNAPSHOT FILE (NOT USED IF .LT. 0) */
+  /*  F        LOGICAL FLAG, T TO REWIND SNAPSHOT FILE AFTER EACH RECORD. */
+  /*  F        LOGICAL FLAG, T TO STOP ON FAILURES. */
+  /*  T        LOGICAL FLAG, T TO TEST ERROR EXITS. */
+  /*  2        0 TO TEST COLUMN-MAJOR, 1 TO TEST ROW-MAJOR, 2 TO TEST BOTH */
+  /*  16.0     THRESHOLD VALUE OF TEST RATIO */
+  /*  6                 NUMBER OF VALUES OF N */
+  /*  0 1 2 3 5 9       VALUES OF N */
+  /*  4                 NUMBER OF VALUES OF K */
+  /*  0 1 2 4           VALUES OF K */
+  /*  4                 NUMBER OF VALUES OF INCX AND INCY */
+  /*  1 2 -1 -2         VALUES OF INCX AND INCY */
+  /*  3                 NUMBER OF VALUES OF ALPHA */
+  /*  (0.0,0.0) (1.0,0.0) (0.7,-0.9)       VALUES OF ALPHA */
+  /*  3                 NUMBER OF VALUES OF BETA */
+  /*  (0.0,0.0) (1.0,0.0) (1.3,-1.1)       VALUES OF BETA */
+  /*  cblas_cgemv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_cgbmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_chemv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_chbmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_chpmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_ctrmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_ctbmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_ctpmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_ctrsv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_ctbsv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_ctpsv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_cgerc  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_cgeru  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_cher   T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_chpr   T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_cher2  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_chpr2  T PUT F FOR NO TEST. SAME COLUMNS. */
+
+  /*     See: */
+
+  /*        Dongarra J. J., Du Croz J. J., Hammarling S.  and Hanson R. J.. */
+  /*        An  extended  set of Fortran  Basic Linear Algebra Subprograms. */
+
+  /*        Technical  Memoranda  Nos. 41 (revision 3) and 81,  Mathematics */
+  /*        and  Computer Science  Division,  Argonne  National Laboratory, */
+  /*        9700 South Cass Avenue, Argonne, Illinois 60439, US. */
+
+  /*        Or */
+
+  /*        NAG  Technical Reports TR3/87 and TR4/87,  Numerical Algorithms */
+  /*        Group  Ltd.,  NAG  Central  Office,  256  Banbury  Road, Oxford */
+  /*        OX2 7DE, UK,  and  Numerical Algorithms Group Inc.,  1101  31st */
+  /*        Street,  Suite 100,  Downers Grove,  Illinois 60515-1263,  USA. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Parameters .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /*     .. Executable Statements .. */
+
+  infoc_1.noutc = 6;
+
+  /*     Read name and unit number for summary output file and open file. */
+
+  s_rsle(&io___2);
+  do_lio(&c__9, &c__1, snaps, (ftnlen)32);
+  e_rsle();
+  s_rsle(&io___4);
+  do_lio(&c__3, &c__1, (char *)&ntra, (ftnlen)sizeof(integer));
+  e_rsle();
+  trace = ntra >= 0;
+  if (trace) {
+    o__1.oerr = 0;
+    o__1.ounit = ntra;
+    o__1.ofnmlen = 32;
+    o__1.ofnm = snaps;
+    o__1.orl = 0;
+    o__1.osta = 0;
+    o__1.oacc = 0;
+    o__1.ofm = 0;
+    o__1.oblnk = 0;
+    f_open(&o__1);
+  }
+  /*     Read the flag that directs rewinding of the snapshot file. */
+  s_rsle(&io___7);
+  do_lio(&c__8, &c__1, (char *)&rewi, (ftnlen)sizeof(logical));
+  e_rsle();
+  rewi = rewi && trace;
+  /*     Read the flag that directs stopping on any failure. */
+  s_rsle(&io___9);
+  do_lio(&c__8, &c__1, (char *)&sfatal, (ftnlen)sizeof(logical));
+  e_rsle();
+  /*     Read the flag that indicates whether error exits are to be tested. */
+  s_rsle(&io___11);
+  do_lio(&c__8, &c__1, (char *)&tsterr, (ftnlen)sizeof(logical));
+  e_rsle();
+  /*     Read the flag that indicates whether row-major data layout to be
+   * tested. */
+  s_rsle(&io___13);
+  do_lio(&c__3, &c__1, (char *)&layout, (ftnlen)sizeof(integer));
+  e_rsle();
+  /*     Read the threshold value of the test ratio */
+  s_rsle(&io___15);
+  do_lio(&c__4, &c__1, (char *)&thresh, (ftnlen)sizeof(real));
+  e_rsle();
+
+  /*     Read and check the parameter values for the tests. */
+
+  /*     Values of N */
+  s_rsle(&io___17);
+  do_lio(&c__3, &c__1, (char *)&nidim, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nidim < 1 || nidim > 9) {
+    s_wsfe(&io___19);
+    do_fio(&c__1, "N", (ftnlen)1);
+    do_fio(&c__1, (char *)&c__9, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L230;
+  }
+  s_rsle(&io___20);
+  i__1 = nidim;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__3, &c__1, (char *)&idim[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_rsle();
+  i__1 = nidim;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    if (idim[i__ - 1] < 0 || idim[i__ - 1] > 65) {
+      s_wsfe(&io___23);
+      do_fio(&c__1, (char *)&c__65, (ftnlen)sizeof(integer));
+      e_wsfe();
+      goto L230;
+    }
+    /* L10: */
+  }
+  /*     Values of K */
+  s_rsle(&io___24);
+  do_lio(&c__3, &c__1, (char *)&nkb, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nkb < 1 || nkb > 7) {
+    s_wsfe(&io___26);
+    do_fio(&c__1, "K", (ftnlen)1);
+    do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L230;
+  }
+  s_rsle(&io___27);
+  i__1 = nkb;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__3, &c__1, (char *)&kb[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_rsle();
+  i__1 = nkb;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    if (kb[i__ - 1] < 0) {
+      s_wsfe(&io___29);
+      e_wsfe();
+      goto L230;
+    }
+    /* L20: */
+  }
+  /*     Values of INCX and INCY */
+  s_rsle(&io___30);
+  do_lio(&c__3, &c__1, (char *)&ninc, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (ninc < 1 || ninc > 7) {
+    s_wsfe(&io___32);
+    do_fio(&c__1, "INCX AND INCY", (ftnlen)13);
+    do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L230;
+  }
+  s_rsle(&io___33);
+  i__1 = ninc;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__3, &c__1, (char *)&inc[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_rsle();
+  i__1 = ninc;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    if (inc[i__ - 1] == 0 || (i__2 = inc[i__ - 1], abs(i__2)) > 2) {
+      s_wsfe(&io___35);
+      do_fio(&c__1, (char *)&c__2, (ftnlen)sizeof(integer));
+      e_wsfe();
+      goto L230;
+    }
+    /* L30: */
+  }
+  /*     Values of ALPHA */
+  s_rsle(&io___36);
+  do_lio(&c__3, &c__1, (char *)&nalf, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nalf < 1 || nalf > 7) {
+    s_wsfe(&io___38);
+    do_fio(&c__1, "ALPHA", (ftnlen)5);
+    do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L230;
+  }
+  s_rsle(&io___39);
+  i__1 = nalf;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__6, &c__1, (char *)&alf[i__ - 1], (ftnlen)sizeof(complex));
+  }
+  e_rsle();
+  /*     Values of BETA */
+  s_rsle(&io___41);
+  do_lio(&c__3, &c__1, (char *)&nbet, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nbet < 1 || nbet > 7) {
+    s_wsfe(&io___43);
+    do_fio(&c__1, "BETA", (ftnlen)4);
+    do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L230;
+  }
+  s_rsle(&io___44);
+  i__1 = nbet;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__6, &c__1, (char *)&bet[i__ - 1], (ftnlen)sizeof(complex));
+  }
+  e_rsle();
+
+  /*     Report values of parameters. */
+
+  s_wsfe(&io___46);
+  e_wsfe();
+  s_wsfe(&io___47);
+  i__1 = nidim;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__1, (char *)&idim[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_wsfe();
+  s_wsfe(&io___48);
+  i__1 = nkb;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__1, (char *)&kb[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_wsfe();
+  s_wsfe(&io___49);
+  i__1 = ninc;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__1, (char *)&inc[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_wsfe();
+  s_wsfe(&io___50);
+  i__1 = nalf;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__2, (char *)&alf[i__ - 1], (ftnlen)sizeof(real));
+  }
+  e_wsfe();
+  s_wsfe(&io___51);
+  i__1 = nbet;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__2, (char *)&bet[i__ - 1], (ftnlen)sizeof(real));
+  }
+  e_wsfe();
+  if (!tsterr) {
+    s_wsle(&io___52);
+    e_wsle();
+    s_wsfe(&io___53);
+    e_wsfe();
+  }
+  s_wsle(&io___54);
+  e_wsle();
+  s_wsfe(&io___55);
+  do_fio(&c__1, (char *)&thresh, (ftnlen)sizeof(real));
+  e_wsfe();
+  s_wsle(&io___56);
+  e_wsle();
+  rorder = FALSE_;
+  corder = FALSE_;
+  if (layout == 2) {
+    rorder = TRUE_;
+    corder = TRUE_;
+    s_wsfe(&io___59);
+    e_wsfe();
+  } else if (layout == 1) {
+    rorder = TRUE_;
+    s_wsfe(&io___60);
+    e_wsfe();
+  } else if (layout == 0) {
+    corder = TRUE_;
+    s_wsfe(&io___61);
+    e_wsfe();
+  }
+  s_wsle(&io___62);
+  e_wsle();
+
+  /*     Read names of subroutines and flags which indicate */
+  /*     whether they are to be tested. */
+
+  for (i__ = 1; i__ <= 17; ++i__) {
+    ltest[i__ - 1] = FALSE_;
+    /* L40: */
+  }
+L50:
+  i__1 = s_rsfe(&io___64);
+  if (i__1 != 0) {
+    goto L80;
+  }
+  i__1 = do_fio(&c__1, snamet, (ftnlen)12);
+  if (i__1 != 0) {
+    goto L80;
+  }
+  i__1 = do_fio(&c__1, (char *)&ltestt, (ftnlen)sizeof(logical));
+  if (i__1 != 0) {
+    goto L80;
+  }
+  i__1 = e_rsfe();
+  if (i__1 != 0) {
+    goto L80;
+  }
+  for (i__ = 1; i__ <= 17; ++i__) {
+    if (s_cmp(snamet, snames + (i__ - 1) * 12, (ftnlen)12, (ftnlen)12) == 0) {
+      goto L70;
+    }
+    /* L60: */
+  }
+  s_wsfe(&io___67);
+  do_fio(&c__1, snamet, (ftnlen)12);
+  e_wsfe();
+  s_stop("", (ftnlen)0);
+L70:
+  ltest[i__ - 1] = ltestt;
+  goto L50;
+
+L80:
+  cl__1.cerr = 0;
+  cl__1.cunit = 5;
+  cl__1.csta = 0;
+  f_clos(&cl__1);
+
+  /*     Compute EPS (the machine precision). */
+
+  eps = 1.f;
+L90:
+  r__1 = eps + 1.f;
+  if (sdiff_(&r__1, &c_b125) == 0.f) {
+    goto L100;
+  }
+  eps *= .5f;
+  goto L90;
+L100:
+  eps += eps;
+  s_wsfe(&io___69);
+  do_fio(&c__1, (char *)&eps, (ftnlen)sizeof(real));
+  e_wsfe();
+
+  /*     Check the reliability of CMVCH using exact data. */
+
+  n = 32;
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = n;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      i__3 = i__ + j * 65 - 66;
+      /* Computing MAX */
+      i__5 = i__ - j + 1;
+      i__4 = max(i__5, 0);
+      a[i__3].r = (real)i__4, a[i__3].i = 0.f;
+      /* L110: */
+    }
+    i__2 = j - 1;
+    x[i__2].r = (real)j, x[i__2].i = 0.f;
+    i__2 = j - 1;
+    y[i__2].r = 0.f, y[i__2].i = 0.f;
+    /* L120: */
+  }
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = j - 1;
+    i__3 = j * ((j + 1) * j) / 2 - (j + 1) * j * (j - 1) / 3;
+    yy[i__2].r = (real)i__3, yy[i__2].i = 0.f;
+    /* L130: */
+  }
+  /*     YY holds the exact result. On exit from CMVCH YT holds */
+  /*     the result computed by CMVCH. */
+  *(unsigned char *)trans = 'N';
+  cmvch_(trans, &n, &n, &c_b2, a, &c__65, x, &c__1, &c_b1, y, &c__1, yt, g, yy,
+         &eps, &err, &fatal, &c__6, &c_true, (ftnlen)1);
+  same = lce_(yy, yt, &n);
+  if (!same || err != 0.f) {
+    s_wsfe(&io___82);
+    do_fio(&c__1, trans, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(real));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+  *(unsigned char *)trans = 'T';
+  cmvch_(trans, &n, &n, &c_b2, a, &c__65, x, &c_n1, &c_b1, y, &c_n1, yt, g, yy,
+         &eps, &err, &fatal, &c__6, &c_true, (ftnlen)1);
+  same = lce_(yy, yt, &n);
+  if (!same || err != 0.f) {
+    s_wsfe(&io___83);
+    do_fio(&c__1, trans, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(real));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+
+  /*     Test each subroutine in turn. */
+
+  for (isnum = 1; isnum <= 17; ++isnum) {
+    s_wsle(&io___85);
+    e_wsle();
+    if (!ltest[isnum - 1]) {
+      /*           Subprogram is not to be tested. */
+      s_wsfe(&io___86);
+      do_fio(&c__1, snames + (isnum - 1) * 12, (ftnlen)12);
+      e_wsfe();
+    } else {
+      s_copy(srnamc_1.srnamt, snames + (isnum - 1) * 12, (ftnlen)12,
+             (ftnlen)12);
+      /*           Test error exits. */
+      if (tsterr) {
+        cc2chke_(snames + (isnum - 1) * 12);
+        s_wsle(&io___87);
+        e_wsle();
+      }
+      /*           Test computations. */
+      infoc_1.infot = 0;
+      infoc_1.ok = TRUE_;
+      fatal = FALSE_;
+      switch (isnum) {
+      case 1:
+        goto L140;
+      case 2:
+        goto L140;
+      case 3:
+        goto L150;
+      case 4:
+        goto L150;
+      case 5:
+        goto L150;
+      case 6:
+        goto L160;
+      case 7:
+        goto L160;
+      case 8:
+        goto L160;
+      case 9:
+        goto L160;
+      case 10:
+        goto L160;
+      case 11:
+        goto L160;
+      case 12:
+        goto L170;
+      case 13:
+        goto L170;
+      case 14:
+        goto L180;
+      case 15:
+        goto L180;
+      case 16:
+        goto L190;
+      case 17:
+        goto L190;
+      }
+    /*           Test CGEMV, 01, and CGBMV, 02. */
+    L140:
+      if (corder) {
+        cchk1_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nkb, kb, &nalf, alf, &nbet, bet,
+               &ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt,
+               g, &c__0, (ftnlen)12);
+      }
+      if (rorder) {
+        cchk1_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nkb, kb, &nalf, alf, &nbet, bet,
+               &ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt,
+               g, &c__1, (ftnlen)12);
+      }
+      goto L200;
+    /*           Test CHEMV, 03, CHBMV, 04, and CHPMV, 05. */
+    L150:
+      if (corder) {
+        cchk2_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nkb, kb, &nalf, alf, &nbet, bet,
+               &ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt,
+               g, &c__0, (ftnlen)12);
+      }
+      if (rorder) {
+        cchk2_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nkb, kb, &nalf, alf, &nbet, bet,
+               &ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt,
+               g, &c__1, (ftnlen)12);
+      }
+      goto L200;
+    /*           Test CTRMV, 06, CTBMV, 07, CTPMV, 08, */
+    /*           CTRSV, 09, CTBSV, 10, and CTPSV, 11. */
+    L160:
+      if (corder) {
+        cchk3_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nkb, kb, &ninc, inc, &c__65, &c__2,
+               a, aa, as, y, yy, ys, yt, g, z__, &c__0, (ftnlen)12);
+      }
+      if (rorder) {
+        cchk3_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nkb, kb, &ninc, inc, &c__65, &c__2,
+               a, aa, as, y, yy, ys, yt, g, z__, &c__1, (ftnlen)12);
+      }
+      goto L200;
+    /*           Test CGERC, 12, CGERU, 13. */
+    L170:
+      if (corder) {
+        cchk4_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &ninc, inc, &c__65,
+               &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt, g, z__, &c__0,
+               (ftnlen)12);
+      }
+      if (rorder) {
+        cchk4_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &ninc, inc, &c__65,
+               &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt, g, z__, &c__1,
+               (ftnlen)12);
+      }
+      goto L200;
+    /*           Test CHER, 14, and CHPR, 15. */
+    L180:
+      if (corder) {
+        cchk5_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &ninc, inc, &c__65,
+               &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt, g, z__, &c__0,
+               (ftnlen)12);
+      }
+      if (rorder) {
+        cchk5_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &ninc, inc, &c__65,
+               &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt, g, z__, &c__1,
+               (ftnlen)12);
+      }
+      goto L200;
+    /*           Test CHER2, 16, and CHPR2, 17. */
+    L190:
+      if (corder) {
+        cchk6_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &ninc, inc, &c__65,
+               &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt, g, z__, &c__0,
+               (ftnlen)12);
+      }
+      if (rorder) {
+        cchk6_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &ninc, inc, &c__65,
+               &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt, g, z__, &c__1,
+               (ftnlen)12);
+      }
+
+    L200:
+      if (fatal && sfatal) {
+        goto L220;
+      }
+    }
+    /* L210: */
+  }
+  s_wsfe(&io___94);
+  e_wsfe();
+  goto L240;
+
+L220:
+  s_wsfe(&io___95);
+  e_wsfe();
+  goto L240;
+
+L230:
+  s_wsfe(&io___96);
+  e_wsfe();
+
+L240:
+  if (trace) {
+    cl__1.cerr = 0;
+    cl__1.cunit = ntra;
+    cl__1.csta = 0;
+    f_clos(&cl__1);
+  }
+  cl__1.cerr = 0;
+  cl__1.cunit = 6;
+  cl__1.csta = 0;
+  f_clos(&cl__1);
+  s_stop("", (ftnlen)0);
+
+  /*     End of CBLAT2. */
+
+  return 0;
+} /* MAIN__ */
+
+/* Subroutine */ int
+cchk1_(char *sname, real *eps, real *thresh, integer *nout, integer *ntra,
+       logical *trace, logical *rewi, logical *fatal, integer *nidim,
+       integer *idim, integer *nkb, integer *kb, integer *nalf, complex *alf,
+       integer *nbet, complex *bet, integer *ninc, integer *inc, integer *nmax,
+       integer *incmax, complex *a, complex *aa, complex *as, complex *x,
+       complex *xx, complex *xs, complex *y, complex *yy, complex *ys,
+       complex *yt, real *g, integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ich[3] = "NTC";
+
+  /* Format strings */
+  static char fmt_9994[] =
+      "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+      "2(i3,\002,\002),\002(\002,f4.1,\002,\002,f4.1,\002), A,\002,/10x"
+      ",i3,\002, X,\002,i2,\002,(\002,f4.1,\002,\002,f4.1,\002), Y,\002"
+      ",i2,\002) .\002)";
+  static char fmt_9995[] =
+      "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+      "4(i3,\002,\002),\002(\002,f4.1,\002,\002,f4.1,\002), A,\002,/10x"
+      ",i3,\002, X,\002,i2,\002,(\002,f4.1,\002,\002,f4.1,\002), Y,\002"
+      ",i2,\002) .\002)";
+  static char fmt_9993[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_9999[] = "(\002 \002,a12,\002 PASSED THE COMPUTATIONAL T"
+                           "ESTS (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_9997[] =
+      "(\002 \002,a12,\002 COMPLETED THE COMPUTATIONA"
+      "L TESTS (\002,i6,\002 C\002,\002ALLS)\002,/\002 ******* BUT WITH"
+      " MAXIMUM TEST RATIO\002,f8.2,\002 - SUSPECT *******\002)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6, i__7, i__8,
+      i__9;
+  alist al__1;
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+      f_rew(alist *);
+
+  /* Local variables */
+  integer i__, m, n, ia, ib, ic, nc, nd, im, in, kl, ml, nk, nl, ku, ix, iy, ms,
+      lx, ly, ns, laa, lda;
+  extern logical lce_(complex *, complex *, integer *);
+  complex als, bls;
+  real err;
+  integer iku, kls, kus;
+  complex beta;
+  integer ldas;
+  logical same;
+  integer incx, incy;
+  logical full, tran, null;
+  extern /* Subroutine */ int cmake_(char *, char *, char *, integer *,
+                                     integer *, complex *, integer *, complex *,
+                                     integer *, integer *, integer *, logical *,
+                                     complex *, ftnlen, ftnlen, ftnlen);
+  complex alpha;
+  logical isame[13];
+  extern /* Subroutine */ int cmvch_(
+      char *, integer *, integer *, complex *, complex *, integer *, complex *,
+      integer *, complex *, complex *, integer *, complex *, real *, complex *,
+      real *, real *, logical *, integer *, logical *, ftnlen);
+  integer nargs;
+  logical reset;
+  integer incxs, incys;
+  char trans[1];
+  logical banded;
+  extern /* Subroutine */ void ccgbmv_(
+      integer *, char *, integer *, integer *, integer *, integer *, complex *,
+      complex *, integer *, complex *, integer *, complex *, complex *,
+      integer *),
+      ccgemv_(integer *, char *, integer *, integer *, complex *, complex *,
+              integer *, complex *, integer *, complex *, complex *, integer *);
+  extern logical lceres_(char *, char *, integer *, integer *, complex *,
+                         complex *, integer *, ftnlen, ftnlen);
+  char ctrans[14];
+  real errmax;
+  complex transl;
+  char transs[1];
+
+  /* Fortran I/O blocks */
+  static cilist io___144 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___145 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___146 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___149 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___151 = {0, 0, 0, fmt_9999, 0};
+  static cilist io___152 = {0, 0, 0, fmt_9997, 0};
+  static cilist io___153 = {0, 0, 0, fmt_9996, 0};
+  static cilist io___154 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___155 = {0, 0, 0, fmt_9995, 0};
+
+  /*  Tests CGEMV and CGBMV. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --kb;
+  --alf;
+  --bet;
+  --inc;
+  --g;
+  --yt;
+  --y;
+  --x;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --ys;
+  --yy;
+  --xs;
+  --xx;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+  full = *(unsigned char *)&sname[8] == 'e';
+  banded = *(unsigned char *)&sname[8] == 'b';
+  /*     Define the number of arguments. */
+  if (full) {
+    nargs = 11;
+  } else if (banded) {
+    nargs = 13;
+  }
+
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.f;
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+    nd = n / 2 + 1;
+
+    for (im = 1; im <= 2; ++im) {
+      if (im == 1) {
+        /* Computing MAX */
+        i__2 = n - nd;
+        m = max(i__2, 0);
+      }
+      if (im == 2) {
+        /* Computing MIN */
+        i__2 = n + nd;
+        m = min(i__2, *nmax);
+      }
+
+      if (banded) {
+        nk = *nkb;
+      } else {
+        nk = 1;
+      }
+      i__2 = nk;
+      for (iku = 1; iku <= i__2; ++iku) {
+        if (banded) {
+          ku = kb[iku];
+          /* Computing MAX */
+          i__3 = ku - 1;
+          kl = max(i__3, 0);
+        } else {
+          ku = n - 1;
+          kl = m - 1;
+        }
+        /*              Set LDA to 1 more than minimum value if room. */
+        if (banded) {
+          lda = kl + ku + 1;
+        } else {
+          lda = m;
+        }
+        if (lda < *nmax) {
+          ++lda;
+        }
+        /*              Skip tests if not enough room. */
+        if (lda > *nmax) {
+          goto L100;
+        }
+        laa = lda * n;
+        null = n <= 0 || m <= 0;
+
+        /*              Generate the matrix A. */
+
+        transl.r = 0.f, transl.i = 0.f;
+        cmake_(sname + 7, " ", " ", &m, &n, &a[a_offset], nmax, &aa[1], &lda,
+               &kl, &ku, &reset, &transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+        for (ic = 1; ic <= 3; ++ic) {
+          *(unsigned char *)trans = *(unsigned char *)&ich[ic - 1];
+          if (*(unsigned char *)trans == 'N') {
+            s_copy(ctrans, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+          } else if (*(unsigned char *)trans == 'T') {
+            s_copy(ctrans, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+          } else {
+            s_copy(ctrans, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+          }
+          tran =
+              *(unsigned char *)trans == 'T' || *(unsigned char *)trans == 'C';
+
+          if (tran) {
+            ml = n;
+            nl = m;
+          } else {
+            ml = m;
+            nl = n;
+          }
+
+          i__3 = *ninc;
+          for (ix = 1; ix <= i__3; ++ix) {
+            incx = inc[ix];
+            lx = abs(incx) * nl;
+
+            /*                    Generate the vector X. */
+
+            transl.r = .5f, transl.i = 0.f;
+            i__4 = abs(incx);
+            i__5 = nl - 1;
+            cmake_("ge", " ", " ", &c__1, &nl, &x[1], &c__1, &xx[1], &i__4,
+                   &c__0, &i__5, &reset, &transl, (ftnlen)2, (ftnlen)1,
+                   (ftnlen)1);
+            if (nl > 1) {
+              i__4 = nl / 2;
+              x[i__4].r = 0.f, x[i__4].i = 0.f;
+              i__4 = abs(incx) * (nl / 2 - 1) + 1;
+              xx[i__4].r = 0.f, xx[i__4].i = 0.f;
+            }
+
+            i__4 = *ninc;
+            for (iy = 1; iy <= i__4; ++iy) {
+              incy = inc[iy];
+              ly = abs(incy) * ml;
+
+              i__5 = *nalf;
+              for (ia = 1; ia <= i__5; ++ia) {
+                i__6 = ia;
+                alpha.r = alf[i__6].r, alpha.i = alf[i__6].i;
+
+                i__6 = *nbet;
+                for (ib = 1; ib <= i__6; ++ib) {
+                  i__7 = ib;
+                  beta.r = bet[i__7].r, beta.i = bet[i__7].i;
+
+                  /*                             Generate the vector Y. */
+
+                  transl.r = 0.f, transl.i = 0.f;
+                  i__7 = abs(incy);
+                  i__8 = ml - 1;
+                  cmake_("ge", " ", " ", &c__1, &ml, &y[1], &c__1, &yy[1],
+                         &i__7, &c__0, &i__8, &reset, &transl, (ftnlen)2,
+                         (ftnlen)1, (ftnlen)1);
+
+                  ++nc;
+
+                  /*                             Save every datum before calling
+                   * the */
+                  /*                             subroutine. */
+
+                  *(unsigned char *)transs = *(unsigned char *)trans;
+                  ms = m;
+                  ns = n;
+                  kls = kl;
+                  kus = ku;
+                  als.r = alpha.r, als.i = alpha.i;
+                  i__7 = laa;
+                  for (i__ = 1; i__ <= i__7; ++i__) {
+                    i__8 = i__;
+                    i__9 = i__;
+                    as[i__8].r = aa[i__9].r, as[i__8].i = aa[i__9].i;
+                    /* L10: */
+                  }
+                  ldas = lda;
+                  i__7 = lx;
+                  for (i__ = 1; i__ <= i__7; ++i__) {
+                    i__8 = i__;
+                    i__9 = i__;
+                    xs[i__8].r = xx[i__9].r, xs[i__8].i = xx[i__9].i;
+                    /* L20: */
+                  }
+                  incxs = incx;
+                  bls.r = beta.r, bls.i = beta.i;
+                  i__7 = ly;
+                  for (i__ = 1; i__ <= i__7; ++i__) {
+                    i__8 = i__;
+                    i__9 = i__;
+                    ys[i__8].r = yy[i__9].r, ys[i__8].i = yy[i__9].i;
+                    /* L30: */
+                  }
+                  incys = incy;
+
+                  /*                             Call the subroutine. */
+
+                  if (full) {
+                    if (*trace) {
+                      io___144.ciunit = *ntra;
+                      s_wsfe(&io___144);
+                      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                      do_fio(&c__1, sname, (ftnlen)12);
+                      do_fio(&c__1, ctrans, (ftnlen)14);
+                      do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer));
+                      do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                      do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(real));
+                      do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+                      do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                      do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(real));
+                      do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+                      e_wsfe();
+                    }
+                    if (*rewi) {
+                      al__1.aerr = 0;
+                      al__1.aunit = *ntra;
+                      f_rew(&al__1);
+                    }
+                    ccgemv_(iorder, trans, &m, &n, &alpha, &aa[1], &lda, &xx[1],
+                            &incx, &beta, &yy[1], &incy);
+                  } else if (banded) {
+                    if (*trace) {
+                      io___145.ciunit = *ntra;
+                      s_wsfe(&io___145);
+                      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                      do_fio(&c__1, sname, (ftnlen)12);
+                      do_fio(&c__1, ctrans, (ftnlen)14);
+                      do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer));
+                      do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                      do_fio(&c__1, (char *)&kl, (ftnlen)sizeof(integer));
+                      do_fio(&c__1, (char *)&ku, (ftnlen)sizeof(integer));
+                      do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(real));
+                      do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+                      do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                      do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(real));
+                      do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+                      e_wsfe();
+                    }
+                    if (*rewi) {
+                      al__1.aerr = 0;
+                      al__1.aunit = *ntra;
+                      f_rew(&al__1);
+                    }
+                    ccgbmv_(iorder, trans, &m, &n, &kl, &ku, &alpha, &aa[1],
+                            &lda, &xx[1], &incx, &beta, &yy[1], &incy);
+                  }
+
+                  /*                            Check if error-exit was taken
+                   * incorrectly. */
+
+                  if (!infoc_1.ok) {
+                    io___146.ciunit = *nout;
+                    s_wsfe(&io___146);
+                    e_wsfe();
+                    *fatal = TRUE_;
+                    goto L130;
+                  }
+
+                  /*                             See what data changed inside
+                   * subroutines. */
+
+                  /*        IF(TRANS .NE. 'C' .OR. (INCX .GT. 0 .AND. INCY .GT.
+                   * 0)) THEN */
+                  isame[0] =
+                      *(unsigned char *)trans == *(unsigned char *)transs;
+                  isame[1] = ms == m;
+                  isame[2] = ns == n;
+                  if (full) {
+                    isame[3] = als.r == alpha.r && als.i == alpha.i;
+                    isame[4] = lce_(&as[1], &aa[1], &laa);
+                    isame[5] = ldas == lda;
+                    isame[6] = lce_(&xs[1], &xx[1], &lx);
+                    isame[7] = incxs == incx;
+                    isame[8] = bls.r == beta.r && bls.i == beta.i;
+                    if (null) {
+                      isame[9] = lce_(&ys[1], &yy[1], &ly);
+                    } else {
+                      i__7 = abs(incy);
+                      isame[9] = lceres_("ge", " ", &c__1, &ml, &ys[1], &yy[1],
+                                         &i__7, (ftnlen)2, (ftnlen)1);
+                    }
+                    isame[10] = incys == incy;
+                  } else if (banded) {
+                    isame[3] = kls == kl;
+                    isame[4] = kus == ku;
+                    isame[5] = als.r == alpha.r && als.i == alpha.i;
+                    isame[6] = lce_(&as[1], &aa[1], &laa);
+                    isame[7] = ldas == lda;
+                    isame[8] = lce_(&xs[1], &xx[1], &lx);
+                    isame[9] = incxs == incx;
+                    isame[10] = bls.r == beta.r && bls.i == beta.i;
+                    if (null) {
+                      isame[11] = lce_(&ys[1], &yy[1], &ly);
+                    } else {
+                      i__7 = abs(incy);
+                      isame[11] = lceres_("ge", " ", &c__1, &ml, &ys[1], &yy[1],
+                                          &i__7, (ftnlen)2, (ftnlen)1);
+                    }
+                    isame[12] = incys == incy;
+                  }
+
+                  /*                             If data was incorrectly
+                   * changed, report */
+                  /*                             and return. */
+
+                  same = TRUE_;
+                  i__7 = nargs;
+                  for (i__ = 1; i__ <= i__7; ++i__) {
+                    same = same && isame[i__ - 1];
+                    if (!isame[i__ - 1]) {
+                      io___149.ciunit = *nout;
+                      s_wsfe(&io___149);
+                      do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                      e_wsfe();
+                    }
+                    /* L40: */
+                  }
+                  if (!same) {
+                    *fatal = TRUE_;
+                    goto L130;
+                  }
+
+                  if (!null) {
+
+                    /*                                Check the result. */
+
+                    cmvch_(trans, &m, &n, &alpha, &a[a_offset], nmax, &x[1],
+                           &incx, &beta, &y[1], &incy, &yt[1], &g[1], &yy[1],
+                           eps, &err, fatal, nout, &c_true, (ftnlen)1);
+                    errmax = max(errmax, err);
+                    /*                                If got really bad answer,
+                     * report and */
+                    /*                                return. */
+                    if (*fatal) {
+                      goto L130;
+                    }
+                  } else {
+                    /*                                Avoid repeating tests with
+                     * M.le.0 or */
+                    /*                                N.le.0. */
+                    goto L110;
+                  }
+                  /*                          END IF */
+
+                  /* L50: */
+                }
+
+                /* L60: */
+              }
+
+              /* L70: */
+            }
+
+            /* L80: */
+          }
+
+          /* L90: */
+        }
+
+      L100:;
+      }
+
+    L110:;
+    }
+
+    /* L120: */
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    io___151.ciunit = *nout;
+    s_wsfe(&io___151);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else {
+    io___152.ciunit = *nout;
+    s_wsfe(&io___152);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+    e_wsfe();
+  }
+  goto L140;
+
+L130:
+  io___153.ciunit = *nout;
+  s_wsfe(&io___153);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  if (full) {
+    io___154.ciunit = *nout;
+    s_wsfe(&io___154);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, ctrans, (ftnlen)14);
+    do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(real));
+    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(real));
+    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else if (banded) {
+    io___155.ciunit = *nout;
+    s_wsfe(&io___155);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, ctrans, (ftnlen)14);
+    do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&kl, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&ku, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(real));
+    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(real));
+    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L140:
+  return 0;
+
+  /*     End of CCHK1. */
+
+} /* cchk1_ */
+
+/* Subroutine */ int
+cchk2_(char *sname, real *eps, real *thresh, integer *nout, integer *ntra,
+       logical *trace, logical *rewi, logical *fatal, integer *nidim,
+       integer *idim, integer *nkb, integer *kb, integer *nalf, complex *alf,
+       integer *nbet, complex *bet, integer *ninc, integer *inc, integer *nmax,
+       integer *incmax, complex *a, complex *aa, complex *as, complex *x,
+       complex *xx, complex *xs, complex *y, complex *yy, complex *ys,
+       complex *yt, real *g, integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ich[2] = "UL";
+
+  /* Format strings */
+  static char fmt_9993[] =
+      "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+      "i3,\002,(\002,f4.1,\002,\002,f4.1,\002), A,\002,i3,\002, X,\002,"
+      "/10x,i2,\002,(\002,f4.1,\002,\002,f4.1,\002), \002,\002Y,\002,i2,"
+      "\002) .\002)";
+  static char fmt_9994[] =
+      "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+      "2(i3,\002,\002),\002(\002,f4.1,\002,\002,f4.1,\002), A,\002,i3"
+      ",\002, X,\002,/10x,i2,\002,(\002,f4.1,\002,\002,f4.1,\002), Y"
+      ",\002,i2,\002) .\002)";
+  static char fmt_9995[] =
+      "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+      "i3,\002,(\002,f4.1,\002,\002,f4.1,\002), AP, X,\002,/10x,i2,\002"
+      ",(\002,f4.1,\002,\002,f4.1,\002), Y,\002,i2,\002) .\002)";
+  static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_9999[] = "(\002 \002,a12,\002 PASSED THE COMPUTATIONAL T"
+                           "ESTS (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_9997[] =
+      "(\002 \002,a12,\002 COMPLETED THE COMPUTATIONA"
+      "L TESTS (\002,i6,\002 C\002,\002ALLS)\002,/\002 ******* BUT WITH"
+      " MAXIMUM TEST RATIO\002,f8.2,\002 - SUSPECT *******\002)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6, i__7, i__8,
+      i__9;
+  alist al__1;
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+      f_rew(alist *);
+
+  /* Local variables */
+  integer i__, k, n, ia, ib, ic, nc, ik, in, nk, ks, ix, iy, ns, lx, ly, laa,
+      lda;
+  extern logical lce_(complex *, complex *, integer *);
+  complex als, bls;
+  real err;
+  complex beta;
+  integer ldas;
+  logical same;
+  integer incx, incy;
+  logical full, null;
+  char uplo[1];
+  extern /* Subroutine */ int cmake_(char *, char *, char *, integer *,
+                                     integer *, complex *, integer *, complex *,
+                                     integer *, integer *, integer *, logical *,
+                                     complex *, ftnlen, ftnlen, ftnlen);
+  complex alpha;
+  logical isame[13];
+  extern /* Subroutine */ int cmvch_(
+      char *, integer *, integer *, complex *, complex *, integer *, complex *,
+      integer *, complex *, complex *, integer *, complex *, real *, complex *,
+      real *, real *, logical *, integer *, logical *, ftnlen);
+  integer nargs;
+  logical reset;
+  char cuplo[14];
+  integer incxs, incys;
+  char uplos[1];
+  logical banded, packed;
+  extern /* Subroutine */ void cchbmv_(
+      integer *, char *, integer *, integer *, complex *, complex *, integer *,
+      complex *, integer *, complex *, complex *, integer *),
+      cchemv_(integer *, char *, integer *, complex *, complex *, integer *,
+              complex *, integer *, complex *, complex *, integer *);
+  extern logical lceres_(char *, char *, integer *, integer *, complex *,
+                         complex *, integer *, ftnlen, ftnlen);
+  extern /* Subroutine */ void cchpmv_(integer *, char *, integer *, complex *,
+                                      complex *, complex *, integer *,
+                                      complex *, complex *, integer *);
+  real errmax;
+  complex transl;
+
+  /* Fortran I/O blocks */
+  static cilist io___195 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___196 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___197 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___198 = {0, 0, 0, fmt_9992, 0};
+  static cilist io___201 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___203 = {0, 0, 0, fmt_9999, 0};
+  static cilist io___204 = {0, 0, 0, fmt_9997, 0};
+  static cilist io___205 = {0, 0, 0, fmt_9996, 0};
+  static cilist io___206 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___207 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___208 = {0, 0, 0, fmt_9995, 0};
+
+  /*  Tests CHEMV, CHBMV and CHPMV. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --kb;
+  --alf;
+  --bet;
+  --inc;
+  --g;
+  --yt;
+  --y;
+  --x;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --ys;
+  --yy;
+  --xs;
+  --xx;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+  full = *(unsigned char *)&sname[8] == 'e';
+  banded = *(unsigned char *)&sname[8] == 'b';
+  packed = *(unsigned char *)&sname[8] == 'p';
+  /*     Define the number of arguments. */
+  if (full) {
+    nargs = 10;
+  } else if (banded) {
+    nargs = 11;
+  } else if (packed) {
+    nargs = 9;
+  }
+
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.f;
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+
+    if (banded) {
+      nk = *nkb;
+    } else {
+      nk = 1;
+    }
+    i__2 = nk;
+    for (ik = 1; ik <= i__2; ++ik) {
+      if (banded) {
+        k = kb[ik];
+      } else {
+        k = n - 1;
+      }
+      /*           Set LDA to 1 more than minimum value if room. */
+      if (banded) {
+        lda = k + 1;
+      } else {
+        lda = n;
+      }
+      if (lda < *nmax) {
+        ++lda;
+      }
+      /*           Skip tests if not enough room. */
+      if (lda > *nmax) {
+        goto L100;
+      }
+      if (packed) {
+        laa = n * (n + 1) / 2;
+      } else {
+        laa = lda * n;
+      }
+      null = n <= 0;
+
+      for (ic = 1; ic <= 2; ++ic) {
+        *(unsigned char *)uplo = *(unsigned char *)&ich[ic - 1];
+        if (*(unsigned char *)uplo == 'U') {
+          s_copy(cuplo, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+        } else {
+          s_copy(cuplo, "    CblasLower", (ftnlen)14, (ftnlen)14);
+        }
+
+        /*              Generate the matrix A. */
+
+        transl.r = 0.f, transl.i = 0.f;
+        cmake_(sname + 7, uplo, " ", &n, &n, &a[a_offset], nmax, &aa[1], &lda,
+               &k, &k, &reset, &transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+        i__3 = *ninc;
+        for (ix = 1; ix <= i__3; ++ix) {
+          incx = inc[ix];
+          lx = abs(incx) * n;
+
+          /*                 Generate the vector X. */
+
+          transl.r = .5f, transl.i = 0.f;
+          i__4 = abs(incx);
+          i__5 = n - 1;
+          cmake_("ge", " ", " ", &c__1, &n, &x[1], &c__1, &xx[1], &i__4, &c__0,
+                 &i__5, &reset, &transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+          if (n > 1) {
+            i__4 = n / 2;
+            x[i__4].r = 0.f, x[i__4].i = 0.f;
+            i__4 = abs(incx) * (n / 2 - 1) + 1;
+            xx[i__4].r = 0.f, xx[i__4].i = 0.f;
+          }
+
+          i__4 = *ninc;
+          for (iy = 1; iy <= i__4; ++iy) {
+            incy = inc[iy];
+            ly = abs(incy) * n;
+
+            i__5 = *nalf;
+            for (ia = 1; ia <= i__5; ++ia) {
+              i__6 = ia;
+              alpha.r = alf[i__6].r, alpha.i = alf[i__6].i;
+
+              i__6 = *nbet;
+              for (ib = 1; ib <= i__6; ++ib) {
+                i__7 = ib;
+                beta.r = bet[i__7].r, beta.i = bet[i__7].i;
+
+                /*                          Generate the vector Y. */
+
+                transl.r = 0.f, transl.i = 0.f;
+                i__7 = abs(incy);
+                i__8 = n - 1;
+                cmake_("ge", " ", " ", &c__1, &n, &y[1], &c__1, &yy[1], &i__7,
+                       &c__0, &i__8, &reset, &transl, (ftnlen)2, (ftnlen)1,
+                       (ftnlen)1);
+
+                ++nc;
+
+                /*                          Save every datum before calling the
+                 */
+                /*                          subroutine. */
+
+                *(unsigned char *)uplos = *(unsigned char *)uplo;
+                ns = n;
+                ks = k;
+                als.r = alpha.r, als.i = alpha.i;
+                i__7 = laa;
+                for (i__ = 1; i__ <= i__7; ++i__) {
+                  i__8 = i__;
+                  i__9 = i__;
+                  as[i__8].r = aa[i__9].r, as[i__8].i = aa[i__9].i;
+                  /* L10: */
+                }
+                ldas = lda;
+                i__7 = lx;
+                for (i__ = 1; i__ <= i__7; ++i__) {
+                  i__8 = i__;
+                  i__9 = i__;
+                  xs[i__8].r = xx[i__9].r, xs[i__8].i = xx[i__9].i;
+                  /* L20: */
+                }
+                incxs = incx;
+                bls.r = beta.r, bls.i = beta.i;
+                i__7 = ly;
+                for (i__ = 1; i__ <= i__7; ++i__) {
+                  i__8 = i__;
+                  i__9 = i__;
+                  ys[i__8].r = yy[i__9].r, ys[i__8].i = yy[i__9].i;
+                  /* L30: */
+                }
+                incys = incy;
+
+                /*                          Call the subroutine. */
+
+                if (full) {
+                  if (*trace) {
+                    io___195.ciunit = *ntra;
+                    s_wsfe(&io___195);
+                    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, sname, (ftnlen)12);
+                    do_fio(&c__1, cuplo, (ftnlen)14);
+                    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(real));
+                    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                    do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(real));
+                    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cchemv_(iorder, uplo, &n, &alpha, &aa[1], &lda, &xx[1], &incx,
+                          &beta, &yy[1], &incy);
+                } else if (banded) {
+                  if (*trace) {
+                    io___196.ciunit = *ntra;
+                    s_wsfe(&io___196);
+                    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, sname, (ftnlen)12);
+                    do_fio(&c__1, cuplo, (ftnlen)14);
+                    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&k, (ftnlen)sizeof(integer));
+                    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(real));
+                    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                    do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(real));
+                    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cchbmv_(iorder, uplo, &n, &k, &alpha, &aa[1], &lda, &xx[1],
+                          &incx, &beta, &yy[1], &incy);
+                } else if (packed) {
+                  if (*trace) {
+                    io___197.ciunit = *ntra;
+                    s_wsfe(&io___197);
+                    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, sname, (ftnlen)12);
+                    do_fio(&c__1, cuplo, (ftnlen)14);
+                    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(real));
+                    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                    do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(real));
+                    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cchpmv_(iorder, uplo, &n, &alpha, &aa[1], &xx[1], &incx,
+                          &beta, &yy[1], &incy);
+                }
+
+                /*                          Check if error-exit was taken
+                 * incorrectly. */
+
+                if (!infoc_1.ok) {
+                  io___198.ciunit = *nout;
+                  s_wsfe(&io___198);
+                  e_wsfe();
+                  *fatal = TRUE_;
+                  goto L120;
+                }
+
+                /*                          See what data changed inside
+                 * subroutines. */
+
+                isame[0] = *(unsigned char *)uplo == *(unsigned char *)uplos;
+                isame[1] = ns == n;
+                if (full) {
+                  isame[2] = als.r == alpha.r && als.i == alpha.i;
+                  isame[3] = lce_(&as[1], &aa[1], &laa);
+                  isame[4] = ldas == lda;
+                  isame[5] = lce_(&xs[1], &xx[1], &lx);
+                  isame[6] = incxs == incx;
+                  isame[7] = bls.r == beta.r && bls.i == beta.i;
+                  if (null) {
+                    isame[8] = lce_(&ys[1], &yy[1], &ly);
+                  } else {
+                    i__7 = abs(incy);
+                    isame[8] = lceres_("ge", " ", &c__1, &n, &ys[1], &yy[1],
+                                       &i__7, (ftnlen)2, (ftnlen)1);
+                  }
+                  isame[9] = incys == incy;
+                } else if (banded) {
+                  isame[2] = ks == k;
+                  isame[3] = als.r == alpha.r && als.i == alpha.i;
+                  isame[4] = lce_(&as[1], &aa[1], &laa);
+                  isame[5] = ldas == lda;
+                  isame[6] = lce_(&xs[1], &xx[1], &lx);
+                  isame[7] = incxs == incx;
+                  isame[8] = bls.r == beta.r && bls.i == beta.i;
+                  if (null) {
+                    isame[9] = lce_(&ys[1], &yy[1], &ly);
+                  } else {
+                    i__7 = abs(incy);
+                    isame[9] = lceres_("ge", " ", &c__1, &n, &ys[1], &yy[1],
+                                       &i__7, (ftnlen)2, (ftnlen)1);
+                  }
+                  isame[10] = incys == incy;
+                } else if (packed) {
+                  isame[2] = als.r == alpha.r && als.i == alpha.i;
+                  isame[3] = lce_(&as[1], &aa[1], &laa);
+                  isame[4] = lce_(&xs[1], &xx[1], &lx);
+                  isame[5] = incxs == incx;
+                  isame[6] = bls.r == beta.r && bls.i == beta.i;
+                  if (null) {
+                    isame[7] = lce_(&ys[1], &yy[1], &ly);
+                  } else {
+                    i__7 = abs(incy);
+                    isame[7] = lceres_("ge", " ", &c__1, &n, &ys[1], &yy[1],
+                                       &i__7, (ftnlen)2, (ftnlen)1);
+                  }
+                  isame[8] = incys == incy;
+                }
+
+                /*                          If data was incorrectly changed,
+                 * report and */
+                /*                          return. */
+
+                same = TRUE_;
+                i__7 = nargs;
+                for (i__ = 1; i__ <= i__7; ++i__) {
+                  same = same && isame[i__ - 1];
+                  if (!isame[i__ - 1]) {
+                    io___201.ciunit = *nout;
+                    s_wsfe(&io___201);
+                    do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  /* L40: */
+                }
+                if (!same) {
+                  *fatal = TRUE_;
+                  goto L120;
+                }
+
+                if (!null) {
+
+                  /*                             Check the result. */
+
+                  cmvch_("N", &n, &n, &alpha, &a[a_offset], nmax, &x[1], &incx,
+                         &beta, &y[1], &incy, &yt[1], &g[1], &yy[1], eps, &err,
+                         fatal, nout, &c_true, (ftnlen)1);
+                  errmax = max(errmax, err);
+                  /*                             If got really bad answer,
+                   * report and */
+                  /*                             return. */
+                  if (*fatal) {
+                    goto L120;
+                  }
+                } else {
+                  /*                             Avoid repeating tests with
+                   * N.le.0 */
+                  goto L110;
+                }
+
+                /* L50: */
+              }
+
+              /* L60: */
+            }
+
+            /* L70: */
+          }
+
+          /* L80: */
+        }
+
+        /* L90: */
+      }
+
+    L100:;
+    }
+
+  L110:;
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    io___203.ciunit = *nout;
+    s_wsfe(&io___203);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else {
+    io___204.ciunit = *nout;
+    s_wsfe(&io___204);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+    e_wsfe();
+  }
+  goto L130;
+
+L120:
+  io___205.ciunit = *nout;
+  s_wsfe(&io___205);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  if (full) {
+    io___206.ciunit = *nout;
+    s_wsfe(&io___206);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(real));
+    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(real));
+    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else if (banded) {
+    io___207.ciunit = *nout;
+    s_wsfe(&io___207);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&k, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(real));
+    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(real));
+    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else if (packed) {
+    io___208.ciunit = *nout;
+    s_wsfe(&io___208);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(real));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(real));
+    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L130:
+  return 0;
+
+  /*     End of CCHK2. */
+
+} /* cchk2_ */
+
+/* Subroutine */ int cchk3_(char *sname, real *eps, real *thresh, integer *nout,
+                            integer *ntra, logical *trace, logical *rewi,
+                            logical *fatal, integer *nidim, integer *idim,
+                            integer *nkb, integer *kb, integer *ninc,
+                            integer *inc, integer *nmax, integer *incmax,
+                            complex *a, complex *aa, complex *as, complex *x,
+                            complex *xx, complex *xs, complex *xt, real *g,
+                            complex *z__, integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ichu[2] = "UL";
+  static char icht[3] = "NTC";
+  static char ichd[2] = "UN";
+
+  /* Format strings */
+  static char fmt_9993[] =
+      "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+      "\002),/10x,i3,\002, A,\002,i3,\002, X,\002,i2,\002) .\002)";
+  static char fmt_9994[] =
+      "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+      "\002),/10x,2(i3,\002,\002),\002 A,\002,i3,\002, X,\002,i2,\002) ."
+      "\002)";
+  static char fmt_9995[] =
+      "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+      "\002),/10x,i3,\002, AP, \002,\002X,\002,i2,\002) .\002)";
+  static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_9999[] = "(\002 \002,a12,\002 PASSED THE COMPUTATIONAL T"
+                           "ESTS (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_9997[] =
+      "(\002 \002,a12,\002 COMPLETED THE COMPUTATIONA"
+      "L TESTS (\002,i6,\002 C\002,\002ALLS)\002,/\002 ******* BUT WITH"
+      " MAXIMUM TEST RATIO\002,f8.2,\002 - SUSPECT *******\002)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;
+  alist al__1;
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_cmp(char *, char *, ftnlen, ftnlen), s_wsfe(cilist *),
+      do_fio(integer *, char *, ftnlen), e_wsfe(void), f_rew(alist *);
+
+  /* Local variables */
+  integer i__, k, n, nc, ik, in, nk, ks, ix, ns, lx, laa, icd, lda;
+  extern logical lce_(complex *, complex *, integer *);
+  integer ict, icu;
+  real err;
+  char diag[1];
+  integer ldas;
+  logical same;
+  integer incx;
+  logical full, null;
+  char uplo[1], cdiag[14];
+  extern /* Subroutine */ int cmake_(char *, char *, char *, integer *,
+                                     integer *, complex *, integer *, complex *,
+                                     integer *, integer *, integer *, logical *,
+                                     complex *, ftnlen, ftnlen, ftnlen);
+  char diags[1];
+  logical isame[13];
+  extern /* Subroutine */ int cmvch_(
+      char *, integer *, integer *, complex *, complex *, integer *, complex *,
+      integer *, complex *, complex *, integer *, complex *, real *, complex *,
+      real *, real *, logical *, integer *, logical *, ftnlen);
+  integer nargs;
+  logical reset;
+  char cuplo[14];
+  integer incxs;
+  char trans[1], uplos[1];
+  logical banded, packed;
+  extern logical lceres_(char *, char *, integer *, integer *, complex *,
+                         complex *, integer *, ftnlen, ftnlen);
+  extern /* Subroutine */ void cctbmv_(
+      integer *, char *, char *, char *, integer *, integer *, complex *,
+      integer *, complex *, integer *),
+      cctbsv_(integer *, char *, char *, char *, integer *, integer *,
+              complex *, integer *, complex *, integer *);
+  char ctrans[14];
+  extern /* Subroutine */ void cctpmv_(integer *, char *, char *, char *,
+                                      integer *, complex *, complex *,
+                                      integer *);
+  real errmax;
+  extern /* Subroutine */ void cctrmv_(
+      integer *, char *, char *, char *, integer *, complex *, integer *,
+      complex *, integer *),
+      cctpsv_(integer *, char *, char *, char *, integer *, complex *,
+              complex *, integer *);
+  complex transl;
+  extern /* Subroutine */ void cctrsv_(
+      integer *, char *, char *, char *, integer *, complex *, integer *,
+      complex *, integer *);
+  char transs[1];
+
+  /* Fortran I/O blocks */
+  static cilist io___248 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___249 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___250 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___251 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___252 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___253 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___254 = {0, 0, 0, fmt_9992, 0};
+  static cilist io___257 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___259 = {0, 0, 0, fmt_9999, 0};
+  static cilist io___260 = {0, 0, 0, fmt_9997, 0};
+  static cilist io___261 = {0, 0, 0, fmt_9996, 0};
+  static cilist io___262 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___263 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___264 = {0, 0, 0, fmt_9995, 0};
+
+  /*  Tests CTRMV, CTBMV, CTPMV, CTRSV, CTBSV and CTPSV. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --kb;
+  --inc;
+  --z__;
+  --g;
+  --xt;
+  --x;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --xs;
+  --xx;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+  full = *(unsigned char *)&sname[8] == 'r';
+  banded = *(unsigned char *)&sname[8] == 'b';
+  packed = *(unsigned char *)&sname[8] == 'p';
+  /*     Define the number of arguments. */
+  if (full) {
+    nargs = 8;
+  } else if (banded) {
+    nargs = 9;
+  } else if (packed) {
+    nargs = 7;
+  }
+
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.f;
+  /*     Set up zero vector for CMVCH. */
+  i__1 = *nmax;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    i__2 = i__;
+    z__[i__2].r = 0.f, z__[i__2].i = 0.f;
+    /* L10: */
+  }
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+
+    if (banded) {
+      nk = *nkb;
+    } else {
+      nk = 1;
+    }
+    i__2 = nk;
+    for (ik = 1; ik <= i__2; ++ik) {
+      if (banded) {
+        k = kb[ik];
+      } else {
+        k = n - 1;
+      }
+      /*           Set LDA to 1 more than minimum value if room. */
+      if (banded) {
+        lda = k + 1;
+      } else {
+        lda = n;
+      }
+      if (lda < *nmax) {
+        ++lda;
+      }
+      /*           Skip tests if not enough room. */
+      if (lda > *nmax) {
+        goto L100;
+      }
+      if (packed) {
+        laa = n * (n + 1) / 2;
+      } else {
+        laa = lda * n;
+      }
+      null = n <= 0;
+
+      for (icu = 1; icu <= 2; ++icu) {
+        *(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+        if (*(unsigned char *)uplo == 'U') {
+          s_copy(cuplo, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+        } else {
+          s_copy(cuplo, "    CblasLower", (ftnlen)14, (ftnlen)14);
+        }
+
+        for (ict = 1; ict <= 3; ++ict) {
+          *(unsigned char *)trans = *(unsigned char *)&icht[ict - 1];
+          if (*(unsigned char *)trans == 'N') {
+            s_copy(ctrans, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+          } else if (*(unsigned char *)trans == 'T') {
+            s_copy(ctrans, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+          } else {
+            s_copy(ctrans, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+          }
+
+          for (icd = 1; icd <= 2; ++icd) {
+            *(unsigned char *)diag = *(unsigned char *)&ichd[icd - 1];
+            if (*(unsigned char *)diag == 'N') {
+              s_copy(cdiag, "  CblasNonUnit", (ftnlen)14, (ftnlen)14);
+            } else {
+              s_copy(cdiag, "     CblasUnit", (ftnlen)14, (ftnlen)14);
+            }
+
+            /*                    Generate the matrix A. */
+
+            transl.r = 0.f, transl.i = 0.f;
+            cmake_(sname + 7, uplo, diag, &n, &n, &a[a_offset], nmax, &aa[1],
+                   &lda, &k, &k, &reset, &transl, (ftnlen)2, (ftnlen)1,
+                   (ftnlen)1);
+
+            i__3 = *ninc;
+            for (ix = 1; ix <= i__3; ++ix) {
+              incx = inc[ix];
+              lx = abs(incx) * n;
+
+              /*                       Generate the vector X. */
+
+              transl.r = .5f, transl.i = 0.f;
+              i__4 = abs(incx);
+              i__5 = n - 1;
+              cmake_("ge", " ", " ", &c__1, &n, &x[1], &c__1, &xx[1], &i__4,
+                     &c__0, &i__5, &reset, &transl, (ftnlen)2, (ftnlen)1,
+                     (ftnlen)1);
+              if (n > 1) {
+                i__4 = n / 2;
+                x[i__4].r = 0.f, x[i__4].i = 0.f;
+                i__4 = abs(incx) * (n / 2 - 1) + 1;
+                xx[i__4].r = 0.f, xx[i__4].i = 0.f;
+              }
+
+              ++nc;
+
+              /*                       Save every datum before calling the
+               * subroutine. */
+
+              *(unsigned char *)uplos = *(unsigned char *)uplo;
+              *(unsigned char *)transs = *(unsigned char *)trans;
+              *(unsigned char *)diags = *(unsigned char *)diag;
+              ns = n;
+              ks = k;
+              i__4 = laa;
+              for (i__ = 1; i__ <= i__4; ++i__) {
+                i__5 = i__;
+                i__6 = i__;
+                as[i__5].r = aa[i__6].r, as[i__5].i = aa[i__6].i;
+                /* L20: */
+              }
+              ldas = lda;
+              i__4 = lx;
+              for (i__ = 1; i__ <= i__4; ++i__) {
+                i__5 = i__;
+                i__6 = i__;
+                xs[i__5].r = xx[i__6].r, xs[i__5].i = xx[i__6].i;
+                /* L30: */
+              }
+              incxs = incx;
+
+              /*                       Call the subroutine. */
+
+              if (s_cmp(sname + 9, "mv", (ftnlen)2, (ftnlen)2) == 0) {
+                if (full) {
+                  if (*trace) {
+                    io___248.ciunit = *ntra;
+                    s_wsfe(&io___248);
+                    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, sname, (ftnlen)12);
+                    do_fio(&c__1, cuplo, (ftnlen)14);
+                    do_fio(&c__1, ctrans, (ftnlen)14);
+                    do_fio(&c__1, cdiag, (ftnlen)14);
+                    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cctrmv_(iorder, uplo, trans, diag, &n, &aa[1], &lda, &xx[1], &incx);
+                } else if (banded) {
+                  if (*trace) {
+                    io___249.ciunit = *ntra;
+                    s_wsfe(&io___249);
+                    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, sname, (ftnlen)12);
+                    do_fio(&c__1, cuplo, (ftnlen)14);
+                    do_fio(&c__1, ctrans, (ftnlen)14);
+                    do_fio(&c__1, cdiag, (ftnlen)14);
+                    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&k, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cctbmv_(iorder, uplo, trans, diag, &n, &k, &aa[1], &lda,
+                          &xx[1], &incx);
+                } else if (packed) {
+                  if (*trace) {
+                    io___250.ciunit = *ntra;
+                    s_wsfe(&io___250);
+                    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, sname, (ftnlen)12);
+                    do_fio(&c__1, cuplo, (ftnlen)14);
+                    do_fio(&c__1, ctrans, (ftnlen)14);
+                    do_fio(&c__1, cdiag, (ftnlen)14);
+                    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cctpmv_(iorder, uplo, trans, diag, &n, &aa[1], &xx[1], &incx);
+                }
+              } else if (s_cmp(sname + 9, "sv", (ftnlen)2, (ftnlen)2) == 0) {
+                if (full) {
+                  if (*trace) {
+                    io___251.ciunit = *ntra;
+                    s_wsfe(&io___251);
+                    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, sname, (ftnlen)12);
+                    do_fio(&c__1, cuplo, (ftnlen)14);
+                    do_fio(&c__1, ctrans, (ftnlen)14);
+                    do_fio(&c__1, cdiag, (ftnlen)14);
+                    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cctrsv_(iorder, uplo, trans, diag, &n, &aa[1], &lda, &xx[1],
+                          &incx);
+                } else if (banded) {
+                  if (*trace) {
+                    io___252.ciunit = *ntra;
+                    s_wsfe(&io___252);
+                    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, sname, (ftnlen)12);
+                    do_fio(&c__1, cuplo, (ftnlen)14);
+                    do_fio(&c__1, ctrans, (ftnlen)14);
+                    do_fio(&c__1, cdiag, (ftnlen)14);
+                    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&k, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cctbsv_(iorder, uplo, trans, diag, &n, &k, &aa[1], &lda,
+                          &xx[1], &incx);
+                } else if (packed) {
+                  if (*trace) {
+                    io___253.ciunit = *ntra;
+                    s_wsfe(&io___253);
+                    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, sname, (ftnlen)12);
+                    do_fio(&c__1, cuplo, (ftnlen)14);
+                    do_fio(&c__1, ctrans, (ftnlen)14);
+                    do_fio(&c__1, cdiag, (ftnlen)14);
+                    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cctpsv_(iorder, uplo, trans, diag, &n, &aa[1], &xx[1], &incx);
+                }
+              }
+
+              /*                       Check if error-exit was taken
+               * incorrectly. */
+
+              if (!infoc_1.ok) {
+                io___254.ciunit = *nout;
+                s_wsfe(&io___254);
+                e_wsfe();
+                *fatal = TRUE_;
+                goto L120;
+              }
+
+              /*                       See what data changed inside subroutines.
+               */
+
+              isame[0] = *(unsigned char *)uplo == *(unsigned char *)uplos;
+              isame[1] = *(unsigned char *)trans == *(unsigned char *)transs;
+              isame[2] = *(unsigned char *)diag == *(unsigned char *)diags;
+              isame[3] = ns == n;
+              if (full) {
+                isame[4] = lce_(&as[1], &aa[1], &laa);
+                isame[5] = ldas == lda;
+                if (null) {
+                  isame[6] = lce_(&xs[1], &xx[1], &lx);
+                } else {
+                  i__4 = abs(incx);
+                  isame[6] = lceres_("ge", " ", &c__1, &n, &xs[1], &xx[1],
+                                     &i__4, (ftnlen)2, (ftnlen)1);
+                }
+                isame[7] = incxs == incx;
+              } else if (banded) {
+                isame[4] = ks == k;
+                isame[5] = lce_(&as[1], &aa[1], &laa);
+                isame[6] = ldas == lda;
+                if (null) {
+                  isame[7] = lce_(&xs[1], &xx[1], &lx);
+                } else {
+                  i__4 = abs(incx);
+                  isame[7] = lceres_("ge", " ", &c__1, &n, &xs[1], &xx[1],
+                                     &i__4, (ftnlen)2, (ftnlen)1);
+                }
+                isame[8] = incxs == incx;
+              } else if (packed) {
+                isame[4] = lce_(&as[1], &aa[1], &laa);
+                if (null) {
+                  isame[5] = lce_(&xs[1], &xx[1], &lx);
+                } else {
+                  i__4 = abs(incx);
+                  isame[5] = lceres_("ge", " ", &c__1, &n, &xs[1], &xx[1],
+                                     &i__4, (ftnlen)2, (ftnlen)1);
+                }
+                isame[6] = incxs == incx;
+              }
+
+              /*                       If data was incorrectly changed, report
+               * and */
+              /*                       return. */
+
+              same = TRUE_;
+              i__4 = nargs;
+              for (i__ = 1; i__ <= i__4; ++i__) {
+                same = same && isame[i__ - 1];
+                if (!isame[i__ - 1]) {
+                  io___257.ciunit = *nout;
+                  s_wsfe(&io___257);
+                  do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                  e_wsfe();
+                }
+                /* L40: */
+              }
+              if (!same) {
+                *fatal = TRUE_;
+                goto L120;
+              }
+
+              if (!null) {
+                if (s_cmp(sname + 9, "mv", (ftnlen)2, (ftnlen)2) == 0) {
+
+                  /*                             Check the result. */
+
+                  cmvch_(trans, &n, &n, &c_b2, &a[a_offset], nmax, &x[1], &incx,
+                         &c_b1, &z__[1], &incx, &xt[1], &g[1], &xx[1], eps,
+                         &err, fatal, nout, &c_true, (ftnlen)1);
+                } else if (s_cmp(sname + 9, "sv", (ftnlen)2, (ftnlen)2) == 0) {
+
+                  /*                             Compute approximation to
+                   * original vector. */
+
+                  i__4 = n;
+                  for (i__ = 1; i__ <= i__4; ++i__) {
+                    i__5 = i__;
+                    i__6 = (i__ - 1) * abs(incx) + 1;
+                    z__[i__5].r = xx[i__6].r, z__[i__5].i = xx[i__6].i;
+                    i__5 = (i__ - 1) * abs(incx) + 1;
+                    i__6 = i__;
+                    xx[i__5].r = x[i__6].r, xx[i__5].i = x[i__6].i;
+                    /* L50: */
+                  }
+                  cmvch_(trans, &n, &n, &c_b2, &a[a_offset], nmax, &z__[1],
+                         &incx, &c_b1, &x[1], &incx, &xt[1], &g[1], &xx[1], eps,
+                         &err, fatal, nout, &c_false, (ftnlen)1);
+                }
+                errmax = max(errmax, err);
+                /*                          If got really bad answer, report and
+                 * return. */
+                if (*fatal) {
+                  goto L120;
+                }
+              } else {
+                /*                          Avoid repeating tests with N.le.0.
+                 */
+                goto L110;
+              }
+
+              /* L60: */
+            }
+
+            /* L70: */
+          }
+
+          /* L80: */
+        }
+
+        /* L90: */
+      }
+
+    L100:;
+    }
+
+  L110:;
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    io___259.ciunit = *nout;
+    s_wsfe(&io___259);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else {
+    io___260.ciunit = *nout;
+    s_wsfe(&io___260);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+    e_wsfe();
+  }
+  goto L130;
+
+L120:
+  io___261.ciunit = *nout;
+  s_wsfe(&io___261);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  if (full) {
+    io___262.ciunit = *nout;
+    s_wsfe(&io___262);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, ctrans, (ftnlen)14);
+    do_fio(&c__1, cdiag, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else if (banded) {
+    io___263.ciunit = *nout;
+    s_wsfe(&io___263);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, ctrans, (ftnlen)14);
+    do_fio(&c__1, cdiag, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&k, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else if (packed) {
+    io___264.ciunit = *nout;
+    s_wsfe(&io___264);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, ctrans, (ftnlen)14);
+    do_fio(&c__1, cdiag, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L130:
+  return 0;
+
+  /*     End of CCHK3. */
+
+} /* cchk3_ */
+
+/* Subroutine */ int cchk4_(char *sname, real *eps, real *thresh, integer *nout,
+                            integer *ntra, logical *trace, logical *rewi,
+                            logical *fatal, integer *nidim, integer *idim,
+                            integer *nalf, complex *alf, integer *ninc,
+                            integer *inc, integer *nmax, integer *incmax,
+                            complex *a, complex *aa, complex *as, complex *x,
+                            complex *xx, complex *xs, complex *y, complex *yy,
+                            complex *ys, complex *yt, real *g, complex *z__,
+                            integer *iorder, ftnlen sname_len) {
+  /* Format strings */
+  static char fmt_9994[] =
+      "(1x,i6,\002: \002,a12,\002(\002,2(i3,\002,\002"
+      "),\002(\002,f4.1,\002,\002,f4.1,\002), X,\002,i2,\002, Y,\002,i2,"
+      "\002, A,\002,i3,\002) .\002)";
+  static char fmt_9993[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_9999[] = "(\002 \002,a12,\002 PASSED THE COMPUTATIONAL T"
+                           "ESTS (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_9997[] =
+      "(\002 \002,a12,\002 COMPLETED THE COMPUTATIONA"
+      "L TESTS (\002,i6,\002 C\002,\002ALLS)\002,/\002 ******* BUT WITH"
+      " MAXIMUM TEST RATIO\002,f8.2,\002 - SUSPECT *******\002)";
+  static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+                           " \002,i3)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6, i__7;
+  complex q__1;
+  alist al__1;
+
+  /* Builtin functions */
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+      f_rew(alist *);
+  void r_cnjg(complex *, complex *);
+
+  /* Local variables */
+  integer i__, j, m, n;
+  complex w[1];
+  integer ia, nc, nd, im, in, ms, ix, iy, ns, lx, ly, laa, lda;
+  extern logical lce_(complex *, complex *, integer *);
+  complex als;
+  real err;
+  integer ldas;
+  logical same, conj;
+  integer incx, incy;
+  logical null;
+  extern /* Subroutine */ int cmake_(char *, char *, char *, integer *,
+                                     integer *, complex *, integer *, complex *,
+                                     integer *, integer *, integer *, logical *,
+                                     complex *, ftnlen, ftnlen, ftnlen);
+  complex alpha;
+  logical isame[13];
+  extern /* Subroutine */ int cmvch_(
+      char *, integer *, integer *, complex *, complex *, integer *, complex *,
+      integer *, complex *, complex *, integer *, complex *, real *, complex *,
+      real *, real *, logical *, integer *, logical *, ftnlen);
+  integer nargs;
+  logical reset;
+  integer incxs, incys;
+  extern /* Subroutine */ void ccgerc_(
+      integer *, integer *, integer *, complex *, complex *, integer *,
+      complex *, integer *, complex *, integer *),
+      ccgeru_(integer *, integer *, integer *, complex *, complex *, integer *,
+              complex *, integer *, complex *, integer *);
+  extern logical lceres_(char *, char *, integer *, integer *, complex *,
+                         complex *, integer *, ftnlen, ftnlen);
+  real errmax;
+  complex transl;
+
+  /* Fortran I/O blocks */
+  static cilist io___294 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___295 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___298 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___302 = {0, 0, 0, fmt_9999, 0};
+  static cilist io___303 = {0, 0, 0, fmt_9997, 0};
+  static cilist io___304 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___305 = {0, 0, 0, fmt_9996, 0};
+  static cilist io___306 = {0, 0, 0, fmt_9994, 0};
+
+  /*  Tests CGERC and CGERU. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --inc;
+  --z__;
+  --g;
+  --yt;
+  --y;
+  --x;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --ys;
+  --yy;
+  --xs;
+  --xx;
+
+  /* Function Body */
+  conj = *(unsigned char *)&sname[10] == 'c';
+  /*     Define the number of arguments. */
+  nargs = 9;
+
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.f;
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+    nd = n / 2 + 1;
+
+    for (im = 1; im <= 2; ++im) {
+      if (im == 1) {
+        /* Computing MAX */
+        i__2 = n - nd;
+        m = max(i__2, 0);
+      }
+      if (im == 2) {
+        /* Computing MIN */
+        i__2 = n + nd;
+        m = min(i__2, *nmax);
+      }
+
+      /*           Set LDA to 1 more than minimum value if room. */
+      lda = m;
+      if (lda < *nmax) {
+        ++lda;
+      }
+      /*           Skip tests if not enough room. */
+      if (lda > *nmax) {
+        goto L110;
+      }
+      laa = lda * n;
+      null = n <= 0 || m <= 0;
+
+      i__2 = *ninc;
+      for (ix = 1; ix <= i__2; ++ix) {
+        incx = inc[ix];
+        lx = abs(incx) * m;
+
+        /*              Generate the vector X. */
+
+        transl.r = .5f, transl.i = 0.f;
+        i__3 = abs(incx);
+        i__4 = m - 1;
+        cmake_("ge", " ", " ", &c__1, &m, &x[1], &c__1, &xx[1], &i__3, &c__0,
+               &i__4, &reset, &transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        if (m > 1) {
+          i__3 = m / 2;
+          x[i__3].r = 0.f, x[i__3].i = 0.f;
+          i__3 = abs(incx) * (m / 2 - 1) + 1;
+          xx[i__3].r = 0.f, xx[i__3].i = 0.f;
+        }
+
+        i__3 = *ninc;
+        for (iy = 1; iy <= i__3; ++iy) {
+          incy = inc[iy];
+          ly = abs(incy) * n;
+
+          /*                 Generate the vector Y. */
+
+          transl.r = 0.f, transl.i = 0.f;
+          i__4 = abs(incy);
+          i__5 = n - 1;
+          cmake_("ge", " ", " ", &c__1, &n, &y[1], &c__1, &yy[1], &i__4, &c__0,
+                 &i__5, &reset, &transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+          if (n > 1) {
+            i__4 = n / 2;
+            y[i__4].r = 0.f, y[i__4].i = 0.f;
+            i__4 = abs(incy) * (n / 2 - 1) + 1;
+            yy[i__4].r = 0.f, yy[i__4].i = 0.f;
+          }
+
+          i__4 = *nalf;
+          for (ia = 1; ia <= i__4; ++ia) {
+            i__5 = ia;
+            alpha.r = alf[i__5].r, alpha.i = alf[i__5].i;
+
+            /*                    Generate the matrix A. */
+
+            transl.r = 0.f, transl.i = 0.f;
+            i__5 = m - 1;
+            i__6 = n - 1;
+            cmake_(sname + 7, " ", " ", &m, &n, &a[a_offset], nmax, &aa[1],
+                   &lda, &i__5, &i__6, &reset, &transl, (ftnlen)2, (ftnlen)1,
+                   (ftnlen)1);
+
+            ++nc;
+
+            /*                    Save every datum before calling the
+             * subroutine. */
+
+            ms = m;
+            ns = n;
+            als.r = alpha.r, als.i = alpha.i;
+            i__5 = laa;
+            for (i__ = 1; i__ <= i__5; ++i__) {
+              i__6 = i__;
+              i__7 = i__;
+              as[i__6].r = aa[i__7].r, as[i__6].i = aa[i__7].i;
+              /* L10: */
+            }
+            ldas = lda;
+            i__5 = lx;
+            for (i__ = 1; i__ <= i__5; ++i__) {
+              i__6 = i__;
+              i__7 = i__;
+              xs[i__6].r = xx[i__7].r, xs[i__6].i = xx[i__7].i;
+              /* L20: */
+            }
+            incxs = incx;
+            i__5 = ly;
+            for (i__ = 1; i__ <= i__5; ++i__) {
+              i__6 = i__;
+              i__7 = i__;
+              ys[i__6].r = yy[i__7].r, ys[i__6].i = yy[i__7].i;
+              /* L30: */
+            }
+            incys = incy;
+
+            /*                    Call the subroutine. */
+
+            if (*trace) {
+              io___294.ciunit = *ntra;
+              s_wsfe(&io___294);
+              do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+              do_fio(&c__1, sname, (ftnlen)12);
+              do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer));
+              do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+              do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(real));
+              do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+              do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+              do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+              e_wsfe();
+            }
+            if (conj) {
+              if (*rewi) {
+                al__1.aerr = 0;
+                al__1.aunit = *ntra;
+                f_rew(&al__1);
+              }
+              ccgerc_(iorder, &m, &n, &alpha, &xx[1], &incx, &yy[1], &incy,
+                      &aa[1], &lda);
+            } else {
+              if (*rewi) {
+                al__1.aerr = 0;
+                al__1.aunit = *ntra;
+                f_rew(&al__1);
+              }
+              ccgeru_(iorder, &m, &n, &alpha, &xx[1], &incx, &yy[1], &incy,
+                      &aa[1], &lda);
+            }
+
+            /*                    Check if error-exit was taken incorrectly. */
+
+            if (!infoc_1.ok) {
+              io___295.ciunit = *nout;
+              s_wsfe(&io___295);
+              e_wsfe();
+              *fatal = TRUE_;
+              goto L140;
+            }
+
+            /*                    See what data changed inside subroutine. */
+
+            isame[0] = ms == m;
+            isame[1] = ns == n;
+            isame[2] = als.r == alpha.r && als.i == alpha.i;
+            isame[3] = lce_(&xs[1], &xx[1], &lx);
+            isame[4] = incxs == incx;
+            isame[5] = lce_(&ys[1], &yy[1], &ly);
+            isame[6] = incys == incy;
+            if (null) {
+              isame[7] = lce_(&as[1], &aa[1], &laa);
+            } else {
+              isame[7] = lceres_("ge", " ", &m, &n, &as[1], &aa[1], &lda,
+                                 (ftnlen)2, (ftnlen)1);
+            }
+            isame[8] = ldas == lda;
+
+            /*                   If data was incorrectly changed, report and
+             * return. */
+
+            same = TRUE_;
+            i__5 = nargs;
+            for (i__ = 1; i__ <= i__5; ++i__) {
+              same = same && isame[i__ - 1];
+              if (!isame[i__ - 1]) {
+                io___298.ciunit = *nout;
+                s_wsfe(&io___298);
+                do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                e_wsfe();
+              }
+              /* L40: */
+            }
+            if (!same) {
+              *fatal = TRUE_;
+              goto L140;
+            }
+
+            if (!null) {
+
+              /*                       Check the result column by column. */
+
+              if (incx > 0) {
+                i__5 = m;
+                for (i__ = 1; i__ <= i__5; ++i__) {
+                  i__6 = i__;
+                  i__7 = i__;
+                  z__[i__6].r = x[i__7].r, z__[i__6].i = x[i__7].i;
+                  /* L50: */
+                }
+              } else {
+                i__5 = m;
+                for (i__ = 1; i__ <= i__5; ++i__) {
+                  i__6 = i__;
+                  i__7 = m - i__ + 1;
+                  z__[i__6].r = x[i__7].r, z__[i__6].i = x[i__7].i;
+                  /* L60: */
+                }
+              }
+              i__5 = n;
+              for (j = 1; j <= i__5; ++j) {
+                if (incy > 0) {
+                  i__6 = j;
+                  w[0].r = y[i__6].r, w[0].i = y[i__6].i;
+                } else {
+                  i__6 = n - j + 1;
+                  w[0].r = y[i__6].r, w[0].i = y[i__6].i;
+                }
+                if (conj) {
+                  r_cnjg(&q__1, w);
+                  w[0].r = q__1.r, w[0].i = q__1.i;
+                }
+                cmvch_("N", &m, &c__1, &alpha, &z__[1], nmax, w, &c__1, &c_b2,
+                       &a[j * a_dim1 + 1], &c__1, &yt[1], &g[1],
+                       &aa[(j - 1) * lda + 1], eps, &err, fatal, nout, &c_true,
+                       (ftnlen)1);
+                errmax = max(errmax, err);
+                /*                          If got really bad answer, report and
+                 * return. */
+                if (*fatal) {
+                  goto L130;
+                }
+                /* L70: */
+              }
+            } else {
+              /*                       Avoid repeating tests with M.le.0 or
+               * N.le.0. */
+              goto L110;
+            }
+
+            /* L80: */
+          }
+
+          /* L90: */
+        }
+
+        /* L100: */
+      }
+
+    L110:;
+    }
+
+    /* L120: */
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    io___302.ciunit = *nout;
+    s_wsfe(&io___302);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else {
+    io___303.ciunit = *nout;
+    s_wsfe(&io___303);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+    e_wsfe();
+  }
+  goto L150;
+
+L130:
+  io___304.ciunit = *nout;
+  s_wsfe(&io___304);
+  do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+  e_wsfe();
+
+L140:
+  io___305.ciunit = *nout;
+  s_wsfe(&io___305);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  io___306.ciunit = *nout;
+  s_wsfe(&io___306);
+  do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+  e_wsfe();
+
+L150:
+  return 0;
+
+  /*     End of CCHK4. */
+
+} /* cchk4_ */
+
+/* Subroutine */ int cchk5_(char *sname, real *eps, real *thresh, integer *nout,
+                            integer *ntra, logical *trace, logical *rewi,
+                            logical *fatal, integer *nidim, integer *idim,
+                            integer *nalf, complex *alf, integer *ninc,
+                            integer *inc, integer *nmax, integer *incmax,
+                            complex *a, complex *aa, complex *as, complex *x,
+                            complex *xx, complex *xs, complex *y, complex *yy,
+                            complex *ys, complex *yt, real *g, complex *z__,
+                            integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ich[2] = "UL";
+
+  /* Format strings */
+  static char fmt_9993[] =
+      "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+      "i3,\002,\002,f4.1,\002, X,\002,i2,\002, A,\002,i3,\002) .\002)";
+  static char fmt_9994[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+                           "i3,\002,\002,f4.1,\002, X,\002,i2,\002, AP) .\002)";
+  static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_9999[] = "(\002 \002,a12,\002 PASSED THE COMPUTATIONAL T"
+                           "ESTS (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_9997[] =
+      "(\002 \002,a12,\002 COMPLETED THE COMPUTATIONA"
+      "L TESTS (\002,i6,\002 C\002,\002ALLS)\002,/\002 ******* BUT WITH"
+      " MAXIMUM TEST RATIO\002,f8.2,\002 - SUSPECT *******\002)";
+  static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+                           " \002,i3)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;
+  complex q__1;
+  alist al__1;
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+      f_rew(alist *);
+  void r_cnjg(complex *, complex *);
+
+  /* Local variables */
+  integer i__, j, n;
+  complex w[1];
+  integer ia, ja, ic, nc, jj, lj, in, ix, ns, lx, laa, lda;
+  extern logical lce_(complex *, complex *, integer *);
+  real err;
+  integer ldas;
+  logical same;
+  real rals;
+  integer incx;
+  logical full, null;
+  char uplo[1];
+  extern /* Subroutine */ int cmake_(char *, char *, char *, integer *,
+                                     integer *, complex *, integer *, complex *,
+                                     integer *, integer *, integer *, logical *,
+                                     complex *, ftnlen, ftnlen, ftnlen);
+  extern void ccher_(integer *, char *, integer *, real *, complex *, integer *,
+                     complex *, integer *);
+  complex alpha;
+  logical isame[13];
+  extern /* Subroutine */ void cchpr_(integer *, char *, integer *, real *,
+                                     complex *, integer *, complex *);
+
+  extern int cmvch_(char *, integer *, integer *, complex *, complex *, integer *,
+                complex *, integer *, complex *, complex *, integer *, complex *,
+                real *, complex *, real *, real *, logical *, integer *, logical *,
+                ftnlen);
+  integer nargs;
+  logical reset;
+  char cuplo[14];
+  integer incxs;
+  logical upper;
+  char uplos[1];
+  logical packed;
+  real ralpha;
+  extern logical lceres_(char *, char *, integer *, integer *, complex *,
+                         complex *, integer *, ftnlen, ftnlen);
+  real errmax;
+  complex transl;
+
+  /* Fortran I/O blocks */
+  static cilist io___336 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___337 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___338 = {0, 0, 0, fmt_9992, 0};
+  static cilist io___341 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___348 = {0, 0, 0, fmt_9999, 0};
+  static cilist io___349 = {0, 0, 0, fmt_9997, 0};
+  static cilist io___350 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___351 = {0, 0, 0, fmt_9996, 0};
+  static cilist io___352 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___353 = {0, 0, 0, fmt_9994, 0};
+
+  /*  Tests CHER and CHPR. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --inc;
+  --z__;
+  --g;
+  --yt;
+  --y;
+  --x;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --ys;
+  --yy;
+  --xs;
+  --xx;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+  full = *(unsigned char *)&sname[8] == 'e';
+  packed = *(unsigned char *)&sname[8] == 'p';
+  /*     Define the number of arguments. */
+  if (full) {
+    nargs = 7;
+  } else if (packed) {
+    nargs = 6;
+  }
+
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.f;
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+    /*        Set LDA to 1 more than minimum value if room. */
+    lda = n;
+    if (lda < *nmax) {
+      ++lda;
+    }
+    /*        Skip tests if not enough room. */
+    if (lda > *nmax) {
+      goto L100;
+    }
+    if (packed) {
+      laa = n * (n + 1) / 2;
+    } else {
+      laa = lda * n;
+    }
+
+    for (ic = 1; ic <= 2; ++ic) {
+      *(unsigned char *)uplo = *(unsigned char *)&ich[ic - 1];
+      if (*(unsigned char *)uplo == 'U') {
+        s_copy(cuplo, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+      } else {
+        s_copy(cuplo, "    CblasLower", (ftnlen)14, (ftnlen)14);
+      }
+      upper = *(unsigned char *)uplo == 'U';
+
+      i__2 = *ninc;
+      for (ix = 1; ix <= i__2; ++ix) {
+        incx = inc[ix];
+        lx = abs(incx) * n;
+
+        /*              Generate the vector X. */
+
+        transl.r = .5f, transl.i = 0.f;
+        i__3 = abs(incx);
+        i__4 = n - 1;
+        cmake_("ge", " ", " ", &c__1, &n, &x[1], &c__1, &xx[1], &i__3, &c__0,
+               &i__4, &reset, &transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        if (n > 1) {
+          i__3 = n / 2;
+          x[i__3].r = 0.f, x[i__3].i = 0.f;
+          i__3 = abs(incx) * (n / 2 - 1) + 1;
+          xx[i__3].r = 0.f, xx[i__3].i = 0.f;
+        }
+
+        i__3 = *nalf;
+        for (ia = 1; ia <= i__3; ++ia) {
+          i__4 = ia;
+          ralpha = alf[i__4].r;
+          q__1.r = ralpha, q__1.i = 0.f;
+          alpha.r = q__1.r, alpha.i = q__1.i;
+          null = n <= 0 || ralpha == 0.f;
+
+          /*                 Generate the matrix A. */
+
+          transl.r = 0.f, transl.i = 0.f;
+          i__4 = n - 1;
+          i__5 = n - 1;
+          cmake_(sname + 7, uplo, " ", &n, &n, &a[a_offset], nmax, &aa[1], &lda,
+                 &i__4, &i__5, &reset, &transl, (ftnlen)2, (ftnlen)1,
+                 (ftnlen)1);
+
+          ++nc;
+
+          /*                 Save every datum before calling the subroutine. */
+
+          *(unsigned char *)uplos = *(unsigned char *)uplo;
+          ns = n;
+          rals = ralpha;
+          i__4 = laa;
+          for (i__ = 1; i__ <= i__4; ++i__) {
+            i__5 = i__;
+            i__6 = i__;
+            as[i__5].r = aa[i__6].r, as[i__5].i = aa[i__6].i;
+            /* L10: */
+          }
+          ldas = lda;
+          i__4 = lx;
+          for (i__ = 1; i__ <= i__4; ++i__) {
+            i__5 = i__;
+            i__6 = i__;
+            xs[i__5].r = xx[i__6].r, xs[i__5].i = xx[i__6].i;
+            /* L20: */
+          }
+          incxs = incx;
+
+          /*                 Call the subroutine. */
+
+          if (full) {
+            if (*trace) {
+              io___336.ciunit = *ntra;
+              s_wsfe(&io___336);
+              do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+              do_fio(&c__1, sname, (ftnlen)12);
+              do_fio(&c__1, cuplo, (ftnlen)14);
+              do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+              do_fio(&c__1, (char *)&ralpha, (ftnlen)sizeof(real));
+              do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+              do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+              e_wsfe();
+            }
+            if (*rewi) {
+              al__1.aerr = 0;
+              al__1.aunit = *ntra;
+              f_rew(&al__1);
+            }
+            ccher_(iorder, uplo, &n, &ralpha, &xx[1], &incx, &aa[1], &lda);
+          } else if (packed) {
+            if (*trace) {
+              io___337.ciunit = *ntra;
+              s_wsfe(&io___337);
+              do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+              do_fio(&c__1, sname, (ftnlen)12);
+              do_fio(&c__1, cuplo, (ftnlen)14);
+              do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+              do_fio(&c__1, (char *)&ralpha, (ftnlen)sizeof(real));
+              do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+              e_wsfe();
+            }
+            if (*rewi) {
+              al__1.aerr = 0;
+              al__1.aunit = *ntra;
+              f_rew(&al__1);
+            }
+            cchpr_(iorder, uplo, &n, &ralpha, &xx[1], &incx, &aa[1]);
+          }
+
+          /*                 Check if error-exit was taken incorrectly. */
+
+          if (!infoc_1.ok) {
+            io___338.ciunit = *nout;
+            s_wsfe(&io___338);
+            e_wsfe();
+            *fatal = TRUE_;
+            goto L120;
+          }
+
+          /*                 See what data changed inside subroutines. */
+
+          isame[0] = *(unsigned char *)uplo == *(unsigned char *)uplos;
+          isame[1] = ns == n;
+          isame[2] = rals == ralpha;
+          isame[3] = lce_(&xs[1], &xx[1], &lx);
+          isame[4] = incxs == incx;
+          if (null) {
+            isame[5] = lce_(&as[1], &aa[1], &laa);
+          } else {
+            isame[5] = lceres_(sname + 7, uplo, &n, &n, &as[1], &aa[1], &lda,
+                               (ftnlen)2, (ftnlen)1);
+          }
+          if (!packed) {
+            isame[6] = ldas == lda;
+          }
+
+          /*                 If data was incorrectly changed, report and return.
+           */
+
+          same = TRUE_;
+          i__4 = nargs;
+          for (i__ = 1; i__ <= i__4; ++i__) {
+            same = same && isame[i__ - 1];
+            if (!isame[i__ - 1]) {
+              io___341.ciunit = *nout;
+              s_wsfe(&io___341);
+              do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+              e_wsfe();
+            }
+            /* L30: */
+          }
+          if (!same) {
+            *fatal = TRUE_;
+            goto L120;
+          }
+
+          if (!null) {
+
+            /*                    Check the result column by column. */
+
+            if (incx > 0) {
+              i__4 = n;
+              for (i__ = 1; i__ <= i__4; ++i__) {
+                i__5 = i__;
+                i__6 = i__;
+                z__[i__5].r = x[i__6].r, z__[i__5].i = x[i__6].i;
+                /* L40: */
+              }
+            } else {
+              i__4 = n;
+              for (i__ = 1; i__ <= i__4; ++i__) {
+                i__5 = i__;
+                i__6 = n - i__ + 1;
+                z__[i__5].r = x[i__6].r, z__[i__5].i = x[i__6].i;
+                /* L50: */
+              }
+            }
+            ja = 1;
+            i__4 = n;
+            for (j = 1; j <= i__4; ++j) {
+              r_cnjg(&q__1, &z__[j]);
+              w[0].r = q__1.r, w[0].i = q__1.i;
+              if (upper) {
+                jj = 1;
+                lj = j;
+              } else {
+                jj = j;
+                lj = n - j + 1;
+              }
+              cmvch_("N", &lj, &c__1, &alpha, &z__[jj], &lj, w, &c__1, &c_b2,
+                     &a[jj + j * a_dim1], &c__1, &yt[1], &g[1], &aa[ja], eps,
+                     &err, fatal, nout, &c_true, (ftnlen)1);
+              if (full) {
+                if (upper) {
+                  ja += lda;
+                } else {
+                  ja = ja + lda + 1;
+                }
+              } else {
+                ja += lj;
+              }
+              errmax = max(errmax, err);
+              /*                       If got really bad answer, report and
+               * return. */
+              if (*fatal) {
+                goto L110;
+              }
+              /* L60: */
+            }
+          } else {
+            /*                    Avoid repeating tests if N.le.0. */
+            if (n <= 0) {
+              goto L100;
+            }
+          }
+
+          /* L70: */
+        }
+
+        /* L80: */
+      }
+
+      /* L90: */
+    }
+
+  L100:;
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    io___348.ciunit = *nout;
+    s_wsfe(&io___348);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else {
+    io___349.ciunit = *nout;
+    s_wsfe(&io___349);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+    e_wsfe();
+  }
+  goto L130;
+
+L110:
+  io___350.ciunit = *nout;
+  s_wsfe(&io___350);
+  do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+  e_wsfe();
+
+L120:
+  io___351.ciunit = *nout;
+  s_wsfe(&io___351);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  if (full) {
+    io___352.ciunit = *nout;
+    s_wsfe(&io___352);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&ralpha, (ftnlen)sizeof(real));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else if (packed) {
+    io___353.ciunit = *nout;
+    s_wsfe(&io___353);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&ralpha, (ftnlen)sizeof(real));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L130:
+  return 0;
+
+  /*     End of CCHK5. */
+
+} /* cchk5_ */
+
+/* Subroutine */ int cchk6_(char *sname, real *eps, real *thresh, integer *nout,
+                            integer *ntra, logical *trace, logical *rewi,
+                            logical *fatal, integer *nidim, integer *idim,
+                            integer *nalf, complex *alf, integer *ninc,
+                            integer *inc, integer *nmax, integer *incmax,
+                            complex *a, complex *aa, complex *as, complex *x,
+                            complex *xx, complex *xs, complex *y, complex *yy,
+                            complex *ys, complex *yt, real *g, complex *z__,
+                            integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ich[2] = "UL";
+
+  /* Format strings */
+  static char fmt_9993[] =
+      "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+      "i3,\002,(\002,f4.1,\002,\002,f4.1,\002), X,\002,i2,\002, Y,\002,"
+      "i2,\002, A,\002,i3,\002) .\002)";
+  static char fmt_9994[] =
+      "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+      "i3,\002,(\002,f4.1,\002,\002,f4.1,\002), X,\002,i2,\002, Y,\002,"
+      "i2,\002, AP) .\002)";
+  static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_9999[] = "(\002 \002,a12,\002 PASSED THE COMPUTATIONAL T"
+                           "ESTS (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_9997[] =
+      "(\002 \002,a12,\002 COMPLETED THE COMPUTATIONA"
+      "L TESTS (\002,i6,\002 C\002,\002ALLS)\002,/\002 ******* BUT WITH"
+      " MAXIMUM TEST RATIO\002,f8.2,\002 - SUSPECT *******\002)";
+  static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+                           " \002,i3)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4, i__5,
+      i__6, i__7;
+  complex q__1, q__2, q__3;
+  alist al__1;
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+      f_rew(alist *);
+  void r_cnjg(complex *, complex *);
+
+  /* Local variables */
+  integer i__, j, n;
+  complex w[2];
+  integer ia, ja, ic, nc, jj, lj, in, ix, iy, ns, lx, ly, laa, lda;
+  extern logical lce_(complex *, complex *, integer *);
+  complex als;
+  real err;
+  integer ldas;
+  logical same;
+  integer incx, incy;
+  logical full, null;
+  char uplo[1];
+  extern /* Subroutine */ int cmake_(char *, char *, char *, integer *,
+                                     integer *, complex *, integer *, complex *,
+                                     integer *, integer *, integer *, logical *,
+                                     complex *, ftnlen, ftnlen, ftnlen);
+  complex alpha;
+  logical isame[13];
+  extern /* Subroutine */ int cmvch_(
+      char *, integer *, integer *, complex *, complex *, integer *, complex *,
+      integer *, complex *, complex *, integer *, complex *, real *, complex *,
+      real *, real *, logical *, integer *, logical *, ftnlen);
+  integer nargs;
+  logical reset;
+  char cuplo[14];
+  integer incxs, incys;
+  logical upper;
+  char uplos[1];
+  extern /* Subroutine */ void ccher2_(integer *, char *, integer *, complex *,
+                                      complex *, integer *, complex *,
+                                      integer *, complex *, integer *),
+      cchpr2_(integer *, char *, integer *, complex *, complex *, integer *,
+              complex *, integer *, complex *);
+  logical packed;
+  extern logical lceres_(char *, char *, integer *, integer *, complex *,
+                         complex *, integer *, ftnlen, ftnlen);
+  real errmax;
+  complex transl;
+
+  /* Fortran I/O blocks */
+  static cilist io___386 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___387 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___388 = {0, 0, 0, fmt_9992, 0};
+  static cilist io___391 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___398 = {0, 0, 0, fmt_9999, 0};
+  static cilist io___399 = {0, 0, 0, fmt_9997, 0};
+  static cilist io___400 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___401 = {0, 0, 0, fmt_9996, 0};
+  static cilist io___402 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___403 = {0, 0, 0, fmt_9994, 0};
+
+  /*  Tests CHER2 and CHPR2. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --inc;
+  z_dim1 = *nmax;
+  z_offset = 1 + z_dim1;
+  z__ -= z_offset;
+  --g;
+  --yt;
+  --y;
+  --x;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --ys;
+  --yy;
+  --xs;
+  --xx;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+  full = *(unsigned char *)&sname[8] == 'e';
+  packed = *(unsigned char *)&sname[8] == 'p';
+  /*     Define the number of arguments. */
+  if (full) {
+    nargs = 9;
+  } else if (packed) {
+    nargs = 8;
+  }
+
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.f;
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+    /*        Set LDA to 1 more than minimum value if room. */
+    lda = n;
+    if (lda < *nmax) {
+      ++lda;
+    }
+    /*        Skip tests if not enough room. */
+    if (lda > *nmax) {
+      goto L140;
+    }
+    if (packed) {
+      laa = n * (n + 1) / 2;
+    } else {
+      laa = lda * n;
+    }
+
+    for (ic = 1; ic <= 2; ++ic) {
+      *(unsigned char *)uplo = *(unsigned char *)&ich[ic - 1];
+      if (*(unsigned char *)uplo == 'U') {
+        s_copy(cuplo, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+      } else {
+        s_copy(cuplo, "    CblasLower", (ftnlen)14, (ftnlen)14);
+      }
+      upper = *(unsigned char *)uplo == 'U';
+
+      i__2 = *ninc;
+      for (ix = 1; ix <= i__2; ++ix) {
+        incx = inc[ix];
+        lx = abs(incx) * n;
+
+        /*              Generate the vector X. */
+
+        transl.r = .5f, transl.i = 0.f;
+        i__3 = abs(incx);
+        i__4 = n - 1;
+        cmake_("ge", " ", " ", &c__1, &n, &x[1], &c__1, &xx[1], &i__3, &c__0,
+               &i__4, &reset, &transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        if (n > 1) {
+          i__3 = n / 2;
+          x[i__3].r = 0.f, x[i__3].i = 0.f;
+          i__3 = abs(incx) * (n / 2 - 1) + 1;
+          xx[i__3].r = 0.f, xx[i__3].i = 0.f;
+        }
+
+        i__3 = *ninc;
+        for (iy = 1; iy <= i__3; ++iy) {
+          incy = inc[iy];
+          ly = abs(incy) * n;
+
+          /*                 Generate the vector Y. */
+
+          transl.r = 0.f, transl.i = 0.f;
+          i__4 = abs(incy);
+          i__5 = n - 1;
+          cmake_("ge", " ", " ", &c__1, &n, &y[1], &c__1, &yy[1], &i__4, &c__0,
+                 &i__5, &reset, &transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+          if (n > 1) {
+            i__4 = n / 2;
+            y[i__4].r = 0.f, y[i__4].i = 0.f;
+            i__4 = abs(incy) * (n / 2 - 1) + 1;
+            yy[i__4].r = 0.f, yy[i__4].i = 0.f;
+          }
+
+          i__4 = *nalf;
+          for (ia = 1; ia <= i__4; ++ia) {
+            i__5 = ia;
+            alpha.r = alf[i__5].r, alpha.i = alf[i__5].i;
+            null = n <= 0 || alpha.r == 0.f && alpha.i == 0.f;
+
+            /*                    Generate the matrix A. */
+
+            transl.r = 0.f, transl.i = 0.f;
+            i__5 = n - 1;
+            i__6 = n - 1;
+            cmake_(sname + 7, uplo, " ", &n, &n, &a[a_offset], nmax, &aa[1],
+                   &lda, &i__5, &i__6, &reset, &transl, (ftnlen)2, (ftnlen)1,
+                   (ftnlen)1);
+
+            ++nc;
+
+            /*                    Save every datum before calling the
+             * subroutine. */
+
+            *(unsigned char *)uplos = *(unsigned char *)uplo;
+            ns = n;
+            als.r = alpha.r, als.i = alpha.i;
+            i__5 = laa;
+            for (i__ = 1; i__ <= i__5; ++i__) {
+              i__6 = i__;
+              i__7 = i__;
+              as[i__6].r = aa[i__7].r, as[i__6].i = aa[i__7].i;
+              /* L10: */
+            }
+            ldas = lda;
+            i__5 = lx;
+            for (i__ = 1; i__ <= i__5; ++i__) {
+              i__6 = i__;
+              i__7 = i__;
+              xs[i__6].r = xx[i__7].r, xs[i__6].i = xx[i__7].i;
+              /* L20: */
+            }
+            incxs = incx;
+            i__5 = ly;
+            for (i__ = 1; i__ <= i__5; ++i__) {
+              i__6 = i__;
+              i__7 = i__;
+              ys[i__6].r = yy[i__7].r, ys[i__6].i = yy[i__7].i;
+              /* L30: */
+            }
+            incys = incy;
+
+            /*                    Call the subroutine. */
+
+            if (full) {
+              if (*trace) {
+                io___386.ciunit = *ntra;
+                s_wsfe(&io___386);
+                do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                do_fio(&c__1, sname, (ftnlen)12);
+                do_fio(&c__1, cuplo, (ftnlen)14);
+                do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(real));
+                do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+                do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+                e_wsfe();
+              }
+              if (*rewi) {
+                al__1.aerr = 0;
+                al__1.aunit = *ntra;
+                f_rew(&al__1);
+              }
+              ccher2_(iorder, uplo, &n, &alpha, &xx[1], &incx, &yy[1], &incy,
+                      &aa[1], &lda);
+            } else if (packed) {
+              if (*trace) {
+                io___387.ciunit = *ntra;
+                s_wsfe(&io___387);
+                do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                do_fio(&c__1, sname, (ftnlen)12);
+                do_fio(&c__1, cuplo, (ftnlen)14);
+                do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(real));
+                do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+                e_wsfe();
+              }
+              if (*rewi) {
+                al__1.aerr = 0;
+                al__1.aunit = *ntra;
+                f_rew(&al__1);
+              }
+              cchpr2_(iorder, uplo, &n, &alpha, &xx[1], &incx, &yy[1], &incy,
+                      &aa[1]);
+            }
+
+            /*                    Check if error-exit was taken incorrectly. */
+
+            if (!infoc_1.ok) {
+              io___388.ciunit = *nout;
+              s_wsfe(&io___388);
+              e_wsfe();
+              *fatal = TRUE_;
+              goto L160;
+            }
+
+            /*                    See what data changed inside subroutines. */
+
+            isame[0] = *(unsigned char *)uplo == *(unsigned char *)uplos;
+            isame[1] = ns == n;
+            isame[2] = als.r == alpha.r && als.i == alpha.i;
+            isame[3] = lce_(&xs[1], &xx[1], &lx);
+            isame[4] = incxs == incx;
+            isame[5] = lce_(&ys[1], &yy[1], &ly);
+            isame[6] = incys == incy;
+            if (null) {
+              isame[7] = lce_(&as[1], &aa[1], &laa);
+            } else {
+              isame[7] = lceres_(sname + 7, uplo, &n, &n, &as[1], &aa[1], &lda,
+                                 (ftnlen)2, (ftnlen)1);
+            }
+            if (!packed) {
+              isame[8] = ldas == lda;
+            }
+
+            /*                   If data was incorrectly changed, report and
+             * return. */
+
+            same = TRUE_;
+            i__5 = nargs;
+            for (i__ = 1; i__ <= i__5; ++i__) {
+              same = same && isame[i__ - 1];
+              if (!isame[i__ - 1]) {
+                io___391.ciunit = *nout;
+                s_wsfe(&io___391);
+                do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                e_wsfe();
+              }
+              /* L40: */
+            }
+            if (!same) {
+              *fatal = TRUE_;
+              goto L160;
+            }
+
+            if (!null) {
+
+              /*                       Check the result column by column. */
+
+              if (incx > 0) {
+                i__5 = n;
+                for (i__ = 1; i__ <= i__5; ++i__) {
+                  i__6 = i__ + z_dim1;
+                  i__7 = i__;
+                  z__[i__6].r = x[i__7].r, z__[i__6].i = x[i__7].i;
+                  /* L50: */
+                }
+              } else {
+                i__5 = n;
+                for (i__ = 1; i__ <= i__5; ++i__) {
+                  i__6 = i__ + z_dim1;
+                  i__7 = n - i__ + 1;
+                  z__[i__6].r = x[i__7].r, z__[i__6].i = x[i__7].i;
+                  /* L60: */
+                }
+              }
+              if (incy > 0) {
+                i__5 = n;
+                for (i__ = 1; i__ <= i__5; ++i__) {
+                  i__6 = i__ + (z_dim1 << 1);
+                  i__7 = i__;
+                  z__[i__6].r = y[i__7].r, z__[i__6].i = y[i__7].i;
+                  /* L70: */
+                }
+              } else {
+                i__5 = n;
+                for (i__ = 1; i__ <= i__5; ++i__) {
+                  i__6 = i__ + (z_dim1 << 1);
+                  i__7 = n - i__ + 1;
+                  z__[i__6].r = y[i__7].r, z__[i__6].i = y[i__7].i;
+                  /* L80: */
+                }
+              }
+              ja = 1;
+              i__5 = n;
+              for (j = 1; j <= i__5; ++j) {
+                r_cnjg(&q__2, &z__[j + (z_dim1 << 1)]);
+                q__1.r = alpha.r * q__2.r - alpha.i * q__2.i,
+                q__1.i = alpha.r * q__2.i + alpha.i * q__2.r;
+                w[0].r = q__1.r, w[0].i = q__1.i;
+                r_cnjg(&q__2, &alpha);
+                r_cnjg(&q__3, &z__[j + z_dim1]);
+                q__1.r = q__2.r * q__3.r - q__2.i * q__3.i,
+                q__1.i = q__2.r * q__3.i + q__2.i * q__3.r;
+                w[1].r = q__1.r, w[1].i = q__1.i;
+                if (upper) {
+                  jj = 1;
+                  lj = j;
+                } else {
+                  jj = j;
+                  lj = n - j + 1;
+                }
+                cmvch_("N", &lj, &c__2, &c_b2, &z__[jj + z_dim1], nmax, w,
+                       &c__1, &c_b2, &a[jj + j * a_dim1], &c__1, &yt[1], &g[1],
+                       &aa[ja], eps, &err, fatal, nout, &c_true, (ftnlen)1);
+                if (full) {
+                  if (upper) {
+                    ja += lda;
+                  } else {
+                    ja = ja + lda + 1;
+                  }
+                } else {
+                  ja += lj;
+                }
+                errmax = max(errmax, err);
+                /*                          If got really bad answer, report and
+                 * return. */
+                if (*fatal) {
+                  goto L150;
+                }
+                /* L90: */
+              }
+            } else {
+              /*                       Avoid repeating tests with N.le.0. */
+              if (n <= 0) {
+                goto L140;
+              }
+            }
+
+            /* L100: */
+          }
+
+          /* L110: */
+        }
+
+        /* L120: */
+      }
+
+      /* L130: */
+    }
+
+  L140:;
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    io___398.ciunit = *nout;
+    s_wsfe(&io___398);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else {
+    io___399.ciunit = *nout;
+    s_wsfe(&io___399);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+    e_wsfe();
+  }
+  goto L170;
+
+L150:
+  io___400.ciunit = *nout;
+  s_wsfe(&io___400);
+  do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+  e_wsfe();
+
+L160:
+  io___401.ciunit = *nout;
+  s_wsfe(&io___401);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  if (full) {
+    io___402.ciunit = *nout;
+    s_wsfe(&io___402);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(real));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else if (packed) {
+    io___403.ciunit = *nout;
+    s_wsfe(&io___403);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(real));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L170:
+  return 0;
+
+  /*     End of CCHK6. */
+
+} /* cchk6_ */
+
+/* Subroutine */ int cmvch_(char *trans, integer *m, integer *n, complex *alpha,
+                            complex *a, integer *nmax, complex *x,
+                            integer *incx, complex *beta, complex *y,
+                            integer *incy, complex *yt, real *g, complex *yy,
+                            real *eps, real *err, logical *fatal, integer *nout,
+                            logical *mv, ftnlen trans_len) {
+  /* Format strings */
+  static char fmt_9999[] =
+      "(\002 ******* FATAL ERROR - COMPUTED RESULT IS"
+      " LESS THAN HAL\002,\002F ACCURATE *******\002,/\002             "
+      "          EXPECTED RE\002,\002SULT                    COMPUTED R"
+      "ESULT\002)";
+  static char fmt_9998[] = "(1x,i7,2(\002  (\002,g15.6,\002,\002,g15.6,"
+                           "\002)\002))";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;
+  real r__1, r__2, r__3, r__4, r__5, r__6;
+  complex q__1, q__2, q__3;
+
+  /* Builtin functions */
+  double r_imag(complex *);
+  void r_cnjg(complex *, complex *);
+  double c_abs(complex *), sqrt(doublereal);
+  integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, j, ml, nl, iy, jx, kx, ky;
+  real erri;
+  logical tran, ctran;
+  integer incxl, incyl;
+
+  /* Fortran I/O blocks */
+  static cilist io___417 = {0, 0, 0, fmt_9999, 0};
+  static cilist io___418 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___419 = {0, 0, 0, fmt_9998, 0};
+
+  /*  Checks the results of the computational tests. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Statement Functions .. */
+  /*     .. Statement Function definitions .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --x;
+  --y;
+  --yt;
+  --g;
+  --yy;
+
+  /* Function Body */
+  tran = *(unsigned char *)trans == 'T';
+  ctran = *(unsigned char *)trans == 'C';
+  if (tran || ctran) {
+    ml = *n;
+    nl = *m;
+  } else {
+    ml = *m;
+    nl = *n;
+  }
+  if (*incx < 0) {
+    kx = nl;
+    incxl = -1;
+  } else {
+    kx = 1;
+    incxl = 1;
+  }
+  if (*incy < 0) {
+    ky = ml;
+    incyl = -1;
+  } else {
+    ky = 1;
+    incyl = 1;
+  }
+
+  /*     Compute expected result in YT using data in A, X and Y. */
+  /*     Compute gauges in G. */
+
+  iy = ky;
+  i__1 = ml;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    i__2 = iy;
+    yt[i__2].r = 0.f, yt[i__2].i = 0.f;
+    g[iy] = 0.f;
+    jx = kx;
+    if (tran) {
+      i__2 = nl;
+      for (j = 1; j <= i__2; ++j) {
+        i__3 = iy;
+        i__4 = iy;
+        i__5 = j + i__ * a_dim1;
+        i__6 = jx;
+        q__2.r = a[i__5].r * x[i__6].r - a[i__5].i * x[i__6].i,
+        q__2.i = a[i__5].r * x[i__6].i + a[i__5].i * x[i__6].r;
+        q__1.r = yt[i__4].r + q__2.r, q__1.i = yt[i__4].i + q__2.i;
+        yt[i__3].r = q__1.r, yt[i__3].i = q__1.i;
+        i__3 = j + i__ * a_dim1;
+        i__4 = jx;
+        g[iy] += ((r__1 = a[i__3].r, abs(r__1)) +
+                  (r__2 = r_imag(&a[j + i__ * a_dim1]), abs(r__2))) *
+                 ((r__3 = x[i__4].r, abs(r__3)) +
+                  (r__4 = r_imag(&x[jx]), abs(r__4)));
+        jx += incxl;
+        /* L10: */
+      }
+    } else if (ctran) {
+      i__2 = nl;
+      for (j = 1; j <= i__2; ++j) {
+        i__3 = iy;
+        i__4 = iy;
+        r_cnjg(&q__3, &a[j + i__ * a_dim1]);
+        i__5 = jx;
+        q__2.r = q__3.r * x[i__5].r - q__3.i * x[i__5].i,
+        q__2.i = q__3.r * x[i__5].i + q__3.i * x[i__5].r;
+        q__1.r = yt[i__4].r + q__2.r, q__1.i = yt[i__4].i + q__2.i;
+        yt[i__3].r = q__1.r, yt[i__3].i = q__1.i;
+        i__3 = j + i__ * a_dim1;
+        i__4 = jx;
+        g[iy] += ((r__1 = a[i__3].r, abs(r__1)) +
+                  (r__2 = r_imag(&a[j + i__ * a_dim1]), abs(r__2))) *
+                 ((r__3 = x[i__4].r, abs(r__3)) +
+                  (r__4 = r_imag(&x[jx]), abs(r__4)));
+        jx += incxl;
+        /* L20: */
+      }
+    } else {
+      i__2 = nl;
+      for (j = 1; j <= i__2; ++j) {
+        i__3 = iy;
+        i__4 = iy;
+        i__5 = i__ + j * a_dim1;
+        i__6 = jx;
+        q__2.r = a[i__5].r * x[i__6].r - a[i__5].i * x[i__6].i,
+        q__2.i = a[i__5].r * x[i__6].i + a[i__5].i * x[i__6].r;
+        q__1.r = yt[i__4].r + q__2.r, q__1.i = yt[i__4].i + q__2.i;
+        yt[i__3].r = q__1.r, yt[i__3].i = q__1.i;
+        i__3 = i__ + j * a_dim1;
+        i__4 = jx;
+        g[iy] += ((r__1 = a[i__3].r, abs(r__1)) +
+                  (r__2 = r_imag(&a[i__ + j * a_dim1]), abs(r__2))) *
+                 ((r__3 = x[i__4].r, abs(r__3)) +
+                  (r__4 = r_imag(&x[jx]), abs(r__4)));
+        jx += incxl;
+        /* L30: */
+      }
+    }
+    i__2 = iy;
+    i__3 = iy;
+    q__2.r = alpha->r * yt[i__3].r - alpha->i * yt[i__3].i,
+    q__2.i = alpha->r * yt[i__3].i + alpha->i * yt[i__3].r;
+    i__4 = iy;
+    q__3.r = beta->r * y[i__4].r - beta->i * y[i__4].i,
+    q__3.i = beta->r * y[i__4].i + beta->i * y[i__4].r;
+    q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;
+    yt[i__2].r = q__1.r, yt[i__2].i = q__1.i;
+    i__2 = iy;
+    g[iy] = ((r__1 = alpha->r, abs(r__1)) + (r__2 = r_imag(alpha), abs(r__2))) *
+                g[iy] +
+            ((r__3 = beta->r, abs(r__3)) + (r__4 = r_imag(beta), abs(r__4))) *
+                ((r__5 = y[i__2].r, abs(r__5)) +
+                 (r__6 = r_imag(&y[iy]), abs(r__6)));
+    iy += incyl;
+    /* L40: */
+  }
+
+  /*     Compute the error ratio for this result. */
+
+  *err = 0.f;
+  i__1 = ml;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    i__2 = i__;
+    i__3 = (i__ - 1) * abs(*incy) + 1;
+    q__1.r = yt[i__2].r - yy[i__3].r, q__1.i = yt[i__2].i - yy[i__3].i;
+    erri = c_abs(&q__1) / *eps;
+    if (g[i__] != 0.f) {
+      erri /= g[i__];
+    }
+    *err = max(*err, erri);
+    if (*err * sqrt(*eps) >= 1.f) {
+      goto L60;
+    }
+    /* L50: */
+  }
+  /*     If the loop completes, all results are at least half accurate. */
+  goto L80;
+
+  /*     Report fatal error. */
+
+L60:
+  *fatal = TRUE_;
+  io___417.ciunit = *nout;
+  s_wsfe(&io___417);
+  e_wsfe();
+  i__1 = ml;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    if (*mv) {
+      io___418.ciunit = *nout;
+      s_wsfe(&io___418);
+      do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+      do_fio(&c__2, (char *)&yt[i__], (ftnlen)sizeof(real));
+      do_fio(&c__2, (char *)&yy[(i__ - 1) * abs(*incy) + 1],
+             (ftnlen)sizeof(real));
+      e_wsfe();
+    } else {
+      io___419.ciunit = *nout;
+      s_wsfe(&io___419);
+      do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+      do_fio(&c__2, (char *)&yy[(i__ - 1) * abs(*incy) + 1],
+             (ftnlen)sizeof(real));
+      do_fio(&c__2, (char *)&yt[i__], (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+    /* L70: */
+  }
+
+L80:
+  return 0;
+
+  /*     End of CMVCH. */
+
+} /* cmvch_ */
+
+logical lce_(complex *ri, complex *rj, integer *lr) {
+  /* System generated locals */
+  integer i__1, i__2, i__3;
+  logical ret_val;
+
+  /* Local variables */
+  integer i__;
+
+  /*  Tests if two arrays are identical. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  --rj;
+  --ri;
+
+  /* Function Body */
+  i__1 = *lr;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    i__2 = i__;
+    i__3 = i__;
+    if (ri[i__2].r != rj[i__3].r || ri[i__2].i != rj[i__3].i) {
+      goto L20;
+    }
+    /* L10: */
+  }
+  ret_val = TRUE_;
+  goto L30;
+L20:
+  ret_val = FALSE_;
+L30:
+  return ret_val;
+
+  /*     End of LCE. */
+
+} /* lce_ */
+
+logical lceres_(char *type__, char *uplo, integer *m, integer *n, complex *aa,
+                complex *as, integer *lda, ftnlen type_len, ftnlen uplo_len) {
+  /* System generated locals */
+  integer aa_dim1, aa_offset, as_dim1, as_offset, i__1, i__2, i__3, i__4;
+  logical ret_val;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen);
+
+  /* Local variables */
+  integer i__, j, ibeg, iend;
+  logical upper;
+
+  /*  Tests if selected elements in two arrays are equal. */
+
+  /*  TYPE is 'ge', 'he' or 'hp'. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  as_dim1 = *lda;
+  as_offset = 1 + as_dim1;
+  as -= as_offset;
+  aa_dim1 = *lda;
+  aa_offset = 1 + aa_dim1;
+  aa -= aa_offset;
+
+  /* Function Body */
+  upper = *(unsigned char *)uplo == 'U';
+  if (s_cmp(type__, "ge", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      i__2 = *lda;
+      for (i__ = *m + 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + j * aa_dim1;
+        i__4 = i__ + j * as_dim1;
+        if (aa[i__3].r != as[i__4].r || aa[i__3].i != as[i__4].i) {
+          goto L70;
+        }
+        /* L10: */
+      }
+      /* L20: */
+    }
+  } else if (s_cmp(type__, "he", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      if (upper) {
+        ibeg = 1;
+        iend = j;
+      } else {
+        ibeg = j;
+        iend = *n;
+      }
+      i__2 = ibeg - 1;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + j * aa_dim1;
+        i__4 = i__ + j * as_dim1;
+        if (aa[i__3].r != as[i__4].r || aa[i__3].i != as[i__4].i) {
+          goto L70;
+        }
+        /* L30: */
+      }
+      i__2 = *lda;
+      for (i__ = iend + 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + j * aa_dim1;
+        i__4 = i__ + j * as_dim1;
+        if (aa[i__3].r != as[i__4].r || aa[i__3].i != as[i__4].i) {
+          goto L70;
+        }
+        /* L40: */
+      }
+      /* L50: */
+    }
+  }
+
+  /* L60: */
+  ret_val = TRUE_;
+  goto L80;
+L70:
+  ret_val = FALSE_;
+L80:
+  return ret_val;
+
+  /*     End of LCERES. */
+
+} /* lceres_ */
+
+/* Complex */ VOID cbeg_(complex *ret_val, logical *reset) {
+  /* System generated locals */
+  real r__1, r__2;
+  complex q__1;
+
+  /* Local variables */
+  static integer i__, j, ic, mi, mj;
+
+  /*  Generates complex numbers as pairs of random numbers uniformly */
+  /*  distributed between -0.5 and 0.5. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Save statement .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Executable Statements .. */
+  if (*reset) {
+    /*        Initialize local variables. */
+    mi = 891;
+    mj = 457;
+    i__ = 7;
+    j = 7;
+    ic = 0;
+    *reset = FALSE_;
+  }
+
+  /*     The sequence of values of I or J is bounded between 1 and 999. */
+  /*     If initial I or J = 1,2,3,6,7 or 9, the period will be 50. */
+  /*     If initial I or J = 4 or 8, the period will be 25. */
+  /*     If initial I or J = 5, the period will be 10. */
+  /*     IC is used to break up the period by skipping 1 value of I or J */
+  /*     in 6. */
+
+  ++ic;
+L10:
+  i__ *= mi;
+  j *= mj;
+  i__ -= i__ / 1000 * 1000;
+  j -= j / 1000 * 1000;
+  if (ic >= 5) {
+    ic = 0;
+    goto L10;
+  }
+  r__1 = (i__ - 500) / 1001.f;
+  r__2 = (j - 500) / 1001.f;
+  q__1.r = r__1, q__1.i = r__2;
+  ret_val->r = q__1.r, ret_val->i = q__1.i;
+  return;
+
+  /*     End of CBEG. */
+
+} /* cbeg_ */
+
+real sdiff_(real *x, real *y) {
+  /* System generated locals */
+  real ret_val;
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Executable Statements .. */
+  ret_val = *x - *y;
+  return ret_val;
+
+  /*     End of SDIFF. */
+
+} /* sdiff_ */
+
+/* Subroutine */ int cmake_(char *type__, char *uplo, char *diag, integer *m,
+                            integer *n, complex *a, integer *nmax, complex *aa,
+                            integer *lda, integer *kl, integer *ku,
+                            logical *reset, complex *transl, ftnlen type_len,
+                            ftnlen uplo_len, ftnlen diag_len) {
+  /* System generated locals */
+  integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
+  real r__1;
+  complex q__1, q__2;
+
+  /* Builtin functions */
+  void r_cnjg(complex *, complex *);
+  integer s_cmp(char *, char *, ftnlen, ftnlen);
+
+  /* Local variables */
+  integer i__, j, i1, i2, i3, jj, kk;
+  logical gen, tri, sym;
+  extern /* Complex */ VOID cbeg_(complex *, logical *);
+  integer ibeg, iend, ioff;
+  logical unit, lower, upper;
+
+  /*  Generates values for an M by N matrix A within the bandwidth */
+  /*  defined by KL and KU. */
+  /*  Stores the values in the array AA in the data structure required */
+  /*  by the routine, with unwanted elements set to rogue value. */
+
+  /*  TYPE is 'ge', 'gb', 'he', 'hb', 'hp', 'tr', 'tb' OR 'tp'. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. External Functions .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --aa;
+
+  /* Function Body */
+  gen = *(unsigned char *)type__ == 'g';
+  sym = *(unsigned char *)type__ == 'h';
+  tri = *(unsigned char *)type__ == 't';
+  upper = (sym || tri) && *(unsigned char *)uplo == 'U';
+  lower = (sym || tri) && *(unsigned char *)uplo == 'L';
+  unit = tri && *(unsigned char *)diag == 'U';
+
+  /*     Generate data in array A. */
+
+  i__1 = *n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = *m;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      if (gen || upper && i__ <= j || lower && i__ >= j) {
+        if (i__ <= j && j - i__ <= *ku || i__ >= j && i__ - j <= *kl) {
+          i__3 = i__ + j * a_dim1;
+          cbeg_(&q__2, reset);
+          q__1.r = q__2.r + transl->r, q__1.i = q__2.i + transl->i;
+          a[i__3].r = q__1.r, a[i__3].i = q__1.i;
+        } else {
+          i__3 = i__ + j * a_dim1;
+          a[i__3].r = 0.f, a[i__3].i = 0.f;
+        }
+        if (i__ != j) {
+          if (sym) {
+            i__3 = j + i__ * a_dim1;
+            r_cnjg(&q__1, &a[i__ + j * a_dim1]);
+            a[i__3].r = q__1.r, a[i__3].i = q__1.i;
+          } else if (tri) {
+            i__3 = j + i__ * a_dim1;
+            a[i__3].r = 0.f, a[i__3].i = 0.f;
+          }
+        }
+      }
+      /* L10: */
+    }
+    if (sym) {
+      i__2 = j + j * a_dim1;
+      i__3 = j + j * a_dim1;
+      r__1 = a[i__3].r;
+      q__1.r = r__1, q__1.i = 0.f;
+      a[i__2].r = q__1.r, a[i__2].i = q__1.i;
+    }
+    if (tri) {
+      i__2 = j + j * a_dim1;
+      i__3 = j + j * a_dim1;
+      q__1.r = a[i__3].r + 1.f, q__1.i = a[i__3].i + 0.f;
+      a[i__2].r = q__1.r, a[i__2].i = q__1.i;
+    }
+    if (unit) {
+      i__2 = j + j * a_dim1;
+      a[i__2].r = 1.f, a[i__2].i = 0.f;
+    }
+    /* L20: */
+  }
+
+  /*     Store elements in array AS in data structure required by routine. */
+
+  if (s_cmp(type__, "ge", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      i__2 = *m;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        i__4 = i__ + j * a_dim1;
+        aa[i__3].r = a[i__4].r, aa[i__3].i = a[i__4].i;
+        /* L30: */
+      }
+      i__2 = *lda;
+      for (i__ = *m + 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        aa[i__3].r = -1e10f, aa[i__3].i = 1e10f;
+        /* L40: */
+      }
+      /* L50: */
+    }
+  } else if (s_cmp(type__, "gb", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      i__2 = *ku + 1 - j;
+      for (i1 = 1; i1 <= i__2; ++i1) {
+        i__3 = i1 + (j - 1) * *lda;
+        aa[i__3].r = -1e10f, aa[i__3].i = 1e10f;
+        /* L60: */
+      }
+      /* Computing MIN */
+      i__3 = *kl + *ku + 1, i__4 = *ku + 1 + *m - j;
+      i__2 = min(i__3, i__4);
+      for (i2 = i1; i2 <= i__2; ++i2) {
+        i__3 = i2 + (j - 1) * *lda;
+        i__4 = i2 + j - *ku - 1 + j * a_dim1;
+        aa[i__3].r = a[i__4].r, aa[i__3].i = a[i__4].i;
+        /* L70: */
+      }
+      i__2 = *lda;
+      for (i3 = i2; i3 <= i__2; ++i3) {
+        i__3 = i3 + (j - 1) * *lda;
+        aa[i__3].r = -1e10f, aa[i__3].i = 1e10f;
+        /* L80: */
+      }
+      /* L90: */
+    }
+  } else if (s_cmp(type__, "he", (ftnlen)2, (ftnlen)2) == 0 ||
+             s_cmp(type__, "tr", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      if (upper) {
+        ibeg = 1;
+        if (unit) {
+          iend = j - 1;
+        } else {
+          iend = j;
+        }
+      } else {
+        if (unit) {
+          ibeg = j + 1;
+        } else {
+          ibeg = j;
+        }
+        iend = *n;
+      }
+      i__2 = ibeg - 1;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        aa[i__3].r = -1e10f, aa[i__3].i = 1e10f;
+        /* L100: */
+      }
+      i__2 = iend;
+      for (i__ = ibeg; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        i__4 = i__ + j * a_dim1;
+        aa[i__3].r = a[i__4].r, aa[i__3].i = a[i__4].i;
+        /* L110: */
+      }
+      i__2 = *lda;
+      for (i__ = iend + 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        aa[i__3].r = -1e10f, aa[i__3].i = 1e10f;
+        /* L120: */
+      }
+      if (sym) {
+        jj = j + (j - 1) * *lda;
+        i__2 = jj;
+        i__3 = jj;
+        r__1 = aa[i__3].r;
+        q__1.r = r__1, q__1.i = -1e10f;
+        aa[i__2].r = q__1.r, aa[i__2].i = q__1.i;
+      }
+      /* L130: */
+    }
+  } else if (s_cmp(type__, "hb", (ftnlen)2, (ftnlen)2) == 0 ||
+             s_cmp(type__, "tb", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      if (upper) {
+        kk = *kl + 1;
+        /* Computing MAX */
+        i__2 = 1, i__3 = *kl + 2 - j;
+        ibeg = max(i__2, i__3);
+        if (unit) {
+          iend = *kl;
+        } else {
+          iend = *kl + 1;
+        }
+      } else {
+        kk = 1;
+        if (unit) {
+          ibeg = 2;
+        } else {
+          ibeg = 1;
+        }
+        /* Computing MIN */
+        i__2 = *kl + 1, i__3 = *m + 1 - j;
+        iend = min(i__2, i__3);
+      }
+      i__2 = ibeg - 1;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        aa[i__3].r = -1e10f, aa[i__3].i = 1e10f;
+        /* L140: */
+      }
+      i__2 = iend;
+      for (i__ = ibeg; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        i__4 = i__ + j - kk + j * a_dim1;
+        aa[i__3].r = a[i__4].r, aa[i__3].i = a[i__4].i;
+        /* L150: */
+      }
+      i__2 = *lda;
+      for (i__ = iend + 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        aa[i__3].r = -1e10f, aa[i__3].i = 1e10f;
+        /* L160: */
+      }
+      if (sym) {
+        jj = kk + (j - 1) * *lda;
+        i__2 = jj;
+        i__3 = jj;
+        r__1 = aa[i__3].r;
+        q__1.r = r__1, q__1.i = -1e10f;
+        aa[i__2].r = q__1.r, aa[i__2].i = q__1.i;
+      }
+      /* L170: */
+    }
+  } else if (s_cmp(type__, "hp", (ftnlen)2, (ftnlen)2) == 0 ||
+             s_cmp(type__, "tp", (ftnlen)2, (ftnlen)2) == 0) {
+    ioff = 0;
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      if (upper) {
+        ibeg = 1;
+        iend = j;
+      } else {
+        ibeg = j;
+        iend = *n;
+      }
+      i__2 = iend;
+      for (i__ = ibeg; i__ <= i__2; ++i__) {
+        ++ioff;
+        i__3 = ioff;
+        i__4 = i__ + j * a_dim1;
+        aa[i__3].r = a[i__4].r, aa[i__3].i = a[i__4].i;
+        if (i__ == j) {
+          if (unit) {
+            i__3 = ioff;
+            aa[i__3].r = -1e10f, aa[i__3].i = 1e10f;
+          }
+          if (sym) {
+            i__3 = ioff;
+            i__4 = ioff;
+            r__1 = aa[i__4].r;
+            q__1.r = r__1, q__1.i = -1e10f;
+            aa[i__3].r = q__1.r, aa[i__3].i = q__1.i;
+          }
+        }
+        /* L180: */
+      }
+      /* L190: */
+    }
+  }
+  return 0;
+
+  /*     End of CMAKE. */
+
+} /* cmake_ */
+
+/* Main program alias */ int cblat2_() {
+  MAIN__();
+  return 0;
+}
diff --git a/CBLAS/testing/c_cblat3.c b/CBLAS/testing/c_cblat3.c
new file mode 100644
index 0000000..f695b79
--- /dev/null
+++ b/CBLAS/testing/c_cblat3.c
@@ -0,0 +1,4431 @@
+/* testing/c_cblat3.f -- translated by f2c (version 20191129).
+   You must link the resulting object file with libf2c:
+        on Microsoft Windows system, link with libf2c.lib;
+        on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+        or, if you install libf2c.a in a standard place, with -lf2c -lm
+        -- in that order, at the end of the command line, as in
+                cc *.o -lf2c -lm
+        Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+                http://www.netlib.org/f2c/libf2c.zip
+*/
+
+#include "f2c.h"
+
+/* Common Block Declarations */
+
+struct {
+  integer infot, noutc;
+  logical ok, lerr;
+} infoc_;
+
+#define infoc_1 infoc_
+
+struct {
+  char srnamt[12];
+} srnamc_;
+
+#define srnamc_1 srnamc_
+
+/* Table of constant values */
+
+static complex c_b1 = {0.f, 0.f};
+static complex c_b2 = {1.f, 0.f};
+static integer c__9 = 9;
+static integer c__1 = 1;
+static integer c__3 = 3;
+static integer c__8 = 8;
+static integer c__4 = 4;
+static integer c__65 = 65;
+static integer c__7 = 7;
+static integer c__6 = 6;
+static integer c__2 = 2;
+static real c_b91 = 1.f;
+static logical c_true = TRUE_;
+static integer c__0 = 0;
+static logical c_false = FALSE_;
+
+/* Main program */ int MAIN__(void) {
+  /* Initialized data */
+
+  static char snames[12 * 9] = "cblas_cgemm "
+                               "cblas_chemm "
+                               "cblas_csymm "
+                               "cblas_ctrmm "
+                               "cblas_ctrsm "
+                               "cblas_cherk "
+                               "cblas_csyrk "
+                               "cbl"
+                               "as_cher2k"
+                               "cblas_csyr2k";
+
+  /* Format strings */
+  static char fmt_9997[] = "(\002 NUMBER OF VALUES OF \002,a,\002 IS LESS "
+                           "THAN 1 OR GREATER \002,\002THAN \002,i2)";
+  static char fmt_9996[] = "(\002 VALUE OF N IS LESS THAN 0 OR GREATER THA"
+                           "N \002,i2)";
+  static char fmt_9995[] =
+      "(\002 TESTS OF THE COMPLEX          LEVEL 3 BL"
+      "AS\002,//\002 THE F\002,\002OLLOWING PARAMETER VALUES WILL BE US"
+      "ED:\002)";
+  static char fmt_9994[] = "(\002   FOR N              \002,9i6)";
+  static char fmt_9993[] = "(\002   FOR ALPHA          \002,7(\002(\002,f4"
+                           ".1,\002,\002,f4.1,\002)  \002,:))";
+  static char fmt_9992[] = "(\002   FOR BETA           \002,7(\002(\002,f4"
+                           ".1,\002,\002,f4.1,\002)  \002,:))";
+  static char fmt_9984[] = "(\002 ERROR-EXITS WILL NOT BE TESTED\002)";
+  static char fmt_9999[] = "(\002 ROUTINES PASS COMPUTATIONAL TESTS IF TES"
+                           "T RATIO IS LES\002,\002S THAN\002,f8.2)";
+  static char fmt_10002[] = "(\002 COLUMN-MAJOR AND ROW-MAJOR DATA LAYOUTS"
+                            " ARE TESTED\002)";
+  static char fmt_10001[] = "(\002 ROW-MAJOR DATA LAYOUT IS TESTED\002)";
+  static char fmt_10000[] = "(\002 COLUMN-MAJOR DATA LAYOUT IS TESTED\002)";
+  static char fmt_9988[] = "(a12,l2)";
+  static char fmt_9990[] =
+      "(\002 SUBPROGRAM NAME \002,a12,\002 NOT RECOGN"
+      "IZED\002,/\002 ******* T\002,\002ESTS ABANDONED *******\002)";
+  static char fmt_9998[] = "(\002 RELATIVE MACHINE PRECISION IS TAKEN TO"
+                           " BE\002,1p,e9.1)";
+  static char fmt_9989[] =
+      "(\002 ERROR IN CMMCH -  IN-LINE DOT PRODUCTS A"
+      "RE BEING EVALU\002,\002ATED WRONGLY.\002,/\002 CMMCH WAS CALLED "
+      "WITH TRANSA = \002,a1,\002AND TRANSB = \002,a1,/\002 AND RETURNE"
+      "D SAME = \002,l1,\002 AND \002,\002 ERR = \002,f12.3,\002.\002,"
+      "/\002 THIS MAY BE DUE TO FAULTS IN THE \002,\002ARITHMETIC OR TH"
+      "E COMPILER.\002,/\002 ******* TESTS ABANDONED \002,\002******"
+      "*\002)";
+  static char fmt_9987[] = "(1x,a12,\002 WAS NOT TESTED\002)";
+  static char fmt_9986[] = "(/\002 END OF TESTS\002)";
+  static char fmt_9985[] = "(/\002 ******* FATAL ERROR - TESTS ABANDONED *"
+                           "******\002)";
+  static char fmt_9991[] =
+      "(\002 AMEND DATA FILE OR INCREASE ARRAY SIZES "
+      "IN PROGRAM\002,/\002 ******* TESTS ABANDONED *******\002)";
+
+  /* System generated locals */
+  integer i__1, i__2, i__3, i__4, i__5;
+  real r__1;
+  olist o__1;
+  cllist cl__1;
+
+  /* Builtin functions */
+  integer s_rsle(cilist *), do_lio(integer *, integer *, char *, ftnlen),
+      e_rsle(void), f_open(olist *), s_wsfe(cilist *),
+      do_fio(integer *, char *, ftnlen), e_wsfe(void), s_wsle(cilist *),
+      e_wsle(void), s_rsfe(cilist *), e_rsfe(void),
+      s_cmp(char *, char *, ftnlen, ftnlen);
+  /* Subroutine */ int s_stop(char *, ftnlen);
+  integer f_clos(cllist *);
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+
+  /* Local variables */
+  complex c__[4225] /* was [65][65] */;
+  real g[65];
+  integer i__, j, n;
+  complex w[130], aa[4225], ab[8450] /* was [65][130] */, bb[4225], cc[4225],
+      as[4225], bs[4225], cs[4225], ct[65], alf[7];
+  extern logical lce_(complex *, complex *, integer *);
+  complex bet[7];
+  real eps, err;
+  integer nalf, idim[9];
+  logical same;
+  integer nbet, ntra;
+  logical rewi;
+  extern /* Subroutine */ int cchk1_(
+      char *, real *, real *, integer *, integer *, logical *, logical *,
+      logical *, integer *, integer *, integer *, complex *, integer *,
+      complex *, integer *, complex *, complex *, complex *, complex *,
+      complex *, complex *, complex *, complex *, complex *, complex *, real *,
+      integer *, ftnlen),
+      cchk2_(char *, real *, real *, integer *, integer *, logical *, logical *,
+             logical *, integer *, integer *, integer *, complex *, integer *,
+             complex *, integer *, complex *, complex *, complex *, complex *,
+             complex *, complex *, complex *, complex *, complex *, complex *,
+             real *, integer *, ftnlen),
+      cchk3_(char *, real *, real *, integer *, integer *, logical *, logical *,
+             logical *, integer *, integer *, integer *, complex *, integer *,
+             complex *, complex *, complex *, complex *, complex *, complex *,
+             complex *, real *, complex *, integer *, ftnlen),
+      cchk4_(char *, real *, real *, integer *, integer *, logical *, logical *,
+             logical *, integer *, integer *, integer *, complex *, integer *,
+             complex *, integer *, complex *, complex *, complex *, complex *,
+             complex *, complex *, complex *, complex *, complex *, complex *,
+             real *, integer *, ftnlen),
+      cchk5_(char *, real *, real *, integer *, integer *, logical *, logical *,
+             logical *, integer *, integer *, integer *, complex *, integer *,
+             complex *, integer *, complex *, complex *, complex *, complex *,
+             complex *, complex *, complex *, complex *, complex *, real *,
+             complex *, integer *, ftnlen);
+  logical fatal;
+  extern /* Subroutine */ int cmmch_(
+      char *, char *, integer *, integer *, integer *, complex *, complex *,
+      integer *, complex *, integer *, complex *, complex *, integer *,
+      complex *, real *, complex *, integer *, real *, real *, logical *,
+      integer *, logical *, ftnlen, ftnlen);
+  extern real sdiff_(real *, real *);
+  logical trace;
+  integer nidim;
+  char snaps[32];
+  integer isnum;
+  logical ltest[9], sfatal, corder;
+  char snamet[12], transa[1], transb[1];
+  real thresh;
+  logical rorder;
+  extern /* Subroutine */ void cc3chke_(char *);
+  integer layout;
+  logical ltestt, tsterr;
+
+  /* Fortran I/O blocks */
+  static cilist io___2 = {0, 5, 0, 0, 0};
+  static cilist io___4 = {0, 5, 0, 0, 0};
+  static cilist io___7 = {0, 5, 0, 0, 0};
+  static cilist io___9 = {0, 5, 0, 0, 0};
+  static cilist io___11 = {0, 5, 0, 0, 0};
+  static cilist io___13 = {0, 5, 0, 0, 0};
+  static cilist io___15 = {0, 5, 0, 0, 0};
+  static cilist io___17 = {0, 5, 0, 0, 0};
+  static cilist io___19 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___20 = {0, 5, 0, 0, 0};
+  static cilist io___23 = {0, 6, 0, fmt_9996, 0};
+  static cilist io___24 = {0, 5, 0, 0, 0};
+  static cilist io___26 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___27 = {0, 5, 0, 0, 0};
+  static cilist io___29 = {0, 5, 0, 0, 0};
+  static cilist io___31 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___32 = {0, 5, 0, 0, 0};
+  static cilist io___34 = {0, 6, 0, fmt_9995, 0};
+  static cilist io___35 = {0, 6, 0, fmt_9994, 0};
+  static cilist io___36 = {0, 6, 0, fmt_9993, 0};
+  static cilist io___37 = {0, 6, 0, fmt_9992, 0};
+  static cilist io___38 = {0, 6, 0, 0, 0};
+  static cilist io___39 = {0, 6, 0, fmt_9984, 0};
+  static cilist io___40 = {0, 6, 0, 0, 0};
+  static cilist io___41 = {0, 6, 0, fmt_9999, 0};
+  static cilist io___42 = {0, 6, 0, 0, 0};
+  static cilist io___45 = {0, 6, 0, fmt_10002, 0};
+  static cilist io___46 = {0, 6, 0, fmt_10001, 0};
+  static cilist io___47 = {0, 6, 0, fmt_10000, 0};
+  static cilist io___48 = {0, 6, 0, 0, 0};
+  static cilist io___50 = {0, 5, 1, fmt_9988, 0};
+  static cilist io___53 = {0, 6, 0, fmt_9990, 0};
+  static cilist io___55 = {0, 6, 0, fmt_9998, 0};
+  static cilist io___68 = {0, 6, 0, fmt_9989, 0};
+  static cilist io___69 = {0, 6, 0, fmt_9989, 0};
+  static cilist io___70 = {0, 6, 0, fmt_9989, 0};
+  static cilist io___71 = {0, 6, 0, fmt_9989, 0};
+  static cilist io___73 = {0, 6, 0, 0, 0};
+  static cilist io___74 = {0, 6, 0, fmt_9987, 0};
+  static cilist io___75 = {0, 6, 0, 0, 0};
+  static cilist io___82 = {0, 6, 0, fmt_9986, 0};
+  static cilist io___83 = {0, 6, 0, fmt_9985, 0};
+  static cilist io___84 = {0, 6, 0, fmt_9991, 0};
+
+  /*  Test program for the COMPLEX          Level 3 Blas. */
+
+  /*  The program must be driven by a short data file. The first 13 records */
+  /*  of the file are read using list-directed input, the last 9 records */
+  /*  are read using the format ( A12, L2 ). An annotated example of a data */
+  /*  file can be obtained by deleting the first 3 characters from the */
+  /*  following 22 lines: */
+  /*  'CBLAT3.SNAP'     NAME OF SNAPSHOT OUTPUT FILE */
+  /*  -1                UNIT NUMBER OF SNAPSHOT FILE (NOT USED IF .LT. 0) */
+  /*  F        LOGICAL FLAG, T TO REWIND SNAPSHOT FILE AFTER EACH RECORD. */
+  /*  F        LOGICAL FLAG, T TO STOP ON FAILURES. */
+  /*  T        LOGICAL FLAG, T TO TEST ERROR EXITS. */
+  /*  2        0 TO TEST COLUMN-MAJOR, 1 TO TEST ROW-MAJOR, 2 TO TEST BOTH */
+  /*  16.0     THRESHOLD VALUE OF TEST RATIO */
+  /*  6                 NUMBER OF VALUES OF N */
+  /*  0 1 2 3 5 9       VALUES OF N */
+  /*  3                 NUMBER OF VALUES OF ALPHA */
+  /*  (0.0,0.0) (1.0,0.0) (0.7,-0.9)       VALUES OF ALPHA */
+  /*  3                 NUMBER OF VALUES OF BETA */
+  /*  (0.0,0.0) (1.0,0.0) (1.3,-1.1)       VALUES OF BETA */
+  /*  cblas_cgemm  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_chemm  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_csymm  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_ctrmm  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_ctrsm  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_cherk  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_csyrk  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_cher2k T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_csyr2k T PUT F FOR NO TEST. SAME COLUMNS. */
+
+  /*  See: */
+
+  /*     Dongarra J. J., Du Croz J. J., Duff I. S. and Hammarling S. */
+  /*     A Set of Level 3 Basic Linear Algebra Subprograms. */
+
+  /*     Technical Memorandum No.88 (Revision 1), Mathematics and */
+  /*     Computer Science Division, Argonne National Laboratory, 9700 */
+  /*     South Cass Avenue, Argonne, Illinois 60439, US. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /*     .. Executable Statements .. */
+
+  infoc_1.noutc = 6;
+
+  /*     Read name and unit number for snapshot output file and open file. */
+
+  s_rsle(&io___2);
+  do_lio(&c__9, &c__1, snaps, (ftnlen)32);
+  e_rsle();
+  s_rsle(&io___4);
+  do_lio(&c__3, &c__1, (char *)&ntra, (ftnlen)sizeof(integer));
+  e_rsle();
+  trace = ntra >= 0;
+  if (trace) {
+    o__1.oerr = 0;
+    o__1.ounit = ntra;
+    o__1.ofnmlen = 32;
+    o__1.ofnm = snaps;
+    o__1.orl = 0;
+    o__1.osta = 0;
+    o__1.oacc = 0;
+    o__1.ofm = 0;
+    o__1.oblnk = 0;
+    f_open(&o__1);
+  }
+  /*     Read the flag that directs rewinding of the snapshot file. */
+  s_rsle(&io___7);
+  do_lio(&c__8, &c__1, (char *)&rewi, (ftnlen)sizeof(logical));
+  e_rsle();
+  rewi = rewi && trace;
+  /*     Read the flag that directs stopping on any failure. */
+  s_rsle(&io___9);
+  do_lio(&c__8, &c__1, (char *)&sfatal, (ftnlen)sizeof(logical));
+  e_rsle();
+  /*     Read the flag that indicates whether error exits are to be tested. */
+  s_rsle(&io___11);
+  do_lio(&c__8, &c__1, (char *)&tsterr, (ftnlen)sizeof(logical));
+  e_rsle();
+  /*     Read the flag that indicates whether row-major data layout to be
+   * tested. */
+  s_rsle(&io___13);
+  do_lio(&c__3, &c__1, (char *)&layout, (ftnlen)sizeof(integer));
+  e_rsle();
+  /*     Read the threshold value of the test ratio */
+  s_rsle(&io___15);
+  do_lio(&c__4, &c__1, (char *)&thresh, (ftnlen)sizeof(real));
+  e_rsle();
+
+  /*     Read and check the parameter values for the tests. */
+
+  /*     Values of N */
+  s_rsle(&io___17);
+  do_lio(&c__3, &c__1, (char *)&nidim, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nidim < 1 || nidim > 9) {
+    s_wsfe(&io___19);
+    do_fio(&c__1, "N", (ftnlen)1);
+    do_fio(&c__1, (char *)&c__9, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L220;
+  }
+  s_rsle(&io___20);
+  i__1 = nidim;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__3, &c__1, (char *)&idim[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_rsle();
+  i__1 = nidim;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    if (idim[i__ - 1] < 0 || idim[i__ - 1] > 65) {
+      s_wsfe(&io___23);
+      do_fio(&c__1, (char *)&c__65, (ftnlen)sizeof(integer));
+      e_wsfe();
+      goto L220;
+    }
+    /* L10: */
+  }
+  /*     Values of ALPHA */
+  s_rsle(&io___24);
+  do_lio(&c__3, &c__1, (char *)&nalf, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nalf < 1 || nalf > 7) {
+    s_wsfe(&io___26);
+    do_fio(&c__1, "ALPHA", (ftnlen)5);
+    do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L220;
+  }
+  s_rsle(&io___27);
+  i__1 = nalf;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__6, &c__1, (char *)&alf[i__ - 1], (ftnlen)sizeof(complex));
+  }
+  e_rsle();
+  /*     Values of BETA */
+  s_rsle(&io___29);
+  do_lio(&c__3, &c__1, (char *)&nbet, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nbet < 1 || nbet > 7) {
+    s_wsfe(&io___31);
+    do_fio(&c__1, "BETA", (ftnlen)4);
+    do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L220;
+  }
+  s_rsle(&io___32);
+  i__1 = nbet;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__6, &c__1, (char *)&bet[i__ - 1], (ftnlen)sizeof(complex));
+  }
+  e_rsle();
+
+  /*     Report values of parameters. */
+
+  s_wsfe(&io___34);
+  e_wsfe();
+  s_wsfe(&io___35);
+  i__1 = nidim;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__1, (char *)&idim[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_wsfe();
+  s_wsfe(&io___36);
+  i__1 = nalf;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__2, (char *)&alf[i__ - 1], (ftnlen)sizeof(real));
+  }
+  e_wsfe();
+  s_wsfe(&io___37);
+  i__1 = nbet;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__2, (char *)&bet[i__ - 1], (ftnlen)sizeof(real));
+  }
+  e_wsfe();
+  if (!tsterr) {
+    s_wsle(&io___38);
+    e_wsle();
+    s_wsfe(&io___39);
+    e_wsfe();
+  }
+  s_wsle(&io___40);
+  e_wsle();
+  s_wsfe(&io___41);
+  do_fio(&c__1, (char *)&thresh, (ftnlen)sizeof(real));
+  e_wsfe();
+  s_wsle(&io___42);
+  e_wsle();
+  rorder = FALSE_;
+  corder = FALSE_;
+  if (layout == 2) {
+    rorder = TRUE_;
+    corder = TRUE_;
+    s_wsfe(&io___45);
+    e_wsfe();
+  } else if (layout == 1) {
+    rorder = TRUE_;
+    s_wsfe(&io___46);
+    e_wsfe();
+  } else if (layout == 0) {
+    corder = TRUE_;
+    s_wsfe(&io___47);
+    e_wsfe();
+  }
+  s_wsle(&io___48);
+  e_wsle();
+
+  /*     Read names of subroutines and flags which indicate */
+  /*     whether they are to be tested. */
+
+  for (i__ = 1; i__ <= 9; ++i__) {
+    ltest[i__ - 1] = FALSE_;
+    /* L20: */
+  }
+L30:
+  i__1 = s_rsfe(&io___50);
+  if (i__1 != 0) {
+    goto L60;
+  }
+  i__1 = do_fio(&c__1, snamet, (ftnlen)12);
+  if (i__1 != 0) {
+    goto L60;
+  }
+  i__1 = do_fio(&c__1, (char *)&ltestt, (ftnlen)sizeof(logical));
+  if (i__1 != 0) {
+    goto L60;
+  }
+  i__1 = e_rsfe();
+  if (i__1 != 0) {
+    goto L60;
+  }
+  for (i__ = 1; i__ <= 9; ++i__) {
+    if (s_cmp(snamet, snames + (i__ - 1) * 12, (ftnlen)12, (ftnlen)12) == 0) {
+      goto L50;
+    }
+    /* L40: */
+  }
+  s_wsfe(&io___53);
+  do_fio(&c__1, snamet, (ftnlen)12);
+  e_wsfe();
+  s_stop("", (ftnlen)0);
+L50:
+  ltest[i__ - 1] = ltestt;
+  goto L30;
+
+L60:
+  cl__1.cerr = 0;
+  cl__1.cunit = 5;
+  cl__1.csta = 0;
+  f_clos(&cl__1);
+
+  /*     Compute EPS (the machine precision). */
+
+  eps = 1.f;
+L70:
+  r__1 = eps + 1.f;
+  if (sdiff_(&r__1, &c_b91) == 0.f) {
+    goto L80;
+  }
+  eps *= .5f;
+  goto L70;
+L80:
+  eps += eps;
+  s_wsfe(&io___55);
+  do_fio(&c__1, (char *)&eps, (ftnlen)sizeof(real));
+  e_wsfe();
+
+  /*     Check the reliability of CMMCH using exact data. */
+
+  n = 32;
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = n;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      i__3 = i__ + j * 65 - 66;
+      /* Computing MAX */
+      i__5 = i__ - j + 1;
+      i__4 = max(i__5, 0);
+      ab[i__3].r = (real)i__4, ab[i__3].i = 0.f;
+      /* L90: */
+    }
+    i__2 = j + 4224;
+    ab[i__2].r = (real)j, ab[i__2].i = 0.f;
+    i__2 = (j + 65) * 65 - 65;
+    ab[i__2].r = (real)j, ab[i__2].i = 0.f;
+    i__2 = j - 1;
+    c__[i__2].r = 0.f, c__[i__2].i = 0.f;
+    /* L100: */
+  }
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = j - 1;
+    i__3 = j * ((j + 1) * j) / 2 - (j + 1) * j * (j - 1) / 3;
+    cc[i__2].r = (real)i__3, cc[i__2].i = 0.f;
+    /* L110: */
+  }
+  /*     CC holds the exact result. On exit from CMMCH CT holds */
+  /*     the result computed by CMMCH. */
+  *(unsigned char *)transa = 'N';
+  *(unsigned char *)transb = 'N';
+  cmmch_(transa, transb, &n, &c__1, &n, &c_b2, ab, &c__65, &ab[4225], &c__65,
+         &c_b1, c__, &c__65, ct, g, cc, &c__65, &eps, &err, &fatal, &c__6,
+         &c_true, (ftnlen)1, (ftnlen)1);
+  same = lce_(cc, ct, &n);
+  if (!same || err != 0.f) {
+    s_wsfe(&io___68);
+    do_fio(&c__1, transa, (ftnlen)1);
+    do_fio(&c__1, transb, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(real));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+  *(unsigned char *)transb = 'C';
+  cmmch_(transa, transb, &n, &c__1, &n, &c_b2, ab, &c__65, &ab[4225], &c__65,
+         &c_b1, c__, &c__65, ct, g, cc, &c__65, &eps, &err, &fatal, &c__6,
+         &c_true, (ftnlen)1, (ftnlen)1);
+  same = lce_(cc, ct, &n);
+  if (!same || err != 0.f) {
+    s_wsfe(&io___69);
+    do_fio(&c__1, transa, (ftnlen)1);
+    do_fio(&c__1, transb, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(real));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = j + 4224;
+    i__3 = n - j + 1;
+    ab[i__2].r = (real)i__3, ab[i__2].i = 0.f;
+    i__2 = (j + 65) * 65 - 65;
+    i__3 = n - j + 1;
+    ab[i__2].r = (real)i__3, ab[i__2].i = 0.f;
+    /* L120: */
+  }
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = n - j;
+    i__3 = j * ((j + 1) * j) / 2 - (j + 1) * j * (j - 1) / 3;
+    cc[i__2].r = (real)i__3, cc[i__2].i = 0.f;
+    /* L130: */
+  }
+  *(unsigned char *)transa = 'C';
+  *(unsigned char *)transb = 'N';
+  cmmch_(transa, transb, &n, &c__1, &n, &c_b2, ab, &c__65, &ab[4225], &c__65,
+         &c_b1, c__, &c__65, ct, g, cc, &c__65, &eps, &err, &fatal, &c__6,
+         &c_true, (ftnlen)1, (ftnlen)1);
+  same = lce_(cc, ct, &n);
+  if (!same || err != 0.f) {
+    s_wsfe(&io___70);
+    do_fio(&c__1, transa, (ftnlen)1);
+    do_fio(&c__1, transb, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(real));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+  *(unsigned char *)transb = 'C';
+  cmmch_(transa, transb, &n, &c__1, &n, &c_b2, ab, &c__65, &ab[4225], &c__65,
+         &c_b1, c__, &c__65, ct, g, cc, &c__65, &eps, &err, &fatal, &c__6,
+         &c_true, (ftnlen)1, (ftnlen)1);
+  same = lce_(cc, ct, &n);
+  if (!same || err != 0.f) {
+    s_wsfe(&io___71);
+    do_fio(&c__1, transa, (ftnlen)1);
+    do_fio(&c__1, transb, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(real));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+
+  /*     Test each subroutine in turn. */
+
+  for (isnum = 1; isnum <= 9; ++isnum) {
+    s_wsle(&io___73);
+    e_wsle();
+    if (!ltest[isnum - 1]) {
+      /*           Subprogram is not to be tested. */
+      s_wsfe(&io___74);
+      do_fio(&c__1, snames + (isnum - 1) * 12, (ftnlen)12);
+      e_wsfe();
+    } else {
+      s_copy(srnamc_1.srnamt, snames + (isnum - 1) * 12, (ftnlen)12,
+             (ftnlen)12);
+      /*           Test error exits. */
+      if (tsterr) {
+        cc3chke_(snames + (isnum - 1) * 12);
+        s_wsle(&io___75);
+        e_wsle();
+      }
+      /*           Test computations. */
+      infoc_1.infot = 0;
+      infoc_1.ok = TRUE_;
+      fatal = FALSE_;
+      switch (isnum) {
+      case 1:
+        goto L140;
+      case 2:
+        goto L150;
+      case 3:
+        goto L150;
+      case 4:
+        goto L160;
+      case 5:
+        goto L160;
+      case 6:
+        goto L170;
+      case 7:
+        goto L170;
+      case 8:
+        goto L180;
+      case 9:
+        goto L180;
+      }
+    /*           Test CGEMM, 01. */
+    L140:
+      if (corder) {
+        cchk1_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__0,
+               (ftnlen)12);
+      }
+      if (rorder) {
+        cchk1_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__1,
+               (ftnlen)12);
+      }
+      goto L190;
+    /*           Test CHEMM, 02, CSYMM, 03. */
+    L150:
+      if (corder) {
+        cchk2_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__0,
+               (ftnlen)12);
+      }
+      if (rorder) {
+        cchk2_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__1,
+               (ftnlen)12);
+      }
+      goto L190;
+    /*           Test CTRMM, 04, CTRSM, 05. */
+    L160:
+      if (corder) {
+        cchk3_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &c__65, ab, aa, as,
+               &ab[4225], bb, bs, ct, g, c__, &c__0, (ftnlen)12);
+      }
+      if (rorder) {
+        cchk3_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &c__65, ab, aa, as,
+               &ab[4225], bb, bs, ct, g, c__, &c__1, (ftnlen)12);
+      }
+      goto L190;
+    /*           Test CHERK, 06, CSYRK, 07. */
+    L170:
+      if (corder) {
+        cchk4_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__0,
+               (ftnlen)12);
+      }
+      if (rorder) {
+        cchk4_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__1,
+               (ftnlen)12);
+      }
+      goto L190;
+    /*           Test CHER2K, 08, CSYR2K, 09. */
+    L180:
+      if (corder) {
+        cchk5_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, bb, bs, c__, cc, cs, ct, g, w, &c__0, (ftnlen)12);
+      }
+      if (rorder) {
+        cchk5_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, bb, bs, c__, cc, cs, ct, g, w, &c__1, (ftnlen)12);
+      }
+      goto L190;
+
+    L190:
+      if (fatal && sfatal) {
+        goto L210;
+      }
+    }
+    /* L200: */
+  }
+  s_wsfe(&io___82);
+  e_wsfe();
+  goto L230;
+
+L210:
+  s_wsfe(&io___83);
+  e_wsfe();
+  goto L230;
+
+L220:
+  s_wsfe(&io___84);
+  e_wsfe();
+
+L230:
+  if (trace) {
+    cl__1.cerr = 0;
+    cl__1.cunit = ntra;
+    cl__1.csta = 0;
+    f_clos(&cl__1);
+  }
+  cl__1.cerr = 0;
+  cl__1.cunit = 6;
+  cl__1.csta = 0;
+  f_clos(&cl__1);
+  s_stop("", (ftnlen)0);
+
+  /*     End of CBLAT3. */
+
+  return 0;
+} /* MAIN__ */
+
+/* Subroutine */ int
+cchk1_(char *sname, real *eps, real *thresh, integer *nout, integer *ntra,
+       logical *trace, logical *rewi, logical *fatal, integer *nidim,
+       integer *idim, integer *nalf, complex *alf, integer *nbet, complex *bet,
+       integer *nmax, complex *a, complex *aa, complex *as, complex *b,
+       complex *bb, complex *bs, complex *c__, complex *cc, complex *cs,
+       complex *ct, real *g, integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ich[3] = "NTC";
+
+  /* Format strings */
+  static char fmt_9994[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
+      i__3, i__4, i__5, i__6, i__7, i__8;
+  alist al__1;
+
+  /* Builtin functions */
+  integer f_rew(alist *), s_wsfe(cilist *), e_wsfe(void),
+      do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, k, m, n, ia, ib, ma, mb, na, nb, nc, ik, im, in, ks, ms, ns, ica,
+      icb, laa, lbb, lda, lcc, ldb, ldc;
+  extern logical lce_(complex *, complex *, integer *);
+  complex als, bls;
+  real err;
+  complex beta;
+  integer ldas, ldbs, ldcs;
+  logical same, null;
+  extern /* Subroutine */ int cmake_(
+      char *, char *, char *, integer *, integer *, complex *, integer *,
+      complex *, integer *, logical *, complex *, ftnlen, ftnlen, ftnlen);
+  complex alpha;
+  extern /* Subroutine */ int cmmch_(
+      char *, char *, integer *, integer *, integer *, complex *, complex *,
+      integer *, complex *, integer *, complex *, complex *, integer *,
+      complex *, real *, complex *, integer *, real *, real *, logical *,
+      integer *, logical *, ftnlen, ftnlen);
+  logical isame[13], trana, tranb;
+  integer nargs;
+  logical reset;
+  extern /* Subroutine */ int cprcn1_(
+      integer *, integer *, char *, integer *, char *, char *, integer *,
+      integer *, integer *, complex *, integer *, integer *, complex *,
+      integer *, ftnlen, ftnlen, ftnlen);
+
+  extern void ccgemm_(integer *, char *, char *, integer *, integer *, integer *,
+                      complex *, complex *, integer *, complex *, integer *, complex *,
+                      complex *, integer *);
+  extern logical lceres_(char *, char *, integer *, integer *, complex *,
+                         complex *, integer *, ftnlen, ftnlen);
+  char tranas[1], tranbs[1], transa[1], transb[1];
+  real errmax;
+
+  /* Fortran I/O blocks */
+  static cilist io___128 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___131 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___133 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___134 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___135 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___136 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___137 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests CGEMM. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --bet;
+  --g;
+  --ct;
+  --cs;
+  --cc;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --bs;
+  --bb;
+  b_dim1 = *nmax;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+
+  nargs = 13;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.f;
+
+  i__1 = *nidim;
+  for (im = 1; im <= i__1; ++im) {
+    m = idim[im];
+
+    i__2 = *nidim;
+    for (in = 1; in <= i__2; ++in) {
+      n = idim[in];
+      /*           Set LDC to 1 more than minimum value if room. */
+      ldc = m;
+      if (ldc < *nmax) {
+        ++ldc;
+      }
+      /*           Skip tests if not enough room. */
+      if (ldc > *nmax) {
+        goto L100;
+      }
+      lcc = ldc * n;
+      null = n <= 0 || m <= 0;
+
+      i__3 = *nidim;
+      for (ik = 1; ik <= i__3; ++ik) {
+        k = idim[ik];
+
+        for (ica = 1; ica <= 3; ++ica) {
+          *(unsigned char *)transa = *(unsigned char *)&ich[ica - 1];
+          trana = *(unsigned char *)transa == 'T' ||
+                  *(unsigned char *)transa == 'C';
+
+          if (trana) {
+            ma = k;
+            na = m;
+          } else {
+            ma = m;
+            na = k;
+          }
+          /*                 Set LDA to 1 more than minimum value if room. */
+          lda = ma;
+          if (lda < *nmax) {
+            ++lda;
+          }
+          /*                 Skip tests if not enough room. */
+          if (lda > *nmax) {
+            goto L80;
+          }
+          laa = lda * na;
+
+          /*                 Generate the matrix A. */
+
+          cmake_("ge", " ", " ", &ma, &na, &a[a_offset], nmax, &aa[1], &lda,
+                 &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+          for (icb = 1; icb <= 3; ++icb) {
+            *(unsigned char *)transb = *(unsigned char *)&ich[icb - 1];
+            tranb = *(unsigned char *)transb == 'T' ||
+                    *(unsigned char *)transb == 'C';
+
+            if (tranb) {
+              mb = n;
+              nb = k;
+            } else {
+              mb = k;
+              nb = n;
+            }
+            /*                    Set LDB to 1 more than minimum value if room.
+             */
+            ldb = mb;
+            if (ldb < *nmax) {
+              ++ldb;
+            }
+            /*                    Skip tests if not enough room. */
+            if (ldb > *nmax) {
+              goto L70;
+            }
+            lbb = ldb * nb;
+
+            /*                    Generate the matrix B. */
+
+            cmake_("ge", " ", " ", &mb, &nb, &b[b_offset], nmax, &bb[1], &ldb,
+                   &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+            i__4 = *nalf;
+            for (ia = 1; ia <= i__4; ++ia) {
+              i__5 = ia;
+              alpha.r = alf[i__5].r, alpha.i = alf[i__5].i;
+
+              i__5 = *nbet;
+              for (ib = 1; ib <= i__5; ++ib) {
+                i__6 = ib;
+                beta.r = bet[i__6].r, beta.i = bet[i__6].i;
+
+                /*                          Generate the matrix C. */
+
+                cmake_("ge", " ", " ", &m, &n, &c__[c_offset], nmax, &cc[1],
+                       &ldc, &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+                ++nc;
+
+                /*                          Save every datum before calling the
+                 */
+                /*                          subroutine. */
+
+                *(unsigned char *)tranas = *(unsigned char *)transa;
+                *(unsigned char *)tranbs = *(unsigned char *)transb;
+                ms = m;
+                ns = n;
+                ks = k;
+                als.r = alpha.r, als.i = alpha.i;
+                i__6 = laa;
+                for (i__ = 1; i__ <= i__6; ++i__) {
+                  i__7 = i__;
+                  i__8 = i__;
+                  as[i__7].r = aa[i__8].r, as[i__7].i = aa[i__8].i;
+                  /* L10: */
+                }
+                ldas = lda;
+                i__6 = lbb;
+                for (i__ = 1; i__ <= i__6; ++i__) {
+                  i__7 = i__;
+                  i__8 = i__;
+                  bs[i__7].r = bb[i__8].r, bs[i__7].i = bb[i__8].i;
+                  /* L20: */
+                }
+                ldbs = ldb;
+                bls.r = beta.r, bls.i = beta.i;
+                i__6 = lcc;
+                for (i__ = 1; i__ <= i__6; ++i__) {
+                  i__7 = i__;
+                  i__8 = i__;
+                  cs[i__7].r = cc[i__8].r, cs[i__7].i = cc[i__8].i;
+                  /* L30: */
+                }
+                ldcs = ldc;
+
+                /*                          Call the subroutine. */
+
+                if (*trace) {
+                  cprcn1_(ntra, &nc, sname, iorder, transa, transb, &m, &n, &k,
+                          &alpha, &lda, &ldb, &beta, &ldc, (ftnlen)12,
+                          (ftnlen)1, (ftnlen)1);
+                }
+                if (*rewi) {
+                  al__1.aerr = 0;
+                  al__1.aunit = *ntra;
+                  f_rew(&al__1);
+                }
+                ccgemm_(iorder, transa, transb, &m, &n, &k, &alpha, &aa[1],
+                        &lda, &bb[1], &ldb, &beta, &cc[1], &ldc);
+
+                /*                          Check if error-exit was taken
+                 * incorrectly. */
+
+                if (!infoc_1.ok) {
+                  io___128.ciunit = *nout;
+                  s_wsfe(&io___128);
+                  e_wsfe();
+                  *fatal = TRUE_;
+                  goto L120;
+                }
+
+                /*                          See what data changed inside
+                 * subroutines. */
+
+                isame[0] = *(unsigned char *)transa == *(unsigned char *)tranas;
+                isame[1] = *(unsigned char *)transb == *(unsigned char *)tranbs;
+                isame[2] = ms == m;
+                isame[3] = ns == n;
+                isame[4] = ks == k;
+                isame[5] = als.r == alpha.r && als.i == alpha.i;
+                isame[6] = lce_(&as[1], &aa[1], &laa);
+                isame[7] = ldas == lda;
+                isame[8] = lce_(&bs[1], &bb[1], &lbb);
+                isame[9] = ldbs == ldb;
+                isame[10] = bls.r == beta.r && bls.i == beta.i;
+                if (null) {
+                  isame[11] = lce_(&cs[1], &cc[1], &lcc);
+                } else {
+                  isame[11] = lceres_("ge", " ", &m, &n, &cs[1], &cc[1], &ldc,
+                                      (ftnlen)2, (ftnlen)1);
+                }
+                isame[12] = ldcs == ldc;
+
+                /*                          If data was incorrectly changed,
+                 * report */
+                /*                          and return. */
+
+                same = TRUE_;
+                i__6 = nargs;
+                for (i__ = 1; i__ <= i__6; ++i__) {
+                  same = same && isame[i__ - 1];
+                  if (!isame[i__ - 1]) {
+                    io___131.ciunit = *nout;
+                    s_wsfe(&io___131);
+                    do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  /* L40: */
+                }
+                if (!same) {
+                  *fatal = TRUE_;
+                  goto L120;
+                }
+
+                if (!null) {
+
+                  /*                             Check the result. */
+
+                  cmmch_(transa, transb, &m, &n, &k, &alpha, &a[a_offset], nmax,
+                         &b[b_offset], nmax, &beta, &c__[c_offset], nmax,
+                         &ct[1], &g[1], &cc[1], &ldc, eps, &err, fatal, nout,
+                         &c_true, (ftnlen)1, (ftnlen)1);
+                  errmax = max(errmax, err);
+                  /*                             If got really bad answer,
+                   * report and */
+                  /*                             return. */
+                  if (*fatal) {
+                    goto L120;
+                  }
+                }
+
+                /* L50: */
+              }
+
+              /* L60: */
+            }
+
+          L70:;
+          }
+
+        L80:;
+        }
+
+        /* L90: */
+      }
+
+    L100:;
+    }
+
+    /* L110: */
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___133.ciunit = *nout;
+      s_wsfe(&io___133);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___134.ciunit = *nout;
+      s_wsfe(&io___134);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___135.ciunit = *nout;
+      s_wsfe(&io___135);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___136.ciunit = *nout;
+      s_wsfe(&io___136);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+  }
+  goto L130;
+
+L120:
+  io___137.ciunit = *nout;
+  s_wsfe(&io___137);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  cprcn1_(nout, &nc, sname, iorder, transa, transb, &m, &n, &k, &alpha, &lda,
+          &ldb, &beta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+
+L130:
+  return 0;
+
+  /* L9995: */
+
+  /*     End of CCHK1. */
+
+} /* cchk1_ */
+
+/* Subroutine */ int cprcn1_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *transa, char *transb,
+                             integer *m, integer *n, integer *k, complex *alpha,
+                             integer *lda, integer *ldb, complex *beta,
+                             integer *ldc, ftnlen sname_len, ftnlen transa_len,
+                             ftnlen transb_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+                           "a14,\002,\002,a14,\002,\002)";
+  static char fmt_9994[] =
+      "(10x,3(i3,\002,\002),\002 (\002,f4.1,\002,\002"
+      ",f4.1,\002) , A,\002,i3,\002, B,\002,i3,\002, (\002,f4.1,\002"
+      ",\002,f4.1,\002) , C,\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char crc[14], cta[14], ctb[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___141 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___142 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(cta, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(cta, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cta, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transb == 'N') {
+    s_copy(ctb, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transb == 'T') {
+    s_copy(ctb, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ctb, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___141.ciunit = *nout;
+  s_wsfe(&io___141);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cta, (ftnlen)14);
+  do_fio(&c__1, ctb, (ftnlen)14);
+  e_wsfe();
+  io___142.ciunit = *nout;
+  s_wsfe(&io___142);
+  do_fio(&c__1, (char *)&(*m), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*k), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*alpha), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*ldb), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*beta), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* cprcn1_ */
+
+/* Subroutine */ int
+cchk2_(char *sname, real *eps, real *thresh, integer *nout, integer *ntra,
+       logical *trace, logical *rewi, logical *fatal, integer *nidim,
+       integer *idim, integer *nalf, complex *alf, integer *nbet, complex *bet,
+       integer *nmax, complex *a, complex *aa, complex *as, complex *b,
+       complex *bb, complex *bs, complex *c__, complex *cc, complex *cs,
+       complex *ct, real *g, integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ichs[2] = "LR";
+  static char ichu[2] = "UL";
+
+  /* Format strings */
+  static char fmt_9994[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
+      i__3, i__4, i__5, i__6, i__7;
+  alist al__1;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen), f_rew(alist *),
+      s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, m, n, ia, ib, na, nc, im, in, ms, ns, laa, lbb, lda, lcc, ldb,
+      ldc;
+  extern logical lce_(complex *, complex *, integer *);
+  integer ics;
+  complex als, bls;
+  integer icu;
+  real err;
+  complex beta;
+  integer ldas, ldbs, ldcs;
+  logical same;
+  char side[1];
+  logical conj, left, null;
+  char uplo[1];
+  extern /* Subroutine */ int cmake_(
+      char *, char *, char *, integer *, integer *, complex *, integer *,
+      complex *, integer *, logical *, complex *, ftnlen, ftnlen, ftnlen);
+  complex alpha;
+  extern /* Subroutine */ int cmmch_(
+      char *, char *, integer *, integer *, integer *, complex *, complex *,
+      integer *, complex *, integer *, complex *, complex *, integer *,
+      complex *, real *, complex *, integer *, real *, real *, logical *,
+      integer *, logical *, ftnlen, ftnlen);
+  logical isame[13];
+  char sides[1];
+  integer nargs;
+  logical reset;
+  char uplos[1];
+  extern /* Subroutine */ int cprcn2_(
+      integer *, integer *, char *, integer *, char *, char *, integer *,
+      integer *, complex *, integer *, integer *, complex *, integer *, ftnlen,
+      ftnlen, ftnlen);
+  extern void cchemm_(integer *, char *, char *, integer *, integer *, complex *,
+              complex *, integer *, complex *, integer *, complex *, complex *,
+              integer *);
+  extern logical lceres_(char *, char *, integer *, integer *, complex *,
+                         complex *, integer *, ftnlen, ftnlen);
+  extern /* Subroutine */ void ccsymm_(
+      integer *, char *, char *, integer *, integer *, complex *, complex *,
+      integer *, complex *, integer *, complex *, complex *, integer *);
+  real errmax;
+
+  /* Fortran I/O blocks */
+  static cilist io___181 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___184 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___186 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___187 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___188 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___189 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___190 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests CHEMM and CSYMM. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --bet;
+  --g;
+  --ct;
+  --cs;
+  --cc;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --bs;
+  --bb;
+  b_dim1 = *nmax;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+  conj = s_cmp(sname + 7, "he", (ftnlen)2, (ftnlen)2) == 0;
+
+  nargs = 12;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.f;
+
+  i__1 = *nidim;
+  for (im = 1; im <= i__1; ++im) {
+    m = idim[im];
+
+    i__2 = *nidim;
+    for (in = 1; in <= i__2; ++in) {
+      n = idim[in];
+      /*           Set LDC to 1 more than minimum value if room. */
+      ldc = m;
+      if (ldc < *nmax) {
+        ++ldc;
+      }
+      /*           Skip tests if not enough room. */
+      if (ldc > *nmax) {
+        goto L90;
+      }
+      lcc = ldc * n;
+      null = n <= 0 || m <= 0;
+      /*           Set LDB to 1 more than minimum value if room. */
+      ldb = m;
+      if (ldb < *nmax) {
+        ++ldb;
+      }
+      /*           Skip tests if not enough room. */
+      if (ldb > *nmax) {
+        goto L90;
+      }
+      lbb = ldb * n;
+
+      /*           Generate the matrix B. */
+
+      cmake_("ge", " ", " ", &m, &n, &b[b_offset], nmax, &bb[1], &ldb, &reset,
+             &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+      for (ics = 1; ics <= 2; ++ics) {
+        *(unsigned char *)side = *(unsigned char *)&ichs[ics - 1];
+        left = *(unsigned char *)side == 'L';
+
+        if (left) {
+          na = m;
+        } else {
+          na = n;
+        }
+        /*              Set LDA to 1 more than minimum value if room. */
+        lda = na;
+        if (lda < *nmax) {
+          ++lda;
+        }
+        /*              Skip tests if not enough room. */
+        if (lda > *nmax) {
+          goto L80;
+        }
+        laa = lda * na;
+
+        for (icu = 1; icu <= 2; ++icu) {
+          *(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+
+          /*                 Generate the hermitian or symmetric matrix A. */
+
+          cmake_(sname + 7, uplo, " ", &na, &na, &a[a_offset], nmax, &aa[1],
+                 &lda, &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+          i__3 = *nalf;
+          for (ia = 1; ia <= i__3; ++ia) {
+            i__4 = ia;
+            alpha.r = alf[i__4].r, alpha.i = alf[i__4].i;
+
+            i__4 = *nbet;
+            for (ib = 1; ib <= i__4; ++ib) {
+              i__5 = ib;
+              beta.r = bet[i__5].r, beta.i = bet[i__5].i;
+
+              /*                       Generate the matrix C. */
+
+              cmake_("ge", " ", " ", &m, &n, &c__[c_offset], nmax, &cc[1], &ldc,
+                     &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+              ++nc;
+
+              /*                       Save every datum before calling the */
+              /*                       subroutine. */
+
+              *(unsigned char *)sides = *(unsigned char *)side;
+              *(unsigned char *)uplos = *(unsigned char *)uplo;
+              ms = m;
+              ns = n;
+              als.r = alpha.r, als.i = alpha.i;
+              i__5 = laa;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                i__6 = i__;
+                i__7 = i__;
+                as[i__6].r = aa[i__7].r, as[i__6].i = aa[i__7].i;
+                /* L10: */
+              }
+              ldas = lda;
+              i__5 = lbb;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                i__6 = i__;
+                i__7 = i__;
+                bs[i__6].r = bb[i__7].r, bs[i__6].i = bb[i__7].i;
+                /* L20: */
+              }
+              ldbs = ldb;
+              bls.r = beta.r, bls.i = beta.i;
+              i__5 = lcc;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                i__6 = i__;
+                i__7 = i__;
+                cs[i__6].r = cc[i__7].r, cs[i__6].i = cc[i__7].i;
+                /* L30: */
+              }
+              ldcs = ldc;
+
+              /*                       Call the subroutine. */
+
+              if (*trace) {
+                cprcn2_(ntra, &nc, sname, iorder, side, uplo, &m, &n, &alpha,
+                        &lda, &ldb, &beta, &ldc, (ftnlen)12, (ftnlen)1,
+                        (ftnlen)1);
+              }
+              if (*rewi) {
+                al__1.aerr = 0;
+                al__1.aunit = *ntra;
+                f_rew(&al__1);
+              }
+              if (conj) {
+                cchemm_(iorder, side, uplo, &m, &n, &alpha, &aa[1], &lda,
+                        &bb[1], &ldb, &beta, &cc[1], &ldc);
+              } else {
+                ccsymm_(iorder, side, uplo, &m, &n, &alpha, &aa[1], &lda,
+                        &bb[1], &ldb, &beta, &cc[1], &ldc);
+              }
+
+              /*                       Check if error-exit was taken
+               * incorrectly. */
+
+              if (!infoc_1.ok) {
+                io___181.ciunit = *nout;
+                s_wsfe(&io___181);
+                e_wsfe();
+                *fatal = TRUE_;
+                goto L110;
+              }
+
+              /*                       See what data changed inside subroutines.
+               */
+
+              isame[0] = *(unsigned char *)sides == *(unsigned char *)side;
+              isame[1] = *(unsigned char *)uplos == *(unsigned char *)uplo;
+              isame[2] = ms == m;
+              isame[3] = ns == n;
+              isame[4] = als.r == alpha.r && als.i == alpha.i;
+              isame[5] = lce_(&as[1], &aa[1], &laa);
+              isame[6] = ldas == lda;
+              isame[7] = lce_(&bs[1], &bb[1], &lbb);
+              isame[8] = ldbs == ldb;
+              isame[9] = bls.r == beta.r && bls.i == beta.i;
+              if (null) {
+                isame[10] = lce_(&cs[1], &cc[1], &lcc);
+              } else {
+                isame[10] = lceres_("ge", " ", &m, &n, &cs[1], &cc[1], &ldc,
+                                    (ftnlen)2, (ftnlen)1);
+              }
+              isame[11] = ldcs == ldc;
+
+              /*                       If data was incorrectly changed, report
+               * and */
+              /*                       return. */
+
+              same = TRUE_;
+              i__5 = nargs;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                same = same && isame[i__ - 1];
+                if (!isame[i__ - 1]) {
+                  io___184.ciunit = *nout;
+                  s_wsfe(&io___184);
+                  do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                  e_wsfe();
+                }
+                /* L40: */
+              }
+              if (!same) {
+                *fatal = TRUE_;
+                goto L110;
+              }
+
+              if (!null) {
+
+                /*                          Check the result. */
+
+                if (left) {
+                  cmmch_("N", "N", &m, &n, &m, &alpha, &a[a_offset], nmax,
+                         &b[b_offset], nmax, &beta, &c__[c_offset], nmax,
+                         &ct[1], &g[1], &cc[1], &ldc, eps, &err, fatal, nout,
+                         &c_true, (ftnlen)1, (ftnlen)1);
+                } else {
+                  cmmch_("N", "N", &m, &n, &n, &alpha, &b[b_offset], nmax,
+                         &a[a_offset], nmax, &beta, &c__[c_offset], nmax,
+                         &ct[1], &g[1], &cc[1], &ldc, eps, &err, fatal, nout,
+                         &c_true, (ftnlen)1, (ftnlen)1);
+                }
+                errmax = max(errmax, err);
+                /*                          If got really bad answer, report and
+                 */
+                /*                          return. */
+                if (*fatal) {
+                  goto L110;
+                }
+              }
+
+              /* L50: */
+            }
+
+            /* L60: */
+          }
+
+          /* L70: */
+        }
+
+      L80:;
+      }
+
+    L90:;
+    }
+
+    /* L100: */
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___186.ciunit = *nout;
+      s_wsfe(&io___186);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___187.ciunit = *nout;
+      s_wsfe(&io___187);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___188.ciunit = *nout;
+      s_wsfe(&io___188);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___189.ciunit = *nout;
+      s_wsfe(&io___189);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+  }
+  goto L120;
+
+L110:
+  io___190.ciunit = *nout;
+  s_wsfe(&io___190);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  cprcn2_(nout, &nc, sname, iorder, side, uplo, &m, &n, &alpha, &lda, &ldb,
+          &beta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+
+L120:
+  return 0;
+
+  /* L9995: */
+
+  /*     End of CCHK2. */
+
+} /* cchk2_ */
+
+/* Subroutine */ int cprcn2_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *side, char *uplo,
+                             integer *m, integer *n, complex *alpha,
+                             integer *lda, integer *ldb, complex *beta,
+                             integer *ldc, ftnlen sname_len, ftnlen side_len,
+                             ftnlen uplo_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+                           "a14,\002,\002,a14,\002,\002)";
+  static char fmt_9994[] =
+      "(10x,2(i3,\002,\002),\002 (\002,f4.1,\002,\002"
+      ",f4.1,\002), A,\002,i3,\002, B,\002,i3,\002, (\002,f4.1,\002,"
+      "\002,f4.1,\002), \002,\002C,\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char cs[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___194 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___195 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)side == 'L') {
+    s_copy(cs, "     CblasLeft", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cs, "    CblasRight", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___194.ciunit = *nout;
+  s_wsfe(&io___194);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cs, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  e_wsfe();
+  io___195.ciunit = *nout;
+  s_wsfe(&io___195);
+  do_fio(&c__1, (char *)&(*m), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*alpha), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*ldb), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*beta), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* cprcn2_ */
+
+/* Subroutine */ int cchk3_(char *sname, real *eps, real *thresh, integer *nout,
+                            integer *ntra, logical *trace, logical *rewi,
+                            logical *fatal, integer *nidim, integer *idim,
+                            integer *nalf, complex *alf, integer *nmax,
+                            complex *a, complex *aa, complex *as, complex *b,
+                            complex *bb, complex *bs, complex *ct, real *g,
+                            complex *c__, integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ichu[2] = "UL";
+  static char icht[3] = "NTC";
+  static char ichd[2] = "UN";
+  static char ichs[2] = "LR";
+
+  /* Format strings */
+  static char fmt_9994[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
+      i__3, i__4, i__5, i__6, i__7;
+  complex q__1;
+  alist al__1;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen), f_rew(alist *),
+      s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, j, m, n, ia, na, nc, im, in, ms, ns, laa, icd, lbb, lda, ldb;
+  extern logical lce_(complex *, complex *, integer *);
+  integer ics;
+  complex als;
+  integer ict, icu;
+  real err;
+  char diag[1];
+  integer ldas, ldbs;
+  logical same;
+  char side[1];
+  logical left, null;
+  char uplo[1];
+  extern /* Subroutine */ int cmake_(
+      char *, char *, char *, integer *, integer *, complex *, integer *,
+      complex *, integer *, logical *, complex *, ftnlen, ftnlen, ftnlen);
+  complex alpha;
+  char diags[1];
+  extern /* Subroutine */ int cmmch_(
+      char *, char *, integer *, integer *, integer *, complex *, complex *,
+      integer *, complex *, integer *, complex *, complex *, integer *,
+      complex *, real *, complex *, integer *, real *, real *, logical *,
+      integer *, logical *, ftnlen, ftnlen);
+  logical isame[13];
+  char sides[1];
+  integer nargs;
+  logical reset;
+  char uplos[1];
+  extern /* Subroutine */ int cprcn3_(
+      integer *, integer *, char *, integer *, char *, char *, char *, char *,
+      integer *, integer *, complex *, integer *, integer *, ftnlen, ftnlen,
+      ftnlen, ftnlen, ftnlen);
+  extern logical lceres_(char *, char *, integer *, integer *, complex *,
+                         complex *, integer *, ftnlen, ftnlen);
+  extern /* Subroutine */ void cctrmm_(
+      integer *, char *, char *, char *, char *, integer *, integer *,
+      complex *, complex *, integer *, complex *, integer *);
+  char tranas[1], transa[1];
+  extern /* Subroutine */ void cctrsm_(
+      integer *, char *, char *, char *, char *, integer *, integer *,
+      complex *, complex *, integer *, complex *, integer *);
+  real errmax;
+
+  /* Fortran I/O blocks */
+  static cilist io___236 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___239 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___241 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___242 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___243 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___244 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___245 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests CTRMM and CTRSM. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --g;
+  --ct;
+  --bs;
+  --bb;
+  b_dim1 = *nmax;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+
+  nargs = 11;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.f;
+  /*     Set up zero matrix for CMMCH. */
+  i__1 = *nmax;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = *nmax;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      i__3 = i__ + j * c_dim1;
+      c__[i__3].r = 0.f, c__[i__3].i = 0.f;
+      /* L10: */
+    }
+    /* L20: */
+  }
+
+  i__1 = *nidim;
+  for (im = 1; im <= i__1; ++im) {
+    m = idim[im];
+
+    i__2 = *nidim;
+    for (in = 1; in <= i__2; ++in) {
+      n = idim[in];
+      /*           Set LDB to 1 more than minimum value if room. */
+      ldb = m;
+      if (ldb < *nmax) {
+        ++ldb;
+      }
+      /*           Skip tests if not enough room. */
+      if (ldb > *nmax) {
+        goto L130;
+      }
+      lbb = ldb * n;
+      null = m <= 0 || n <= 0;
+
+      for (ics = 1; ics <= 2; ++ics) {
+        *(unsigned char *)side = *(unsigned char *)&ichs[ics - 1];
+        left = *(unsigned char *)side == 'L';
+        if (left) {
+          na = m;
+        } else {
+          na = n;
+        }
+        /*              Set LDA to 1 more than minimum value if room. */
+        lda = na;
+        if (lda < *nmax) {
+          ++lda;
+        }
+        /*              Skip tests if not enough room. */
+        if (lda > *nmax) {
+          goto L130;
+        }
+        laa = lda * na;
+
+        for (icu = 1; icu <= 2; ++icu) {
+          *(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+
+          for (ict = 1; ict <= 3; ++ict) {
+            *(unsigned char *)transa = *(unsigned char *)&icht[ict - 1];
+
+            for (icd = 1; icd <= 2; ++icd) {
+              *(unsigned char *)diag = *(unsigned char *)&ichd[icd - 1];
+
+              i__3 = *nalf;
+              for (ia = 1; ia <= i__3; ++ia) {
+                i__4 = ia;
+                alpha.r = alf[i__4].r, alpha.i = alf[i__4].i;
+
+                /*                          Generate the matrix A. */
+
+                cmake_("tr", uplo, diag, &na, &na, &a[a_offset], nmax, &aa[1],
+                       &lda, &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+                /*                          Generate the matrix B. */
+
+                cmake_("ge", " ", " ", &m, &n, &b[b_offset], nmax, &bb[1], &ldb,
+                       &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+                ++nc;
+
+                /*                          Save every datum before calling the
+                 */
+                /*                          subroutine. */
+
+                *(unsigned char *)sides = *(unsigned char *)side;
+                *(unsigned char *)uplos = *(unsigned char *)uplo;
+                *(unsigned char *)tranas = *(unsigned char *)transa;
+                *(unsigned char *)diags = *(unsigned char *)diag;
+                ms = m;
+                ns = n;
+                als.r = alpha.r, als.i = alpha.i;
+                i__4 = laa;
+                for (i__ = 1; i__ <= i__4; ++i__) {
+                  i__5 = i__;
+                  i__6 = i__;
+                  as[i__5].r = aa[i__6].r, as[i__5].i = aa[i__6].i;
+                  /* L30: */
+                }
+                ldas = lda;
+                i__4 = lbb;
+                for (i__ = 1; i__ <= i__4; ++i__) {
+                  i__5 = i__;
+                  i__6 = i__;
+                  bs[i__5].r = bb[i__6].r, bs[i__5].i = bb[i__6].i;
+                  /* L40: */
+                }
+                ldbs = ldb;
+
+                /*                          Call the subroutine. */
+
+                if (s_cmp(sname + 9, "mm", (ftnlen)2, (ftnlen)2) == 0) {
+                  if (*trace) {
+                    cprcn3_(ntra, &nc, sname, iorder, side, uplo, transa, diag,
+                            &m, &n, &alpha, &lda, &ldb, (ftnlen)12, (ftnlen)1,
+                            (ftnlen)1, (ftnlen)1, (ftnlen)1);
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cctrmm_(iorder, side, uplo, transa, diag, &m, &n, &alpha,
+                          &aa[1], &lda, &bb[1], &ldb);
+                } else if (s_cmp(sname + 9, "sm", (ftnlen)2, (ftnlen)2) == 0) {
+                  if (*trace) {
+                    cprcn3_(ntra, &nc, sname, iorder, side, uplo, transa, diag,
+                            &m, &n, &alpha, &lda, &ldb, (ftnlen)12, (ftnlen)1,
+                            (ftnlen)1, (ftnlen)1, (ftnlen)1);
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cctrsm_(iorder, side, uplo, transa, diag, &m, &n, &alpha,
+                          &aa[1], &lda, &bb[1], &ldb);
+                }
+
+                /*                          Check if error-exit was taken
+                 * incorrectly. */
+
+                if (!infoc_1.ok) {
+                  io___236.ciunit = *nout;
+                  s_wsfe(&io___236);
+                  e_wsfe();
+                  *fatal = TRUE_;
+                  goto L150;
+                }
+
+                /*                          See what data changed inside
+                 * subroutines. */
+
+                isame[0] = *(unsigned char *)sides == *(unsigned char *)side;
+                isame[1] = *(unsigned char *)uplos == *(unsigned char *)uplo;
+                isame[2] = *(unsigned char *)tranas == *(unsigned char *)transa;
+                isame[3] = *(unsigned char *)diags == *(unsigned char *)diag;
+                isame[4] = ms == m;
+                isame[5] = ns == n;
+                isame[6] = als.r == alpha.r && als.i == alpha.i;
+                isame[7] = lce_(&as[1], &aa[1], &laa);
+                isame[8] = ldas == lda;
+                if (null) {
+                  isame[9] = lce_(&bs[1], &bb[1], &lbb);
+                } else {
+                  isame[9] = lceres_("ge", " ", &m, &n, &bs[1], &bb[1], &ldb,
+                                     (ftnlen)2, (ftnlen)1);
+                }
+                isame[10] = ldbs == ldb;
+
+                /*                          If data was incorrectly changed,
+                 * report and */
+                /*                          return. */
+
+                same = TRUE_;
+                i__4 = nargs;
+                for (i__ = 1; i__ <= i__4; ++i__) {
+                  same = same && isame[i__ - 1];
+                  if (!isame[i__ - 1]) {
+                    io___239.ciunit = *nout;
+                    s_wsfe(&io___239);
+                    do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  /* L50: */
+                }
+                if (!same) {
+                  *fatal = TRUE_;
+                  goto L150;
+                }
+
+                if (!null) {
+                  if (s_cmp(sname + 9, "mm", (ftnlen)2, (ftnlen)2) == 0) {
+
+                    /*                                Check the result. */
+
+                    if (left) {
+                      cmmch_(transa, "N", &m, &n, &m, &alpha, &a[a_offset],
+                             nmax, &b[b_offset], nmax, &c_b1, &c__[c_offset],
+                             nmax, &ct[1], &g[1], &bb[1], &ldb, eps, &err,
+                             fatal, nout, &c_true, (ftnlen)1, (ftnlen)1);
+                    } else {
+                      cmmch_("N", transa, &m, &n, &n, &alpha, &b[b_offset],
+                             nmax, &a[a_offset], nmax, &c_b1, &c__[c_offset],
+                             nmax, &ct[1], &g[1], &bb[1], &ldb, eps, &err,
+                             fatal, nout, &c_true, (ftnlen)1, (ftnlen)1);
+                    }
+                  } else if (s_cmp(sname + 9, "sm", (ftnlen)2, (ftnlen)2) ==
+                             0) {
+
+                    /*                                Compute approximation to
+                     * original */
+                    /*                                matrix. */
+
+                    i__4 = n;
+                    for (j = 1; j <= i__4; ++j) {
+                      i__5 = m;
+                      for (i__ = 1; i__ <= i__5; ++i__) {
+                        i__6 = i__ + j * c_dim1;
+                        i__7 = i__ + (j - 1) * ldb;
+                        c__[i__6].r = bb[i__7].r, c__[i__6].i = bb[i__7].i;
+                        i__6 = i__ + (j - 1) * ldb;
+                        i__7 = i__ + j * b_dim1;
+                        q__1.r = alpha.r * b[i__7].r - alpha.i * b[i__7].i,
+                        q__1.i = alpha.r * b[i__7].i + alpha.i * b[i__7].r;
+                        bb[i__6].r = q__1.r, bb[i__6].i = q__1.i;
+                        /* L60: */
+                      }
+                      /* L70: */
+                    }
+
+                    if (left) {
+                      cmmch_(transa, "N", &m, &n, &m, &c_b2, &a[a_offset], nmax,
+                             &c__[c_offset], nmax, &c_b1, &b[b_offset], nmax,
+                             &ct[1], &g[1], &bb[1], &ldb, eps, &err, fatal,
+                             nout, &c_false, (ftnlen)1, (ftnlen)1);
+                    } else {
+                      cmmch_("N", transa, &m, &n, &n, &c_b2, &c__[c_offset],
+                             nmax, &a[a_offset], nmax, &c_b1, &b[b_offset],
+                             nmax, &ct[1], &g[1], &bb[1], &ldb, eps, &err,
+                             fatal, nout, &c_false, (ftnlen)1, (ftnlen)1);
+                    }
+                  }
+                  errmax = max(errmax, err);
+                  /*                             If got really bad answer,
+                   * report and */
+                  /*                             return. */
+                  if (*fatal) {
+                    goto L150;
+                  }
+                }
+
+                /* L80: */
+              }
+
+              /* L90: */
+            }
+
+            /* L100: */
+          }
+
+          /* L110: */
+        }
+
+        /* L120: */
+      }
+
+    L130:;
+    }
+
+    /* L140: */
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___241.ciunit = *nout;
+      s_wsfe(&io___241);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___242.ciunit = *nout;
+      s_wsfe(&io___242);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___243.ciunit = *nout;
+      s_wsfe(&io___243);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___244.ciunit = *nout;
+      s_wsfe(&io___244);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+  }
+  goto L160;
+
+L150:
+  io___245.ciunit = *nout;
+  s_wsfe(&io___245);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  cprcn3_(ntra, &nc, sname, iorder, side, uplo, transa, diag, &m, &n, &alpha,
+          &lda, &ldb, (ftnlen)12, (ftnlen)1, (ftnlen)1, (ftnlen)1, (ftnlen)1);
+
+L160:
+  return 0;
+
+  /* L9995: */
+
+  /*     End of CCHK3. */
+
+} /* cchk3_ */
+
+/* Subroutine */ int cprcn3_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *side, char *uplo,
+                             char *transa, char *diag, integer *m, integer *n,
+                             complex *alpha, integer *lda, integer *ldb,
+                             ftnlen sname_len, ftnlen side_len, ftnlen uplo_len,
+                             ftnlen transa_len, ftnlen diag_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+                           "a14,\002,\002,a14,\002,\002)";
+  static char fmt_9994[] =
+      "(10x,2(a14,\002,\002),2(i3,\002,\002),\002 "
+      "(\002,f4.1,\002,\002,f4.1,\002), A,\002,i3,\002, B,\002,i3,\002)."
+      "\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char ca[14], cd[14], cs[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___251 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___252 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)side == 'L') {
+    s_copy(cs, "     CblasLeft", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cs, "    CblasRight", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(ca, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(ca, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ca, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)diag == 'N') {
+    s_copy(cd, "  CblasNonUnit", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cd, "     CblasUnit", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___251.ciunit = *nout;
+  s_wsfe(&io___251);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cs, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  e_wsfe();
+  io___252.ciunit = *nout;
+  s_wsfe(&io___252);
+  do_fio(&c__1, ca, (ftnlen)14);
+  do_fio(&c__1, cd, (ftnlen)14);
+  do_fio(&c__1, (char *)&(*m), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*alpha), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*ldb), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* cprcn3_ */
+
+/* Subroutine */ int
+cchk4_(char *sname, real *eps, real *thresh, integer *nout, integer *ntra,
+       logical *trace, logical *rewi, logical *fatal, integer *nidim,
+       integer *idim, integer *nalf, complex *alf, integer *nbet, complex *bet,
+       integer *nmax, complex *a, complex *aa, complex *as, complex *b,
+       complex *bb, complex *bs, complex *c__, complex *cc, complex *cs,
+       complex *ct, real *g, integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char icht[2] = "NC";
+  static char ichu[2] = "UL";
+
+  /* Format strings */
+  static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+                           " \002,i3)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
+      i__3, i__4, i__5, i__6, i__7;
+  complex q__1;
+  alist al__1;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen), f_rew(alist *),
+      s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, j, k, n, ia, ib, jc, ma, na, nc, ik, in, jj, lj, ks, ns, laa,
+      lda, lcc, ldc;
+  extern logical lce_(complex *, complex *, integer *);
+  complex als;
+  integer ict, icu;
+  real err;
+  complex beta;
+  integer ldas, ldcs;
+  logical same, conj;
+  complex bets;
+  real rals;
+  logical tran, null;
+  char uplo[1];
+  extern /* Subroutine */ int cmake_(
+      char *, char *, char *, integer *, integer *, complex *, integer *,
+      complex *, integer *, logical *, complex *, ftnlen, ftnlen, ftnlen);
+  complex alpha;
+  extern /* Subroutine */ int cmmch_(
+      char *, char *, integer *, integer *, integer *, complex *, complex *,
+      integer *, complex *, integer *, complex *, complex *, integer *,
+      complex *, real *, complex *, integer *, real *, real *, logical *,
+      integer *, logical *, ftnlen, ftnlen);
+  real rbeta;
+  logical isame[13];
+  integer nargs;
+  real rbets;
+  logical reset;
+  char trans[1];
+  logical upper;
+  char uplos[1];
+  extern /* Subroutine */ int cprcn4_(integer *, integer *, char *, integer *,
+                                      char *, char *, integer *, integer *,
+                                      complex *, integer *, complex *,
+                                      integer *, ftnlen, ftnlen, ftnlen),
+      cprcn6_(integer *, integer *, char *, integer *, char *, char *,
+              integer *, integer *, real *, integer *, real *, integer *,
+              ftnlen, ftnlen, ftnlen);
+  extern void ccherk_(integer *, char *, char *, integer *, integer *, real *,
+              complex *, integer *, real *, complex *, integer *);
+  real ralpha;
+  extern logical lceres_(char *, char *, integer *, integer *, complex *,
+                         complex *, integer *, ftnlen, ftnlen);
+  real errmax;
+  extern /* Subroutine */ void ccsyrk_(
+      integer *, char *, char *, integer *, integer *, complex *, complex *,
+      integer *, complex *, complex *, integer *);
+  char transs[1], transt[1];
+
+  /* Fortran I/O blocks */
+  static cilist io___294 = {0, 0, 0, fmt_9992, 0};
+  static cilist io___297 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___304 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___305 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___306 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___307 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___308 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___309 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests CHERK and CSYRK. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --bet;
+  --g;
+  --ct;
+  --cs;
+  --cc;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --bs;
+  --bb;
+  b_dim1 = *nmax;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+  conj = s_cmp(sname + 7, "he", (ftnlen)2, (ftnlen)2) == 0;
+
+  nargs = 10;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.f;
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+    /*        Set LDC to 1 more than minimum value if room. */
+    ldc = n;
+    if (ldc < *nmax) {
+      ++ldc;
+    }
+    /*        Skip tests if not enough room. */
+    if (ldc > *nmax) {
+      goto L100;
+    }
+    lcc = ldc * n;
+
+    i__2 = *nidim;
+    for (ik = 1; ik <= i__2; ++ik) {
+      k = idim[ik];
+
+      for (ict = 1; ict <= 2; ++ict) {
+        *(unsigned char *)trans = *(unsigned char *)&icht[ict - 1];
+        tran = *(unsigned char *)trans == 'C';
+        if (tran && !conj) {
+          *(unsigned char *)trans = 'T';
+        }
+        if (tran) {
+          ma = k;
+          na = n;
+        } else {
+          ma = n;
+          na = k;
+        }
+        /*              Set LDA to 1 more than minimum value if room. */
+        lda = ma;
+        if (lda < *nmax) {
+          ++lda;
+        }
+        /*              Skip tests if not enough room. */
+        if (lda > *nmax) {
+          goto L80;
+        }
+        laa = lda * na;
+
+        /*              Generate the matrix A. */
+
+        cmake_("ge", " ", " ", &ma, &na, &a[a_offset], nmax, &aa[1], &lda,
+               &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+        for (icu = 1; icu <= 2; ++icu) {
+          *(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+          upper = *(unsigned char *)uplo == 'U';
+
+          i__3 = *nalf;
+          for (ia = 1; ia <= i__3; ++ia) {
+            i__4 = ia;
+            alpha.r = alf[i__4].r, alpha.i = alf[i__4].i;
+            if (conj) {
+              ralpha = alpha.r;
+              q__1.r = ralpha, q__1.i = 0.f;
+              alpha.r = q__1.r, alpha.i = q__1.i;
+            }
+
+            i__4 = *nbet;
+            for (ib = 1; ib <= i__4; ++ib) {
+              i__5 = ib;
+              beta.r = bet[i__5].r, beta.i = bet[i__5].i;
+              if (conj) {
+                rbeta = beta.r;
+                q__1.r = rbeta, q__1.i = 0.f;
+                beta.r = q__1.r, beta.i = q__1.i;
+              }
+              null = n <= 0;
+              if (conj) {
+                null = null || (k <= 0 || ralpha == 0.f) && rbeta == 1.f;
+              }
+
+              /*                       Generate the matrix C. */
+
+              cmake_(sname + 7, uplo, " ", &n, &n, &c__[c_offset], nmax, &cc[1],
+                     &ldc, &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+              ++nc;
+
+              /*                       Save every datum before calling the
+               * subroutine. */
+
+              *(unsigned char *)uplos = *(unsigned char *)uplo;
+              *(unsigned char *)transs = *(unsigned char *)trans;
+              ns = n;
+              ks = k;
+              if (conj) {
+                rals = ralpha;
+              } else {
+                als.r = alpha.r, als.i = alpha.i;
+              }
+              i__5 = laa;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                i__6 = i__;
+                i__7 = i__;
+                as[i__6].r = aa[i__7].r, as[i__6].i = aa[i__7].i;
+                /* L10: */
+              }
+              ldas = lda;
+              if (conj) {
+                rbets = rbeta;
+              } else {
+                bets.r = beta.r, bets.i = beta.i;
+              }
+              i__5 = lcc;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                i__6 = i__;
+                i__7 = i__;
+                cs[i__6].r = cc[i__7].r, cs[i__6].i = cc[i__7].i;
+                /* L20: */
+              }
+              ldcs = ldc;
+
+              /*                       Call the subroutine. */
+
+              if (conj) {
+                if (*trace) {
+                  cprcn6_(ntra, &nc, sname, iorder, uplo, trans, &n, &k,
+                          &ralpha, &lda, &rbeta, &ldc, (ftnlen)12, (ftnlen)1,
+                          (ftnlen)1);
+                }
+                if (*rewi) {
+                  al__1.aerr = 0;
+                  al__1.aunit = *ntra;
+                  f_rew(&al__1);
+                }
+                ccherk_(iorder, uplo, trans, &n, &k, &ralpha, &aa[1], &lda,
+                        &rbeta, &cc[1], &ldc);
+              } else {
+                if (*trace) {
+                  cprcn4_(ntra, &nc, sname, iorder, uplo, trans, &n, &k, &alpha,
+                          &lda, &beta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+                }
+                if (*rewi) {
+                  al__1.aerr = 0;
+                  al__1.aunit = *ntra;
+                  f_rew(&al__1);
+                }
+                ccsyrk_(iorder, uplo, trans, &n, &k, &alpha, &aa[1], &lda,
+                        &beta, &cc[1], &ldc);
+              }
+
+              /*                       Check if error-exit was taken
+               * incorrectly. */
+
+              if (!infoc_1.ok) {
+                io___294.ciunit = *nout;
+                s_wsfe(&io___294);
+                e_wsfe();
+                *fatal = TRUE_;
+                goto L120;
+              }
+
+              /*                       See what data changed inside subroutines.
+               */
+
+              isame[0] = *(unsigned char *)uplos == *(unsigned char *)uplo;
+              isame[1] = *(unsigned char *)transs == *(unsigned char *)trans;
+              isame[2] = ns == n;
+              isame[3] = ks == k;
+              if (conj) {
+                isame[4] = rals == ralpha;
+              } else {
+                isame[4] = als.r == alpha.r && als.i == alpha.i;
+              }
+              isame[5] = lce_(&as[1], &aa[1], &laa);
+              isame[6] = ldas == lda;
+              if (conj) {
+                isame[7] = rbets == rbeta;
+              } else {
+                isame[7] = bets.r == beta.r && bets.i == beta.i;
+              }
+              if (null) {
+                isame[8] = lce_(&cs[1], &cc[1], &lcc);
+              } else {
+                isame[8] = lceres_(sname + 7, uplo, &n, &n, &cs[1], &cc[1],
+                                   &ldc, (ftnlen)2, (ftnlen)1);
+              }
+              isame[9] = ldcs == ldc;
+
+              /*                       If data was incorrectly changed, report
+               * and */
+              /*                       return. */
+
+              same = TRUE_;
+              i__5 = nargs;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                same = same && isame[i__ - 1];
+                if (!isame[i__ - 1]) {
+                  io___297.ciunit = *nout;
+                  s_wsfe(&io___297);
+                  do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                  e_wsfe();
+                }
+                /* L30: */
+              }
+              if (!same) {
+                *fatal = TRUE_;
+                goto L120;
+              }
+
+              if (!null) {
+
+                /*                          Check the result column by column.
+                 */
+
+                if (conj) {
+                  *(unsigned char *)transt = 'C';
+                } else {
+                  *(unsigned char *)transt = 'T';
+                }
+                jc = 1;
+                i__5 = n;
+                for (j = 1; j <= i__5; ++j) {
+                  if (upper) {
+                    jj = 1;
+                    lj = j;
+                  } else {
+                    jj = j;
+                    lj = n - j + 1;
+                  }
+                  if (tran) {
+                    cmmch_(transt, "N", &lj, &c__1, &k, &alpha,
+                           &a[jj * a_dim1 + 1], nmax, &a[j * a_dim1 + 1], nmax,
+                           &beta, &c__[jj + j * c_dim1], nmax, &ct[1], &g[1],
+                           &cc[jc], &ldc, eps, &err, fatal, nout, &c_true,
+                           (ftnlen)1, (ftnlen)1);
+                  } else {
+                    cmmch_("N", transt, &lj, &c__1, &k, &alpha, &a[jj + a_dim1],
+                           nmax, &a[j + a_dim1], nmax, &beta,
+                           &c__[jj + j * c_dim1], nmax, &ct[1], &g[1], &cc[jc],
+                           &ldc, eps, &err, fatal, nout, &c_true, (ftnlen)1,
+                           (ftnlen)1);
+                  }
+                  if (upper) {
+                    jc += ldc;
+                  } else {
+                    jc = jc + ldc + 1;
+                  }
+                  errmax = max(errmax, err);
+                  /*                             If got really bad answer,
+                   * report and */
+                  /*                             return. */
+                  if (*fatal) {
+                    goto L110;
+                  }
+                  /* L40: */
+                }
+              }
+
+              /* L50: */
+            }
+
+            /* L60: */
+          }
+
+          /* L70: */
+        }
+
+      L80:;
+      }
+
+      /* L90: */
+    }
+
+  L100:;
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___304.ciunit = *nout;
+      s_wsfe(&io___304);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___305.ciunit = *nout;
+      s_wsfe(&io___305);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___306.ciunit = *nout;
+      s_wsfe(&io___306);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___307.ciunit = *nout;
+      s_wsfe(&io___307);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+  }
+  goto L130;
+
+L110:
+  if (n > 1) {
+    io___308.ciunit = *nout;
+    s_wsfe(&io___308);
+    do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L120:
+  io___309.ciunit = *nout;
+  s_wsfe(&io___309);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  if (conj) {
+    cprcn6_(nout, &nc, sname, iorder, uplo, trans, &n, &k, &ralpha, &lda,
+            &rbeta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+  } else {
+    cprcn4_(nout, &nc, sname, iorder, uplo, trans, &n, &k, &alpha, &lda, &beta,
+            &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+  }
+
+L130:
+  return 0;
+
+  /* L9994: */
+  /* L9993: */
+
+  /*     End of CCHK4. */
+
+} /* cchk4_ */
+
+/* Subroutine */ int cprcn4_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *uplo, char *transa,
+                             integer *n, integer *k, complex *alpha,
+                             integer *lda, complex *beta, integer *ldc,
+                             ftnlen sname_len, ftnlen uplo_len,
+                             ftnlen transa_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+                           "\002))";
+  static char fmt_9994[] =
+      "(10x,2(i3,\002,\002),\002 (\002,f4.1,\002,\002"
+      ",f4.1,\002), A,\002,i3,\002, (\002,f4.1,\002,\002,f4.1,\002), C"
+      ",\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char ca[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___313 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___314 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(ca, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(ca, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ca, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___313.ciunit = *nout;
+  s_wsfe(&io___313);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  do_fio(&c__1, ca, (ftnlen)14);
+  e_wsfe();
+  io___314.ciunit = *nout;
+  s_wsfe(&io___314);
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*k), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*alpha), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*beta), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* cprcn4_ */
+
+/* Subroutine */ int cprcn6_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *uplo, char *transa,
+                             integer *n, integer *k, real *alpha, integer *lda,
+                             real *beta, integer *ldc, ftnlen sname_len,
+                             ftnlen uplo_len, ftnlen transa_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+                           "\002))";
+  static char fmt_9994[] = "(10x,2(i3,\002,\002),f4.1,\002, A,\002,i3"
+                           ",\002,\002,f4.1,\002, C,\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char ca[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___318 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___319 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(ca, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(ca, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ca, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___318.ciunit = *nout;
+  s_wsfe(&io___318);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  do_fio(&c__1, ca, (ftnlen)14);
+  e_wsfe();
+  io___319.ciunit = *nout;
+  s_wsfe(&io___319);
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*k), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*alpha), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*beta), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* cprcn6_ */
+
+/* Subroutine */ int
+cchk5_(char *sname, real *eps, real *thresh, integer *nout, integer *ntra,
+       logical *trace, logical *rewi, logical *fatal, integer *nidim,
+       integer *idim, integer *nalf, complex *alf, integer *nbet, complex *bet,
+       integer *nmax, complex *ab, complex *aa, complex *as, complex *bb,
+       complex *bs, complex *c__, complex *cc, complex *cs, complex *ct,
+       real *g, complex *w, integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char icht[2] = "NC";
+  static char ichu[2] = "UL";
+
+  /* Format strings */
+  static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+                           " \002,i3)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer c_dim1, c_offset, i__1, i__2, i__3, i__4, i__5, i__6, i__7, i__8;
+  complex q__1, q__2;
+  alist al__1;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen), f_rew(alist *),
+      s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+  void r_cnjg(complex *, complex *);
+
+  /* Local variables */
+  integer i__, j, k, n, ia, ib, jc, ma, na, nc, ik, in, jj, lj, ks, ns, laa,
+      lbb, lda, lcc, ldb, ldc;
+  extern logical lce_(complex *, complex *, integer *);
+  complex als;
+  integer ict, icu;
+  real err;
+  integer jjab;
+  complex beta;
+  integer ldas, ldbs, ldcs;
+  logical same, conj;
+  complex bets;
+  logical tran, null;
+  char uplo[1];
+  extern /* Subroutine */ int cmake_(
+      char *, char *, char *, integer *, integer *, complex *, integer *,
+      complex *, integer *, logical *, complex *, ftnlen, ftnlen, ftnlen);
+  complex alpha;
+  extern /* Subroutine */ int cmmch_(
+      char *, char *, integer *, integer *, integer *, complex *, complex *,
+      integer *, complex *, integer *, complex *, complex *, integer *,
+      complex *, real *, complex *, integer *, real *, real *, logical *,
+      integer *, logical *, ftnlen, ftnlen);
+  real rbeta;
+  logical isame[13];
+  integer nargs;
+  real rbets;
+  logical reset;
+  char trans[1];
+  logical upper;
+  char uplos[1];
+  extern /* Subroutine */ int cprcn5_(
+      integer *, integer *, char *, integer *, char *, char *, integer *,
+      integer *, complex *, integer *, integer *, complex *, integer *, ftnlen,
+      ftnlen, ftnlen),
+      cprcn7_(integer *, integer *, char *, integer *, char *, char *,
+              integer *, integer *, complex *, integer *, integer *, real *,
+              integer *, ftnlen, ftnlen, ftnlen);
+  extern logical lceres_(char *, char *, integer *, integer *, complex *,
+                         complex *, integer *, ftnlen, ftnlen);
+  real errmax;
+  char transs[1], transt[1];
+  extern /* Subroutine */ void ccher2k_(integer *, char *, char *, integer *,
+                                        integer *, complex *, complex *,
+                                        integer *, complex *, integer *, real *,
+                                        complex *, integer *);
+  extern void ccsyr2k_(integer *, char *, char *, integer *, integer *, complex *,
+                       complex *, integer *, complex *, integer *, complex *, complex *,
+                       integer *);
+
+  /* Fortran I/O blocks */
+  static cilist io___362 = {0, 0, 0, fmt_9992, 0};
+  static cilist io___365 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___373 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___374 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___375 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___376 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___377 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___378 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests CHER2K and CSYR2K. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --bet;
+  --w;
+  --g;
+  --ct;
+  --cs;
+  --cc;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --bs;
+  --bb;
+  --as;
+  --aa;
+  --ab;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+  conj = s_cmp(sname + 7, "he", (ftnlen)2, (ftnlen)2) == 0;
+
+  nargs = 12;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.f;
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+    /*        Set LDC to 1 more than minimum value if room. */
+    ldc = n;
+    if (ldc < *nmax) {
+      ++ldc;
+    }
+    /*        Skip tests if not enough room. */
+    if (ldc > *nmax) {
+      goto L130;
+    }
+    lcc = ldc * n;
+
+    i__2 = *nidim;
+    for (ik = 1; ik <= i__2; ++ik) {
+      k = idim[ik];
+
+      for (ict = 1; ict <= 2; ++ict) {
+        *(unsigned char *)trans = *(unsigned char *)&icht[ict - 1];
+        tran = *(unsigned char *)trans == 'C';
+        if (tran && !conj) {
+          *(unsigned char *)trans = 'T';
+        }
+        if (tran) {
+          ma = k;
+          na = n;
+        } else {
+          ma = n;
+          na = k;
+        }
+        /*              Set LDA to 1 more than minimum value if room. */
+        lda = ma;
+        if (lda < *nmax) {
+          ++lda;
+        }
+        /*              Skip tests if not enough room. */
+        if (lda > *nmax) {
+          goto L110;
+        }
+        laa = lda * na;
+
+        /*              Generate the matrix A. */
+
+        if (tran) {
+          i__3 = *nmax << 1;
+          cmake_("ge", " ", " ", &ma, &na, &ab[1], &i__3, &aa[1], &lda, &reset,
+                 &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        } else {
+          cmake_("ge", " ", " ", &ma, &na, &ab[1], nmax, &aa[1], &lda, &reset,
+                 &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        }
+
+        /*              Generate the matrix B. */
+
+        ldb = lda;
+        lbb = laa;
+        if (tran) {
+          i__3 = *nmax << 1;
+          cmake_("ge", " ", " ", &ma, &na, &ab[k + 1], &i__3, &bb[1], &ldb,
+                 &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        } else {
+          cmake_("ge", " ", " ", &ma, &na, &ab[k * *nmax + 1], nmax, &bb[1],
+                 &ldb, &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        }
+
+        for (icu = 1; icu <= 2; ++icu) {
+          *(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+          upper = *(unsigned char *)uplo == 'U';
+
+          i__3 = *nalf;
+          for (ia = 1; ia <= i__3; ++ia) {
+            i__4 = ia;
+            alpha.r = alf[i__4].r, alpha.i = alf[i__4].i;
+
+            i__4 = *nbet;
+            for (ib = 1; ib <= i__4; ++ib) {
+              i__5 = ib;
+              beta.r = bet[i__5].r, beta.i = bet[i__5].i;
+              if (conj) {
+                rbeta = beta.r;
+                q__1.r = rbeta, q__1.i = 0.f;
+                beta.r = q__1.r, beta.i = q__1.i;
+              }
+              null = n <= 0;
+              if (conj) {
+                null = null || (k <= 0 || alpha.r == 0.f && alpha.i == 0.f) &&
+                                   rbeta == 1.f;
+              }
+
+              /*                       Generate the matrix C. */
+
+              cmake_(sname + 7, uplo, " ", &n, &n, &c__[c_offset], nmax, &cc[1],
+                     &ldc, &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+              ++nc;
+
+              /*                       Save every datum before calling the
+               * subroutine. */
+
+              *(unsigned char *)uplos = *(unsigned char *)uplo;
+              *(unsigned char *)transs = *(unsigned char *)trans;
+              ns = n;
+              ks = k;
+              als.r = alpha.r, als.i = alpha.i;
+              i__5 = laa;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                i__6 = i__;
+                i__7 = i__;
+                as[i__6].r = aa[i__7].r, as[i__6].i = aa[i__7].i;
+                /* L10: */
+              }
+              ldas = lda;
+              i__5 = lbb;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                i__6 = i__;
+                i__7 = i__;
+                bs[i__6].r = bb[i__7].r, bs[i__6].i = bb[i__7].i;
+                /* L20: */
+              }
+              ldbs = ldb;
+              if (conj) {
+                rbets = rbeta;
+              } else {
+                bets.r = beta.r, bets.i = beta.i;
+              }
+              i__5 = lcc;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                i__6 = i__;
+                i__7 = i__;
+                cs[i__6].r = cc[i__7].r, cs[i__6].i = cc[i__7].i;
+                /* L30: */
+              }
+              ldcs = ldc;
+
+              /*                       Call the subroutine. */
+
+              if (conj) {
+                if (*trace) {
+                  cprcn7_(ntra, &nc, sname, iorder, uplo, trans, &n, &k, &alpha,
+                          &lda, &ldb, &rbeta, &ldc, (ftnlen)12, (ftnlen)1,
+                          (ftnlen)1);
+                }
+                if (*rewi) {
+                  al__1.aerr = 0;
+                  al__1.aunit = *ntra;
+                  f_rew(&al__1);
+                }
+                ccher2k_(iorder, uplo, trans, &n, &k, &alpha, &aa[1], &lda,
+                         &bb[1], &ldb, &rbeta, &cc[1], &ldc);
+              } else {
+                if (*trace) {
+                  cprcn5_(ntra, &nc, sname, iorder, uplo, trans, &n, &k, &alpha,
+                          &lda, &ldb, &beta, &ldc, (ftnlen)12, (ftnlen)1,
+                          (ftnlen)1);
+                }
+                if (*rewi) {
+                  al__1.aerr = 0;
+                  al__1.aunit = *ntra;
+                  f_rew(&al__1);
+                }
+                ccsyr2k_(iorder, uplo, trans, &n, &k, &alpha, &aa[1], &lda,
+                         &bb[1], &ldb, &beta, &cc[1], &ldc);
+              }
+
+              /*                       Check if error-exit was taken
+               * incorrectly. */
+
+              if (!infoc_1.ok) {
+                io___362.ciunit = *nout;
+                s_wsfe(&io___362);
+                e_wsfe();
+                *fatal = TRUE_;
+                goto L150;
+              }
+
+              /*                       See what data changed inside subroutines.
+               */
+
+              isame[0] = *(unsigned char *)uplos == *(unsigned char *)uplo;
+              isame[1] = *(unsigned char *)transs == *(unsigned char *)trans;
+              isame[2] = ns == n;
+              isame[3] = ks == k;
+              isame[4] = als.r == alpha.r && als.i == alpha.i;
+              isame[5] = lce_(&as[1], &aa[1], &laa);
+              isame[6] = ldas == lda;
+              isame[7] = lce_(&bs[1], &bb[1], &lbb);
+              isame[8] = ldbs == ldb;
+              if (conj) {
+                isame[9] = rbets == rbeta;
+              } else {
+                isame[9] = bets.r == beta.r && bets.i == beta.i;
+              }
+              if (null) {
+                isame[10] = lce_(&cs[1], &cc[1], &lcc);
+              } else {
+                isame[10] = lceres_("he", uplo, &n, &n, &cs[1], &cc[1], &ldc,
+                                    (ftnlen)2, (ftnlen)1);
+              }
+              isame[11] = ldcs == ldc;
+
+              /*                       If data was incorrectly changed, report
+               * and */
+              /*                       return. */
+
+              same = TRUE_;
+              i__5 = nargs;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                same = same && isame[i__ - 1];
+                if (!isame[i__ - 1]) {
+                  io___365.ciunit = *nout;
+                  s_wsfe(&io___365);
+                  do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                  e_wsfe();
+                }
+                /* L40: */
+              }
+              if (!same) {
+                *fatal = TRUE_;
+                goto L150;
+              }
+
+              if (!null) {
+
+                /*                          Check the result column by column.
+                 */
+
+                if (conj) {
+                  *(unsigned char *)transt = 'C';
+                } else {
+                  *(unsigned char *)transt = 'T';
+                }
+                jjab = 1;
+                jc = 1;
+                i__5 = n;
+                for (j = 1; j <= i__5; ++j) {
+                  if (upper) {
+                    jj = 1;
+                    lj = j;
+                  } else {
+                    jj = j;
+                    lj = n - j + 1;
+                  }
+                  if (tran) {
+                    i__6 = k;
+                    for (i__ = 1; i__ <= i__6; ++i__) {
+                      i__7 = i__;
+                      i__8 = (j - 1 << 1) * *nmax + k + i__;
+                      q__1.r = alpha.r * ab[i__8].r - alpha.i * ab[i__8].i,
+                      q__1.i = alpha.r * ab[i__8].i + alpha.i * ab[i__8].r;
+                      w[i__7].r = q__1.r, w[i__7].i = q__1.i;
+                      if (conj) {
+                        i__7 = k + i__;
+                        r_cnjg(&q__2, &alpha);
+                        i__8 = (j - 1 << 1) * *nmax + i__;
+                        q__1.r = q__2.r * ab[i__8].r - q__2.i * ab[i__8].i,
+                        q__1.i = q__2.r * ab[i__8].i + q__2.i * ab[i__8].r;
+                        w[i__7].r = q__1.r, w[i__7].i = q__1.i;
+                      } else {
+                        i__7 = k + i__;
+                        i__8 = (j - 1 << 1) * *nmax + i__;
+                        q__1.r = alpha.r * ab[i__8].r - alpha.i * ab[i__8].i,
+                        q__1.i = alpha.r * ab[i__8].i + alpha.i * ab[i__8].r;
+                        w[i__7].r = q__1.r, w[i__7].i = q__1.i;
+                      }
+                      /* L50: */
+                    }
+                    i__6 = k << 1;
+                    i__7 = *nmax << 1;
+                    i__8 = *nmax << 1;
+                    cmmch_(transt, "N", &lj, &c__1, &i__6, &c_b2, &ab[jjab],
+                           &i__7, &w[1], &i__8, &beta, &c__[jj + j * c_dim1],
+                           nmax, &ct[1], &g[1], &cc[jc], &ldc, eps, &err, fatal,
+                           nout, &c_true, (ftnlen)1, (ftnlen)1);
+                  } else {
+                    i__6 = k;
+                    for (i__ = 1; i__ <= i__6; ++i__) {
+                      if (conj) {
+                        i__7 = i__;
+                        r_cnjg(&q__2, &ab[(k + i__ - 1) * *nmax + j]);
+                        q__1.r = alpha.r * q__2.r - alpha.i * q__2.i,
+                        q__1.i = alpha.r * q__2.i + alpha.i * q__2.r;
+                        w[i__7].r = q__1.r, w[i__7].i = q__1.i;
+                        i__7 = k + i__;
+                        i__8 = (i__ - 1) * *nmax + j;
+                        q__2.r = alpha.r * ab[i__8].r - alpha.i * ab[i__8].i,
+                        q__2.i = alpha.r * ab[i__8].i + alpha.i * ab[i__8].r;
+                        r_cnjg(&q__1, &q__2);
+                        w[i__7].r = q__1.r, w[i__7].i = q__1.i;
+                      } else {
+                        i__7 = i__;
+                        i__8 = (k + i__ - 1) * *nmax + j;
+                        q__1.r = alpha.r * ab[i__8].r - alpha.i * ab[i__8].i,
+                        q__1.i = alpha.r * ab[i__8].i + alpha.i * ab[i__8].r;
+                        w[i__7].r = q__1.r, w[i__7].i = q__1.i;
+                        i__7 = k + i__;
+                        i__8 = (i__ - 1) * *nmax + j;
+                        q__1.r = alpha.r * ab[i__8].r - alpha.i * ab[i__8].i,
+                        q__1.i = alpha.r * ab[i__8].i + alpha.i * ab[i__8].r;
+                        w[i__7].r = q__1.r, w[i__7].i = q__1.i;
+                      }
+                      /* L60: */
+                    }
+                    i__6 = k << 1;
+                    i__7 = *nmax << 1;
+                    cmmch_("N", "N", &lj, &c__1, &i__6, &c_b2, &ab[jj], nmax,
+                           &w[1], &i__7, &beta, &c__[jj + j * c_dim1], nmax,
+                           &ct[1], &g[1], &cc[jc], &ldc, eps, &err, fatal, nout,
+                           &c_true, (ftnlen)1, (ftnlen)1);
+                  }
+                  if (upper) {
+                    jc += ldc;
+                  } else {
+                    jc = jc + ldc + 1;
+                    if (tran) {
+                      jjab += *nmax << 1;
+                    }
+                  }
+                  errmax = max(errmax, err);
+                  /*                             If got really bad answer,
+                   * report and */
+                  /*                             return. */
+                  if (*fatal) {
+                    goto L140;
+                  }
+                  /* L70: */
+                }
+              }
+
+              /* L80: */
+            }
+
+            /* L90: */
+          }
+
+          /* L100: */
+        }
+
+      L110:;
+      }
+
+      /* L120: */
+    }
+
+  L130:;
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___373.ciunit = *nout;
+      s_wsfe(&io___373);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___374.ciunit = *nout;
+      s_wsfe(&io___374);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___375.ciunit = *nout;
+      s_wsfe(&io___375);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___376.ciunit = *nout;
+      s_wsfe(&io___376);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+  }
+  goto L160;
+
+L140:
+  if (n > 1) {
+    io___377.ciunit = *nout;
+    s_wsfe(&io___377);
+    do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L150:
+  io___378.ciunit = *nout;
+  s_wsfe(&io___378);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  if (conj) {
+    cprcn7_(nout, &nc, sname, iorder, uplo, trans, &n, &k, &alpha, &lda, &ldb,
+            &rbeta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+  } else {
+    cprcn5_(nout, &nc, sname, iorder, uplo, trans, &n, &k, &alpha, &lda, &ldb,
+            &beta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+  }
+
+L160:
+  return 0;
+
+  /* L9994: */
+  /* L9993: */
+
+  /*     End of CCHK5. */
+
+} /* cchk5_ */
+
+/* Subroutine */ int cprcn5_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *uplo, char *transa,
+                             integer *n, integer *k, complex *alpha,
+                             integer *lda, integer *ldb, complex *beta,
+                             integer *ldc, ftnlen sname_len, ftnlen uplo_len,
+                             ftnlen transa_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+                           "\002))";
+  static char fmt_9994[] =
+      "(10x,2(i3,\002,\002),\002 (\002,f4.1,\002,\002"
+      ",f4.1,\002), A,\002,i3,\002, B\002,i3,\002, (\002,f4.1,\002,\002"
+      ",f4.1,\002), C,\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char ca[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___382 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___383 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(ca, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(ca, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ca, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___382.ciunit = *nout;
+  s_wsfe(&io___382);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  do_fio(&c__1, ca, (ftnlen)14);
+  e_wsfe();
+  io___383.ciunit = *nout;
+  s_wsfe(&io___383);
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*k), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*alpha), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*ldb), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*beta), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* cprcn5_ */
+
+/* Subroutine */ int cprcn7_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *uplo, char *transa,
+                             integer *n, integer *k, complex *alpha,
+                             integer *lda, integer *ldb, real *beta,
+                             integer *ldc, ftnlen sname_len, ftnlen uplo_len,
+                             ftnlen transa_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+                           "\002))";
+  static char fmt_9994[] =
+      "(10x,2(i3,\002,\002),\002 (\002,f4.1,\002,\002"
+      ",f4.1,\002), A,\002,i3,\002, B\002,i3,\002,\002,f4.1,\002, C,"
+      "\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char ca[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___387 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___388 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(ca, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(ca, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ca, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___387.ciunit = *nout;
+  s_wsfe(&io___387);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  do_fio(&c__1, ca, (ftnlen)14);
+  e_wsfe();
+  io___388.ciunit = *nout;
+  s_wsfe(&io___388);
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*k), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*alpha), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*ldb), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*beta), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* cprcn7_ */
+
+/* Subroutine */ int cmake_(char *type__, char *uplo, char *diag, integer *m,
+                            integer *n, complex *a, integer *nmax, complex *aa,
+                            integer *lda, logical *reset, complex *transl,
+                            ftnlen type_len, ftnlen uplo_len, ftnlen diag_len) {
+  /* System generated locals */
+  integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
+  real r__1;
+  complex q__1, q__2;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen);
+  void r_cnjg(complex *, complex *);
+
+  /* Local variables */
+  integer i__, j, jj;
+  logical gen, her, tri, sym;
+  extern /* Complex */ VOID cbeg_(complex *, logical *);
+  integer ibeg, iend;
+  logical unit, lower, upper;
+
+  /*  Generates values for an M by N matrix A. */
+  /*  Stores the values in the array AA in the data structure required */
+  /*  by the routine, with unwanted elements set to rogue value. */
+
+  /*  TYPE is 'ge', 'he', 'sy' or 'tr'. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. External Functions .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --aa;
+
+  /* Function Body */
+  gen = s_cmp(type__, "ge", (ftnlen)2, (ftnlen)2) == 0;
+  her = s_cmp(type__, "he", (ftnlen)2, (ftnlen)2) == 0;
+  sym = s_cmp(type__, "sy", (ftnlen)2, (ftnlen)2) == 0;
+  tri = s_cmp(type__, "tr", (ftnlen)2, (ftnlen)2) == 0;
+  upper = (her || sym || tri) && *(unsigned char *)uplo == 'U';
+  lower = (her || sym || tri) && *(unsigned char *)uplo == 'L';
+  unit = tri && *(unsigned char *)diag == 'U';
+
+  /*     Generate data in array A. */
+
+  i__1 = *n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = *m;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      if (gen || upper && i__ <= j || lower && i__ >= j) {
+        i__3 = i__ + j * a_dim1;
+        cbeg_(&q__2, reset);
+        q__1.r = q__2.r + transl->r, q__1.i = q__2.i + transl->i;
+        a[i__3].r = q__1.r, a[i__3].i = q__1.i;
+        if (i__ != j) {
+          /*                 Set some elements to zero */
+          if (*n > 3 && j == *n / 2) {
+            i__3 = i__ + j * a_dim1;
+            a[i__3].r = 0.f, a[i__3].i = 0.f;
+          }
+          if (her) {
+            i__3 = j + i__ * a_dim1;
+            r_cnjg(&q__1, &a[i__ + j * a_dim1]);
+            a[i__3].r = q__1.r, a[i__3].i = q__1.i;
+          } else if (sym) {
+            i__3 = j + i__ * a_dim1;
+            i__4 = i__ + j * a_dim1;
+            a[i__3].r = a[i__4].r, a[i__3].i = a[i__4].i;
+          } else if (tri) {
+            i__3 = j + i__ * a_dim1;
+            a[i__3].r = 0.f, a[i__3].i = 0.f;
+          }
+        }
+      }
+      /* L10: */
+    }
+    if (her) {
+      i__2 = j + j * a_dim1;
+      i__3 = j + j * a_dim1;
+      r__1 = a[i__3].r;
+      q__1.r = r__1, q__1.i = 0.f;
+      a[i__2].r = q__1.r, a[i__2].i = q__1.i;
+    }
+    if (tri) {
+      i__2 = j + j * a_dim1;
+      i__3 = j + j * a_dim1;
+      q__1.r = a[i__3].r + 1.f, q__1.i = a[i__3].i + 0.f;
+      a[i__2].r = q__1.r, a[i__2].i = q__1.i;
+    }
+    if (unit) {
+      i__2 = j + j * a_dim1;
+      a[i__2].r = 1.f, a[i__2].i = 0.f;
+    }
+    /* L20: */
+  }
+
+  /*     Store elements in array AS in data structure required by routine. */
+
+  if (s_cmp(type__, "ge", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      i__2 = *m;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        i__4 = i__ + j * a_dim1;
+        aa[i__3].r = a[i__4].r, aa[i__3].i = a[i__4].i;
+        /* L30: */
+      }
+      i__2 = *lda;
+      for (i__ = *m + 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        aa[i__3].r = -1e10f, aa[i__3].i = 1e10f;
+        /* L40: */
+      }
+      /* L50: */
+    }
+  } else if (s_cmp(type__, "he", (ftnlen)2, (ftnlen)2) == 0 ||
+             s_cmp(type__, "sy", (ftnlen)2, (ftnlen)2) == 0 ||
+             s_cmp(type__, "tr", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      if (upper) {
+        ibeg = 1;
+        if (unit) {
+          iend = j - 1;
+        } else {
+          iend = j;
+        }
+      } else {
+        if (unit) {
+          ibeg = j + 1;
+        } else {
+          ibeg = j;
+        }
+        iend = *n;
+      }
+      i__2 = ibeg - 1;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        aa[i__3].r = -1e10f, aa[i__3].i = 1e10f;
+        /* L60: */
+      }
+      i__2 = iend;
+      for (i__ = ibeg; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        i__4 = i__ + j * a_dim1;
+        aa[i__3].r = a[i__4].r, aa[i__3].i = a[i__4].i;
+        /* L70: */
+      }
+      i__2 = *lda;
+      for (i__ = iend + 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        aa[i__3].r = -1e10f, aa[i__3].i = 1e10f;
+        /* L80: */
+      }
+      if (her) {
+        jj = j + (j - 1) * *lda;
+        i__2 = jj;
+        i__3 = jj;
+        r__1 = aa[i__3].r;
+        q__1.r = r__1, q__1.i = -1e10f;
+        aa[i__2].r = q__1.r, aa[i__2].i = q__1.i;
+      }
+      /* L90: */
+    }
+  }
+  return 0;
+
+  /*     End of CMAKE. */
+
+} /* cmake_ */
+
+/* Subroutine */ int cmmch_(char *transa, char *transb, integer *m, integer *n,
+                            integer *kk, complex *alpha, complex *a,
+                            integer *lda, complex *b, integer *ldb,
+                            complex *beta, complex *c__, integer *ldc,
+                            complex *ct, real *g, complex *cc, integer *ldcc,
+                            real *eps, real *err, logical *fatal, integer *nout,
+                            logical *mv, ftnlen transa_len, ftnlen transb_len) {
+  /* Format strings */
+  static char fmt_9999[] =
+      "(\002 ******* FATAL ERROR - COMPUTED RESULT IS"
+      " LESS THAN HAL\002,\002F ACCURATE *******\002,/\002             "
+      "          EXPECTED RE\002,\002SULT                    COMPUTED R"
+      "ESULT\002)";
+  static char fmt_9998[] = "(1x,i7,2(\002  (\002,g15.6,\002,\002,g15.6,"
+                           "\002)\002))";
+  static char fmt_9997[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+                           " \002,i3)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, cc_dim1,
+      cc_offset, i__1, i__2, i__3, i__4, i__5, i__6, i__7;
+  real r__1, r__2, r__3, r__4, r__5, r__6;
+  complex q__1, q__2, q__3, q__4;
+
+  /* Builtin functions */
+  double r_imag(complex *);
+  void r_cnjg(complex *, complex *);
+  double sqrt(doublereal);
+  integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, j, k;
+  real erri;
+  logical trana, tranb, ctrana, ctranb;
+
+  /* Fortran I/O blocks */
+  static cilist io___409 = {0, 0, 0, fmt_9999, 0};
+  static cilist io___410 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___411 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___412 = {0, 0, 0, fmt_9997, 0};
+
+  /*  Checks the results of the computational tests. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Statement Functions .. */
+  /*     .. Statement Function definitions .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  a_dim1 = *lda;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  b_dim1 = *ldb;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  c_dim1 = *ldc;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --ct;
+  --g;
+  cc_dim1 = *ldcc;
+  cc_offset = 1 + cc_dim1;
+  cc -= cc_offset;
+
+  /* Function Body */
+  trana = *(unsigned char *)transa == 'T' || *(unsigned char *)transa == 'C';
+  tranb = *(unsigned char *)transb == 'T' || *(unsigned char *)transb == 'C';
+  ctrana = *(unsigned char *)transa == 'C';
+  ctranb = *(unsigned char *)transb == 'C';
+
+  /*     Compute expected result, one column at a time, in CT using data */
+  /*     in A, B and C. */
+  /*     Compute gauges in G. */
+
+  i__1 = *n;
+  for (j = 1; j <= i__1; ++j) {
+
+    i__2 = *m;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      i__3 = i__;
+      ct[i__3].r = 0.f, ct[i__3].i = 0.f;
+      g[i__] = 0.f;
+      /* L10: */
+    }
+    if (!trana && !tranb) {
+      i__2 = *kk;
+      for (k = 1; k <= i__2; ++k) {
+        i__3 = *m;
+        for (i__ = 1; i__ <= i__3; ++i__) {
+          i__4 = i__;
+          i__5 = i__;
+          i__6 = i__ + k * a_dim1;
+          i__7 = k + j * b_dim1;
+          q__2.r = a[i__6].r * b[i__7].r - a[i__6].i * b[i__7].i,
+          q__2.i = a[i__6].r * b[i__7].i + a[i__6].i * b[i__7].r;
+          q__1.r = ct[i__5].r + q__2.r, q__1.i = ct[i__5].i + q__2.i;
+          ct[i__4].r = q__1.r, ct[i__4].i = q__1.i;
+          i__4 = i__ + k * a_dim1;
+          i__5 = k + j * b_dim1;
+          g[i__] += ((r__1 = a[i__4].r, abs(r__1)) +
+                     (r__2 = r_imag(&a[i__ + k * a_dim1]), abs(r__2))) *
+                    ((r__3 = b[i__5].r, abs(r__3)) +
+                     (r__4 = r_imag(&b[k + j * b_dim1]), abs(r__4)));
+          /* L20: */
+        }
+        /* L30: */
+      }
+    } else if (trana && !tranb) {
+      if (ctrana) {
+        i__2 = *kk;
+        for (k = 1; k <= i__2; ++k) {
+          i__3 = *m;
+          for (i__ = 1; i__ <= i__3; ++i__) {
+            i__4 = i__;
+            i__5 = i__;
+            r_cnjg(&q__3, &a[k + i__ * a_dim1]);
+            i__6 = k + j * b_dim1;
+            q__2.r = q__3.r * b[i__6].r - q__3.i * b[i__6].i,
+            q__2.i = q__3.r * b[i__6].i + q__3.i * b[i__6].r;
+            q__1.r = ct[i__5].r + q__2.r, q__1.i = ct[i__5].i + q__2.i;
+            ct[i__4].r = q__1.r, ct[i__4].i = q__1.i;
+            i__4 = k + i__ * a_dim1;
+            i__5 = k + j * b_dim1;
+            g[i__] += ((r__1 = a[i__4].r, abs(r__1)) +
+                       (r__2 = r_imag(&a[k + i__ * a_dim1]), abs(r__2))) *
+                      ((r__3 = b[i__5].r, abs(r__3)) +
+                       (r__4 = r_imag(&b[k + j * b_dim1]), abs(r__4)));
+            /* L40: */
+          }
+          /* L50: */
+        }
+      } else {
+        i__2 = *kk;
+        for (k = 1; k <= i__2; ++k) {
+          i__3 = *m;
+          for (i__ = 1; i__ <= i__3; ++i__) {
+            i__4 = i__;
+            i__5 = i__;
+            i__6 = k + i__ * a_dim1;
+            i__7 = k + j * b_dim1;
+            q__2.r = a[i__6].r * b[i__7].r - a[i__6].i * b[i__7].i,
+            q__2.i = a[i__6].r * b[i__7].i + a[i__6].i * b[i__7].r;
+            q__1.r = ct[i__5].r + q__2.r, q__1.i = ct[i__5].i + q__2.i;
+            ct[i__4].r = q__1.r, ct[i__4].i = q__1.i;
+            i__4 = k + i__ * a_dim1;
+            i__5 = k + j * b_dim1;
+            g[i__] += ((r__1 = a[i__4].r, abs(r__1)) +
+                       (r__2 = r_imag(&a[k + i__ * a_dim1]), abs(r__2))) *
+                      ((r__3 = b[i__5].r, abs(r__3)) +
+                       (r__4 = r_imag(&b[k + j * b_dim1]), abs(r__4)));
+            /* L60: */
+          }
+          /* L70: */
+        }
+      }
+    } else if (!trana && tranb) {
+      if (ctranb) {
+        i__2 = *kk;
+        for (k = 1; k <= i__2; ++k) {
+          i__3 = *m;
+          for (i__ = 1; i__ <= i__3; ++i__) {
+            i__4 = i__;
+            i__5 = i__;
+            i__6 = i__ + k * a_dim1;
+            r_cnjg(&q__3, &b[j + k * b_dim1]);
+            q__2.r = a[i__6].r * q__3.r - a[i__6].i * q__3.i,
+            q__2.i = a[i__6].r * q__3.i + a[i__6].i * q__3.r;
+            q__1.r = ct[i__5].r + q__2.r, q__1.i = ct[i__5].i + q__2.i;
+            ct[i__4].r = q__1.r, ct[i__4].i = q__1.i;
+            i__4 = i__ + k * a_dim1;
+            i__5 = j + k * b_dim1;
+            g[i__] += ((r__1 = a[i__4].r, abs(r__1)) +
+                       (r__2 = r_imag(&a[i__ + k * a_dim1]), abs(r__2))) *
+                      ((r__3 = b[i__5].r, abs(r__3)) +
+                       (r__4 = r_imag(&b[j + k * b_dim1]), abs(r__4)));
+            /* L80: */
+          }
+          /* L90: */
+        }
+      } else {
+        i__2 = *kk;
+        for (k = 1; k <= i__2; ++k) {
+          i__3 = *m;
+          for (i__ = 1; i__ <= i__3; ++i__) {
+            i__4 = i__;
+            i__5 = i__;
+            i__6 = i__ + k * a_dim1;
+            i__7 = j + k * b_dim1;
+            q__2.r = a[i__6].r * b[i__7].r - a[i__6].i * b[i__7].i,
+            q__2.i = a[i__6].r * b[i__7].i + a[i__6].i * b[i__7].r;
+            q__1.r = ct[i__5].r + q__2.r, q__1.i = ct[i__5].i + q__2.i;
+            ct[i__4].r = q__1.r, ct[i__4].i = q__1.i;
+            i__4 = i__ + k * a_dim1;
+            i__5 = j + k * b_dim1;
+            g[i__] += ((r__1 = a[i__4].r, abs(r__1)) +
+                       (r__2 = r_imag(&a[i__ + k * a_dim1]), abs(r__2))) *
+                      ((r__3 = b[i__5].r, abs(r__3)) +
+                       (r__4 = r_imag(&b[j + k * b_dim1]), abs(r__4)));
+            /* L100: */
+          }
+          /* L110: */
+        }
+      }
+    } else if (trana && tranb) {
+      if (ctrana) {
+        if (ctranb) {
+          i__2 = *kk;
+          for (k = 1; k <= i__2; ++k) {
+            i__3 = *m;
+            for (i__ = 1; i__ <= i__3; ++i__) {
+              i__4 = i__;
+              i__5 = i__;
+              r_cnjg(&q__3, &a[k + i__ * a_dim1]);
+              r_cnjg(&q__4, &b[j + k * b_dim1]);
+              q__2.r = q__3.r * q__4.r - q__3.i * q__4.i,
+              q__2.i = q__3.r * q__4.i + q__3.i * q__4.r;
+              q__1.r = ct[i__5].r + q__2.r, q__1.i = ct[i__5].i + q__2.i;
+              ct[i__4].r = q__1.r, ct[i__4].i = q__1.i;
+              i__4 = k + i__ * a_dim1;
+              i__5 = j + k * b_dim1;
+              g[i__] += ((r__1 = a[i__4].r, abs(r__1)) +
+                         (r__2 = r_imag(&a[k + i__ * a_dim1]), abs(r__2))) *
+                        ((r__3 = b[i__5].r, abs(r__3)) +
+                         (r__4 = r_imag(&b[j + k * b_dim1]), abs(r__4)));
+              /* L120: */
+            }
+            /* L130: */
+          }
+        } else {
+          i__2 = *kk;
+          for (k = 1; k <= i__2; ++k) {
+            i__3 = *m;
+            for (i__ = 1; i__ <= i__3; ++i__) {
+              i__4 = i__;
+              i__5 = i__;
+              r_cnjg(&q__3, &a[k + i__ * a_dim1]);
+              i__6 = j + k * b_dim1;
+              q__2.r = q__3.r * b[i__6].r - q__3.i * b[i__6].i,
+              q__2.i = q__3.r * b[i__6].i + q__3.i * b[i__6].r;
+              q__1.r = ct[i__5].r + q__2.r, q__1.i = ct[i__5].i + q__2.i;
+              ct[i__4].r = q__1.r, ct[i__4].i = q__1.i;
+              i__4 = k + i__ * a_dim1;
+              i__5 = j + k * b_dim1;
+              g[i__] += ((r__1 = a[i__4].r, abs(r__1)) +
+                         (r__2 = r_imag(&a[k + i__ * a_dim1]), abs(r__2))) *
+                        ((r__3 = b[i__5].r, abs(r__3)) +
+                         (r__4 = r_imag(&b[j + k * b_dim1]), abs(r__4)));
+              /* L140: */
+            }
+            /* L150: */
+          }
+        }
+      } else {
+        if (ctranb) {
+          i__2 = *kk;
+          for (k = 1; k <= i__2; ++k) {
+            i__3 = *m;
+            for (i__ = 1; i__ <= i__3; ++i__) {
+              i__4 = i__;
+              i__5 = i__;
+              i__6 = k + i__ * a_dim1;
+              r_cnjg(&q__3, &b[j + k * b_dim1]);
+              q__2.r = a[i__6].r * q__3.r - a[i__6].i * q__3.i,
+              q__2.i = a[i__6].r * q__3.i + a[i__6].i * q__3.r;
+              q__1.r = ct[i__5].r + q__2.r, q__1.i = ct[i__5].i + q__2.i;
+              ct[i__4].r = q__1.r, ct[i__4].i = q__1.i;
+              i__4 = k + i__ * a_dim1;
+              i__5 = j + k * b_dim1;
+              g[i__] += ((r__1 = a[i__4].r, abs(r__1)) +
+                         (r__2 = r_imag(&a[k + i__ * a_dim1]), abs(r__2))) *
+                        ((r__3 = b[i__5].r, abs(r__3)) +
+                         (r__4 = r_imag(&b[j + k * b_dim1]), abs(r__4)));
+              /* L160: */
+            }
+            /* L170: */
+          }
+        } else {
+          i__2 = *kk;
+          for (k = 1; k <= i__2; ++k) {
+            i__3 = *m;
+            for (i__ = 1; i__ <= i__3; ++i__) {
+              i__4 = i__;
+              i__5 = i__;
+              i__6 = k + i__ * a_dim1;
+              i__7 = j + k * b_dim1;
+              q__2.r = a[i__6].r * b[i__7].r - a[i__6].i * b[i__7].i,
+              q__2.i = a[i__6].r * b[i__7].i + a[i__6].i * b[i__7].r;
+              q__1.r = ct[i__5].r + q__2.r, q__1.i = ct[i__5].i + q__2.i;
+              ct[i__4].r = q__1.r, ct[i__4].i = q__1.i;
+              i__4 = k + i__ * a_dim1;
+              i__5 = j + k * b_dim1;
+              g[i__] += ((r__1 = a[i__4].r, abs(r__1)) +
+                         (r__2 = r_imag(&a[k + i__ * a_dim1]), abs(r__2))) *
+                        ((r__3 = b[i__5].r, abs(r__3)) +
+                         (r__4 = r_imag(&b[j + k * b_dim1]), abs(r__4)));
+              /* L180: */
+            }
+            /* L190: */
+          }
+        }
+      }
+    }
+    i__2 = *m;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      i__3 = i__;
+      i__4 = i__;
+      q__2.r = alpha->r * ct[i__4].r - alpha->i * ct[i__4].i,
+      q__2.i = alpha->r * ct[i__4].i + alpha->i * ct[i__4].r;
+      i__5 = i__ + j * c_dim1;
+      q__3.r = beta->r * c__[i__5].r - beta->i * c__[i__5].i,
+      q__3.i = beta->r * c__[i__5].i + beta->i * c__[i__5].r;
+      q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;
+      ct[i__3].r = q__1.r, ct[i__3].i = q__1.i;
+      i__3 = i__ + j * c_dim1;
+      g[i__] =
+          ((r__1 = alpha->r, abs(r__1)) + (r__2 = r_imag(alpha), abs(r__2))) *
+              g[i__] +
+          ((r__3 = beta->r, abs(r__3)) + (r__4 = r_imag(beta), abs(r__4))) *
+              ((r__5 = c__[i__3].r, abs(r__5)) +
+               (r__6 = r_imag(&c__[i__ + j * c_dim1]), abs(r__6)));
+      /* L200: */
+    }
+
+    /*        Compute the error ratio for this result. */
+
+    *err = 0.f;
+    i__2 = *m;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      i__3 = i__;
+      i__4 = i__ + j * cc_dim1;
+      q__2.r = ct[i__3].r - cc[i__4].r, q__2.i = ct[i__3].i - cc[i__4].i;
+      q__1.r = q__2.r, q__1.i = q__2.i;
+      erri = ((r__1 = q__1.r, abs(r__1)) + (r__2 = r_imag(&q__1), abs(r__2))) /
+             *eps;
+      if (g[i__] != 0.f) {
+        erri /= g[i__];
+      }
+      *err = max(*err, erri);
+      if (*err * sqrt(*eps) >= 1.f) {
+        goto L230;
+      }
+      /* L210: */
+    }
+
+    /* L220: */
+  }
+
+  /*     If the loop completes, all results are at least half accurate. */
+  goto L250;
+
+  /*     Report fatal error. */
+
+L230:
+  *fatal = TRUE_;
+  io___409.ciunit = *nout;
+  s_wsfe(&io___409);
+  e_wsfe();
+  i__1 = *m;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    if (*mv) {
+      io___410.ciunit = *nout;
+      s_wsfe(&io___410);
+      do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+      do_fio(&c__2, (char *)&ct[i__], (ftnlen)sizeof(real));
+      do_fio(&c__2, (char *)&cc[i__ + j * cc_dim1], (ftnlen)sizeof(real));
+      e_wsfe();
+    } else {
+      io___411.ciunit = *nout;
+      s_wsfe(&io___411);
+      do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+      do_fio(&c__2, (char *)&cc[i__ + j * cc_dim1], (ftnlen)sizeof(real));
+      do_fio(&c__2, (char *)&ct[i__], (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+    /* L240: */
+  }
+  if (*n > 1) {
+    io___412.ciunit = *nout;
+    s_wsfe(&io___412);
+    do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L250:
+  return 0;
+
+  /*     End of CMMCH. */
+
+} /* cmmch_ */
+
+logical lce_(complex *ri, complex *rj, integer *lr) {
+  /* System generated locals */
+  integer i__1, i__2, i__3;
+  logical ret_val;
+
+  /* Local variables */
+  integer i__;
+
+  /*  Tests if two arrays are identical. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  --rj;
+  --ri;
+
+  /* Function Body */
+  i__1 = *lr;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    i__2 = i__;
+    i__3 = i__;
+    if (ri[i__2].r != rj[i__3].r || ri[i__2].i != rj[i__3].i) {
+      goto L20;
+    }
+    /* L10: */
+  }
+  ret_val = TRUE_;
+  goto L30;
+L20:
+  ret_val = FALSE_;
+L30:
+  return ret_val;
+
+  /*     End of LCE. */
+
+} /* lce_ */
+
+logical lceres_(char *type__, char *uplo, integer *m, integer *n, complex *aa,
+                complex *as, integer *lda, ftnlen type_len, ftnlen uplo_len) {
+  /* System generated locals */
+  integer aa_dim1, aa_offset, as_dim1, as_offset, i__1, i__2, i__3, i__4;
+  logical ret_val;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen);
+
+  /* Local variables */
+  integer i__, j, ibeg, iend;
+  logical upper;
+
+  /*  Tests if selected elements in two arrays are equal. */
+
+  /*  TYPE is 'ge' or 'he' or 'sy'. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  as_dim1 = *lda;
+  as_offset = 1 + as_dim1;
+  as -= as_offset;
+  aa_dim1 = *lda;
+  aa_offset = 1 + aa_dim1;
+  aa -= aa_offset;
+
+  /* Function Body */
+  upper = *(unsigned char *)uplo == 'U';
+  if (s_cmp(type__, "ge", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      i__2 = *lda;
+      for (i__ = *m + 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + j * aa_dim1;
+        i__4 = i__ + j * as_dim1;
+        if (aa[i__3].r != as[i__4].r || aa[i__3].i != as[i__4].i) {
+          goto L70;
+        }
+        /* L10: */
+      }
+      /* L20: */
+    }
+  } else if (s_cmp(type__, "he", (ftnlen)2, (ftnlen)2) == 0 ||
+             s_cmp(type__, "sy", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      if (upper) {
+        ibeg = 1;
+        iend = j;
+      } else {
+        ibeg = j;
+        iend = *n;
+      }
+      i__2 = ibeg - 1;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + j * aa_dim1;
+        i__4 = i__ + j * as_dim1;
+        if (aa[i__3].r != as[i__4].r || aa[i__3].i != as[i__4].i) {
+          goto L70;
+        }
+        /* L30: */
+      }
+      i__2 = *lda;
+      for (i__ = iend + 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + j * aa_dim1;
+        i__4 = i__ + j * as_dim1;
+        if (aa[i__3].r != as[i__4].r || aa[i__3].i != as[i__4].i) {
+          goto L70;
+        }
+        /* L40: */
+      }
+      /* L50: */
+    }
+  }
+
+  /* L60: */
+  ret_val = TRUE_;
+  goto L80;
+L70:
+  ret_val = FALSE_;
+L80:
+  return ret_val;
+
+  /*     End of LCERES. */
+
+} /* lceres_ */
+
+/* Complex */ VOID cbeg_(complex *ret_val, logical *reset) {
+  /* System generated locals */
+  real r__1, r__2;
+  complex q__1;
+
+  /* Local variables */
+  static integer i__, j, ic, mi, mj;
+
+  /*  Generates complex numbers as pairs of random numbers uniformly */
+  /*  distributed between -0.5 and 0.5. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Save statement .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Executable Statements .. */
+  if (*reset) {
+    /*        Initialize local variables. */
+    mi = 891;
+    mj = 457;
+    i__ = 7;
+    j = 7;
+    ic = 0;
+    *reset = FALSE_;
+  }
+
+  /*     The sequence of values of I or J is bounded between 1 and 999. */
+  /*     If initial I or J = 1,2,3,6,7 or 9, the period will be 50. */
+  /*     If initial I or J = 4 or 8, the period will be 25. */
+  /*     If initial I or J = 5, the period will be 10. */
+  /*     IC is used to break up the period by skipping 1 value of I or J */
+  /*     in 6. */
+
+  ++ic;
+L10:
+  i__ *= mi;
+  j *= mj;
+  i__ -= i__ / 1000 * 1000;
+  j -= j / 1000 * 1000;
+  if (ic >= 5) {
+    ic = 0;
+    goto L10;
+  }
+  r__1 = (i__ - 500) / 1001.f;
+  r__2 = (j - 500) / 1001.f;
+  q__1.r = r__1, q__1.i = r__2;
+  ret_val->r = q__1.r, ret_val->i = q__1.i;
+  return;
+
+  /*     End of CBEG. */
+
+} /* cbeg_ */
+
+real sdiff_(real *x, real *y) {
+  /* System generated locals */
+  real ret_val;
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Executable Statements .. */
+  ret_val = *x - *y;
+  return ret_val;
+
+  /*     End of SDIFF. */
+
+} /* sdiff_ */
+
+/* Main program alias */ int cblat3_() {
+  MAIN__();
+  return 0;
+}
diff --git a/CBLAS/testing/c_dblat1.c b/CBLAS/testing/c_dblat1.c
new file mode 100644
index 0000000..f0d080a
--- /dev/null
+++ b/CBLAS/testing/c_dblat1.c
@@ -0,0 +1,882 @@
+/* testing/c_dblat1.f -- translated by f2c (version 20191129).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+#include "f2c.h"
+
+/* Common Block Declarations */
+
+struct {
+    integer icase, n, incx, incy, mode;
+    logical pass;
+} combla_;
+
+#define combla_1 combla_
+
+/* Table of constant values */
+
+static integer c__1 = 1;
+static integer c__9 = 9;
+static doublereal c_b34 = 1.;
+static integer c__5 = 5;
+
+/* Main program */ int MAIN__(void)
+{
+    /* Initialized data */
+
+    static doublereal sfac = 9.765625e-4;
+
+    /* Format strings */
+    static char fmt_99999[] = "(\002 Real CBLAS Test Program Results\002,/1x)"
+	    ;
+    static char fmt_99998[] = "(\002                                    ----"
+	    "- PASS -----\002)";
+
+    /* Builtin functions */
+    integer s_wsfe(cilist *), e_wsfe(void);
+    /* Subroutine */ int s_stop(char *, ftnlen);
+
+    /* Local variables */
+    integer ic;
+    extern /* Subroutine */ int check0_(doublereal *), check1_(doublereal *), 
+	    check2_(doublereal *), check3_(doublereal *), header_(void);
+
+    /* Fortran I/O blocks */
+    static cilist io___2 = { 0, 6, 0, fmt_99999, 0 };
+    static cilist io___4 = { 0, 6, 0, fmt_99998, 0 };
+
+
+/*     Test program for the DOUBLE PRECISION Level 1 CBLAS. */
+/*     Based upon the original CBLAS test routine together with: */
+/*     F06EAF Example Program Text */
+/*     .. Parameters .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. External Subroutines .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+    s_wsfe(&io___2);
+    e_wsfe();
+    for (ic = 1; ic <= 10; ++ic) {
+	combla_1.icase = ic;
+	header_();
+
+/*        .. Initialize  PASS,  INCX,  INCY, and MODE for a new case. .. */
+/*        .. the value 9999 for INCX, INCY or MODE will appear in the .. */
+/*        .. detailed  output, if any, for cases  that do not involve .. */
+/*        .. these parameters .. */
+
+	combla_1.pass = TRUE_;
+	combla_1.incx = 9999;
+	combla_1.incy = 9999;
+	combla_1.mode = 9999;
+	if (combla_1.icase == 3) {
+	    check0_(&sfac);
+	} else if (combla_1.icase == 7 || combla_1.icase == 8 || 
+		combla_1.icase == 9 || combla_1.icase == 10) {
+	    check1_(&sfac);
+	} else if (combla_1.icase == 1 || combla_1.icase == 2 || 
+		combla_1.icase == 5 || combla_1.icase == 6) {
+	    check2_(&sfac);
+	} else if (combla_1.icase == 4) {
+	    check3_(&sfac);
+	}
+/*        -- Print */
+	if (combla_1.pass) {
+	    s_wsfe(&io___4);
+	    e_wsfe();
+	}
+/* L20: */
+    }
+    s_stop("", (ftnlen)0);
+
+    return 0;
+} /* MAIN__ */
+
+/* Subroutine */ int header_(void)
+{
+    /* Initialized data */
+
+    static char l[15*10] = "CBLAS_DDOT     " "CBLAS_DAXPY    " "CBLAS_DROTG "
+	    "   " "CBLAS_DROT     " "CBLAS_DCOPY    " "CBLAS_DSWAP    " "CBLA"
+	    "S_DNRM2    " "CBLAS_DASUM    " "CBLAS_DSCAL    " "CBLAS_IDAMAX   "
+	    ;
+
+    /* Format strings */
+    static char fmt_99999[] = "(/\002 Test of subprogram number\002,i3,9x,a1"
+	    "5)";
+
+    /* Builtin functions */
+    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+    /* Fortran I/O blocks */
+    static cilist io___6 = { 0, 6, 0, fmt_99999, 0 };
+
+
+/*     .. Parameters .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Arrays .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+    s_wsfe(&io___6);
+    do_fio(&c__1, (char *)&combla_1.icase, (ftnlen)sizeof(integer));
+    do_fio(&c__1, l + (0 + (0 + (combla_1.icase - 1) * 15)), (ftnlen)15);
+    e_wsfe();
+    return 0;
+
+} /* header_ */
+
+/* Subroutine */ int check0_(doublereal *sfac)
+{
+    /* Initialized data */
+
+    static doublereal ds1[8] = { .8,.6,.8,-.6,.8,0.,1.,0. };
+    static doublereal datrue[8] = { .5,.5,.5,-.5,-.5,0.,1.,1. };
+    static doublereal dbtrue[8] = { 0.,.6,0.,-.6,0.,0.,1.,0. };
+    static doublereal da1[8] = { .3,.4,-.3,-.4,-.3,0.,0.,1. };
+    static doublereal db1[8] = { .4,.3,.4,.3,-.4,0.,1.,0. };
+    static doublereal dc1[8] = { .6,.8,-.6,.8,.6,1.,0.,1. };
+
+    /* Builtin functions */
+    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
+	    e_wsle(void);
+    /* Subroutine */ int s_stop(char *, ftnlen);
+
+    /* Local variables */
+    integer k;
+    extern /* Subroutine */ void drotgtest_(doublereal *, doublereal *, 
+	    doublereal *, doublereal *);
+    doublereal sa, sb, sc, ss;
+    extern /* Subroutine */ int stest1_(doublereal *, doublereal *, 
+	    doublereal *, doublereal *);
+
+    /* Fortran I/O blocks */
+    static cilist io___18 = { 0, 6, 0, 0, 0 };
+
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Subroutines .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+
+/*     Compute true values which cannot be prestored */
+/*     in decimal notation */
+
+    dbtrue[0] = 1.6666666666666667;
+    dbtrue[2] = -1.6666666666666667;
+    dbtrue[4] = 1.6666666666666667;
+
+    for (k = 1; k <= 8; ++k) {
+/*        .. Set N=K for identification in output if any .. */
+	combla_1.n = k;
+	if (combla_1.icase == 3) {
+/*           .. DROTGTEST .. */
+	    if (k > 8) {
+		goto L40;
+	    }
+	    sa = da1[k - 1];
+	    sb = db1[k - 1];
+	    drotgtest_(&sa, &sb, &sc, &ss);
+	    stest1_(&sa, &datrue[k - 1], &datrue[k - 1], sfac);
+	    stest1_(&sb, &dbtrue[k - 1], &dbtrue[k - 1], sfac);
+	    stest1_(&sc, &dc1[k - 1], &dc1[k - 1], sfac);
+	    stest1_(&ss, &ds1[k - 1], &ds1[k - 1], sfac);
+	} else {
+	    s_wsle(&io___18);
+	    do_lio(&c__9, &c__1, " Shouldn't be here in CHECK0", (ftnlen)28);
+	    e_wsle();
+	    s_stop("", (ftnlen)0);
+	}
+/* L20: */
+    }
+L40:
+    return 0;
+} /* check0_ */
+
+/* Subroutine */ int check1_(doublereal *sfac)
+{
+    /* Initialized data */
+
+    static doublereal sa[10] = { .3,-1.,0.,1.,.3,.3,.3,.3,.3,.3 };
+    static doublereal dv[80]	/* was [8][5][2] */ = { .1,2.,2.,2.,2.,2.,2.,
+	    2.,.3,3.,3.,3.,3.,3.,3.,3.,.3,-.4,4.,4.,4.,4.,4.,4.,.2,-.6,.3,5.,
+	    5.,5.,5.,5.,.1,-.3,.5,-.1,6.,6.,6.,6.,.1,8.,8.,8.,8.,8.,8.,8.,.3,
+	    9.,9.,9.,9.,9.,9.,9.,.3,2.,-.4,2.,2.,2.,2.,2.,.2,3.,-.6,5.,.3,2.,
+	    2.,2.,.1,4.,-.3,6.,-.5,7.,-.1,3. };
+    static doublereal dtrue1[5] = { 0.,.3,.5,.7,.6 };
+    static doublereal dtrue3[5] = { 0.,.3,.7,1.1,1. };
+    static doublereal dtrue5[80]	/* was [8][5][2] */ = { .1,2.,2.,2.,
+	    2.,2.,2.,2.,-.3,3.,3.,3.,3.,3.,3.,3.,0.,0.,4.,4.,4.,4.,4.,4.,.2,
+	    -.6,.3,5.,5.,5.,5.,5.,.03,-.09,.15,-.03,6.,6.,6.,6.,.1,8.,8.,8.,
+	    8.,8.,8.,8.,.09,9.,9.,9.,9.,9.,9.,9.,.09,2.,-.12,2.,2.,2.,2.,2.,
+	    .06,3.,-.18,5.,.09,2.,2.,2.,.03,4.,-.09,6.,-.15,7.,-.03,3. };
+    static integer itrue2[5] = { 0,1,2,2,3 };
+
+    /* System generated locals */
+    integer i__1;
+    doublereal d__1;
+
+    /* Builtin functions */
+    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
+	    e_wsle(void);
+    /* Subroutine */ int s_stop(char *, ftnlen);
+
+    /* Local variables */
+    integer i__;
+    extern doublereal dnrm2test_(integer *, doublereal *, integer *);
+    extern /* Subroutine */ void dscaltest_(integer *, doublereal *, 
+	    doublereal *, integer *);
+    extern doublereal dasumtest_(integer *, doublereal *, integer *);
+    doublereal sx[8];
+    integer np1;
+    extern integer idamaxtest_(integer *, doublereal *, integer *);
+    integer len;
+    doublereal stemp[1], strue[8];
+    extern /* Subroutine */ int stest_(integer *, doublereal *, doublereal *, 
+	    doublereal *, doublereal *), itest1_(integer *, integer *), 
+	    stest1_(doublereal *, doublereal *, doublereal *, doublereal *);
+
+    /* Fortran I/O blocks */
+    static cilist io___31 = { 0, 6, 0, 0, 0 };
+
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+    for (combla_1.incx = 1; combla_1.incx <= 2; ++combla_1.incx) {
+	for (np1 = 1; np1 <= 5; ++np1) {
+	    combla_1.n = np1 - 1;
+	    len = max(combla_1.n,1) << 1;
+/*           .. Set vector arguments .. */
+	    i__1 = len;
+	    for (i__ = 1; i__ <= i__1; ++i__) {
+		sx[i__ - 1] = dv[i__ + (np1 + combla_1.incx * 5 << 3) - 49];
+/* L20: */
+	    }
+
+	    if (combla_1.icase == 7) {
+/*              .. DNRM2TEST .. */
+		stemp[0] = dtrue1[np1 - 1];
+		d__1 = dnrm2test_(&combla_1.n, sx, &combla_1.incx);
+		stest1_(&d__1, stemp, stemp, sfac);
+	    } else if (combla_1.icase == 8) {
+/*              .. DASUMTEST .. */
+		stemp[0] = dtrue3[np1 - 1];
+		d__1 = dasumtest_(&combla_1.n, sx, &combla_1.incx);
+		stest1_(&d__1, stemp, stemp, sfac);
+	    } else if (combla_1.icase == 9) {
+/*              .. DSCALTEST .. */
+		dscaltest_(&combla_1.n, &sa[(combla_1.incx - 1) * 5 + np1 - 1]
+			, sx, &combla_1.incx);
+		i__1 = len;
+		for (i__ = 1; i__ <= i__1; ++i__) {
+		    strue[i__ - 1] = dtrue5[i__ + (np1 + combla_1.incx * 5 << 
+			    3) - 49];
+/* L40: */
+		}
+		stest_(&len, sx, strue, strue, sfac);
+	    } else if (combla_1.icase == 10) {
+/*              .. IDAMAXTEST .. */
+		i__1 = idamaxtest_(&combla_1.n, sx, &combla_1.incx);
+		itest1_(&i__1, &itrue2[np1 - 1]);
+	    } else {
+		s_wsle(&io___31);
+		do_lio(&c__9, &c__1, " Shouldn't be here in CHECK1", (ftnlen)
+			28);
+		e_wsle();
+		s_stop("", (ftnlen)0);
+	    }
+/* L60: */
+	}
+/* L80: */
+    }
+    return 0;
+} /* check1_ */
+
+/* Subroutine */ int check2_(doublereal *sfac)
+{
+    /* Initialized data */
+
+    static doublereal sa = .3;
+    static integer incxs[4] = { 1,2,-2,-1 };
+    static integer incys[4] = { 1,-2,1,-2 };
+    static integer lens[8]	/* was [4][2] */ = { 1,1,2,4,1,1,3,7 };
+    static integer ns[4] = { 0,1,2,4 };
+    static doublereal dx1[7] = { .6,.1,-.5,.8,.9,-.3,-.4 };
+    static doublereal dy1[7] = { .5,-.9,.3,.7,-.6,.2,.8 };
+    static doublereal dt7[16]	/* was [4][4] */ = { 0.,.3,.21,.62,0.,.3,-.07,
+	    .85,0.,.3,-.79,-.74,0.,.3,.33,1.27 };
+    static doublereal dt8[112]	/* was [7][4][4] */ = { .5,0.,0.,0.,0.,0.,0.,
+	    .68,0.,0.,0.,0.,0.,0.,.68,-.87,0.,0.,0.,0.,0.,.68,-.87,.15,.94,0.,
+	    0.,0.,.5,0.,0.,0.,0.,0.,0.,.68,0.,0.,0.,0.,0.,0.,.35,-.9,.48,0.,
+	    0.,0.,0.,.38,-.9,.57,.7,-.75,.2,.98,.5,0.,0.,0.,0.,0.,0.,.68,0.,
+	    0.,0.,0.,0.,0.,.35,-.72,0.,0.,0.,0.,0.,.38,-.63,.15,.88,0.,0.,0.,
+	    .5,0.,0.,0.,0.,0.,0.,.68,0.,0.,0.,0.,0.,0.,.68,-.9,.33,0.,0.,0.,
+	    0.,.68,-.9,.33,.7,-.75,.2,1.04 };
+    static doublereal dt10x[112]	/* was [7][4][4] */ = { .6,0.,0.,0.,
+	    0.,0.,0.,.5,0.,0.,0.,0.,0.,0.,.5,-.9,0.,0.,0.,0.,0.,.5,-.9,.3,.7,
+	    0.,0.,0.,.6,0.,0.,0.,0.,0.,0.,.5,0.,0.,0.,0.,0.,0.,.3,.1,.5,0.,0.,
+	    0.,0.,.8,.1,-.6,.8,.3,-.3,.5,.6,0.,0.,0.,0.,0.,0.,.5,0.,0.,0.,0.,
+	    0.,0.,-.9,.1,.5,0.,0.,0.,0.,.7,.1,.3,.8,-.9,-.3,.5,.6,0.,0.,0.,0.,
+	    0.,0.,.5,0.,0.,0.,0.,0.,0.,.5,.3,0.,0.,0.,0.,0.,.5,.3,-.6,.8,0.,
+	    0.,0. };
+    static doublereal dt10y[112]	/* was [7][4][4] */ = { .5,0.,0.,0.,
+	    0.,0.,0.,.6,0.,0.,0.,0.,0.,0.,.6,.1,0.,0.,0.,0.,0.,.6,.1,-.5,.8,
+	    0.,0.,0.,.5,0.,0.,0.,0.,0.,0.,.6,0.,0.,0.,0.,0.,0.,-.5,-.9,.6,0.,
+	    0.,0.,0.,-.4,-.9,.9,.7,-.5,.2,.6,.5,0.,0.,0.,0.,0.,0.,.6,0.,0.,0.,
+	    0.,0.,0.,-.5,.6,0.,0.,0.,0.,0.,-.4,.9,-.5,.6,0.,0.,0.,.5,0.,0.,0.,
+	    0.,0.,0.,.6,0.,0.,0.,0.,0.,0.,.6,-.9,.1,0.,0.,0.,0.,.6,-.9,.1,.7,
+	    -.5,.2,.8 };
+    static doublereal ssize1[4] = { 0.,.3,1.6,3.2 };
+    static doublereal ssize2[28]	/* was [14][2] */ = { 0.,0.,0.,0.,0.,
+	    0.,0.,0.,0.,0.,0.,0.,0.,0.,1.17,1.17,1.17,1.17,1.17,1.17,1.17,
+	    1.17,1.17,1.17,1.17,1.17,1.17,1.17 };
+
+    /* System generated locals */
+    integer i__1;
+    doublereal d__1;
+
+    /* Builtin functions */
+    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
+	    e_wsle(void);
+    /* Subroutine */ int s_stop(char *, ftnlen);
+
+    /* Local variables */
+    extern doublereal ddottest_(integer *, doublereal *, integer *, 
+	    doublereal *, integer *);
+    integer i__, j;
+    extern /* Subroutine */ void dcopytest_(integer *, doublereal *, integer *,
+	     doublereal *, integer *), dswaptest_(integer *, doublereal *, 
+	    integer *, doublereal *, integer *), daxpytest_(integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, integer *);
+    integer ki, kn, mx, my;
+    doublereal sx[7], sy[7], stx[7], sty[7];
+    integer lenx, leny, ksize;
+    extern /* Subroutine */ int stest_(integer *, doublereal *, doublereal *, 
+	    doublereal *, doublereal *), stest1_(doublereal *, doublereal *, 
+	    doublereal *, doublereal *);
+
+    /* Fortran I/O blocks */
+    static cilist io___58 = { 0, 6, 0, 0, 0 };
+
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+
+    for (ki = 1; ki <= 4; ++ki) {
+	combla_1.incx = incxs[ki - 1];
+	combla_1.incy = incys[ki - 1];
+	mx = abs(combla_1.incx);
+	my = abs(combla_1.incy);
+
+	for (kn = 1; kn <= 4; ++kn) {
+	    combla_1.n = ns[kn - 1];
+	    ksize = min(2,kn);
+	    lenx = lens[kn + (mx << 2) - 5];
+	    leny = lens[kn + (my << 2) - 5];
+/*           .. Initialize all argument arrays .. */
+	    for (i__ = 1; i__ <= 7; ++i__) {
+		sx[i__ - 1] = dx1[i__ - 1];
+		sy[i__ - 1] = dy1[i__ - 1];
+/* L20: */
+	    }
+
+	    if (combla_1.icase == 1) {
+/*              .. DDOTTEST .. */
+		d__1 = ddottest_(&combla_1.n, sx, &combla_1.incx, sy, &
+			combla_1.incy);
+		stest1_(&d__1, &dt7[kn + (ki << 2) - 5], &ssize1[kn - 1], 
+			sfac);
+	    } else if (combla_1.icase == 2) {
+/*              .. DAXPYTEST .. */
+		daxpytest_(&combla_1.n, &sa, sx, &combla_1.incx, sy, &
+			combla_1.incy);
+		i__1 = leny;
+		for (j = 1; j <= i__1; ++j) {
+		    sty[j - 1] = dt8[j + (kn + (ki << 2)) * 7 - 36];
+/* L40: */
+		}
+		stest_(&leny, sy, sty, &ssize2[ksize * 14 - 14], sfac);
+	    } else if (combla_1.icase == 5) {
+/*              .. DCOPYTEST .. */
+		for (i__ = 1; i__ <= 7; ++i__) {
+		    sty[i__ - 1] = dt10y[i__ + (kn + (ki << 2)) * 7 - 36];
+/* L60: */
+		}
+		dcopytest_(&combla_1.n, sx, &combla_1.incx, sy, &
+			combla_1.incy);
+		stest_(&leny, sy, sty, ssize2, &c_b34);
+	    } else if (combla_1.icase == 6) {
+/*              .. DSWAPTEST .. */
+		dswaptest_(&combla_1.n, sx, &combla_1.incx, sy, &
+			combla_1.incy);
+		for (i__ = 1; i__ <= 7; ++i__) {
+		    stx[i__ - 1] = dt10x[i__ + (kn + (ki << 2)) * 7 - 36];
+		    sty[i__ - 1] = dt10y[i__ + (kn + (ki << 2)) * 7 - 36];
+/* L80: */
+		}
+		stest_(&lenx, sx, stx, ssize2, &c_b34);
+		stest_(&leny, sy, sty, ssize2, &c_b34);
+	    } else {
+		s_wsle(&io___58);
+		do_lio(&c__9, &c__1, " Shouldn't be here in CHECK2", (ftnlen)
+			28);
+		e_wsle();
+		s_stop("", (ftnlen)0);
+	    }
+/* L100: */
+	}
+/* L120: */
+    }
+    return 0;
+} /* check2_ */
+
+/* Subroutine */ int check3_(doublereal *sfac)
+{
+    /* Initialized data */
+
+    static integer incxs[4] = { 1,2,-2,-1 };
+    static integer incys[4] = { 1,-2,1,-2 };
+    static integer lens[8]	/* was [4][2] */ = { 1,1,2,4,1,1,3,7 };
+    static integer ns[4] = { 0,1,2,4 };
+    static doublereal dx1[7] = { .6,.1,-.5,.8,.9,-.3,-.4 };
+    static doublereal dy1[7] = { .5,-.9,.3,.7,-.6,.2,.8 };
+    static doublereal sc = .8;
+    static doublereal ss = .6;
+    static doublereal dt9x[112]	/* was [7][4][4] */ = { .6,0.,0.,0.,0.,0.,0.,
+	    .78,0.,0.,0.,0.,0.,0.,.78,-.46,0.,0.,0.,0.,0.,.78,-.46,-.22,1.06,
+	    0.,0.,0.,.6,0.,0.,0.,0.,0.,0.,.78,0.,0.,0.,0.,0.,0.,.66,.1,-.1,0.,
+	    0.,0.,0.,.96,.1,-.76,.8,.9,-.3,-.02,.6,0.,0.,0.,0.,0.,0.,.78,0.,
+	    0.,0.,0.,0.,0.,-.06,.1,-.1,0.,0.,0.,0.,.9,.1,-.22,.8,.18,-.3,-.02,
+	    .6,0.,0.,0.,0.,0.,0.,.78,0.,0.,0.,0.,0.,0.,.78,.26,0.,0.,0.,0.,0.,
+	    .78,.26,-.76,1.12,0.,0.,0. };
+    static doublereal dt9y[112]	/* was [7][4][4] */ = { .5,0.,0.,0.,0.,0.,0.,
+	    .04,0.,0.,0.,0.,0.,0.,.04,-.78,0.,0.,0.,0.,0.,.04,-.78,.54,.08,0.,
+	    0.,0.,.5,0.,0.,0.,0.,0.,0.,.04,0.,0.,0.,0.,0.,0.,.7,-.9,-.12,0.,
+	    0.,0.,0.,.64,-.9,-.3,.7,-.18,.2,.28,.5,0.,0.,0.,0.,0.,0.,.04,0.,
+	    0.,0.,0.,0.,0.,.7,-1.08,0.,0.,0.,0.,0.,.64,-1.26,.54,.2,0.,0.,0.,
+	    .5,0.,0.,0.,0.,0.,0.,.04,0.,0.,0.,0.,0.,0.,.04,-.9,.18,0.,0.,0.,
+	    0.,.04,-.9,.18,.7,-.18,.2,.16 };
+    static doublereal ssize2[28]	/* was [14][2] */ = { 0.,0.,0.,0.,0.,
+	    0.,0.,0.,0.,0.,0.,0.,0.,0.,1.17,1.17,1.17,1.17,1.17,1.17,1.17,
+	    1.17,1.17,1.17,1.17,1.17,1.17,1.17 };
+
+    /* Builtin functions */
+    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
+	    e_wsle(void);
+    /* Subroutine */ int s_stop(char *, ftnlen);
+
+    /* Local variables */
+    extern /* Subroutine */ void drottest_(integer *, doublereal *, integer *, 
+	    doublereal *, integer *, doublereal *, doublereal *);
+    integer i__, k, ki, kn, mx, my;
+    doublereal sx[7], sy[7], stx[7], sty[7];
+    integer lenx, leny;
+    doublereal mwpc[11];
+    integer mwpn[11];
+    doublereal mwps[11], mwpx[5], mwpy[5];
+    integer ksize;
+    doublereal copyx[5], copyy[5];
+    extern /* Subroutine */ int stest_(integer *, doublereal *, doublereal *, 
+	    doublereal *, doublereal *);
+    doublereal mwptx[55]	/* was [11][5] */, mwpty[55]	/* was [11][5]
+	     */;
+    integer mwpinx[11], mwpiny[11];
+    doublereal mwpstx[5], mwpsty[5];
+
+    /* Fortran I/O blocks */
+    static cilist io___82 = { 0, 6, 0, 0, 0 };
+
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+
+    for (ki = 1; ki <= 4; ++ki) {
+	combla_1.incx = incxs[ki - 1];
+	combla_1.incy = incys[ki - 1];
+	mx = abs(combla_1.incx);
+	my = abs(combla_1.incy);
+
+	for (kn = 1; kn <= 4; ++kn) {
+	    combla_1.n = ns[kn - 1];
+	    ksize = min(2,kn);
+	    lenx = lens[kn + (mx << 2) - 5];
+	    leny = lens[kn + (my << 2) - 5];
+
+	    if (combla_1.icase == 4) {
+/*              .. DROTTEST .. */
+		for (i__ = 1; i__ <= 7; ++i__) {
+		    sx[i__ - 1] = dx1[i__ - 1];
+		    sy[i__ - 1] = dy1[i__ - 1];
+		    stx[i__ - 1] = dt9x[i__ + (kn + (ki << 2)) * 7 - 36];
+		    sty[i__ - 1] = dt9y[i__ + (kn + (ki << 2)) * 7 - 36];
+/* L20: */
+		}
+		drottest_(&combla_1.n, sx, &combla_1.incx, sy, &combla_1.incy,
+			 &sc, &ss);
+		stest_(&lenx, sx, stx, &ssize2[ksize * 14 - 14], sfac);
+		stest_(&leny, sy, sty, &ssize2[ksize * 14 - 14], sfac);
+	    } else {
+		s_wsle(&io___82);
+		do_lio(&c__9, &c__1, " Shouldn't be here in CHECK3", (ftnlen)
+			28);
+		e_wsle();
+		s_stop("", (ftnlen)0);
+	    }
+/* L40: */
+	}
+/* L60: */
+    }
+
+    mwpc[0] = 1.;
+    for (i__ = 2; i__ <= 11; ++i__) {
+	mwpc[i__ - 1] = 0.;
+/* L80: */
+    }
+    mwps[0] = 0.f;
+    for (i__ = 2; i__ <= 6; ++i__) {
+	mwps[i__ - 1] = 1.f;
+/* L100: */
+    }
+    for (i__ = 7; i__ <= 11; ++i__) {
+	mwps[i__ - 1] = -1.f;
+/* L120: */
+    }
+    mwpinx[0] = 1;
+    mwpinx[1] = 1;
+    mwpinx[2] = 1;
+    mwpinx[3] = -1;
+    mwpinx[4] = 1;
+    mwpinx[5] = -1;
+    mwpinx[6] = 1;
+    mwpinx[7] = 1;
+    mwpinx[8] = -1;
+    mwpinx[9] = 1;
+    mwpinx[10] = -1;
+    mwpiny[0] = 1;
+    mwpiny[1] = 1;
+    mwpiny[2] = -1;
+    mwpiny[3] = -1;
+    mwpiny[4] = 2;
+    mwpiny[5] = 1;
+    mwpiny[6] = 1;
+    mwpiny[7] = -1;
+    mwpiny[8] = -1;
+    mwpiny[9] = 2;
+    mwpiny[10] = 1;
+    for (i__ = 1; i__ <= 11; ++i__) {
+	mwpn[i__ - 1] = 5;
+/* L140: */
+    }
+    mwpn[4] = 3;
+    mwpn[9] = 3;
+    for (i__ = 1; i__ <= 5; ++i__) {
+	mwpx[i__ - 1] = (doublereal) i__;
+	mwpy[i__ - 1] = (doublereal) i__;
+	mwptx[i__ * 11 - 11] = (doublereal) i__;
+	mwpty[i__ * 11 - 11] = (doublereal) i__;
+	mwptx[i__ * 11 - 10] = (doublereal) i__;
+	mwpty[i__ * 11 - 10] = (doublereal) (-i__);
+	mwptx[i__ * 11 - 9] = (doublereal) (6 - i__);
+	mwpty[i__ * 11 - 9] = (doublereal) (i__ - 6);
+	mwptx[i__ * 11 - 8] = (doublereal) i__;
+	mwpty[i__ * 11 - 8] = (doublereal) (-i__);
+	mwptx[i__ * 11 - 6] = (doublereal) (6 - i__);
+	mwpty[i__ * 11 - 6] = (doublereal) (i__ - 6);
+	mwptx[i__ * 11 - 5] = (doublereal) (-i__);
+	mwpty[i__ * 11 - 5] = (doublereal) i__;
+	mwptx[i__ * 11 - 4] = (doublereal) (i__ - 6);
+	mwpty[i__ * 11 - 4] = (doublereal) (6 - i__);
+	mwptx[i__ * 11 - 3] = (doublereal) (-i__);
+	mwpty[i__ * 11 - 3] = (doublereal) i__;
+	mwptx[i__ * 11 - 1] = (doublereal) (i__ - 6);
+	mwpty[i__ * 11 - 1] = (doublereal) (6 - i__);
+/* L160: */
+    }
+    mwptx[4] = 1.;
+    mwptx[15] = 3.;
+    mwptx[26] = 5.;
+    mwptx[37] = 4.;
+    mwptx[48] = 5.;
+    mwpty[4] = -1.;
+    mwpty[15] = 2.;
+    mwpty[26] = -2.;
+    mwpty[37] = 4.;
+    mwpty[48] = -3.;
+    mwptx[9] = -1.;
+    mwptx[20] = -3.;
+    mwptx[31] = -5.;
+    mwptx[42] = 4.;
+    mwptx[53] = 5.;
+    mwpty[9] = 1.;
+    mwpty[20] = 2.;
+    mwpty[31] = 2.;
+    mwpty[42] = 4.;
+    mwpty[53] = 3.;
+    for (i__ = 1; i__ <= 11; ++i__) {
+	combla_1.incx = mwpinx[i__ - 1];
+	combla_1.incy = mwpiny[i__ - 1];
+	for (k = 1; k <= 5; ++k) {
+	    copyx[k - 1] = mwpx[k - 1];
+	    copyy[k - 1] = mwpy[k - 1];
+	    mwpstx[k - 1] = mwptx[i__ + k * 11 - 12];
+	    mwpsty[k - 1] = mwpty[i__ + k * 11 - 12];
+/* L180: */
+	}
+	drottest_(&mwpn[i__ - 1], copyx, &combla_1.incx, copyy, &
+		combla_1.incy, &mwpc[i__ - 1], &mwps[i__ - 1]);
+	stest_(&c__5, copyx, mwpstx, mwpstx, sfac);
+	stest_(&c__5, copyy, mwpsty, mwpsty, sfac);
+/* L200: */
+    }
+    return 0;
+} /* check3_ */
+
+/* Subroutine */ int stest_(integer *len, doublereal *scomp, doublereal *
+	strue, doublereal *ssize, doublereal *sfac)
+{
+    /* Format strings */
+    static char fmt_99999[] = "(\002                                       F"
+	    "AIL\002)";
+    static char fmt_99998[] = "(/\002 CASE  N INCX INCY MODE  I             "
+	    "               \002,\002 COMP(I)                             TRU"
+	    "E(I)  DIFFERENCE\002,\002     SIZE(I)\002,/1x)";
+    static char fmt_99997[] = "(1x,i4,i3,3i5,i3,2d36.8,2d12.4)";
+
+    /* System generated locals */
+    integer i__1;
+    doublereal d__1, d__2, d__3, d__4, d__5;
+
+    /* Builtin functions */
+    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+    /* Local variables */
+    integer i__;
+    doublereal sd;
+    extern doublereal sdiff_(doublereal *, doublereal *);
+
+    /* Fortran I/O blocks */
+    static cilist io___99 = { 0, 6, 0, fmt_99999, 0 };
+    static cilist io___100 = { 0, 6, 0, fmt_99998, 0 };
+    static cilist io___101 = { 0, 6, 0, fmt_99997, 0 };
+
+
+/*     ********************************* STEST ************************** */
+
+/*     THIS SUBR COMPARES ARRAYS  SCOMP() AND STRUE() OF LENGTH LEN TO */
+/*     SEE IF THE TERM BY TERM DIFFERENCES, MULTIPLIED BY SFAC, ARE */
+/*     NEGLIGIBLE. */
+
+/*     C. L. LAWSON, JPL, 1974 DEC 10 */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. External Functions .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Common blocks .. */
+/*     .. Executable Statements .. */
+
+    /* Parameter adjustments */
+    --ssize;
+    --strue;
+    --scomp;
+
+    /* Function Body */
+    i__1 = *len;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	sd = scomp[i__] - strue[i__];
+	d__4 = (d__1 = ssize[i__], abs(d__1)) + (d__2 = *sfac * sd, abs(d__2))
+		;
+	d__5 = (d__3 = ssize[i__], abs(d__3));
+	if (sdiff_(&d__4, &d__5) == 0.) {
+	    goto L40;
+	}
+
+/*                             HERE    SCOMP(I) IS NOT CLOSE TO STRUE(I). */
+
+	if (! combla_1.pass) {
+	    goto L20;
+	}
+/*                             PRINT FAIL MESSAGE AND HEADER. */
+	combla_1.pass = FALSE_;
+	s_wsfe(&io___99);
+	e_wsfe();
+	s_wsfe(&io___100);
+	e_wsfe();
+L20:
+	s_wsfe(&io___101);
+	do_fio(&c__1, (char *)&combla_1.icase, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&combla_1.n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&combla_1.incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&combla_1.incy, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&combla_1.mode, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&scomp[i__], (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&strue[i__], (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&sd, (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&ssize[i__], (ftnlen)sizeof(doublereal));
+	e_wsfe();
+L40:
+	;
+    }
+    return 0;
+
+} /* stest_ */
+
+/* Subroutine */ int stest1_(doublereal *scomp1, doublereal *strue1, 
+	doublereal *ssize, doublereal *sfac)
+{
+    doublereal scomp[1], strue[1];
+    extern /* Subroutine */ int stest_(integer *, doublereal *, doublereal *, 
+	    doublereal *, doublereal *);
+
+/*     ************************* STEST1 ***************************** */
+
+/*     THIS IS AN INTERFACE SUBROUTINE TO ACCOMODATE THE FORTRAN */
+/*     REQUIREMENT THAT WHEN A DUMMY ARGUMENT IS AN ARRAY, THE */
+/*     ACTUAL ARGUMENT MUST ALSO BE AN ARRAY OR AN ARRAY ELEMENT. */
+
+/*     C.L. LAWSON, JPL, 1978 DEC 6 */
+
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Arrays .. */
+/*     .. External Subroutines .. */
+/*     .. Executable Statements .. */
+
+    /* Parameter adjustments */
+    --ssize;
+
+    /* Function Body */
+    scomp[0] = *scomp1;
+    strue[0] = *strue1;
+    stest_(&c__1, scomp, strue, &ssize[1], sfac);
+
+    return 0;
+} /* stest1_ */
+
+doublereal sdiff_(doublereal *sa, doublereal *sb)
+{
+    /* System generated locals */
+    doublereal ret_val;
+
+/*     ********************************* SDIFF ************************** */
+/*     COMPUTES DIFFERENCE OF TWO NUMBERS.  C. L. LAWSON, JPL 1974 FEB 15 */
+
+/*     .. Scalar Arguments .. */
+/*     .. Executable Statements .. */
+    ret_val = *sa - *sb;
+    return ret_val;
+} /* sdiff_ */
+
+/* Subroutine */ int itest1_(integer *icomp, integer *itrue)
+{
+    /* Format strings */
+    static char fmt_99999[] = "(\002                                       F"
+	    "AIL\002)";
+    static char fmt_99998[] = "(/\002 CASE  N INCX INCY MODE                "
+	    "               \002,\002 COMP                                TRU"
+	    "E     DIFFERENCE\002,/1x)";
+    static char fmt_99997[] = "(1x,i4,i3,3i5,2i36,i12)";
+
+    /* Builtin functions */
+    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+    /* Local variables */
+    integer id;
+
+    /* Fortran I/O blocks */
+    static cilist io___104 = { 0, 6, 0, fmt_99999, 0 };
+    static cilist io___105 = { 0, 6, 0, fmt_99998, 0 };
+    static cilist io___107 = { 0, 6, 0, fmt_99997, 0 };
+
+
+/*     ********************************* ITEST1 ************************* */
+
+/*     THIS SUBROUTINE COMPARES THE VARIABLES ICOMP AND ITRUE FOR */
+/*     EQUALITY. */
+/*     C. L. LAWSON, JPL, 1974 DEC 10 */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. Common blocks .. */
+/*     .. Executable Statements .. */
+
+    if (*icomp == *itrue) {
+	goto L40;
+    }
+
+/*                            HERE ICOMP IS NOT EQUAL TO ITRUE. */
+
+    if (! combla_1.pass) {
+	goto L20;
+    }
+/*                             PRINT FAIL MESSAGE AND HEADER. */
+    combla_1.pass = FALSE_;
+    s_wsfe(&io___104);
+    e_wsfe();
+    s_wsfe(&io___105);
+    e_wsfe();
+L20:
+    id = *icomp - *itrue;
+    s_wsfe(&io___107);
+    do_fio(&c__1, (char *)&combla_1.icase, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&combla_1.n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&combla_1.incx, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&combla_1.incy, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&combla_1.mode, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&(*icomp), (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&(*itrue), (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&id, (ftnlen)sizeof(integer));
+    e_wsfe();
+L40:
+    return 0;
+
+} /* itest1_ */
+
+/* Main program alias */ int dcblat1_ () { MAIN__ (); return 0; }
diff --git a/CBLAS/testing/c_dblat2.c b/CBLAS/testing/c_dblat2.c
new file mode 100644
index 0000000..ffc05f4
--- /dev/null
+++ b/CBLAS/testing/c_dblat2.c
@@ -0,0 +1,4767 @@
+/* testing/c_dblat2.f -- translated by f2c (version 20191129).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+#include "f2c.h"
+
+/* Common Block Declarations */
+
+struct {
+    integer infot, noutc;
+    logical ok;
+} infoc_;
+
+#define infoc_1 infoc_
+
+struct {
+    char srnamt[12];
+} srnamc_;
+
+#define srnamc_1 srnamc_
+
+/* Table of constant values */
+
+static integer c__9 = 9;
+static integer c__1 = 1;
+static integer c__3 = 3;
+static integer c__8 = 8;
+static integer c__5 = 5;
+static integer c__65 = 65;
+static integer c__7 = 7;
+static integer c__2 = 2;
+static doublereal c_b123 = 1.;
+static doublereal c_b135 = 0.;
+static integer c__6 = 6;
+static logical c_true = TRUE_;
+static integer c_n1 = -1;
+static integer c__0 = 0;
+static logical c_false = FALSE_;
+
+/* Main program */ int MAIN__(void)
+{
+    /* Initialized data */
+
+    static char snames[12*16] = "cblas_dgemv " "cblas_dgbmv " "cblas_dsymv " 
+	    "cblas_dsbmv " "cblas_dspmv " "cblas_dtrmv " "cblas_dtbmv " "cbl"
+	    "as_dtpmv " "cblas_dtrsv " "cblas_dtbsv " "cblas_dtpsv " "cblas_d"
+	    "ger  " "cblas_dsyr  " "cblas_dspr  " "cblas_dsyr2 " "cblas_dspr2 "
+	    ;
+
+    /* Format strings */
+    static char fmt_9997[] = "(\002 NUMBER OF VALUES OF \002,a,\002 IS LESS "
+	    "THAN 1 OR GREATER \002,\002THAN \002,i2)";
+    static char fmt_9996[] = "(\002 VALUE OF N IS LESS THAN 0 OR GREATER THA"
+	    "N \002,i2)";
+    static char fmt_9995[] = "(\002 VALUE OF K IS LESS THAN 0\002)";
+    static char fmt_9994[] = "(\002 ABSOLUTE VALUE OF INCX OR INCY IS 0 OR G"
+	    "REATER THAN \002,i2)";
+    static char fmt_9993[] = "(\002 TESTS OF THE DOUBLE PRECISION LEVEL 2 BL"
+	    "AS\002,//\002 THE F\002,\002OLLOWING PARAMETER VALUES WILL BE US"
+	    "ED:\002)";
+    static char fmt_9992[] = "(\002   FOR N              \002,9i6)";
+    static char fmt_9991[] = "(\002   FOR K              \002,7i6)";
+    static char fmt_9990[] = "(\002   FOR INCX AND INCY  \002,7i6)";
+    static char fmt_9989[] = "(\002   FOR ALPHA          \002,7f6.1)";
+    static char fmt_9988[] = "(\002   FOR BETA           \002,7f6.1)";
+    static char fmt_9980[] = "(\002 ERROR-EXITS WILL NOT BE TESTED\002)";
+    static char fmt_9999[] = "(\002 ROUTINES PASS COMPUTATIONAL TESTS IF TES"
+	    "T RATIO IS LES\002,\002S THAN\002,f8.2)";
+    static char fmt_10002[] = "(\002 COLUMN-MAJOR AND ROW-MAJOR DATA LAYOUTS"
+	    " ARE TESTED\002)";
+    static char fmt_10001[] = "(\002 ROW-MAJOR DATA LAYOUT IS TESTED\002)";
+    static char fmt_10000[] = "(\002 COLUMN-MAJOR DATA LAYOUT IS TESTED\002)";
+    static char fmt_9984[] = "(a12,l2)";
+    static char fmt_9986[] = "(\002 SUBPROGRAM NAME \002,a12,\002 NOT RECOGN"
+	    "IZED\002,/\002 ******* T\002,\002ESTS ABANDONED *******\002)";
+    static char fmt_9998[] = "(\002 RELATIVE MACHINE PRECISION IS TAKEN TO"
+	    " BE\002,1p,d9.1)";
+    static char fmt_9985[] = "(\002 ERROR IN DMVCH -  IN-LINE DOT PRODUCTS A"
+	    "RE BEING EVALU\002,\002ATED WRONGLY.\002,/\002 DMVCH WAS CALLED "
+	    "WITH TRANS = \002,a1,\002 AND RETURNED SAME = \002,l1,\002 AND E"
+	    "RR = \002,f12.3,\002.\002,/\002 THIS MAY BE DUE TO FAULTS IN THE"
+	    " ARITHMETIC OR THE COMPILER.\002,/\002 ******* TESTS ABANDONED *"
+	    "******\002)";
+    static char fmt_9983[] = "(1x,a12,\002 WAS NOT TESTED\002)";
+    static char fmt_9982[] = "(/\002 END OF TESTS\002)";
+    static char fmt_9981[] = "(/\002 ******* FATAL ERROR - TESTS ABANDONED *"
+	    "******\002)";
+    static char fmt_9987[] = "(\002 AMEND DATA FILE OR INCREASE ARRAY SIZES "
+	    "IN PROGRAM\002,/\002 ******* TESTS ABANDONED *******\002)";
+
+    /* System generated locals */
+    integer i__1, i__2, i__3;
+    doublereal d__1;
+    olist o__1;
+    cllist cl__1;
+
+    /* Builtin functions */
+    integer s_rsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
+	    e_rsle(void), f_open(olist *), s_wsfe(cilist *), do_fio(integer *,
+	     char *, ftnlen), e_wsfe(void), s_wsle(cilist *), e_wsle(void), 
+	    s_rsfe(cilist *), e_rsfe(void), s_cmp(char *, char *, ftnlen, 
+	    ftnlen);
+    /* Subroutine */ int s_stop(char *, ftnlen);
+    integer f_clos(cllist *);
+    /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+
+    /* Local variables */
+    doublereal a[4225]	/* was [65][65] */, g[65];
+    integer i__, j, n;
+    doublereal x[65], y[65], z__[130], aa[4225];
+    integer kb[7];
+    doublereal as[4225], xs[130], ys[130], yt[65], xx[130], yy[130], alf[7];
+    extern logical lde_(doublereal *, doublereal *, integer *);
+    integer inc[7], nkb;
+    doublereal bet[7], eps, err;
+    integer nalf, idim[9];
+    logical same;
+    integer ninc, nbet, ntra;
+    logical rewi;
+    extern /* Subroutine */ int dchk1_(char *, doublereal *, doublereal *, 
+	    integer *, integer *, logical *, logical *, logical *, integer *, 
+	    integer *, integer *, integer *, integer *, doublereal *, integer 
+	    *, doublereal *, integer *, integer *, integer *, integer *, 
+	    doublereal *, doublereal *, doublereal *, doublereal *, 
+	    doublereal *, doublereal *, doublereal *, doublereal *, 
+	    doublereal *, doublereal *, doublereal *, integer *, ftnlen), 
+	    dchk2_(char *, doublereal *, doublereal *, integer *, integer *, 
+	    logical *, logical *, logical *, integer *, integer *, integer *, 
+	    integer *, integer *, doublereal *, integer *, doublereal *, 
+	    integer *, integer *, integer *, integer *, doublereal *, 
+	    doublereal *, doublereal *, doublereal *, doublereal *, 
+	    doublereal *, doublereal *, doublereal *, doublereal *, 
+	    doublereal *, doublereal *, integer *, ftnlen), dchk3_(char *, 
+	    doublereal *, doublereal *, integer *, integer *, logical *, 
+	    logical *, logical *, integer *, integer *, integer *, integer *, 
+	    integer *, integer *, integer *, integer *, doublereal *, 
+	    doublereal *, doublereal *, doublereal *, doublereal *, 
+	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
+	     ftnlen), dchk4_(char *, doublereal *, doublereal *, integer *, 
+	    integer *, logical *, logical *, logical *, integer *, integer *, 
+	    integer *, doublereal *, integer *, integer *, integer *, integer 
+	    *, doublereal *, doublereal *, doublereal *, doublereal *, 
+	    doublereal *, doublereal *, doublereal *, doublereal *, 
+	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
+	     ftnlen), dchk5_(char *, doublereal *, doublereal *, integer *, 
+	    integer *, logical *, logical *, logical *, integer *, integer *, 
+	    integer *, doublereal *, integer *, integer *, integer *, integer 
+	    *, doublereal *, doublereal *, doublereal *, doublereal *, 
+	    doublereal *, doublereal *, doublereal *, doublereal *, 
+	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
+	     ftnlen), dchk6_(char *, doublereal *, doublereal *, integer *, 
+	    integer *, logical *, logical *, logical *, integer *, integer *, 
+	    integer *, doublereal *, integer *, integer *, integer *, integer 
+	    *, doublereal *, doublereal *, doublereal *, doublereal *, 
+	    doublereal *, doublereal *, doublereal *, doublereal *, 
+	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
+	     ftnlen);
+    extern doublereal ddiff_(doublereal *, doublereal *);
+    logical fatal, trace;
+    integer nidim;
+    extern /* Subroutine */ int dmvch_(char *, integer *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
+	     doublereal *, doublereal *, doublereal *, logical *, integer *, 
+	    logical *, ftnlen);
+    char snaps[32], trans[1];
+    integer isnum;
+    logical ltest[16], sfatal, corder;
+    char snamet[12];
+    doublereal thresh;
+    logical rorder;
+    extern /* Subroutine */ void cd2chke_(char *);
+    integer layout;
+    logical ltestt, tsterr;
+
+    /* Fortran I/O blocks */
+    static cilist io___2 = { 0, 5, 0, 0, 0 };
+    static cilist io___4 = { 0, 5, 0, 0, 0 };
+    static cilist io___7 = { 0, 5, 0, 0, 0 };
+    static cilist io___9 = { 0, 5, 0, 0, 0 };
+    static cilist io___11 = { 0, 5, 0, 0, 0 };
+    static cilist io___13 = { 0, 5, 0, 0, 0 };
+    static cilist io___15 = { 0, 5, 0, 0, 0 };
+    static cilist io___17 = { 0, 5, 0, 0, 0 };
+    static cilist io___19 = { 0, 6, 0, fmt_9997, 0 };
+    static cilist io___20 = { 0, 5, 0, 0, 0 };
+    static cilist io___23 = { 0, 6, 0, fmt_9996, 0 };
+    static cilist io___24 = { 0, 5, 0, 0, 0 };
+    static cilist io___26 = { 0, 6, 0, fmt_9997, 0 };
+    static cilist io___27 = { 0, 5, 0, 0, 0 };
+    static cilist io___29 = { 0, 6, 0, fmt_9995, 0 };
+    static cilist io___30 = { 0, 5, 0, 0, 0 };
+    static cilist io___32 = { 0, 6, 0, fmt_9997, 0 };
+    static cilist io___33 = { 0, 5, 0, 0, 0 };
+    static cilist io___35 = { 0, 6, 0, fmt_9994, 0 };
+    static cilist io___36 = { 0, 5, 0, 0, 0 };
+    static cilist io___38 = { 0, 6, 0, fmt_9997, 0 };
+    static cilist io___39 = { 0, 5, 0, 0, 0 };
+    static cilist io___41 = { 0, 5, 0, 0, 0 };
+    static cilist io___43 = { 0, 6, 0, fmt_9997, 0 };
+    static cilist io___44 = { 0, 5, 0, 0, 0 };
+    static cilist io___46 = { 0, 6, 0, fmt_9993, 0 };
+    static cilist io___47 = { 0, 6, 0, fmt_9992, 0 };
+    static cilist io___48 = { 0, 6, 0, fmt_9991, 0 };
+    static cilist io___49 = { 0, 6, 0, fmt_9990, 0 };
+    static cilist io___50 = { 0, 6, 0, fmt_9989, 0 };
+    static cilist io___51 = { 0, 6, 0, fmt_9988, 0 };
+    static cilist io___52 = { 0, 6, 0, 0, 0 };
+    static cilist io___53 = { 0, 6, 0, fmt_9980, 0 };
+    static cilist io___54 = { 0, 6, 0, 0, 0 };
+    static cilist io___55 = { 0, 6, 0, fmt_9999, 0 };
+    static cilist io___56 = { 0, 6, 0, 0, 0 };
+    static cilist io___59 = { 0, 6, 0, fmt_10002, 0 };
+    static cilist io___60 = { 0, 6, 0, fmt_10001, 0 };
+    static cilist io___61 = { 0, 6, 0, fmt_10000, 0 };
+    static cilist io___62 = { 0, 6, 0, 0, 0 };
+    static cilist io___64 = { 0, 5, 1, fmt_9984, 0 };
+    static cilist io___67 = { 0, 6, 0, fmt_9986, 0 };
+    static cilist io___69 = { 0, 6, 0, fmt_9998, 0 };
+    static cilist io___82 = { 0, 6, 0, fmt_9985, 0 };
+    static cilist io___83 = { 0, 6, 0, fmt_9985, 0 };
+    static cilist io___85 = { 0, 6, 0, 0, 0 };
+    static cilist io___86 = { 0, 6, 0, fmt_9983, 0 };
+    static cilist io___87 = { 0, 6, 0, 0, 0 };
+    static cilist io___94 = { 0, 6, 0, fmt_9982, 0 };
+    static cilist io___95 = { 0, 6, 0, fmt_9981, 0 };
+    static cilist io___96 = { 0, 6, 0, fmt_9987, 0 };
+
+
+
+/*  Test program for the DOUBLE PRECISION Level 2 Blas. */
+
+/*  The program must be driven by a short data file. The first 17 records */
+/*  of the file are read using list-directed input, the last 16 records */
+/*  are read using the format ( A12, L2 ). An annotated example of a data */
+/*  file can be obtained by deleting the first 3 characters from the */
+/*  following 33 lines: */
+/*  'DBLAT2.SNAP'     NAME OF SNAPSHOT OUTPUT FILE */
+/*  -1                UNIT NUMBER OF SNAPSHOT FILE (NOT USED IF .LT. 0) */
+/*  F        LOGICAL FLAG, T TO REWIND SNAPSHOT FILE AFTER EACH RECORD. */
+/*  F        LOGICAL FLAG, T TO STOP ON FAILURES. */
+/*  T        LOGICAL FLAG, T TO TEST ERROR EXITS. */
+/*  2        0 TO TEST COLUMN-MAJOR, 1 TO TEST ROW-MAJOR, 2 TO TEST BOTH */
+/*  16.0     THRESHOLD VALUE OF TEST RATIO */
+/*  6                 NUMBER OF VALUES OF N */
+/*  0 1 2 3 5 9       VALUES OF N */
+/*  4                 NUMBER OF VALUES OF K */
+/*  0 1 2 4           VALUES OF K */
+/*  4                 NUMBER OF VALUES OF INCX AND INCY */
+/*  1 2 -1 -2         VALUES OF INCX AND INCY */
+/*  3                 NUMBER OF VALUES OF ALPHA */
+/*  0.0 1.0 0.7       VALUES OF ALPHA */
+/*  3                 NUMBER OF VALUES OF BETA */
+/*  0.0 1.0 0.9       VALUES OF BETA */
+/*  cblas_dgemv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_dgbmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_dsymv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_dsbmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_dspmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_dtrmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_dtbmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_dtpmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_dtrsv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_dtbsv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_dtpsv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_dger   T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_dsyr   T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_dspr   T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_dsyr2  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_dspr2  T PUT F FOR NO TEST. SAME COLUMNS. */
+
+/*     See: */
+
+/*        Dongarra J. J., Du Croz J. J., Hammarling S.  and Hanson R. J.. */
+/*        An  extended  set of Fortran  Basic Linear Algebra Subprograms. */
+
+/*        Technical  Memoranda  Nos. 41 (revision 3) and 81,  Mathematics */
+/*        and  Computer Science  Division,  Argonne  National Laboratory, */
+/*        9700 South Cass Avenue, Argonne, Illinois 60439, US. */
+
+/*        Or */
+
+/*        NAG  Technical Reports TR3/87 and TR4/87,  Numerical Algorithms */
+/*        Group  Ltd.,  NAG  Central  Office,  256  Banbury  Road, Oxford */
+/*        OX2 7DE, UK,  and  Numerical Algorithms Group Inc.,  1101  31st */
+/*        Street,  Suite 100,  Downers Grove,  Illinois 60515-1263,  USA. */
+
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Parameters .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Scalars in Common .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+
+    infoc_1.noutc = 6;
+
+/*     Read name and unit number for snapshot output file and open file. */
+
+    s_rsle(&io___2);
+    do_lio(&c__9, &c__1, snaps, (ftnlen)32);
+    e_rsle();
+    s_rsle(&io___4);
+    do_lio(&c__3, &c__1, (char *)&ntra, (ftnlen)sizeof(integer));
+    e_rsle();
+    trace = ntra >= 0;
+    if (trace) {
+	o__1.oerr = 0;
+	o__1.ounit = ntra;
+	o__1.ofnmlen = 32;
+	o__1.ofnm = snaps;
+	o__1.orl = 0;
+	o__1.osta = 0;
+	o__1.oacc = 0;
+	o__1.ofm = 0;
+	o__1.oblnk = 0;
+	f_open(&o__1);
+    }
+/*     Read the flag that directs rewinding of the snapshot file. */
+    s_rsle(&io___7);
+    do_lio(&c__8, &c__1, (char *)&rewi, (ftnlen)sizeof(logical));
+    e_rsle();
+    rewi = rewi && trace;
+/*     Read the flag that directs stopping on any failure. */
+    s_rsle(&io___9);
+    do_lio(&c__8, &c__1, (char *)&sfatal, (ftnlen)sizeof(logical));
+    e_rsle();
+/*     Read the flag that indicates whether error exits are to be tested. */
+    s_rsle(&io___11);
+    do_lio(&c__8, &c__1, (char *)&tsterr, (ftnlen)sizeof(logical));
+    e_rsle();
+/*     Read the flag that indicates whether row-major data layout to be tested. */
+    s_rsle(&io___13);
+    do_lio(&c__3, &c__1, (char *)&layout, (ftnlen)sizeof(integer));
+    e_rsle();
+/*     Read the threshold value of the test ratio */
+    s_rsle(&io___15);
+    do_lio(&c__5, &c__1, (char *)&thresh, (ftnlen)sizeof(doublereal));
+    e_rsle();
+
+/*     Read and check the parameter values for the tests. */
+
+/*     Values of N */
+    s_rsle(&io___17);
+    do_lio(&c__3, &c__1, (char *)&nidim, (ftnlen)sizeof(integer));
+    e_rsle();
+    if (nidim < 1 || nidim > 9) {
+	s_wsfe(&io___19);
+	do_fio(&c__1, "N", (ftnlen)1);
+	do_fio(&c__1, (char *)&c__9, (ftnlen)sizeof(integer));
+	e_wsfe();
+	goto L230;
+    }
+    s_rsle(&io___20);
+    i__1 = nidim;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_lio(&c__3, &c__1, (char *)&idim[i__ - 1], (ftnlen)sizeof(integer));
+    }
+    e_rsle();
+    i__1 = nidim;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	if (idim[i__ - 1] < 0 || idim[i__ - 1] > 65) {
+	    s_wsfe(&io___23);
+	    do_fio(&c__1, (char *)&c__65, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	    goto L230;
+	}
+/* L10: */
+    }
+/*     Values of K */
+    s_rsle(&io___24);
+    do_lio(&c__3, &c__1, (char *)&nkb, (ftnlen)sizeof(integer));
+    e_rsle();
+    if (nkb < 1 || nkb > 7) {
+	s_wsfe(&io___26);
+	do_fio(&c__1, "K", (ftnlen)1);
+	do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+	e_wsfe();
+	goto L230;
+    }
+    s_rsle(&io___27);
+    i__1 = nkb;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_lio(&c__3, &c__1, (char *)&kb[i__ - 1], (ftnlen)sizeof(integer));
+    }
+    e_rsle();
+    i__1 = nkb;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	if (kb[i__ - 1] < 0) {
+	    s_wsfe(&io___29);
+	    e_wsfe();
+	    goto L230;
+	}
+/* L20: */
+    }
+/*     Values of INCX and INCY */
+    s_rsle(&io___30);
+    do_lio(&c__3, &c__1, (char *)&ninc, (ftnlen)sizeof(integer));
+    e_rsle();
+    if (ninc < 1 || ninc > 7) {
+	s_wsfe(&io___32);
+	do_fio(&c__1, "INCX AND INCY", (ftnlen)13);
+	do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+	e_wsfe();
+	goto L230;
+    }
+    s_rsle(&io___33);
+    i__1 = ninc;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_lio(&c__3, &c__1, (char *)&inc[i__ - 1], (ftnlen)sizeof(integer));
+    }
+    e_rsle();
+    i__1 = ninc;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	if (inc[i__ - 1] == 0 || (i__2 = inc[i__ - 1], abs(i__2)) > 2) {
+	    s_wsfe(&io___35);
+	    do_fio(&c__1, (char *)&c__2, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	    goto L230;
+	}
+/* L30: */
+    }
+/*     Values of ALPHA */
+    s_rsle(&io___36);
+    do_lio(&c__3, &c__1, (char *)&nalf, (ftnlen)sizeof(integer));
+    e_rsle();
+    if (nalf < 1 || nalf > 7) {
+	s_wsfe(&io___38);
+	do_fio(&c__1, "ALPHA", (ftnlen)5);
+	do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+	e_wsfe();
+	goto L230;
+    }
+    s_rsle(&io___39);
+    i__1 = nalf;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_lio(&c__5, &c__1, (char *)&alf[i__ - 1], (ftnlen)sizeof(doublereal)
+		);
+    }
+    e_rsle();
+/*     Values of BETA */
+    s_rsle(&io___41);
+    do_lio(&c__3, &c__1, (char *)&nbet, (ftnlen)sizeof(integer));
+    e_rsle();
+    if (nbet < 1 || nbet > 7) {
+	s_wsfe(&io___43);
+	do_fio(&c__1, "BETA", (ftnlen)4);
+	do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+	e_wsfe();
+	goto L230;
+    }
+    s_rsle(&io___44);
+    i__1 = nbet;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_lio(&c__5, &c__1, (char *)&bet[i__ - 1], (ftnlen)sizeof(doublereal)
+		);
+    }
+    e_rsle();
+
+/*     Report values of parameters. */
+
+    s_wsfe(&io___46);
+    e_wsfe();
+    s_wsfe(&io___47);
+    i__1 = nidim;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_fio(&c__1, (char *)&idim[i__ - 1], (ftnlen)sizeof(integer));
+    }
+    e_wsfe();
+    s_wsfe(&io___48);
+    i__1 = nkb;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_fio(&c__1, (char *)&kb[i__ - 1], (ftnlen)sizeof(integer));
+    }
+    e_wsfe();
+    s_wsfe(&io___49);
+    i__1 = ninc;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_fio(&c__1, (char *)&inc[i__ - 1], (ftnlen)sizeof(integer));
+    }
+    e_wsfe();
+    s_wsfe(&io___50);
+    i__1 = nalf;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_fio(&c__1, (char *)&alf[i__ - 1], (ftnlen)sizeof(doublereal));
+    }
+    e_wsfe();
+    s_wsfe(&io___51);
+    i__1 = nbet;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_fio(&c__1, (char *)&bet[i__ - 1], (ftnlen)sizeof(doublereal));
+    }
+    e_wsfe();
+    if (! tsterr) {
+	s_wsle(&io___52);
+	e_wsle();
+	s_wsfe(&io___53);
+	e_wsfe();
+    }
+    s_wsle(&io___54);
+    e_wsle();
+    s_wsfe(&io___55);
+    do_fio(&c__1, (char *)&thresh, (ftnlen)sizeof(doublereal));
+    e_wsfe();
+    s_wsle(&io___56);
+    e_wsle();
+    rorder = FALSE_;
+    corder = FALSE_;
+    if (layout == 2) {
+	rorder = TRUE_;
+	corder = TRUE_;
+	s_wsfe(&io___59);
+	e_wsfe();
+    } else if (layout == 1) {
+	rorder = TRUE_;
+	s_wsfe(&io___60);
+	e_wsfe();
+    } else if (layout == 0) {
+	corder = TRUE_;
+	s_wsfe(&io___61);
+	e_wsfe();
+    }
+    s_wsle(&io___62);
+    e_wsle();
+
+/*     Read names of subroutines and flags which indicate */
+/*     whether they are to be tested. */
+
+    for (i__ = 1; i__ <= 16; ++i__) {
+	ltest[i__ - 1] = FALSE_;
+/* L40: */
+    }
+L50:
+    i__1 = s_rsfe(&io___64);
+    if (i__1 != 0) {
+	goto L80;
+    }
+    i__1 = do_fio(&c__1, snamet, (ftnlen)12);
+    if (i__1 != 0) {
+	goto L80;
+    }
+    i__1 = do_fio(&c__1, (char *)&ltestt, (ftnlen)sizeof(logical));
+    if (i__1 != 0) {
+	goto L80;
+    }
+    i__1 = e_rsfe();
+    if (i__1 != 0) {
+	goto L80;
+    }
+    for (i__ = 1; i__ <= 16; ++i__) {
+	if (s_cmp(snamet, snames + (i__ - 1) * 12, (ftnlen)12, (ftnlen)12) == 
+		0) {
+	    goto L70;
+	}
+/* L60: */
+    }
+    s_wsfe(&io___67);
+    do_fio(&c__1, snamet, (ftnlen)12);
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+L70:
+    ltest[i__ - 1] = ltestt;
+    goto L50;
+
+L80:
+    cl__1.cerr = 0;
+    cl__1.cunit = 5;
+    cl__1.csta = 0;
+    f_clos(&cl__1);
+
+/*     Compute EPS (the machine precision). */
+
+    eps = 1.;
+L90:
+    d__1 = eps + 1.;
+    if (ddiff_(&d__1, &c_b123) == 0.) {
+	goto L100;
+    }
+    eps *= .5;
+    goto L90;
+L100:
+    eps += eps;
+    s_wsfe(&io___69);
+    do_fio(&c__1, (char *)&eps, (ftnlen)sizeof(doublereal));
+    e_wsfe();
+
+/*     Check the reliability of DMVCH using exact data. */
+
+    n = 32;
+    i__1 = n;
+    for (j = 1; j <= i__1; ++j) {
+	i__2 = n;
+	for (i__ = 1; i__ <= i__2; ++i__) {
+/* Computing MAX */
+	    i__3 = i__ - j + 1;
+	    a[i__ + j * 65 - 66] = (doublereal) max(i__3,0);
+/* L110: */
+	}
+	x[j - 1] = (doublereal) j;
+	y[j - 1] = 0.;
+/* L120: */
+    }
+    i__1 = n;
+    for (j = 1; j <= i__1; ++j) {
+	yy[j - 1] = (doublereal) (j * ((j + 1) * j) / 2 - (j + 1) * j * (j - 
+		1) / 3);
+/* L130: */
+    }
+/*     YY holds the exact result. On exit from DMVCH YT holds */
+/*     the result computed by DMVCH. */
+    *(unsigned char *)trans = 'N';
+    dmvch_(trans, &n, &n, &c_b123, a, &c__65, x, &c__1, &c_b135, y, &c__1, yt,
+	     g, yy, &eps, &err, &fatal, &c__6, &c_true, (ftnlen)1);
+    same = lde_(yy, yt, &n);
+    if (! same || err != 0.) {
+	s_wsfe(&io___82);
+	do_fio(&c__1, trans, (ftnlen)1);
+	do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+	do_fio(&c__1, (char *)&err, (ftnlen)sizeof(doublereal));
+	e_wsfe();
+	s_stop("", (ftnlen)0);
+    }
+    *(unsigned char *)trans = 'T';
+    dmvch_(trans, &n, &n, &c_b123, a, &c__65, x, &c_n1, &c_b135, y, &c_n1, yt,
+	     g, yy, &eps, &err, &fatal, &c__6, &c_true, (ftnlen)1);
+    same = lde_(yy, yt, &n);
+    if (! same || err != 0.) {
+	s_wsfe(&io___83);
+	do_fio(&c__1, trans, (ftnlen)1);
+	do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+	do_fio(&c__1, (char *)&err, (ftnlen)sizeof(doublereal));
+	e_wsfe();
+	s_stop("", (ftnlen)0);
+    }
+
+/*     Test each subroutine in turn. */
+
+    for (isnum = 1; isnum <= 16; ++isnum) {
+	s_wsle(&io___85);
+	e_wsle();
+	if (! ltest[isnum - 1]) {
+/*           Subprogram is not to be tested. */
+	    s_wsfe(&io___86);
+	    do_fio(&c__1, snames + (isnum - 1) * 12, (ftnlen)12);
+	    e_wsfe();
+	} else {
+	    s_copy(srnamc_1.srnamt, snames + (isnum - 1) * 12, (ftnlen)12, (
+		    ftnlen)12);
+/*           Test error exits. */
+	    if (tsterr) {
+		cd2chke_(snames + (isnum - 1) * 12);
+		s_wsle(&io___87);
+		e_wsle();
+	    }
+/*           Test computations. */
+	    infoc_1.infot = 0;
+	    infoc_1.ok = TRUE_;
+	    fatal = FALSE_;
+	    switch (isnum) {
+		case 1:  goto L140;
+		case 2:  goto L140;
+		case 3:  goto L150;
+		case 4:  goto L150;
+		case 5:  goto L150;
+		case 6:  goto L160;
+		case 7:  goto L160;
+		case 8:  goto L160;
+		case 9:  goto L160;
+		case 10:  goto L160;
+		case 11:  goto L160;
+		case 12:  goto L170;
+		case 13:  goto L180;
+		case 14:  goto L180;
+		case 15:  goto L190;
+		case 16:  goto L190;
+	    }
+/*           Test DGEMV, 01, and DGBMV, 02. */
+L140:
+	    if (corder) {
+		dchk1_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nkb, kb, &nalf,
+			 alf, &nbet, bet, &ninc, inc, &c__65, &c__2, a, aa, 
+			as, x, xx, xs, y, yy, ys, yt, g, &c__0, (ftnlen)12);
+	    }
+	    if (rorder) {
+		dchk1_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nkb, kb, &nalf,
+			 alf, &nbet, bet, &ninc, inc, &c__65, &c__2, a, aa, 
+			as, x, xx, xs, y, yy, ys, yt, g, &c__1, (ftnlen)12);
+	    }
+	    goto L200;
+/*           Test DSYMV, 03, DSBMV, 04, and DSPMV, 05. */
+L150:
+	    if (corder) {
+		dchk2_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nkb, kb, &nalf,
+			 alf, &nbet, bet, &ninc, inc, &c__65, &c__2, a, aa, 
+			as, x, xx, xs, y, yy, ys, yt, g, &c__0, (ftnlen)12);
+	    }
+	    if (rorder) {
+		dchk2_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nkb, kb, &nalf,
+			 alf, &nbet, bet, &ninc, inc, &c__65, &c__2, a, aa, 
+			as, x, xx, xs, y, yy, ys, yt, g, &c__1, (ftnlen)12);
+	    }
+	    goto L200;
+/*           Test DTRMV, 06, DTBMV, 07, DTPMV, 08, */
+/*           DTRSV, 09, DTBSV, 10, and DTPSV, 11. */
+L160:
+	    if (corder) {
+		dchk3_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nkb, kb, &ninc,
+			 inc, &c__65, &c__2, a, aa, as, y, yy, ys, yt, g, z__,
+			 &c__0, (ftnlen)12);
+	    }
+	    if (rorder) {
+		dchk3_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nkb, kb, &ninc,
+			 inc, &c__65, &c__2, a, aa, as, y, yy, ys, yt, g, z__,
+			 &c__1, (ftnlen)12);
+	    }
+	    goto L200;
+/*           Test DGER, 12. */
+L170:
+	    if (corder) {
+		dchk4_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nalf, alf, &
+			ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy,
+			 ys, yt, g, z__, &c__0, (ftnlen)12);
+	    }
+	    if (rorder) {
+		dchk4_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nalf, alf, &
+			ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy,
+			 ys, yt, g, z__, &c__1, (ftnlen)12);
+	    }
+	    goto L200;
+/*           Test DSYR, 13, and DSPR, 14. */
+L180:
+	    if (corder) {
+		dchk5_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nalf, alf, &
+			ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy,
+			 ys, yt, g, z__, &c__0, (ftnlen)12);
+	    }
+	    if (rorder) {
+		dchk5_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nalf, alf, &
+			ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy,
+			 ys, yt, g, z__, &c__1, (ftnlen)12);
+	    }
+	    goto L200;
+/*           Test DSYR2, 15, and DSPR2, 16. */
+L190:
+	    if (corder) {
+		dchk6_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nalf, alf, &
+			ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy,
+			 ys, yt, g, z__, &c__0, (ftnlen)12);
+	    }
+	    if (rorder) {
+		dchk6_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nalf, alf, &
+			ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy,
+			 ys, yt, g, z__, &c__1, (ftnlen)12);
+	    }
+
+L200:
+	    if (fatal && sfatal) {
+		goto L220;
+	    }
+	}
+/* L210: */
+    }
+    s_wsfe(&io___94);
+    e_wsfe();
+    goto L240;
+
+L220:
+    s_wsfe(&io___95);
+    e_wsfe();
+    goto L240;
+
+L230:
+    s_wsfe(&io___96);
+    e_wsfe();
+
+L240:
+    if (trace) {
+	cl__1.cerr = 0;
+	cl__1.cunit = ntra;
+	cl__1.csta = 0;
+	f_clos(&cl__1);
+    }
+    cl__1.cerr = 0;
+    cl__1.cunit = 6;
+    cl__1.csta = 0;
+    f_clos(&cl__1);
+    s_stop("", (ftnlen)0);
+
+
+/*     End of DBLAT2. */
+
+    return 0;
+} /* MAIN__ */
+
+/* Subroutine */ int dchk1_(char *sname, doublereal *eps, doublereal *thresh, 
+	integer *nout, integer *ntra, logical *trace, logical *rewi, logical *
+	fatal, integer *nidim, integer *idim, integer *nkb, integer *kb, 
+	integer *nalf, doublereal *alf, integer *nbet, doublereal *bet, 
+	integer *ninc, integer *inc, integer *nmax, integer *incmax, 
+	doublereal *a, doublereal *aa, doublereal *as, doublereal *x, 
+	doublereal *xx, doublereal *xs, doublereal *y, doublereal *yy, 
+	doublereal *ys, doublereal *yt, doublereal *g, integer *iorder, 
+	ftnlen sname_len)
+{
+    /* Initialized data */
+
+    static char ich[3] = "NTC";
+
+    /* Format strings */
+    static char fmt_9994[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+	    "2(i3,\002,\002),f4.1,\002, A,\002,i3,\002, X,\002,i2,\002,\002,f"
+	    "4.1,\002, Y,\002,i2,\002)         .\002)";
+    static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+	    "4(i3,\002,\002),f4.1,\002, A,\002,i3,\002,\002,/10x,\002X,\002,i"
+	    "2,\002,\002,f4.1,\002, Y,\002,i2,\002) .\002)";
+    static char fmt_9993[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+	    "N VALID CALL *\002,\002******\002)";
+    static char fmt_9998[] = "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+	    " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+    static char fmt_10000[] = "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10001[] = "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10002[] = "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+	    "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_10003[] = "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+	    "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+	    "BER:\002)";
+
+    /* System generated locals */
+    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6, i__7, i__8;
+    alist al__1;
+
+    /* Builtin functions */
+    /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+	     f_rew(alist *);
+
+    /* Local variables */
+    integer i__, m, n, ia, ib, ic, nc, nd, im, in, kl, ml, nk, nl, ku, ix, iy,
+	     ms, lx, ly, ns, laa, lda;
+    extern logical lde_(doublereal *, doublereal *, integer *);
+    doublereal als, bls, err;
+    integer iku, kls, kus;
+    doublereal beta;
+    integer ldas;
+    logical same;
+    integer incx, incy;
+    logical full, tran, null;
+    extern /* Subroutine */ int dmake_(char *, char *, char *, integer *, 
+	    integer *, doublereal *, integer *, doublereal *, integer *, 
+	    integer *, integer *, logical *, doublereal *, ftnlen, ftnlen, 
+	    ftnlen);
+    doublereal alpha;
+    logical isame[13];
+    extern /* Subroutine */ int dmvch_(char *, integer *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
+	     doublereal *, doublereal *, doublereal *, logical *, integer *, 
+	    logical *, ftnlen);
+    integer nargs;
+    logical reset;
+    integer incxs, incys;
+    char trans[1];
+    logical banded;
+    extern /* Subroutine */ void cdgbmv_(integer *, char *, integer *, integer 
+	    *, integer *, integer *, doublereal *, doublereal *, integer *, 
+	    doublereal *, integer *, doublereal *, doublereal *, integer *),
+	    cdgemv_(integer *, char *, integer *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
+	    doublereal *, doublereal *, integer *);
+    extern logical lderes_(char *, char *, integer *, integer *, doublereal *,
+	     doublereal *, integer *, ftnlen, ftnlen);
+    char ctrans[14];
+    doublereal errmax, transl;
+    char transs[1];
+
+    /* Fortran I/O blocks */
+    static cilist io___144 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___145 = { 0, 0, 0, fmt_9995, 0 };
+    static cilist io___146 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___149 = { 0, 0, 0, fmt_9998, 0 };
+    static cilist io___151 = { 0, 0, 0, fmt_10000, 0 };
+    static cilist io___152 = { 0, 0, 0, fmt_10001, 0 };
+    static cilist io___153 = { 0, 0, 0, fmt_10002, 0 };
+    static cilist io___154 = { 0, 0, 0, fmt_10003, 0 };
+    static cilist io___155 = { 0, 0, 0, fmt_9996, 0 };
+    static cilist io___156 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___157 = { 0, 0, 0, fmt_9995, 0 };
+
+
+
+/*  Tests DGEMV and DGBMV. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Scalars in Common .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+    /* Parameter adjustments */
+    --idim;
+    --kb;
+    --alf;
+    --bet;
+    --inc;
+    --g;
+    --yt;
+    --y;
+    --x;
+    --as;
+    --aa;
+    a_dim1 = *nmax;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --ys;
+    --yy;
+    --xs;
+    --xx;
+
+    /* Function Body */
+/*     .. Executable Statements .. */
+    full = *(unsigned char *)&sname[8] == 'e';
+    banded = *(unsigned char *)&sname[8] == 'b';
+/*     Define the number of arguments. */
+    if (full) {
+	nargs = 11;
+    } else if (banded) {
+	nargs = 13;
+    }
+
+    nc = 0;
+    reset = TRUE_;
+    errmax = 0.;
+
+    i__1 = *nidim;
+    for (in = 1; in <= i__1; ++in) {
+	n = idim[in];
+	nd = n / 2 + 1;
+
+	for (im = 1; im <= 2; ++im) {
+	    if (im == 1) {
+/* Computing MAX */
+		i__2 = n - nd;
+		m = max(i__2,0);
+	    }
+	    if (im == 2) {
+/* Computing MIN */
+		i__2 = n + nd;
+		m = min(i__2,*nmax);
+	    }
+
+	    if (banded) {
+		nk = *nkb;
+	    } else {
+		nk = 1;
+	    }
+	    i__2 = nk;
+	    for (iku = 1; iku <= i__2; ++iku) {
+		if (banded) {
+		    ku = kb[iku];
+/* Computing MAX */
+		    i__3 = ku - 1;
+		    kl = max(i__3,0);
+		} else {
+		    ku = n - 1;
+		    kl = m - 1;
+		}
+/*              Set LDA to 1 more than minimum value if room. */
+		if (banded) {
+		    lda = kl + ku + 1;
+		} else {
+		    lda = m;
+		}
+		if (lda < *nmax) {
+		    ++lda;
+		}
+/*              Skip tests if not enough room. */
+		if (lda > *nmax) {
+		    goto L100;
+		}
+		laa = lda * n;
+		null = n <= 0 || m <= 0;
+
+/*              Generate the matrix A. */
+
+		transl = 0.;
+		dmake_(sname + 7, " ", " ", &m, &n, &a[a_offset], nmax, &aa[1]
+			, &lda, &kl, &ku, &reset, &transl, (ftnlen)2, (ftnlen)
+			1, (ftnlen)1);
+
+		for (ic = 1; ic <= 3; ++ic) {
+		    *(unsigned char *)trans = *(unsigned char *)&ich[ic - 1];
+		    if (*(unsigned char *)trans == 'N') {
+			s_copy(ctrans, "  CblasNoTrans", (ftnlen)14, (ftnlen)
+				14);
+		    } else if (*(unsigned char *)trans == 'T') {
+			s_copy(ctrans, "    CblasTrans", (ftnlen)14, (ftnlen)
+				14);
+		    } else {
+			s_copy(ctrans, "CblasConjTrans", (ftnlen)14, (ftnlen)
+				14);
+		    }
+		    tran = *(unsigned char *)trans == 'T' || *(unsigned char *
+			    )trans == 'C';
+
+		    if (tran) {
+			ml = n;
+			nl = m;
+		    } else {
+			ml = m;
+			nl = n;
+		    }
+
+		    i__3 = *ninc;
+		    for (ix = 1; ix <= i__3; ++ix) {
+			incx = inc[ix];
+			lx = abs(incx) * nl;
+
+/*                    Generate the vector X. */
+
+			transl = .5;
+			i__4 = abs(incx);
+			i__5 = nl - 1;
+			dmake_("ge", " ", " ", &c__1, &nl, &x[1], &c__1, &xx[
+				1], &i__4, &c__0, &i__5, &reset, &transl, (
+				ftnlen)2, (ftnlen)1, (ftnlen)1);
+			if (nl > 1) {
+			    x[nl / 2] = 0.;
+			    xx[abs(incx) * (nl / 2 - 1) + 1] = 0.;
+			}
+
+			i__4 = *ninc;
+			for (iy = 1; iy <= i__4; ++iy) {
+			    incy = inc[iy];
+			    ly = abs(incy) * ml;
+
+			    i__5 = *nalf;
+			    for (ia = 1; ia <= i__5; ++ia) {
+				alpha = alf[ia];
+
+				i__6 = *nbet;
+				for (ib = 1; ib <= i__6; ++ib) {
+				    beta = bet[ib];
+
+/*                             Generate the vector Y. */
+
+				    transl = 0.;
+				    i__7 = abs(incy);
+				    i__8 = ml - 1;
+				    dmake_("ge", " ", " ", &c__1, &ml, &y[1], 
+					    &c__1, &yy[1], &i__7, &c__0, &
+					    i__8, &reset, &transl, (ftnlen)2, 
+					    (ftnlen)1, (ftnlen)1);
+
+				    ++nc;
+
+/*                             Save every datum before calling the */
+/*                             subroutine. */
+
+				    *(unsigned char *)transs = *(unsigned 
+					    char *)trans;
+				    ms = m;
+				    ns = n;
+				    kls = kl;
+				    kus = ku;
+				    als = alpha;
+				    i__7 = laa;
+				    for (i__ = 1; i__ <= i__7; ++i__) {
+					as[i__] = aa[i__];
+/* L10: */
+				    }
+				    ldas = lda;
+				    i__7 = lx;
+				    for (i__ = 1; i__ <= i__7; ++i__) {
+					xs[i__] = xx[i__];
+/* L20: */
+				    }
+				    incxs = incx;
+				    bls = beta;
+				    i__7 = ly;
+				    for (i__ = 1; i__ <= i__7; ++i__) {
+					ys[i__] = yy[i__];
+/* L30: */
+				    }
+				    incys = incy;
+
+/*                             Call the subroutine. */
+
+				    if (full) {
+					if (*trace) {
+					    io___144.ciunit = *ntra;
+					    s_wsfe(&io___144);
+					    do_fio(&c__1, (char *)&nc, (
+						    ftnlen)sizeof(integer));
+					    do_fio(&c__1, sname, (ftnlen)12);
+					    do_fio(&c__1, ctrans, (ftnlen)14);
+					    do_fio(&c__1, (char *)&m, (ftnlen)
+						    sizeof(integer));
+					    do_fio(&c__1, (char *)&n, (ftnlen)
+						    sizeof(integer));
+					    do_fio(&c__1, (char *)&alpha, (
+						    ftnlen)sizeof(doublereal))
+						    ;
+					    do_fio(&c__1, (char *)&lda, (
+						    ftnlen)sizeof(integer));
+					    do_fio(&c__1, (char *)&incx, (
+						    ftnlen)sizeof(integer));
+					    do_fio(&c__1, (char *)&beta, (
+						    ftnlen)sizeof(doublereal))
+						    ;
+					    do_fio(&c__1, (char *)&incy, (
+						    ftnlen)sizeof(integer));
+					    e_wsfe();
+					}
+					if (*rewi) {
+					    al__1.aerr = 0;
+					    al__1.aunit = *ntra;
+					    f_rew(&al__1);
+					}
+					cdgemv_(iorder, trans, &m, &n, &alpha,
+						 &aa[1], &lda, &xx[1], &incx, 
+						&beta, &yy[1], &incy);
+				    } else if (banded) {
+					if (*trace) {
+					    io___145.ciunit = *ntra;
+					    s_wsfe(&io___145);
+					    do_fio(&c__1, (char *)&nc, (
+						    ftnlen)sizeof(integer));
+					    do_fio(&c__1, sname, (ftnlen)12);
+					    do_fio(&c__1, ctrans, (ftnlen)14);
+					    do_fio(&c__1, (char *)&m, (ftnlen)
+						    sizeof(integer));
+					    do_fio(&c__1, (char *)&n, (ftnlen)
+						    sizeof(integer));
+					    do_fio(&c__1, (char *)&kl, (
+						    ftnlen)sizeof(integer));
+					    do_fio(&c__1, (char *)&ku, (
+						    ftnlen)sizeof(integer));
+					    do_fio(&c__1, (char *)&alpha, (
+						    ftnlen)sizeof(doublereal))
+						    ;
+					    do_fio(&c__1, (char *)&lda, (
+						    ftnlen)sizeof(integer));
+					    do_fio(&c__1, (char *)&incx, (
+						    ftnlen)sizeof(integer));
+					    do_fio(&c__1, (char *)&beta, (
+						    ftnlen)sizeof(doublereal))
+						    ;
+					    do_fio(&c__1, (char *)&incy, (
+						    ftnlen)sizeof(integer));
+					    e_wsfe();
+					}
+					if (*rewi) {
+					    al__1.aerr = 0;
+					    al__1.aunit = *ntra;
+					    f_rew(&al__1);
+					}
+					cdgbmv_(iorder, trans, &m, &n, &kl, &
+						ku, &alpha, &aa[1], &lda, &xx[
+						1], &incx, &beta, &yy[1], &
+						incy);
+				    }
+
+/*                             Check if error-exit was taken incorrectly. */
+
+				    if (! infoc_1.ok) {
+					io___146.ciunit = *nout;
+					s_wsfe(&io___146);
+					e_wsfe();
+					*fatal = TRUE_;
+					goto L130;
+				    }
+
+/*                             See what data changed inside subroutines. */
+
+				    isame[0] = *(unsigned char *)trans == *(
+					    unsigned char *)transs;
+				    isame[1] = ms == m;
+				    isame[2] = ns == n;
+				    if (full) {
+					isame[3] = als == alpha;
+					isame[4] = lde_(&as[1], &aa[1], &laa);
+					isame[5] = ldas == lda;
+					isame[6] = lde_(&xs[1], &xx[1], &lx);
+					isame[7] = incxs == incx;
+					isame[8] = bls == beta;
+					if (null) {
+					    isame[9] = lde_(&ys[1], &yy[1], &
+						    ly);
+					} else {
+					    i__7 = abs(incy);
+					    isame[9] = lderes_("ge", " ", &
+						    c__1, &ml, &ys[1], &yy[1],
+						     &i__7, (ftnlen)2, (
+						    ftnlen)1);
+					}
+					isame[10] = incys == incy;
+				    } else if (banded) {
+					isame[3] = kls == kl;
+					isame[4] = kus == ku;
+					isame[5] = als == alpha;
+					isame[6] = lde_(&as[1], &aa[1], &laa);
+					isame[7] = ldas == lda;
+					isame[8] = lde_(&xs[1], &xx[1], &lx);
+					isame[9] = incxs == incx;
+					isame[10] = bls == beta;
+					if (null) {
+					    isame[11] = lde_(&ys[1], &yy[1], &
+						    ly);
+					} else {
+					    i__7 = abs(incy);
+					    isame[11] = lderes_("ge", " ", &
+						    c__1, &ml, &ys[1], &yy[1],
+						     &i__7, (ftnlen)2, (
+						    ftnlen)1);
+					}
+					isame[12] = incys == incy;
+				    }
+
+/*                             If data was incorrectly changed, report */
+/*                             and return. */
+
+				    same = TRUE_;
+				    i__7 = nargs;
+				    for (i__ = 1; i__ <= i__7; ++i__) {
+					same = same && isame[i__ - 1];
+					if (! isame[i__ - 1]) {
+					    io___149.ciunit = *nout;
+					    s_wsfe(&io___149);
+					    do_fio(&c__1, (char *)&i__, (
+						    ftnlen)sizeof(integer));
+					    e_wsfe();
+					}
+/* L40: */
+				    }
+				    if (! same) {
+					*fatal = TRUE_;
+					goto L130;
+				    }
+
+				    if (! null) {
+
+/*                                Check the result. */
+
+					dmvch_(trans, &m, &n, &alpha, &a[
+						a_offset], nmax, &x[1], &incx,
+						 &beta, &y[1], &incy, &yt[1], 
+						&g[1], &yy[1], eps, &err, 
+						fatal, nout, &c_true, (ftnlen)
+						1);
+					errmax = max(errmax,err);
+/*                                If got really bad answer, report and */
+/*                                return. */
+					if (*fatal) {
+					    goto L130;
+					}
+				    } else {
+/*                                Avoid repeating tests with M.le.0 or */
+/*                                N.le.0. */
+					goto L110;
+				    }
+
+/* L50: */
+				}
+
+/* L60: */
+			    }
+
+/* L70: */
+			}
+
+/* L80: */
+		    }
+
+/* L90: */
+		}
+
+L100:
+		;
+	    }
+
+L110:
+	    ;
+	}
+
+/* L120: */
+    }
+
+/*     Report result. */
+
+    if (errmax < *thresh) {
+	if (*iorder == 0) {
+	    io___151.ciunit = *nout;
+	    s_wsfe(&io___151);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___152.ciunit = *nout;
+	    s_wsfe(&io___152);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+    } else {
+	if (*iorder == 0) {
+	    io___153.ciunit = *nout;
+	    s_wsfe(&io___153);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___154.ciunit = *nout;
+	    s_wsfe(&io___154);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+	    e_wsfe();
+	}
+    }
+    goto L140;
+
+L130:
+    io___155.ciunit = *nout;
+    s_wsfe(&io___155);
+    do_fio(&c__1, sname, (ftnlen)12);
+    e_wsfe();
+    if (full) {
+	io___156.ciunit = *nout;
+	s_wsfe(&io___156);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, ctrans, (ftnlen)14);
+	do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&beta, (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+	e_wsfe();
+    } else if (banded) {
+	io___157.ciunit = *nout;
+	s_wsfe(&io___157);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, ctrans, (ftnlen)14);
+	do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&kl, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&ku, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&beta, (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+	e_wsfe();
+    }
+
+L140:
+    return 0;
+
+/* L9997: */
+
+/*     End of DCHK1. */
+
+} /* dchk1_ */
+
+/* Subroutine */ int dchk2_(char *sname, doublereal *eps, doublereal *thresh, 
+	integer *nout, integer *ntra, logical *trace, logical *rewi, logical *
+	fatal, integer *nidim, integer *idim, integer *nkb, integer *kb, 
+	integer *nalf, doublereal *alf, integer *nbet, doublereal *bet, 
+	integer *ninc, integer *inc, integer *nmax, integer *incmax, 
+	doublereal *a, doublereal *aa, doublereal *as, doublereal *x, 
+	doublereal *xx, doublereal *xs, doublereal *y, doublereal *yy, 
+	doublereal *ys, doublereal *yt, doublereal *g, integer *iorder, 
+	ftnlen sname_len)
+{
+    /* Initialized data */
+
+    static char ich[2] = "UL";
+
+    /* Format strings */
+    static char fmt_9993[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+	    "i3,\002,\002,f4.1,\002, A,\002,i3,\002, X,\002,i2,\002,\002,f4.1,"
+	    "\002, Y,\002,i2,\002) .\002)";
+    static char fmt_9994[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+	    "2(i3,\002,\002),f4.1,\002, A,\002,i3,\002, X,\002,i2,\002,\002,f"
+	    "4.1,\002, Y,\002,i2,\002) .\002)";
+    static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+	    "i3,\002,\002,f4.1,\002, AP\002,\002, X,\002,i2,\002,\002,f4.1"
+	    ",\002, Y,\002,i2,\002) .\002)";
+    static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+	    "N VALID CALL *\002,\002******\002)";
+    static char fmt_9998[] = "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+	    " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+    static char fmt_10000[] = "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10001[] = "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10002[] = "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+	    "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_10003[] = "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+	    "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+	    "BER:\002)";
+
+    /* System generated locals */
+    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6, i__7, i__8;
+    alist al__1;
+
+    /* Builtin functions */
+    /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+	     f_rew(alist *);
+
+    /* Local variables */
+    integer i__, k, n, ia, ib, ic, nc, ik, in, nk, ks, ix, iy, ns, lx, ly, 
+	    laa, lda;
+    extern logical lde_(doublereal *, doublereal *, integer *);
+    doublereal als, bls, err, beta;
+    integer ldas;
+    logical same;
+    integer incx, incy;
+    logical full, null;
+    char uplo[1];
+    extern /* Subroutine */ int dmake_(char *, char *, char *, integer *, 
+	    integer *, doublereal *, integer *, doublereal *, integer *, 
+	    integer *, integer *, logical *, doublereal *, ftnlen, ftnlen, 
+	    ftnlen);
+    doublereal alpha;
+    logical isame[13];
+    extern /* Subroutine */ int dmvch_(char *, integer *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
+	     doublereal *, doublereal *, doublereal *, logical *, integer *, 
+	    logical *, ftnlen);
+    integer nargs;
+    logical reset;
+    char cuplo[14];
+    integer incxs, incys;
+    char uplos[1];
+    logical banded, packed;
+    extern logical lderes_(char *, char *, integer *, integer *, doublereal *,
+	     doublereal *, integer *, ftnlen, ftnlen);
+    extern /* Subroutine */ void cdsbmv_(integer *, char *, integer *, integer 
+	    *, doublereal *, doublereal *, integer *, doublereal *, integer *,
+	     doublereal *, doublereal *, integer *), cdspmv_(integer *
+	    , char *, integer *, doublereal *, doublereal *, doublereal *, 
+	    integer *, doublereal *, doublereal *, integer *);
+    doublereal errmax, transl;
+    extern /* Subroutine */ void cdsymv_(integer *, char *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
+	    doublereal *, doublereal *, integer *);
+
+    /* Fortran I/O blocks */
+    static cilist io___197 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___198 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___199 = { 0, 0, 0, fmt_9995, 0 };
+    static cilist io___200 = { 0, 0, 0, fmt_9992, 0 };
+    static cilist io___203 = { 0, 0, 0, fmt_9998, 0 };
+    static cilist io___205 = { 0, 0, 0, fmt_10000, 0 };
+    static cilist io___206 = { 0, 0, 0, fmt_10001, 0 };
+    static cilist io___207 = { 0, 0, 0, fmt_10002, 0 };
+    static cilist io___208 = { 0, 0, 0, fmt_10003, 0 };
+    static cilist io___209 = { 0, 0, 0, fmt_9996, 0 };
+    static cilist io___210 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___211 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___212 = { 0, 0, 0, fmt_9995, 0 };
+
+
+
+/*  Tests DSYMV, DSBMV and DSPMV. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Scalars in Common .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+    /* Parameter adjustments */
+    --idim;
+    --kb;
+    --alf;
+    --bet;
+    --inc;
+    --g;
+    --yt;
+    --y;
+    --x;
+    --as;
+    --aa;
+    a_dim1 = *nmax;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --ys;
+    --yy;
+    --xs;
+    --xx;
+
+    /* Function Body */
+/*     .. Executable Statements .. */
+    full = *(unsigned char *)&sname[8] == 'y';
+    banded = *(unsigned char *)&sname[8] == 'b';
+    packed = *(unsigned char *)&sname[8] == 'p';
+/*     Define the number of arguments. */
+    if (full) {
+	nargs = 10;
+    } else if (banded) {
+	nargs = 11;
+    } else if (packed) {
+	nargs = 9;
+    }
+
+    nc = 0;
+    reset = TRUE_;
+    errmax = 0.;
+
+    i__1 = *nidim;
+    for (in = 1; in <= i__1; ++in) {
+	n = idim[in];
+
+	if (banded) {
+	    nk = *nkb;
+	} else {
+	    nk = 1;
+	}
+	i__2 = nk;
+	for (ik = 1; ik <= i__2; ++ik) {
+	    if (banded) {
+		k = kb[ik];
+	    } else {
+		k = n - 1;
+	    }
+/*           Set LDA to 1 more than minimum value if room. */
+	    if (banded) {
+		lda = k + 1;
+	    } else {
+		lda = n;
+	    }
+	    if (lda < *nmax) {
+		++lda;
+	    }
+/*           Skip tests if not enough room. */
+	    if (lda > *nmax) {
+		goto L100;
+	    }
+	    if (packed) {
+		laa = n * (n + 1) / 2;
+	    } else {
+		laa = lda * n;
+	    }
+	    null = n <= 0;
+
+	    for (ic = 1; ic <= 2; ++ic) {
+		*(unsigned char *)uplo = *(unsigned char *)&ich[ic - 1];
+		if (*(unsigned char *)uplo == 'U') {
+		    s_copy(cuplo, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+		} else {
+		    s_copy(cuplo, "    CblasLower", (ftnlen)14, (ftnlen)14);
+		}
+
+/*              Generate the matrix A. */
+
+		transl = 0.;
+		dmake_(sname + 7, uplo, " ", &n, &n, &a[a_offset], nmax, &aa[
+			1], &lda, &k, &k, &reset, &transl, (ftnlen)2, (ftnlen)
+			1, (ftnlen)1);
+
+		i__3 = *ninc;
+		for (ix = 1; ix <= i__3; ++ix) {
+		    incx = inc[ix];
+		    lx = abs(incx) * n;
+
+/*                 Generate the vector X. */
+
+		    transl = .5;
+		    i__4 = abs(incx);
+		    i__5 = n - 1;
+		    dmake_("ge", " ", " ", &c__1, &n, &x[1], &c__1, &xx[1], &
+			    i__4, &c__0, &i__5, &reset, &transl, (ftnlen)2, (
+			    ftnlen)1, (ftnlen)1);
+		    if (n > 1) {
+			x[n / 2] = 0.;
+			xx[abs(incx) * (n / 2 - 1) + 1] = 0.;
+		    }
+
+		    i__4 = *ninc;
+		    for (iy = 1; iy <= i__4; ++iy) {
+			incy = inc[iy];
+			ly = abs(incy) * n;
+
+			i__5 = *nalf;
+			for (ia = 1; ia <= i__5; ++ia) {
+			    alpha = alf[ia];
+
+			    i__6 = *nbet;
+			    for (ib = 1; ib <= i__6; ++ib) {
+				beta = bet[ib];
+
+/*                          Generate the vector Y. */
+
+				transl = 0.;
+				i__7 = abs(incy);
+				i__8 = n - 1;
+				dmake_("ge", " ", " ", &c__1, &n, &y[1], &
+					c__1, &yy[1], &i__7, &c__0, &i__8, &
+					reset, &transl, (ftnlen)2, (ftnlen)1, 
+					(ftnlen)1);
+
+				++nc;
+
+/*                          Save every datum before calling the */
+/*                          subroutine. */
+
+				*(unsigned char *)uplos = *(unsigned char *)
+					uplo;
+				ns = n;
+				ks = k;
+				als = alpha;
+				i__7 = laa;
+				for (i__ = 1; i__ <= i__7; ++i__) {
+				    as[i__] = aa[i__];
+/* L10: */
+				}
+				ldas = lda;
+				i__7 = lx;
+				for (i__ = 1; i__ <= i__7; ++i__) {
+				    xs[i__] = xx[i__];
+/* L20: */
+				}
+				incxs = incx;
+				bls = beta;
+				i__7 = ly;
+				for (i__ = 1; i__ <= i__7; ++i__) {
+				    ys[i__] = yy[i__];
+/* L30: */
+				}
+				incys = incy;
+
+/*                          Call the subroutine. */
+
+				if (full) {
+				    if (*trace) {
+					io___197.ciunit = *ntra;
+					s_wsfe(&io___197);
+					do_fio(&c__1, (char *)&nc, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, sname, (ftnlen)12);
+					do_fio(&c__1, cuplo, (ftnlen)14);
+					do_fio(&c__1, (char *)&n, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&alpha, (ftnlen)
+						sizeof(doublereal));
+					do_fio(&c__1, (char *)&lda, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&incx, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&beta, (ftnlen)
+						sizeof(doublereal));
+					do_fio(&c__1, (char *)&incy, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+				    if (*rewi) {
+					al__1.aerr = 0;
+					al__1.aunit = *ntra;
+					f_rew(&al__1);
+				    }
+				    cdsymv_(iorder, uplo, &n, &alpha, &aa[1], 
+					    &lda, &xx[1], &incx, &beta, &yy[1]
+					    , &incy);
+				} else if (banded) {
+				    if (*trace) {
+					io___198.ciunit = *ntra;
+					s_wsfe(&io___198);
+					do_fio(&c__1, (char *)&nc, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, sname, (ftnlen)12);
+					do_fio(&c__1, cuplo, (ftnlen)14);
+					do_fio(&c__1, (char *)&n, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&k, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&alpha, (ftnlen)
+						sizeof(doublereal));
+					do_fio(&c__1, (char *)&lda, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&incx, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&beta, (ftnlen)
+						sizeof(doublereal));
+					do_fio(&c__1, (char *)&incy, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+				    if (*rewi) {
+					al__1.aerr = 0;
+					al__1.aunit = *ntra;
+					f_rew(&al__1);
+				    }
+				    cdsbmv_(iorder, uplo, &n, &k, &alpha, &aa[
+					    1], &lda, &xx[1], &incx, &beta, &
+					    yy[1], &incy);
+				} else if (packed) {
+				    if (*trace) {
+					io___199.ciunit = *ntra;
+					s_wsfe(&io___199);
+					do_fio(&c__1, (char *)&nc, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, sname, (ftnlen)12);
+					do_fio(&c__1, cuplo, (ftnlen)14);
+					do_fio(&c__1, (char *)&n, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&alpha, (ftnlen)
+						sizeof(doublereal));
+					do_fio(&c__1, (char *)&incx, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&beta, (ftnlen)
+						sizeof(doublereal));
+					do_fio(&c__1, (char *)&incy, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+				    if (*rewi) {
+					al__1.aerr = 0;
+					al__1.aunit = *ntra;
+					f_rew(&al__1);
+				    }
+				    cdspmv_(iorder, uplo, &n, &alpha, &aa[1], 
+					    &xx[1], &incx, &beta, &yy[1], &
+					    incy);
+				}
+
+/*                          Check if error-exit was taken incorrectly. */
+
+				if (! infoc_1.ok) {
+				    io___200.ciunit = *nout;
+				    s_wsfe(&io___200);
+				    e_wsfe();
+				    *fatal = TRUE_;
+				    goto L120;
+				}
+
+/*                          See what data changed inside subroutines. */
+
+				isame[0] = *(unsigned char *)uplo == *(
+					unsigned char *)uplos;
+				isame[1] = ns == n;
+				if (full) {
+				    isame[2] = als == alpha;
+				    isame[3] = lde_(&as[1], &aa[1], &laa);
+				    isame[4] = ldas == lda;
+				    isame[5] = lde_(&xs[1], &xx[1], &lx);
+				    isame[6] = incxs == incx;
+				    isame[7] = bls == beta;
+				    if (null) {
+					isame[8] = lde_(&ys[1], &yy[1], &ly);
+				    } else {
+					i__7 = abs(incy);
+					isame[8] = lderes_("ge", " ", &c__1, &
+						n, &ys[1], &yy[1], &i__7, (
+						ftnlen)2, (ftnlen)1);
+				    }
+				    isame[9] = incys == incy;
+				} else if (banded) {
+				    isame[2] = ks == k;
+				    isame[3] = als == alpha;
+				    isame[4] = lde_(&as[1], &aa[1], &laa);
+				    isame[5] = ldas == lda;
+				    isame[6] = lde_(&xs[1], &xx[1], &lx);
+				    isame[7] = incxs == incx;
+				    isame[8] = bls == beta;
+				    if (null) {
+					isame[9] = lde_(&ys[1], &yy[1], &ly);
+				    } else {
+					i__7 = abs(incy);
+					isame[9] = lderes_("ge", " ", &c__1, &
+						n, &ys[1], &yy[1], &i__7, (
+						ftnlen)2, (ftnlen)1);
+				    }
+				    isame[10] = incys == incy;
+				} else if (packed) {
+				    isame[2] = als == alpha;
+				    isame[3] = lde_(&as[1], &aa[1], &laa);
+				    isame[4] = lde_(&xs[1], &xx[1], &lx);
+				    isame[5] = incxs == incx;
+				    isame[6] = bls == beta;
+				    if (null) {
+					isame[7] = lde_(&ys[1], &yy[1], &ly);
+				    } else {
+					i__7 = abs(incy);
+					isame[7] = lderes_("ge", " ", &c__1, &
+						n, &ys[1], &yy[1], &i__7, (
+						ftnlen)2, (ftnlen)1);
+				    }
+				    isame[8] = incys == incy;
+				}
+
+/*                          If data was incorrectly changed, report and */
+/*                          return. */
+
+				same = TRUE_;
+				i__7 = nargs;
+				for (i__ = 1; i__ <= i__7; ++i__) {
+				    same = same && isame[i__ - 1];
+				    if (! isame[i__ - 1]) {
+					io___203.ciunit = *nout;
+					s_wsfe(&io___203);
+					do_fio(&c__1, (char *)&i__, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+/* L40: */
+				}
+				if (! same) {
+				    *fatal = TRUE_;
+				    goto L120;
+				}
+
+				if (! null) {
+
+/*                             Check the result. */
+
+				    dmvch_("N", &n, &n, &alpha, &a[a_offset], 
+					    nmax, &x[1], &incx, &beta, &y[1], 
+					    &incy, &yt[1], &g[1], &yy[1], eps,
+					     &err, fatal, nout, &c_true, (
+					    ftnlen)1);
+				    errmax = max(errmax,err);
+/*                             If got really bad answer, report and */
+/*                             return. */
+				    if (*fatal) {
+					goto L120;
+				    }
+				} else {
+/*                             Avoid repeating tests with N.le.0 */
+				    goto L110;
+				}
+
+/* L50: */
+			    }
+
+/* L60: */
+			}
+
+/* L70: */
+		    }
+
+/* L80: */
+		}
+
+/* L90: */
+	    }
+
+L100:
+	    ;
+	}
+
+L110:
+	;
+    }
+
+/*     Report result. */
+
+    if (errmax < *thresh) {
+	if (*iorder == 0) {
+	    io___205.ciunit = *nout;
+	    s_wsfe(&io___205);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___206.ciunit = *nout;
+	    s_wsfe(&io___206);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+    } else {
+	if (*iorder == 0) {
+	    io___207.ciunit = *nout;
+	    s_wsfe(&io___207);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___208.ciunit = *nout;
+	    s_wsfe(&io___208);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+	    e_wsfe();
+	}
+    }
+    goto L130;
+
+L120:
+    io___209.ciunit = *nout;
+    s_wsfe(&io___209);
+    do_fio(&c__1, sname, (ftnlen)12);
+    e_wsfe();
+    if (full) {
+	io___210.ciunit = *nout;
+	s_wsfe(&io___210);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&beta, (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+	e_wsfe();
+    } else if (banded) {
+	io___211.ciunit = *nout;
+	s_wsfe(&io___211);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&k, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&beta, (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+	e_wsfe();
+    } else if (packed) {
+	io___212.ciunit = *nout;
+	s_wsfe(&io___212);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&beta, (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+	e_wsfe();
+    }
+
+L130:
+    return 0;
+
+/* L9997: */
+
+/*     End of DCHK2. */
+
+} /* dchk2_ */
+
+/* Subroutine */ int dchk3_(char *sname, doublereal *eps, doublereal *thresh, 
+	integer *nout, integer *ntra, logical *trace, logical *rewi, logical *
+	fatal, integer *nidim, integer *idim, integer *nkb, integer *kb, 
+	integer *ninc, integer *inc, integer *nmax, integer *incmax, 
+	doublereal *a, doublereal *aa, doublereal *as, doublereal *x, 
+	doublereal *xx, doublereal *xs, doublereal *xt, doublereal *g, 
+	doublereal *z__, integer *iorder, ftnlen sname_len)
+{
+    /* Initialized data */
+
+    static char ichu[2] = "UL";
+    static char icht[3] = "NTC";
+    static char ichd[2] = "UN";
+
+    /* Format strings */
+    static char fmt_9993[] = "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+	    "\002),/10x,i3,\002, A,\002,i3,\002, X,\002,i2,\002) .\002)";
+    static char fmt_9994[] = "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+	    "\002),/10x,2(i3,\002,\002),\002 A,\002,i3,\002, X,\002,i2,\002) ."
+	    "\002)";
+    static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+	    "\002),/10x,i3,\002, AP, \002,\002X,\002,i2,\002) .\002)";
+    static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+	    "N VALID CALL *\002,\002******\002)";
+    static char fmt_9998[] = "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+	    " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+    static char fmt_10000[] = "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10001[] = "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10002[] = "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+	    "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_10003[] = "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+	    "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+	    "BER:\002)";
+
+    /* System generated locals */
+    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
+    alist al__1;
+
+    /* Builtin functions */
+    /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+    integer s_cmp(char *, char *, ftnlen, ftnlen), s_wsfe(cilist *), do_fio(
+	    integer *, char *, ftnlen), e_wsfe(void), f_rew(alist *);
+
+    /* Local variables */
+    integer i__, k, n, nc, ik, in, nk, ks, ix, ns, lx, laa, icd, lda;
+    extern logical lde_(doublereal *, doublereal *, integer *);
+    integer ict, icu;
+    doublereal err;
+    char diag[1];
+    integer ldas;
+    logical same;
+    integer incx;
+    logical full, null;
+    char uplo[1], cdiag[14];
+    extern /* Subroutine */ int dmake_(char *, char *, char *, integer *, 
+	    integer *, doublereal *, integer *, doublereal *, integer *, 
+	    integer *, integer *, logical *, doublereal *, ftnlen, ftnlen, 
+	    ftnlen);
+    char diags[1];
+    logical isame[13];
+    extern /* Subroutine */ int dmvch_(char *, integer *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
+	     doublereal *, doublereal *, doublereal *, logical *, integer *, 
+	    logical *, ftnlen);
+    integer nargs;
+    logical reset;
+    char cuplo[14];
+    integer incxs;
+    char trans[1], uplos[1];
+    logical banded, packed;
+    extern logical lderes_(char *, char *, integer *, integer *, doublereal *,
+	     doublereal *, integer *, ftnlen, ftnlen);
+    extern /* Subroutine */ void cdtbmv_(integer *, char *, char *, char *, 
+	    integer *, integer *, doublereal *, integer *, doublereal *, 
+	    integer *), cdtbsv_(integer *, char *, 
+	    char *, char *, integer *, integer *, doublereal *, integer *, 
+	    doublereal *, integer *);
+    char ctrans[14];
+    doublereal errmax;
+    extern /* Subroutine */ void cdtpmv_(integer *, char *, char *, char *, 
+	    integer *, doublereal *, doublereal *, integer *),
+	    cdtrmv_(integer *, char *, char *, char *, integer *, 
+	    doublereal *, integer *, doublereal *, integer *);
+    doublereal transl;
+    extern /* Subroutine */ void cdtpsv_(integer *, char *, char *, char *, 
+	    integer *, doublereal *, doublereal *, integer *),
+	    cdtrsv_(integer *, char *, char *, char *, integer *, 
+	    doublereal *, integer *, doublereal *, integer *);
+    char transs[1];
+
+    /* Fortran I/O blocks */
+    static cilist io___252 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___253 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___254 = { 0, 0, 0, fmt_9995, 0 };
+    static cilist io___255 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___256 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___257 = { 0, 0, 0, fmt_9995, 0 };
+    static cilist io___258 = { 0, 0, 0, fmt_9992, 0 };
+    static cilist io___261 = { 0, 0, 0, fmt_9998, 0 };
+    static cilist io___263 = { 0, 0, 0, fmt_10000, 0 };
+    static cilist io___264 = { 0, 0, 0, fmt_10001, 0 };
+    static cilist io___265 = { 0, 0, 0, fmt_10002, 0 };
+    static cilist io___266 = { 0, 0, 0, fmt_10003, 0 };
+    static cilist io___267 = { 0, 0, 0, fmt_9996, 0 };
+    static cilist io___268 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___269 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___270 = { 0, 0, 0, fmt_9995, 0 };
+
+
+
+/*  Tests DTRMV, DTBMV, DTPMV, DTRSV, DTBSV and DTPSV. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Scalars in Common .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+    /* Parameter adjustments */
+    --idim;
+    --kb;
+    --inc;
+    --z__;
+    --g;
+    --xt;
+    --x;
+    --as;
+    --aa;
+    a_dim1 = *nmax;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --xs;
+    --xx;
+
+    /* Function Body */
+/*     .. Executable Statements .. */
+    full = *(unsigned char *)&sname[8] == 'r';
+    banded = *(unsigned char *)&sname[8] == 'b';
+    packed = *(unsigned char *)&sname[8] == 'p';
+/*     Define the number of arguments. */
+    if (full) {
+	nargs = 8;
+    } else if (banded) {
+	nargs = 9;
+    } else if (packed) {
+	nargs = 7;
+    }
+
+    nc = 0;
+    reset = TRUE_;
+    errmax = 0.;
+/*     Set up zero vector for DMVCH. */
+    i__1 = *nmax;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	z__[i__] = 0.;
+/* L10: */
+    }
+
+    i__1 = *nidim;
+    for (in = 1; in <= i__1; ++in) {
+	n = idim[in];
+
+	if (banded) {
+	    nk = *nkb;
+	} else {
+	    nk = 1;
+	}
+	i__2 = nk;
+	for (ik = 1; ik <= i__2; ++ik) {
+	    if (banded) {
+		k = kb[ik];
+	    } else {
+		k = n - 1;
+	    }
+/*           Set LDA to 1 more than minimum value if room. */
+	    if (banded) {
+		lda = k + 1;
+	    } else {
+		lda = n;
+	    }
+	    if (lda < *nmax) {
+		++lda;
+	    }
+/*           Skip tests if not enough room. */
+	    if (lda > *nmax) {
+		goto L100;
+	    }
+	    if (packed) {
+		laa = n * (n + 1) / 2;
+	    } else {
+		laa = lda * n;
+	    }
+	    null = n <= 0;
+
+	    for (icu = 1; icu <= 2; ++icu) {
+		*(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+		if (*(unsigned char *)uplo == 'U') {
+		    s_copy(cuplo, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+		} else {
+		    s_copy(cuplo, "    CblasLower", (ftnlen)14, (ftnlen)14);
+		}
+
+		for (ict = 1; ict <= 3; ++ict) {
+		    *(unsigned char *)trans = *(unsigned char *)&icht[ict - 1]
+			    ;
+		    if (*(unsigned char *)trans == 'N') {
+			s_copy(ctrans, "  CblasNoTrans", (ftnlen)14, (ftnlen)
+				14);
+		    } else if (*(unsigned char *)trans == 'T') {
+			s_copy(ctrans, "    CblasTrans", (ftnlen)14, (ftnlen)
+				14);
+		    } else {
+			s_copy(ctrans, "CblasConjTrans", (ftnlen)14, (ftnlen)
+				14);
+		    }
+
+		    for (icd = 1; icd <= 2; ++icd) {
+			*(unsigned char *)diag = *(unsigned char *)&ichd[icd 
+				- 1];
+			if (*(unsigned char *)diag == 'N') {
+			    s_copy(cdiag, "  CblasNonUnit", (ftnlen)14, (
+				    ftnlen)14);
+			} else {
+			    s_copy(cdiag, "     CblasUnit", (ftnlen)14, (
+				    ftnlen)14);
+			}
+
+/*                    Generate the matrix A. */
+
+			transl = 0.;
+			dmake_(sname + 7, uplo, diag, &n, &n, &a[a_offset], 
+				nmax, &aa[1], &lda, &k, &k, &reset, &transl, (
+				ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+			i__3 = *ninc;
+			for (ix = 1; ix <= i__3; ++ix) {
+			    incx = inc[ix];
+			    lx = abs(incx) * n;
+
+/*                       Generate the vector X. */
+
+			    transl = .5;
+			    i__4 = abs(incx);
+			    i__5 = n - 1;
+			    dmake_("ge", " ", " ", &c__1, &n, &x[1], &c__1, &
+				    xx[1], &i__4, &c__0, &i__5, &reset, &
+				    transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+			    if (n > 1) {
+				x[n / 2] = 0.;
+				xx[abs(incx) * (n / 2 - 1) + 1] = 0.;
+			    }
+
+			    ++nc;
+
+/*                       Save every datum before calling the subroutine. */
+
+			    *(unsigned char *)uplos = *(unsigned char *)uplo;
+			    *(unsigned char *)transs = *(unsigned char *)
+				    trans;
+			    *(unsigned char *)diags = *(unsigned char *)diag;
+			    ns = n;
+			    ks = k;
+			    i__4 = laa;
+			    for (i__ = 1; i__ <= i__4; ++i__) {
+				as[i__] = aa[i__];
+/* L20: */
+			    }
+			    ldas = lda;
+			    i__4 = lx;
+			    for (i__ = 1; i__ <= i__4; ++i__) {
+				xs[i__] = xx[i__];
+/* L30: */
+			    }
+			    incxs = incx;
+
+/*                       Call the subroutine. */
+
+			    if (s_cmp(sname + 9, "mv", (ftnlen)2, (ftnlen)2) 
+				    == 0) {
+				if (full) {
+				    if (*trace) {
+					io___252.ciunit = *ntra;
+					s_wsfe(&io___252);
+					do_fio(&c__1, (char *)&nc, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, sname, (ftnlen)12);
+					do_fio(&c__1, cuplo, (ftnlen)14);
+					do_fio(&c__1, ctrans, (ftnlen)14);
+					do_fio(&c__1, cdiag, (ftnlen)14);
+					do_fio(&c__1, (char *)&n, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&lda, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&incx, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+				    if (*rewi) {
+					al__1.aerr = 0;
+					al__1.aunit = *ntra;
+					f_rew(&al__1);
+				    }
+				    cdtrmv_(iorder, uplo, trans, diag, &n, &
+					    aa[1], &lda, &xx[1], &incx);
+				} else if (banded) {
+				    if (*trace) {
+					io___253.ciunit = *ntra;
+					s_wsfe(&io___253);
+					do_fio(&c__1, (char *)&nc, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, sname, (ftnlen)12);
+					do_fio(&c__1, cuplo, (ftnlen)14);
+					do_fio(&c__1, ctrans, (ftnlen)14);
+					do_fio(&c__1, cdiag, (ftnlen)14);
+					do_fio(&c__1, (char *)&n, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&k, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&lda, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&incx, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+				    if (*rewi) {
+					al__1.aerr = 0;
+					al__1.aunit = *ntra;
+					f_rew(&al__1);
+				    }
+				    cdtbmv_(iorder, uplo, trans, diag, &n, &k,
+					     &aa[1], &lda, &xx[1], &incx);
+				} else if (packed) {
+				    if (*trace) {
+					io___254.ciunit = *ntra;
+					s_wsfe(&io___254);
+					do_fio(&c__1, (char *)&nc, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, sname, (ftnlen)12);
+					do_fio(&c__1, cuplo, (ftnlen)14);
+					do_fio(&c__1, ctrans, (ftnlen)14);
+					do_fio(&c__1, cdiag, (ftnlen)14);
+					do_fio(&c__1, (char *)&n, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&incx, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+				    if (*rewi) {
+					al__1.aerr = 0;
+					al__1.aunit = *ntra;
+					f_rew(&al__1);
+				    }
+				    cdtpmv_(iorder, uplo, trans, diag, &n, &
+					    aa[1], &xx[1], &incx);
+				}
+			    } else if (s_cmp(sname + 9, "sv", (ftnlen)2, (
+				    ftnlen)2) == 0) {
+				if (full) {
+				    if (*trace) {
+					io___255.ciunit = *ntra;
+					s_wsfe(&io___255);
+					do_fio(&c__1, (char *)&nc, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, sname, (ftnlen)12);
+					do_fio(&c__1, cuplo, (ftnlen)14);
+					do_fio(&c__1, ctrans, (ftnlen)14);
+					do_fio(&c__1, cdiag, (ftnlen)14);
+					do_fio(&c__1, (char *)&n, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&lda, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&incx, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+				    if (*rewi) {
+					al__1.aerr = 0;
+					al__1.aunit = *ntra;
+					f_rew(&al__1);
+				    }
+				    cdtrsv_(iorder, uplo, trans, diag, &n, &
+					    aa[1], &lda, &xx[1], &incx);
+				} else if (banded) {
+				    if (*trace) {
+					io___256.ciunit = *ntra;
+					s_wsfe(&io___256);
+					do_fio(&c__1, (char *)&nc, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, sname, (ftnlen)12);
+					do_fio(&c__1, cuplo, (ftnlen)14);
+					do_fio(&c__1, ctrans, (ftnlen)14);
+					do_fio(&c__1, cdiag, (ftnlen)14);
+					do_fio(&c__1, (char *)&n, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&k, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&lda, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&incx, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+				    if (*rewi) {
+					al__1.aerr = 0;
+					al__1.aunit = *ntra;
+					f_rew(&al__1);
+				    }
+				    cdtbsv_(iorder, uplo, trans, diag, &n, &k,
+					     &aa[1], &lda, &xx[1], &incx);
+				} else if (packed) {
+				    if (*trace) {
+					io___257.ciunit = *ntra;
+					s_wsfe(&io___257);
+					do_fio(&c__1, (char *)&nc, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, sname, (ftnlen)12);
+					do_fio(&c__1, cuplo, (ftnlen)14);
+					do_fio(&c__1, ctrans, (ftnlen)14);
+					do_fio(&c__1, cdiag, (ftnlen)14);
+					do_fio(&c__1, (char *)&n, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&incx, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+				    if (*rewi) {
+					al__1.aerr = 0;
+					al__1.aunit = *ntra;
+					f_rew(&al__1);
+				    }
+				    cdtpsv_(iorder, uplo, trans, diag, &n, &
+					    aa[1], &xx[1], &incx);
+				}
+			    }
+
+/*                       Check if error-exit was taken incorrectly. */
+
+			    if (! infoc_1.ok) {
+				io___258.ciunit = *nout;
+				s_wsfe(&io___258);
+				e_wsfe();
+				*fatal = TRUE_;
+				goto L120;
+			    }
+
+/*                       See what data changed inside subroutines. */
+
+			    isame[0] = *(unsigned char *)uplo == *(unsigned 
+				    char *)uplos;
+			    isame[1] = *(unsigned char *)trans == *(unsigned 
+				    char *)transs;
+			    isame[2] = *(unsigned char *)diag == *(unsigned 
+				    char *)diags;
+			    isame[3] = ns == n;
+			    if (full) {
+				isame[4] = lde_(&as[1], &aa[1], &laa);
+				isame[5] = ldas == lda;
+				if (null) {
+				    isame[6] = lde_(&xs[1], &xx[1], &lx);
+				} else {
+				    i__4 = abs(incx);
+				    isame[6] = lderes_("ge", " ", &c__1, &n, &
+					    xs[1], &xx[1], &i__4, (ftnlen)2, (
+					    ftnlen)1);
+				}
+				isame[7] = incxs == incx;
+			    } else if (banded) {
+				isame[4] = ks == k;
+				isame[5] = lde_(&as[1], &aa[1], &laa);
+				isame[6] = ldas == lda;
+				if (null) {
+				    isame[7] = lde_(&xs[1], &xx[1], &lx);
+				} else {
+				    i__4 = abs(incx);
+				    isame[7] = lderes_("ge", " ", &c__1, &n, &
+					    xs[1], &xx[1], &i__4, (ftnlen)2, (
+					    ftnlen)1);
+				}
+				isame[8] = incxs == incx;
+			    } else if (packed) {
+				isame[4] = lde_(&as[1], &aa[1], &laa);
+				if (null) {
+				    isame[5] = lde_(&xs[1], &xx[1], &lx);
+				} else {
+				    i__4 = abs(incx);
+				    isame[5] = lderes_("ge", " ", &c__1, &n, &
+					    xs[1], &xx[1], &i__4, (ftnlen)2, (
+					    ftnlen)1);
+				}
+				isame[6] = incxs == incx;
+			    }
+
+/*                       If data was incorrectly changed, report and */
+/*                       return. */
+
+			    same = TRUE_;
+			    i__4 = nargs;
+			    for (i__ = 1; i__ <= i__4; ++i__) {
+				same = same && isame[i__ - 1];
+				if (! isame[i__ - 1]) {
+				    io___261.ciunit = *nout;
+				    s_wsfe(&io___261);
+				    do_fio(&c__1, (char *)&i__, (ftnlen)
+					    sizeof(integer));
+				    e_wsfe();
+				}
+/* L40: */
+			    }
+			    if (! same) {
+				*fatal = TRUE_;
+				goto L120;
+			    }
+
+			    if (! null) {
+				if (s_cmp(sname + 9, "mv", (ftnlen)2, (ftnlen)
+					2) == 0) {
+
+/*                             Check the result. */
+
+				    dmvch_(trans, &n, &n, &c_b123, &a[
+					    a_offset], nmax, &x[1], &incx, &
+					    c_b135, &z__[1], &incx, &xt[1], &
+					    g[1], &xx[1], eps, &err, fatal, 
+					    nout, &c_true, (ftnlen)1);
+				} else if (s_cmp(sname + 9, "sv", (ftnlen)2, (
+					ftnlen)2) == 0) {
+
+/*                             Compute approximation to original vector. */
+
+				    i__4 = n;
+				    for (i__ = 1; i__ <= i__4; ++i__) {
+					z__[i__] = xx[(i__ - 1) * abs(incx) + 
+						1];
+					xx[(i__ - 1) * abs(incx) + 1] = x[i__]
+						;
+/* L50: */
+				    }
+				    dmvch_(trans, &n, &n, &c_b123, &a[
+					    a_offset], nmax, &z__[1], &incx, &
+					    c_b135, &x[1], &incx, &xt[1], &g[
+					    1], &xx[1], eps, &err, fatal, 
+					    nout, &c_false, (ftnlen)1);
+				}
+				errmax = max(errmax,err);
+/*                          If got really bad answer, report and return. */
+				if (*fatal) {
+				    goto L120;
+				}
+			    } else {
+/*                          Avoid repeating tests with N.le.0. */
+				goto L110;
+			    }
+
+/* L60: */
+			}
+
+/* L70: */
+		    }
+
+/* L80: */
+		}
+
+/* L90: */
+	    }
+
+L100:
+	    ;
+	}
+
+L110:
+	;
+    }
+
+/*     Report result. */
+
+    if (errmax < *thresh) {
+	if (*iorder == 0) {
+	    io___263.ciunit = *nout;
+	    s_wsfe(&io___263);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___264.ciunit = *nout;
+	    s_wsfe(&io___264);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+    } else {
+	if (*iorder == 0) {
+	    io___265.ciunit = *nout;
+	    s_wsfe(&io___265);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___266.ciunit = *nout;
+	    s_wsfe(&io___266);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+	    e_wsfe();
+	}
+    }
+    goto L130;
+
+L120:
+    io___267.ciunit = *nout;
+    s_wsfe(&io___267);
+    do_fio(&c__1, sname, (ftnlen)12);
+    e_wsfe();
+    if (full) {
+	io___268.ciunit = *nout;
+	s_wsfe(&io___268);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, ctrans, (ftnlen)14);
+	do_fio(&c__1, cdiag, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	e_wsfe();
+    } else if (banded) {
+	io___269.ciunit = *nout;
+	s_wsfe(&io___269);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, ctrans, (ftnlen)14);
+	do_fio(&c__1, cdiag, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&k, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	e_wsfe();
+    } else if (packed) {
+	io___270.ciunit = *nout;
+	s_wsfe(&io___270);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, ctrans, (ftnlen)14);
+	do_fio(&c__1, cdiag, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	e_wsfe();
+    }
+
+L130:
+    return 0;
+
+/* L9997: */
+
+/*     End of DCHK3. */
+
+} /* dchk3_ */
+
+/* Subroutine */ int dchk4_(char *sname, doublereal *eps, doublereal *thresh, 
+	integer *nout, integer *ntra, logical *trace, logical *rewi, logical *
+	fatal, integer *nidim, integer *idim, integer *nalf, doublereal *alf, 
+	integer *ninc, integer *inc, integer *nmax, integer *incmax, 
+	doublereal *a, doublereal *aa, doublereal *as, doublereal *x, 
+	doublereal *xx, doublereal *xs, doublereal *y, doublereal *yy, 
+	doublereal *ys, doublereal *yt, doublereal *g, doublereal *z__, 
+	integer *iorder, ftnlen sname_len)
+{
+    /* Format strings */
+    static char fmt_9994[] = "(1x,i6,\002: \002,a12,\002(\002,2(i3,\002,\002"
+	    "),f4.1,\002, X,\002,i2,\002, Y,\002,i2,\002, A,\002,i3,\002)    "
+	    "              .\002)";
+    static char fmt_9993[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+	    "N VALID CALL *\002,\002******\002)";
+    static char fmt_9998[] = "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+	    " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+    static char fmt_10000[] = "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10001[] = "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10002[] = "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+	    "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_10003[] = "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+	    "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+	    " \002,i3)";
+    static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+	    "BER:\002)";
+
+    /* System generated locals */
+    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;
+    alist al__1;
+
+    /* Builtin functions */
+    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+	     f_rew(alist *);
+
+    /* Local variables */
+    integer i__, j, m, n;
+    doublereal w[1];
+    integer ia, nc, nd, im, in, ms, ix, iy, ns, lx, ly, laa, lda;
+    extern logical lde_(doublereal *, doublereal *, integer *);
+    doublereal als, err;
+    integer ldas;
+    logical same;
+    integer incx, incy;
+    logical null;
+    extern /* Subroutine */ int dmake_(char *, char *, char *, integer *, 
+	    integer *, doublereal *, integer *, doublereal *, integer *, 
+	    integer *, integer *, logical *, doublereal *, ftnlen, ftnlen, 
+	    ftnlen);
+    void cdger_(integer *, integer *, integer *, doublereal *, 
+	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
+	    integer *);
+    doublereal alpha;
+    logical isame[13];
+    extern /* Subroutine */ int dmvch_(char *, integer *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
+	     doublereal *, doublereal *, doublereal *, logical *, integer *, 
+	    logical *, ftnlen);
+    integer nargs;
+    logical reset;
+    integer incxs, incys;
+    extern logical lderes_(char *, char *, integer *, integer *, doublereal *,
+	     doublereal *, integer *, ftnlen, ftnlen);
+    doublereal errmax, transl;
+
+    /* Fortran I/O blocks */
+    static cilist io___299 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___300 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___303 = { 0, 0, 0, fmt_9998, 0 };
+    static cilist io___307 = { 0, 0, 0, fmt_10000, 0 };
+    static cilist io___308 = { 0, 0, 0, fmt_10001, 0 };
+    static cilist io___309 = { 0, 0, 0, fmt_10002, 0 };
+    static cilist io___310 = { 0, 0, 0, fmt_10003, 0 };
+    static cilist io___311 = { 0, 0, 0, fmt_9995, 0 };
+    static cilist io___312 = { 0, 0, 0, fmt_9996, 0 };
+    static cilist io___313 = { 0, 0, 0, fmt_9994, 0 };
+
+
+
+/*  Tests DGER. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Scalars in Common .. */
+/*     .. Common blocks .. */
+/*     .. Executable Statements .. */
+/*     Define the number of arguments. */
+    /* Parameter adjustments */
+    --idim;
+    --alf;
+    --inc;
+    --z__;
+    --g;
+    --yt;
+    --y;
+    --x;
+    --as;
+    --aa;
+    a_dim1 = *nmax;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --ys;
+    --yy;
+    --xs;
+    --xx;
+
+    /* Function Body */
+    nargs = 9;
+
+    nc = 0;
+    reset = TRUE_;
+    errmax = 0.;
+
+    i__1 = *nidim;
+    for (in = 1; in <= i__1; ++in) {
+	n = idim[in];
+	nd = n / 2 + 1;
+
+	for (im = 1; im <= 2; ++im) {
+	    if (im == 1) {
+/* Computing MAX */
+		i__2 = n - nd;
+		m = max(i__2,0);
+	    }
+	    if (im == 2) {
+/* Computing MIN */
+		i__2 = n + nd;
+		m = min(i__2,*nmax);
+	    }
+
+/*           Set LDA to 1 more than minimum value if room. */
+	    lda = m;
+	    if (lda < *nmax) {
+		++lda;
+	    }
+/*           Skip tests if not enough room. */
+	    if (lda > *nmax) {
+		goto L110;
+	    }
+	    laa = lda * n;
+	    null = n <= 0 || m <= 0;
+
+	    i__2 = *ninc;
+	    for (ix = 1; ix <= i__2; ++ix) {
+		incx = inc[ix];
+		lx = abs(incx) * m;
+
+/*              Generate the vector X. */
+
+		transl = .5;
+		i__3 = abs(incx);
+		i__4 = m - 1;
+		dmake_("ge", " ", " ", &c__1, &m, &x[1], &c__1, &xx[1], &i__3,
+			 &c__0, &i__4, &reset, &transl, (ftnlen)2, (ftnlen)1, 
+			(ftnlen)1);
+		if (m > 1) {
+		    x[m / 2] = 0.;
+		    xx[abs(incx) * (m / 2 - 1) + 1] = 0.;
+		}
+
+		i__3 = *ninc;
+		for (iy = 1; iy <= i__3; ++iy) {
+		    incy = inc[iy];
+		    ly = abs(incy) * n;
+
+/*                 Generate the vector Y. */
+
+		    transl = 0.;
+		    i__4 = abs(incy);
+		    i__5 = n - 1;
+		    dmake_("ge", " ", " ", &c__1, &n, &y[1], &c__1, &yy[1], &
+			    i__4, &c__0, &i__5, &reset, &transl, (ftnlen)2, (
+			    ftnlen)1, (ftnlen)1);
+		    if (n > 1) {
+			y[n / 2] = 0.;
+			yy[abs(incy) * (n / 2 - 1) + 1] = 0.;
+		    }
+
+		    i__4 = *nalf;
+		    for (ia = 1; ia <= i__4; ++ia) {
+			alpha = alf[ia];
+
+/*                    Generate the matrix A. */
+
+			transl = 0.;
+			i__5 = m - 1;
+			i__6 = n - 1;
+			dmake_(sname + 7, " ", " ", &m, &n, &a[a_offset], 
+				nmax, &aa[1], &lda, &i__5, &i__6, &reset, &
+				transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+			++nc;
+
+/*                    Save every datum before calling the subroutine. */
+
+			ms = m;
+			ns = n;
+			als = alpha;
+			i__5 = laa;
+			for (i__ = 1; i__ <= i__5; ++i__) {
+			    as[i__] = aa[i__];
+/* L10: */
+			}
+			ldas = lda;
+			i__5 = lx;
+			for (i__ = 1; i__ <= i__5; ++i__) {
+			    xs[i__] = xx[i__];
+/* L20: */
+			}
+			incxs = incx;
+			i__5 = ly;
+			for (i__ = 1; i__ <= i__5; ++i__) {
+			    ys[i__] = yy[i__];
+/* L30: */
+			}
+			incys = incy;
+
+/*                    Call the subroutine. */
+
+			if (*trace) {
+			    io___299.ciunit = *ntra;
+			    s_wsfe(&io___299);
+			    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer)
+				    );
+			    do_fio(&c__1, sname, (ftnlen)12);
+			    do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer))
+				    ;
+			    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer))
+				    ;
+			    do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(
+				    doublereal));
+			    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(
+				    integer));
+			    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(
+				    integer));
+			    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(
+				    integer));
+			    e_wsfe();
+			}
+			if (*rewi) {
+			    al__1.aerr = 0;
+			    al__1.aunit = *ntra;
+			    f_rew(&al__1);
+			}
+			cdger_(iorder, &m, &n, &alpha, &xx[1], &incx, &yy[1], 
+				&incy, &aa[1], &lda);
+
+/*                    Check if error-exit was taken incorrectly. */
+
+			if (! infoc_1.ok) {
+			    io___300.ciunit = *nout;
+			    s_wsfe(&io___300);
+			    e_wsfe();
+			    *fatal = TRUE_;
+			    goto L140;
+			}
+
+/*                    See what data changed inside subroutine. */
+
+			isame[0] = ms == m;
+			isame[1] = ns == n;
+			isame[2] = als == alpha;
+			isame[3] = lde_(&xs[1], &xx[1], &lx);
+			isame[4] = incxs == incx;
+			isame[5] = lde_(&ys[1], &yy[1], &ly);
+			isame[6] = incys == incy;
+			if (null) {
+			    isame[7] = lde_(&as[1], &aa[1], &laa);
+			} else {
+			    isame[7] = lderes_("ge", " ", &m, &n, &as[1], &aa[
+				    1], &lda, (ftnlen)2, (ftnlen)1);
+			}
+			isame[8] = ldas == lda;
+
+/*                    If data was incorrectly changed, report and return. */
+
+			same = TRUE_;
+			i__5 = nargs;
+			for (i__ = 1; i__ <= i__5; ++i__) {
+			    same = same && isame[i__ - 1];
+			    if (! isame[i__ - 1]) {
+				io___303.ciunit = *nout;
+				s_wsfe(&io___303);
+				do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(
+					integer));
+				e_wsfe();
+			    }
+/* L40: */
+			}
+			if (! same) {
+			    *fatal = TRUE_;
+			    goto L140;
+			}
+
+			if (! null) {
+
+/*                       Check the result column by column. */
+
+			    if (incx > 0) {
+				i__5 = m;
+				for (i__ = 1; i__ <= i__5; ++i__) {
+				    z__[i__] = x[i__];
+/* L50: */
+				}
+			    } else {
+				i__5 = m;
+				for (i__ = 1; i__ <= i__5; ++i__) {
+				    z__[i__] = x[m - i__ + 1];
+/* L60: */
+				}
+			    }
+			    i__5 = n;
+			    for (j = 1; j <= i__5; ++j) {
+				if (incy > 0) {
+				    w[0] = y[j];
+				} else {
+				    w[0] = y[n - j + 1];
+				}
+				dmvch_("N", &m, &c__1, &alpha, &z__[1], nmax, 
+					w, &c__1, &c_b123, &a[j * a_dim1 + 1],
+					 &c__1, &yt[1], &g[1], &aa[(j - 1) * 
+					lda + 1], eps, &err, fatal, nout, &
+					c_true, (ftnlen)1);
+				errmax = max(errmax,err);
+/*                          If got really bad answer, report and return. */
+				if (*fatal) {
+				    goto L130;
+				}
+/* L70: */
+			    }
+			} else {
+/*                       Avoid repeating tests with M.le.0 or N.le.0. */
+			    goto L110;
+			}
+
+/* L80: */
+		    }
+
+/* L90: */
+		}
+
+/* L100: */
+	    }
+
+L110:
+	    ;
+	}
+
+/* L120: */
+    }
+
+/*     Report result. */
+
+    if (errmax < *thresh) {
+	if (*iorder == 0) {
+	    io___307.ciunit = *nout;
+	    s_wsfe(&io___307);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___308.ciunit = *nout;
+	    s_wsfe(&io___308);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+    } else {
+	if (*iorder == 0) {
+	    io___309.ciunit = *nout;
+	    s_wsfe(&io___309);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___310.ciunit = *nout;
+	    s_wsfe(&io___310);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+	    e_wsfe();
+	}
+    }
+    goto L150;
+
+L130:
+    io___311.ciunit = *nout;
+    s_wsfe(&io___311);
+    do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+    e_wsfe();
+
+L140:
+    io___312.ciunit = *nout;
+    s_wsfe(&io___312);
+    do_fio(&c__1, sname, (ftnlen)12);
+    e_wsfe();
+    io___313.ciunit = *nout;
+    s_wsfe(&io___313);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(doublereal));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+    e_wsfe();
+
+L150:
+    return 0;
+
+/* L9997: */
+
+/*     End of DCHK4. */
+
+} /* dchk4_ */
+
+/* Subroutine */ int dchk5_(char *sname, doublereal *eps, doublereal *thresh, 
+	integer *nout, integer *ntra, logical *trace, logical *rewi, logical *
+	fatal, integer *nidim, integer *idim, integer *nalf, doublereal *alf, 
+	integer *ninc, integer *inc, integer *nmax, integer *incmax, 
+	doublereal *a, doublereal *aa, doublereal *as, doublereal *x, 
+	doublereal *xx, doublereal *xs, doublereal *y, doublereal *yy, 
+	doublereal *ys, doublereal *yt, doublereal *g, doublereal *z__, 
+	integer *iorder, ftnlen sname_len)
+{
+    /* Initialized data */
+
+    static char ich[2] = "UL";
+
+    /* Format strings */
+    static char fmt_9993[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+	    "i3,\002,\002,f4.1,\002, X,\002,i2,\002, A,\002,i3,\002) .\002)";
+    static char fmt_9994[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+	    "i3,\002,\002,f4.1,\002, X,\002,i2,\002, AP) .\002)";
+    static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+	    "N VALID CALL *\002,\002******\002)";
+    static char fmt_9998[] = "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+	    " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+    static char fmt_10000[] = "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10001[] = "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10002[] = "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+	    "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_10003[] = "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+	    "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+	    " \002,i3)";
+    static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+	    "BER:\002)";
+
+    /* System generated locals */
+    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
+    alist al__1;
+
+    /* Builtin functions */
+    /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+	     f_rew(alist *);
+
+    /* Local variables */
+    integer i__, j, n;
+    doublereal w[1];
+    integer ia, ja, ic, nc, jj, lj, in, ix, ns, lx, laa, lda;
+    extern logical lde_(doublereal *, doublereal *, integer *);
+    doublereal als, err;
+    integer ldas;
+    logical same;
+    integer incx;
+    logical full, null;
+    char uplo[1];
+    extern /* Subroutine */ int dmake_(char *, char *, char *, integer *, 
+	    integer *, doublereal *, integer *, doublereal *, integer *, 
+	    integer *, integer *, logical *, doublereal *, ftnlen, ftnlen, 
+	    ftnlen);
+    doublereal alpha;
+    logical isame[13];
+    extern /* Subroutine */ int dmvch_(char *, integer *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
+	     doublereal *, doublereal *, doublereal *, logical *, integer *, 
+	    logical *, ftnlen);
+    integer nargs;
+    extern /* Subroutine */ void cdspr_(integer *, char *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *);
+    logical reset;
+    char cuplo[14];
+    integer incxs;
+    extern /* Subroutine */ void cdsyr_(integer *, char *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, integer *);
+    logical upper;
+    char uplos[1];
+    logical packed;
+    extern logical lderes_(char *, char *, integer *, integer *, doublereal *,
+	     doublereal *, integer *, ftnlen, ftnlen);
+    doublereal errmax, transl;
+
+    /* Fortran I/O blocks */
+    static cilist io___342 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___343 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___344 = { 0, 0, 0, fmt_9992, 0 };
+    static cilist io___347 = { 0, 0, 0, fmt_9998, 0 };
+    static cilist io___354 = { 0, 0, 0, fmt_10000, 0 };
+    static cilist io___355 = { 0, 0, 0, fmt_10001, 0 };
+    static cilist io___356 = { 0, 0, 0, fmt_10002, 0 };
+    static cilist io___357 = { 0, 0, 0, fmt_10003, 0 };
+    static cilist io___358 = { 0, 0, 0, fmt_9995, 0 };
+    static cilist io___359 = { 0, 0, 0, fmt_9996, 0 };
+    static cilist io___360 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___361 = { 0, 0, 0, fmt_9994, 0 };
+
+
+
+/*  Tests DSYR and DSPR. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Scalars in Common .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+    /* Parameter adjustments */
+    --idim;
+    --alf;
+    --inc;
+    --z__;
+    --g;
+    --yt;
+    --y;
+    --x;
+    --as;
+    --aa;
+    a_dim1 = *nmax;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --ys;
+    --yy;
+    --xs;
+    --xx;
+
+    /* Function Body */
+/*     .. Executable Statements .. */
+    full = *(unsigned char *)&sname[8] == 'y';
+    packed = *(unsigned char *)&sname[8] == 'p';
+/*     Define the number of arguments. */
+    if (full) {
+	nargs = 7;
+    } else if (packed) {
+	nargs = 6;
+    }
+
+    nc = 0;
+    reset = TRUE_;
+    errmax = 0.;
+
+    i__1 = *nidim;
+    for (in = 1; in <= i__1; ++in) {
+	n = idim[in];
+/*        Set LDA to 1 more than minimum value if room. */
+	lda = n;
+	if (lda < *nmax) {
+	    ++lda;
+	}
+/*        Skip tests if not enough room. */
+	if (lda > *nmax) {
+	    goto L100;
+	}
+	if (packed) {
+	    laa = n * (n + 1) / 2;
+	} else {
+	    laa = lda * n;
+	}
+
+	for (ic = 1; ic <= 2; ++ic) {
+	    *(unsigned char *)uplo = *(unsigned char *)&ich[ic - 1];
+	    if (*(unsigned char *)uplo == 'U') {
+		s_copy(cuplo, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+	    } else {
+		s_copy(cuplo, "    CblasLower", (ftnlen)14, (ftnlen)14);
+	    }
+	    upper = *(unsigned char *)uplo == 'U';
+
+	    i__2 = *ninc;
+	    for (ix = 1; ix <= i__2; ++ix) {
+		incx = inc[ix];
+		lx = abs(incx) * n;
+
+/*              Generate the vector X. */
+
+		transl = .5;
+		i__3 = abs(incx);
+		i__4 = n - 1;
+		dmake_("ge", " ", " ", &c__1, &n, &x[1], &c__1, &xx[1], &i__3,
+			 &c__0, &i__4, &reset, &transl, (ftnlen)2, (ftnlen)1, 
+			(ftnlen)1);
+		if (n > 1) {
+		    x[n / 2] = 0.;
+		    xx[abs(incx) * (n / 2 - 1) + 1] = 0.;
+		}
+
+		i__3 = *nalf;
+		for (ia = 1; ia <= i__3; ++ia) {
+		    alpha = alf[ia];
+		    null = n <= 0 || alpha == 0.;
+
+/*                 Generate the matrix A. */
+
+		    transl = 0.;
+		    i__4 = n - 1;
+		    i__5 = n - 1;
+		    dmake_(sname + 7, uplo, " ", &n, &n, &a[a_offset], nmax, &
+			    aa[1], &lda, &i__4, &i__5, &reset, &transl, (
+			    ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+		    ++nc;
+
+/*                 Save every datum before calling the subroutine. */
+
+		    *(unsigned char *)uplos = *(unsigned char *)uplo;
+		    ns = n;
+		    als = alpha;
+		    i__4 = laa;
+		    for (i__ = 1; i__ <= i__4; ++i__) {
+			as[i__] = aa[i__];
+/* L10: */
+		    }
+		    ldas = lda;
+		    i__4 = lx;
+		    for (i__ = 1; i__ <= i__4; ++i__) {
+			xs[i__] = xx[i__];
+/* L20: */
+		    }
+		    incxs = incx;
+
+/*                 Call the subroutine. */
+
+		    if (full) {
+			if (*trace) {
+			    io___342.ciunit = *ntra;
+			    s_wsfe(&io___342);
+			    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer)
+				    );
+			    do_fio(&c__1, sname, (ftnlen)12);
+			    do_fio(&c__1, cuplo, (ftnlen)14);
+			    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer))
+				    ;
+			    do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(
+				    doublereal));
+			    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(
+				    integer));
+			    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(
+				    integer));
+			    e_wsfe();
+			}
+			if (*rewi) {
+			    al__1.aerr = 0;
+			    al__1.aunit = *ntra;
+			    f_rew(&al__1);
+			}
+			cdsyr_(iorder, uplo, &n, &alpha, &xx[1], &incx, &aa[1]
+				, &lda);
+		    } else if (packed) {
+			if (*trace) {
+			    io___343.ciunit = *ntra;
+			    s_wsfe(&io___343);
+			    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer)
+				    );
+			    do_fio(&c__1, sname, (ftnlen)12);
+			    do_fio(&c__1, cuplo, (ftnlen)14);
+			    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer))
+				    ;
+			    do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(
+				    doublereal));
+			    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(
+				    integer));
+			    e_wsfe();
+			}
+			if (*rewi) {
+			    al__1.aerr = 0;
+			    al__1.aunit = *ntra;
+			    f_rew(&al__1);
+			}
+			cdspr_(iorder, uplo, &n, &alpha, &xx[1], &incx, &aa[1]);
+		    }
+
+/*                 Check if error-exit was taken incorrectly. */
+
+		    if (! infoc_1.ok) {
+			io___344.ciunit = *nout;
+			s_wsfe(&io___344);
+			e_wsfe();
+			*fatal = TRUE_;
+			goto L120;
+		    }
+
+/*                 See what data changed inside subroutines. */
+
+		    isame[0] = *(unsigned char *)uplo == *(unsigned char *)
+			    uplos;
+		    isame[1] = ns == n;
+		    isame[2] = als == alpha;
+		    isame[3] = lde_(&xs[1], &xx[1], &lx);
+		    isame[4] = incxs == incx;
+		    if (null) {
+			isame[5] = lde_(&as[1], &aa[1], &laa);
+		    } else {
+			isame[5] = lderes_(sname + 7, uplo, &n, &n, &as[1], &
+				aa[1], &lda, (ftnlen)2, (ftnlen)1);
+		    }
+		    if (! packed) {
+			isame[6] = ldas == lda;
+		    }
+
+/*                 If data was incorrectly changed, report and return. */
+
+		    same = TRUE_;
+		    i__4 = nargs;
+		    for (i__ = 1; i__ <= i__4; ++i__) {
+			same = same && isame[i__ - 1];
+			if (! isame[i__ - 1]) {
+			    io___347.ciunit = *nout;
+			    s_wsfe(&io___347);
+			    do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(
+				    integer));
+			    e_wsfe();
+			}
+/* L30: */
+		    }
+		    if (! same) {
+			*fatal = TRUE_;
+			goto L120;
+		    }
+
+		    if (! null) {
+
+/*                    Check the result column by column. */
+
+			if (incx > 0) {
+			    i__4 = n;
+			    for (i__ = 1; i__ <= i__4; ++i__) {
+				z__[i__] = x[i__];
+/* L40: */
+			    }
+			} else {
+			    i__4 = n;
+			    for (i__ = 1; i__ <= i__4; ++i__) {
+				z__[i__] = x[n - i__ + 1];
+/* L50: */
+			    }
+			}
+			ja = 1;
+			i__4 = n;
+			for (j = 1; j <= i__4; ++j) {
+			    w[0] = z__[j];
+			    if (upper) {
+				jj = 1;
+				lj = j;
+			    } else {
+				jj = j;
+				lj = n - j + 1;
+			    }
+			    dmvch_("N", &lj, &c__1, &alpha, &z__[jj], &lj, w, 
+				    &c__1, &c_b123, &a[jj + j * a_dim1], &
+				    c__1, &yt[1], &g[1], &aa[ja], eps, &err, 
+				    fatal, nout, &c_true, (ftnlen)1);
+			    if (full) {
+				if (upper) {
+				    ja += lda;
+				} else {
+				    ja = ja + lda + 1;
+				}
+			    } else {
+				ja += lj;
+			    }
+			    errmax = max(errmax,err);
+/*                       If got really bad answer, report and return. */
+			    if (*fatal) {
+				goto L110;
+			    }
+/* L60: */
+			}
+		    } else {
+/*                    Avoid repeating tests if N.le.0. */
+			if (n <= 0) {
+			    goto L100;
+			}
+		    }
+
+/* L70: */
+		}
+
+/* L80: */
+	    }
+
+/* L90: */
+	}
+
+L100:
+	;
+    }
+
+/*     Report result. */
+
+    if (errmax < *thresh) {
+	if (*iorder == 0) {
+	    io___354.ciunit = *nout;
+	    s_wsfe(&io___354);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___355.ciunit = *nout;
+	    s_wsfe(&io___355);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+    } else {
+	if (*iorder == 0) {
+	    io___356.ciunit = *nout;
+	    s_wsfe(&io___356);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___357.ciunit = *nout;
+	    s_wsfe(&io___357);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+	    e_wsfe();
+	}
+    }
+    goto L130;
+
+L110:
+    io___358.ciunit = *nout;
+    s_wsfe(&io___358);
+    do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+    e_wsfe();
+
+L120:
+    io___359.ciunit = *nout;
+    s_wsfe(&io___359);
+    do_fio(&c__1, sname, (ftnlen)12);
+    e_wsfe();
+    if (full) {
+	io___360.ciunit = *nout;
+	s_wsfe(&io___360);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+	e_wsfe();
+    } else if (packed) {
+	io___361.ciunit = *nout;
+	s_wsfe(&io___361);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	e_wsfe();
+    }
+
+L130:
+    return 0;
+
+/* L9997: */
+
+/*     End of DCHK5. */
+
+} /* dchk5_ */
+
+/* Subroutine */ int dchk6_(char *sname, doublereal *eps, doublereal *thresh, 
+	integer *nout, integer *ntra, logical *trace, logical *rewi, logical *
+	fatal, integer *nidim, integer *idim, integer *nalf, doublereal *alf, 
+	integer *ninc, integer *inc, integer *nmax, integer *incmax, 
+	doublereal *a, doublereal *aa, doublereal *as, doublereal *x, 
+	doublereal *xx, doublereal *xs, doublereal *y, doublereal *yy, 
+	doublereal *ys, doublereal *yt, doublereal *g, doublereal *z__, 
+	integer *iorder, ftnlen sname_len)
+{
+    /* Initialized data */
+
+    static char ich[2] = "UL";
+
+    /* Format strings */
+    static char fmt_9993[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+	    "i3,\002,\002,f4.1,\002, X,\002,i2,\002, Y,\002,i2,\002, A,\002,i"
+	    "3,\002) .\002)";
+    static char fmt_9994[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+	    "i3,\002,\002,f4.1,\002, X,\002,i2,\002, Y,\002,i2,\002, AP) ."
+	    "\002)";
+    static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+	    "N VALID CALL *\002,\002******\002)";
+    static char fmt_9998[] = "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+	    " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+    static char fmt_10000[] = "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10001[] = "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10002[] = "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+	    "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_10003[] = "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+	    "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+	    " \002,i3)";
+    static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+	    "BER:\002)";
+
+    /* System generated locals */
+    integer a_dim1, a_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4, i__5, 
+	    i__6;
+    alist al__1;
+
+    /* Builtin functions */
+    /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+	     f_rew(alist *);
+
+    /* Local variables */
+    integer i__, j, n;
+    doublereal w[2];
+    integer ia, ja, ic, nc, jj, lj, in, ix, iy, ns, lx, ly, laa, lda;
+    extern logical lde_(doublereal *, doublereal *, integer *);
+    doublereal als, err;
+    integer ldas;
+    logical same;
+    integer incx, incy;
+    logical full, null;
+    char uplo[1];
+    extern /* Subroutine */ int dmake_(char *, char *, char *, integer *, 
+	    integer *, doublereal *, integer *, doublereal *, integer *, 
+	    integer *, integer *, logical *, doublereal *, ftnlen, ftnlen, 
+	    ftnlen);
+    doublereal alpha;
+    logical isame[13];
+    extern /* Subroutine */ int dmvch_(char *, integer *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
+	     doublereal *, doublereal *, doublereal *, logical *, integer *, 
+	    logical *, ftnlen);
+    integer nargs;
+    logical reset;
+    char cuplo[14];
+    integer incxs, incys;
+    logical upper;
+    char uplos[1];
+    extern /* Subroutine */ void cdspr2_(integer *, char *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
+	    doublereal *), cdsyr2_(integer *, char *, integer *, 
+	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
+	    doublereal *, integer *);
+    logical packed;
+    extern logical lderes_(char *, char *, integer *, integer *, doublereal *,
+	     doublereal *, integer *, ftnlen, ftnlen);
+    doublereal errmax, transl;
+
+    /* Fortran I/O blocks */
+    static cilist io___394 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___395 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___396 = { 0, 0, 0, fmt_9992, 0 };
+    static cilist io___399 = { 0, 0, 0, fmt_9998, 0 };
+    static cilist io___406 = { 0, 0, 0, fmt_10000, 0 };
+    static cilist io___407 = { 0, 0, 0, fmt_10001, 0 };
+    static cilist io___408 = { 0, 0, 0, fmt_10002, 0 };
+    static cilist io___409 = { 0, 0, 0, fmt_10003, 0 };
+    static cilist io___410 = { 0, 0, 0, fmt_9995, 0 };
+    static cilist io___411 = { 0, 0, 0, fmt_9996, 0 };
+    static cilist io___412 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___413 = { 0, 0, 0, fmt_9994, 0 };
+
+
+
+/*  Tests DSYR2 and DSPR2. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Scalars in Common .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+    /* Parameter adjustments */
+    --idim;
+    --alf;
+    --inc;
+    z_dim1 = *nmax;
+    z_offset = 1 + z_dim1;
+    z__ -= z_offset;
+    --g;
+    --yt;
+    --y;
+    --x;
+    --as;
+    --aa;
+    a_dim1 = *nmax;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --ys;
+    --yy;
+    --xs;
+    --xx;
+
+    /* Function Body */
+/*     .. Executable Statements .. */
+    full = *(unsigned char *)&sname[8] == 'y';
+    packed = *(unsigned char *)&sname[8] == 'p';
+/*     Define the number of arguments. */
+    if (full) {
+	nargs = 9;
+    } else if (packed) {
+	nargs = 8;
+    }
+
+    nc = 0;
+    reset = TRUE_;
+    errmax = 0.;
+
+    i__1 = *nidim;
+    for (in = 1; in <= i__1; ++in) {
+	n = idim[in];
+/*        Set LDA to 1 more than minimum value if room. */
+	lda = n;
+	if (lda < *nmax) {
+	    ++lda;
+	}
+/*        Skip tests if not enough room. */
+	if (lda > *nmax) {
+	    goto L140;
+	}
+	if (packed) {
+	    laa = n * (n + 1) / 2;
+	} else {
+	    laa = lda * n;
+	}
+
+	for (ic = 1; ic <= 2; ++ic) {
+	    *(unsigned char *)uplo = *(unsigned char *)&ich[ic - 1];
+	    if (*(unsigned char *)uplo == 'U') {
+		s_copy(cuplo, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+	    } else {
+		s_copy(cuplo, "    CblasLower", (ftnlen)14, (ftnlen)14);
+	    }
+	    upper = *(unsigned char *)uplo == 'U';
+
+	    i__2 = *ninc;
+	    for (ix = 1; ix <= i__2; ++ix) {
+		incx = inc[ix];
+		lx = abs(incx) * n;
+
+/*              Generate the vector X. */
+
+		transl = .5;
+		i__3 = abs(incx);
+		i__4 = n - 1;
+		dmake_("ge", " ", " ", &c__1, &n, &x[1], &c__1, &xx[1], &i__3,
+			 &c__0, &i__4, &reset, &transl, (ftnlen)2, (ftnlen)1, 
+			(ftnlen)1);
+		if (n > 1) {
+		    x[n / 2] = 0.;
+		    xx[abs(incx) * (n / 2 - 1) + 1] = 0.;
+		}
+
+		i__3 = *ninc;
+		for (iy = 1; iy <= i__3; ++iy) {
+		    incy = inc[iy];
+		    ly = abs(incy) * n;
+
+/*                 Generate the vector Y. */
+
+		    transl = 0.;
+		    i__4 = abs(incy);
+		    i__5 = n - 1;
+		    dmake_("ge", " ", " ", &c__1, &n, &y[1], &c__1, &yy[1], &
+			    i__4, &c__0, &i__5, &reset, &transl, (ftnlen)2, (
+			    ftnlen)1, (ftnlen)1);
+		    if (n > 1) {
+			y[n / 2] = 0.;
+			yy[abs(incy) * (n / 2 - 1) + 1] = 0.;
+		    }
+
+		    i__4 = *nalf;
+		    for (ia = 1; ia <= i__4; ++ia) {
+			alpha = alf[ia];
+			null = n <= 0 || alpha == 0.;
+
+/*                    Generate the matrix A. */
+
+			transl = 0.;
+			i__5 = n - 1;
+			i__6 = n - 1;
+			dmake_(sname + 7, uplo, " ", &n, &n, &a[a_offset], 
+				nmax, &aa[1], &lda, &i__5, &i__6, &reset, &
+				transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+			++nc;
+
+/*                    Save every datum before calling the subroutine. */
+
+			*(unsigned char *)uplos = *(unsigned char *)uplo;
+			ns = n;
+			als = alpha;
+			i__5 = laa;
+			for (i__ = 1; i__ <= i__5; ++i__) {
+			    as[i__] = aa[i__];
+/* L10: */
+			}
+			ldas = lda;
+			i__5 = lx;
+			for (i__ = 1; i__ <= i__5; ++i__) {
+			    xs[i__] = xx[i__];
+/* L20: */
+			}
+			incxs = incx;
+			i__5 = ly;
+			for (i__ = 1; i__ <= i__5; ++i__) {
+			    ys[i__] = yy[i__];
+/* L30: */
+			}
+			incys = incy;
+
+/*                    Call the subroutine. */
+
+			if (full) {
+			    if (*trace) {
+				io___394.ciunit = *ntra;
+				s_wsfe(&io___394);
+				do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(
+					integer));
+				do_fio(&c__1, sname, (ftnlen)12);
+				do_fio(&c__1, cuplo, (ftnlen)14);
+				do_fio(&c__1, (char *)&n, (ftnlen)sizeof(
+					integer));
+				do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(
+					doublereal));
+				do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(
+					integer));
+				do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(
+					integer));
+				do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(
+					integer));
+				e_wsfe();
+			    }
+			    if (*rewi) {
+				al__1.aerr = 0;
+				al__1.aunit = *ntra;
+				f_rew(&al__1);
+			    }
+			    cdsyr2_(iorder, uplo, &n, &alpha, &xx[1], &incx, &
+				    yy[1], &incy, &aa[1], &lda);
+			} else if (packed) {
+			    if (*trace) {
+				io___395.ciunit = *ntra;
+				s_wsfe(&io___395);
+				do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(
+					integer));
+				do_fio(&c__1, sname, (ftnlen)12);
+				do_fio(&c__1, cuplo, (ftnlen)14);
+				do_fio(&c__1, (char *)&n, (ftnlen)sizeof(
+					integer));
+				do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(
+					doublereal));
+				do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(
+					integer));
+				do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(
+					integer));
+				e_wsfe();
+			    }
+			    if (*rewi) {
+				al__1.aerr = 0;
+				al__1.aunit = *ntra;
+				f_rew(&al__1);
+			    }
+			    cdspr2_(iorder, uplo, &n, &alpha, &xx[1], &incx, &
+				    yy[1], &incy, &aa[1]);
+			}
+
+/*                    Check if error-exit was taken incorrectly. */
+
+			if (! infoc_1.ok) {
+			    io___396.ciunit = *nout;
+			    s_wsfe(&io___396);
+			    e_wsfe();
+			    *fatal = TRUE_;
+			    goto L160;
+			}
+
+/*                    See what data changed inside subroutines. */
+
+			isame[0] = *(unsigned char *)uplo == *(unsigned char *
+				)uplos;
+			isame[1] = ns == n;
+			isame[2] = als == alpha;
+			isame[3] = lde_(&xs[1], &xx[1], &lx);
+			isame[4] = incxs == incx;
+			isame[5] = lde_(&ys[1], &yy[1], &ly);
+			isame[6] = incys == incy;
+			if (null) {
+			    isame[7] = lde_(&as[1], &aa[1], &laa);
+			} else {
+			    isame[7] = lderes_(sname + 7, uplo, &n, &n, &as[1]
+				    , &aa[1], &lda, (ftnlen)2, (ftnlen)1);
+			}
+			if (! packed) {
+			    isame[8] = ldas == lda;
+			}
+
+/*                    If data was incorrectly changed, report and return. */
+
+			same = TRUE_;
+			i__5 = nargs;
+			for (i__ = 1; i__ <= i__5; ++i__) {
+			    same = same && isame[i__ - 1];
+			    if (! isame[i__ - 1]) {
+				io___399.ciunit = *nout;
+				s_wsfe(&io___399);
+				do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(
+					integer));
+				e_wsfe();
+			    }
+/* L40: */
+			}
+			if (! same) {
+			    *fatal = TRUE_;
+			    goto L160;
+			}
+
+			if (! null) {
+
+/*                       Check the result column by column. */
+
+			    if (incx > 0) {
+				i__5 = n;
+				for (i__ = 1; i__ <= i__5; ++i__) {
+				    z__[i__ + z_dim1] = x[i__];
+/* L50: */
+				}
+			    } else {
+				i__5 = n;
+				for (i__ = 1; i__ <= i__5; ++i__) {
+				    z__[i__ + z_dim1] = x[n - i__ + 1];
+/* L60: */
+				}
+			    }
+			    if (incy > 0) {
+				i__5 = n;
+				for (i__ = 1; i__ <= i__5; ++i__) {
+				    z__[i__ + (z_dim1 << 1)] = y[i__];
+/* L70: */
+				}
+			    } else {
+				i__5 = n;
+				for (i__ = 1; i__ <= i__5; ++i__) {
+				    z__[i__ + (z_dim1 << 1)] = y[n - i__ + 1];
+/* L80: */
+				}
+			    }
+			    ja = 1;
+			    i__5 = n;
+			    for (j = 1; j <= i__5; ++j) {
+				w[0] = z__[j + (z_dim1 << 1)];
+				w[1] = z__[j + z_dim1];
+				if (upper) {
+				    jj = 1;
+				    lj = j;
+				} else {
+				    jj = j;
+				    lj = n - j + 1;
+				}
+				dmvch_("N", &lj, &c__2, &alpha, &z__[jj + 
+					z_dim1], nmax, w, &c__1, &c_b123, &a[
+					jj + j * a_dim1], &c__1, &yt[1], &g[1]
+					, &aa[ja], eps, &err, fatal, nout, &
+					c_true, (ftnlen)1);
+				if (full) {
+				    if (upper) {
+					ja += lda;
+				    } else {
+					ja = ja + lda + 1;
+				    }
+				} else {
+				    ja += lj;
+				}
+				errmax = max(errmax,err);
+/*                          If got really bad answer, report and return. */
+				if (*fatal) {
+				    goto L150;
+				}
+/* L90: */
+			    }
+			} else {
+/*                       Avoid repeating tests with N.le.0. */
+			    if (n <= 0) {
+				goto L140;
+			    }
+			}
+
+/* L100: */
+		    }
+
+/* L110: */
+		}
+
+/* L120: */
+	    }
+
+/* L130: */
+	}
+
+L140:
+	;
+    }
+
+/*     Report result. */
+
+    if (errmax < *thresh) {
+	if (*iorder == 0) {
+	    io___406.ciunit = *nout;
+	    s_wsfe(&io___406);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___407.ciunit = *nout;
+	    s_wsfe(&io___407);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+    } else {
+	if (*iorder == 0) {
+	    io___408.ciunit = *nout;
+	    s_wsfe(&io___408);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___409.ciunit = *nout;
+	    s_wsfe(&io___409);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+	    e_wsfe();
+	}
+    }
+    goto L170;
+
+L150:
+    io___410.ciunit = *nout;
+    s_wsfe(&io___410);
+    do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+    e_wsfe();
+
+L160:
+    io___411.ciunit = *nout;
+    s_wsfe(&io___411);
+    do_fio(&c__1, sname, (ftnlen)12);
+    e_wsfe();
+    if (full) {
+	io___412.ciunit = *nout;
+	s_wsfe(&io___412);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+	e_wsfe();
+    } else if (packed) {
+	io___413.ciunit = *nout;
+	s_wsfe(&io___413);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+	e_wsfe();
+    }
+
+L170:
+    return 0;
+
+/* L9997: */
+
+/*     End of DCHK6. */
+
+} /* dchk6_ */
+
+/* Subroutine */ int dmake_(char *type__, char *uplo, char *diag, integer *m, 
+	integer *n, doublereal *a, integer *nmax, doublereal *aa, integer *
+	lda, integer *kl, integer *ku, logical *reset, doublereal *transl, 
+	ftnlen type_len, ftnlen uplo_len, ftnlen diag_len)
+{
+    /* System generated locals */
+    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
+
+    /* Builtin functions */
+    integer s_cmp(char *, char *, ftnlen, ftnlen);
+
+    /* Local variables */
+    integer i__, j, i1, i2, i3, kk;
+    logical gen, tri, sym;
+    extern doublereal dbeg_(logical *);
+    integer ibeg, iend, ioff;
+    logical unit, lower, upper;
+
+
+/*  Generates values for an M by N matrix A within the bandwidth */
+/*  defined by KL and KU. */
+/*  Stores the values in the array AA in the data structure required */
+/*  by the routine, with unwanted elements set to rogue value. */
+
+/*  TYPE is 'ge', 'gb', 'sy', 'sb', 'sp', 'tr', 'tb' OR 'tp'. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. External Functions .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Executable Statements .. */
+    /* Parameter adjustments */
+    a_dim1 = *nmax;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --aa;
+
+    /* Function Body */
+    gen = *(unsigned char *)type__ == 'g';
+    sym = *(unsigned char *)type__ == 's';
+    tri = *(unsigned char *)type__ == 't';
+    upper = (sym || tri) && *(unsigned char *)uplo == 'U';
+    lower = (sym || tri) && *(unsigned char *)uplo == 'L';
+    unit = tri && *(unsigned char *)diag == 'U';
+
+/*     Generate data in array A. */
+
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+	i__2 = *m;
+	for (i__ = 1; i__ <= i__2; ++i__) {
+	    if (gen || upper && i__ <= j || lower && i__ >= j) {
+		if (i__ <= j && j - i__ <= *ku || i__ >= j && i__ - j <= *kl) 
+			{
+		    a[i__ + j * a_dim1] = dbeg_(reset) + *transl;
+		} else {
+		    a[i__ + j * a_dim1] = 0.;
+		}
+		if (i__ != j) {
+		    if (sym) {
+			a[j + i__ * a_dim1] = a[i__ + j * a_dim1];
+		    } else if (tri) {
+			a[j + i__ * a_dim1] = 0.;
+		    }
+		}
+	    }
+/* L10: */
+	}
+	if (tri) {
+	    a[j + j * a_dim1] += 1.;
+	}
+	if (unit) {
+	    a[j + j * a_dim1] = 1.;
+	}
+/* L20: */
+    }
+
+/*     Store elements in array AS in data structure required by routine. */
+
+    if (s_cmp(type__, "ge", (ftnlen)2, (ftnlen)2) == 0) {
+	i__1 = *n;
+	for (j = 1; j <= i__1; ++j) {
+	    i__2 = *m;
+	    for (i__ = 1; i__ <= i__2; ++i__) {
+		aa[i__ + (j - 1) * *lda] = a[i__ + j * a_dim1];
+/* L30: */
+	    }
+	    i__2 = *lda;
+	    for (i__ = *m + 1; i__ <= i__2; ++i__) {
+		aa[i__ + (j - 1) * *lda] = -1e10;
+/* L40: */
+	    }
+/* L50: */
+	}
+    } else if (s_cmp(type__, "gb", (ftnlen)2, (ftnlen)2) == 0) {
+	i__1 = *n;
+	for (j = 1; j <= i__1; ++j) {
+	    i__2 = *ku + 1 - j;
+	    for (i1 = 1; i1 <= i__2; ++i1) {
+		aa[i1 + (j - 1) * *lda] = -1e10;
+/* L60: */
+	    }
+/* Computing MIN */
+	    i__3 = *kl + *ku + 1, i__4 = *ku + 1 + *m - j;
+	    i__2 = min(i__3,i__4);
+	    for (i2 = i1; i2 <= i__2; ++i2) {
+		aa[i2 + (j - 1) * *lda] = a[i2 + j - *ku - 1 + j * a_dim1];
+/* L70: */
+	    }
+	    i__2 = *lda;
+	    for (i3 = i2; i3 <= i__2; ++i3) {
+		aa[i3 + (j - 1) * *lda] = -1e10;
+/* L80: */
+	    }
+/* L90: */
+	}
+    } else if (s_cmp(type__, "sy", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(type__,
+	     "tr", (ftnlen)2, (ftnlen)2) == 0) {
+	i__1 = *n;
+	for (j = 1; j <= i__1; ++j) {
+	    if (upper) {
+		ibeg = 1;
+		if (unit) {
+		    iend = j - 1;
+		} else {
+		    iend = j;
+		}
+	    } else {
+		if (unit) {
+		    ibeg = j + 1;
+		} else {
+		    ibeg = j;
+		}
+		iend = *n;
+	    }
+	    i__2 = ibeg - 1;
+	    for (i__ = 1; i__ <= i__2; ++i__) {
+		aa[i__ + (j - 1) * *lda] = -1e10;
+/* L100: */
+	    }
+	    i__2 = iend;
+	    for (i__ = ibeg; i__ <= i__2; ++i__) {
+		aa[i__ + (j - 1) * *lda] = a[i__ + j * a_dim1];
+/* L110: */
+	    }
+	    i__2 = *lda;
+	    for (i__ = iend + 1; i__ <= i__2; ++i__) {
+		aa[i__ + (j - 1) * *lda] = -1e10;
+/* L120: */
+	    }
+/* L130: */
+	}
+    } else if (s_cmp(type__, "sb", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(type__,
+	     "tb", (ftnlen)2, (ftnlen)2) == 0) {
+	i__1 = *n;
+	for (j = 1; j <= i__1; ++j) {
+	    if (upper) {
+		kk = *kl + 1;
+/* Computing MAX */
+		i__2 = 1, i__3 = *kl + 2 - j;
+		ibeg = max(i__2,i__3);
+		if (unit) {
+		    iend = *kl;
+		} else {
+		    iend = *kl + 1;
+		}
+	    } else {
+		kk = 1;
+		if (unit) {
+		    ibeg = 2;
+		} else {
+		    ibeg = 1;
+		}
+/* Computing MIN */
+		i__2 = *kl + 1, i__3 = *m + 1 - j;
+		iend = min(i__2,i__3);
+	    }
+	    i__2 = ibeg - 1;
+	    for (i__ = 1; i__ <= i__2; ++i__) {
+		aa[i__ + (j - 1) * *lda] = -1e10;
+/* L140: */
+	    }
+	    i__2 = iend;
+	    for (i__ = ibeg; i__ <= i__2; ++i__) {
+		aa[i__ + (j - 1) * *lda] = a[i__ + j - kk + j * a_dim1];
+/* L150: */
+	    }
+	    i__2 = *lda;
+	    for (i__ = iend + 1; i__ <= i__2; ++i__) {
+		aa[i__ + (j - 1) * *lda] = -1e10;
+/* L160: */
+	    }
+/* L170: */
+	}
+    } else if (s_cmp(type__, "sp", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(type__,
+	     "tp", (ftnlen)2, (ftnlen)2) == 0) {
+	ioff = 0;
+	i__1 = *n;
+	for (j = 1; j <= i__1; ++j) {
+	    if (upper) {
+		ibeg = 1;
+		iend = j;
+	    } else {
+		ibeg = j;
+		iend = *n;
+	    }
+	    i__2 = iend;
+	    for (i__ = ibeg; i__ <= i__2; ++i__) {
+		++ioff;
+		aa[ioff] = a[i__ + j * a_dim1];
+		if (i__ == j) {
+		    if (unit) {
+			aa[ioff] = -1e10;
+		    }
+		}
+/* L180: */
+	    }
+/* L190: */
+	}
+    }
+    return 0;
+
+/*     End of DMAKE. */
+
+} /* dmake_ */
+
+/* Subroutine */ int dmvch_(char *trans, integer *m, integer *n, doublereal *
+	alpha, doublereal *a, integer *nmax, doublereal *x, integer *incx, 
+	doublereal *beta, doublereal *y, integer *incy, doublereal *yt, 
+	doublereal *g, doublereal *yy, doublereal *eps, doublereal *err, 
+	logical *fatal, integer *nout, logical *mv, ftnlen trans_len)
+{
+    /* Format strings */
+    static char fmt_9999[] = "(\002 ******* FATAL ERROR - COMPUTED RESULT IS"
+	    " LESS THAN HAL\002,\002F ACCURATE *******\002,/\002           EX"
+	    "PECTED RESULT   COMPU\002,\002TED RESULT\002)";
+    static char fmt_9998[] = "(1x,i7,2g18.6)";
+
+    /* System generated locals */
+    integer a_dim1, a_offset, i__1, i__2;
+    doublereal d__1;
+
+    /* Builtin functions */
+    double sqrt(doublereal);
+    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+    /* Local variables */
+    integer i__, j, ml, nl, iy, jx, kx, ky;
+    doublereal erri;
+    logical tran;
+    integer incxl, incyl;
+
+    /* Fortran I/O blocks */
+    static cilist io___441 = { 0, 0, 0, fmt_9999, 0 };
+    static cilist io___442 = { 0, 0, 0, fmt_9998, 0 };
+    static cilist io___443 = { 0, 0, 0, fmt_9998, 0 };
+
+
+
+/*  Checks the results of the computational tests. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Executable Statements .. */
+    /* Parameter adjustments */
+    a_dim1 = *nmax;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --x;
+    --y;
+    --yt;
+    --g;
+    --yy;
+
+    /* Function Body */
+    tran = *(unsigned char *)trans == 'T' || *(unsigned char *)trans == 'C';
+    if (tran) {
+	ml = *n;
+	nl = *m;
+    } else {
+	ml = *m;
+	nl = *n;
+    }
+    if (*incx < 0) {
+	kx = nl;
+	incxl = -1;
+    } else {
+	kx = 1;
+	incxl = 1;
+    }
+    if (*incy < 0) {
+	ky = ml;
+	incyl = -1;
+    } else {
+	ky = 1;
+	incyl = 1;
+    }
+
+/*     Compute expected result in YT using data in A, X and Y. */
+/*     Compute gauges in G. */
+
+    iy = ky;
+    i__1 = ml;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	yt[iy] = 0.;
+	g[iy] = 0.;
+	jx = kx;
+	if (tran) {
+	    i__2 = nl;
+	    for (j = 1; j <= i__2; ++j) {
+		yt[iy] += a[j + i__ * a_dim1] * x[jx];
+		g[iy] += (d__1 = a[j + i__ * a_dim1] * x[jx], abs(d__1));
+		jx += incxl;
+/* L10: */
+	    }
+	} else {
+	    i__2 = nl;
+	    for (j = 1; j <= i__2; ++j) {
+		yt[iy] += a[i__ + j * a_dim1] * x[jx];
+		g[iy] += (d__1 = a[i__ + j * a_dim1] * x[jx], abs(d__1));
+		jx += incxl;
+/* L20: */
+	    }
+	}
+	yt[iy] = *alpha * yt[iy] + *beta * y[iy];
+	g[iy] = abs(*alpha) * g[iy] + (d__1 = *beta * y[iy], abs(d__1));
+	iy += incyl;
+/* L30: */
+    }
+
+/*     Compute the error ratio for this result. */
+
+    *err = 0.;
+    i__1 = ml;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	erri = (d__1 = yt[i__] - yy[(i__ - 1) * abs(*incy) + 1], abs(d__1)) / 
+		*eps;
+	if (g[i__] != 0.) {
+	    erri /= g[i__];
+	}
+	*err = max(*err,erri);
+	if (*err * sqrt(*eps) >= 1.) {
+	    goto L50;
+	}
+/* L40: */
+    }
+/*     If the loop completes, all results are at least half accurate. */
+    goto L70;
+
+/*     Report fatal error. */
+
+L50:
+    *fatal = TRUE_;
+    io___441.ciunit = *nout;
+    s_wsfe(&io___441);
+    e_wsfe();
+    i__1 = ml;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	if (*mv) {
+	    io___442.ciunit = *nout;
+	    s_wsfe(&io___442);
+	    do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&yt[i__], (ftnlen)sizeof(doublereal));
+	    do_fio(&c__1, (char *)&yy[(i__ - 1) * abs(*incy) + 1], (ftnlen)
+		    sizeof(doublereal));
+	    e_wsfe();
+	} else {
+	    io___443.ciunit = *nout;
+	    s_wsfe(&io___443);
+	    do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&yy[(i__ - 1) * abs(*incy) + 1], (ftnlen)
+		    sizeof(doublereal));
+	    do_fio(&c__1, (char *)&yt[i__], (ftnlen)sizeof(doublereal));
+	    e_wsfe();
+	}
+/* L60: */
+    }
+
+L70:
+    return 0;
+
+
+/*     End of DMVCH. */
+
+} /* dmvch_ */
+
+logical lde_(doublereal *ri, doublereal *rj, integer *lr)
+{
+    /* System generated locals */
+    integer i__1;
+    logical ret_val;
+
+    /* Local variables */
+    integer i__;
+
+
+/*  Tests if two arrays are identical. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Executable Statements .. */
+    /* Parameter adjustments */
+    --rj;
+    --ri;
+
+    /* Function Body */
+    i__1 = *lr;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	if (ri[i__] != rj[i__]) {
+	    goto L20;
+	}
+/* L10: */
+    }
+    ret_val = TRUE_;
+    goto L30;
+L20:
+    ret_val = FALSE_;
+L30:
+    return ret_val;
+
+/*     End of LDE. */
+
+} /* lde_ */
+
+logical lderes_(char *type__, char *uplo, integer *m, integer *n, doublereal *
+	aa, doublereal *as, integer *lda, ftnlen type_len, ftnlen uplo_len)
+{
+    /* System generated locals */
+    integer aa_dim1, aa_offset, as_dim1, as_offset, i__1, i__2;
+    logical ret_val;
+
+    /* Builtin functions */
+    integer s_cmp(char *, char *, ftnlen, ftnlen);
+
+    /* Local variables */
+    integer i__, j, ibeg, iend;
+    logical upper;
+
+
+/*  Tests if selected elements in two arrays are equal. */
+
+/*  TYPE is 'ge', 'sy' or 'sp'. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Executable Statements .. */
+    /* Parameter adjustments */
+    as_dim1 = *lda;
+    as_offset = 1 + as_dim1;
+    as -= as_offset;
+    aa_dim1 = *lda;
+    aa_offset = 1 + aa_dim1;
+    aa -= aa_offset;
+
+    /* Function Body */
+    upper = *(unsigned char *)uplo == 'U';
+    if (s_cmp(type__, "ge", (ftnlen)2, (ftnlen)2) == 0) {
+	i__1 = *n;
+	for (j = 1; j <= i__1; ++j) {
+	    i__2 = *lda;
+	    for (i__ = *m + 1; i__ <= i__2; ++i__) {
+		if (aa[i__ + j * aa_dim1] != as[i__ + j * as_dim1]) {
+		    goto L70;
+		}
+/* L10: */
+	    }
+/* L20: */
+	}
+    } else if (s_cmp(type__, "sy", (ftnlen)2, (ftnlen)2) == 0) {
+	i__1 = *n;
+	for (j = 1; j <= i__1; ++j) {
+	    if (upper) {
+		ibeg = 1;
+		iend = j;
+	    } else {
+		ibeg = j;
+		iend = *n;
+	    }
+	    i__2 = ibeg - 1;
+	    for (i__ = 1; i__ <= i__2; ++i__) {
+		if (aa[i__ + j * aa_dim1] != as[i__ + j * as_dim1]) {
+		    goto L70;
+		}
+/* L30: */
+	    }
+	    i__2 = *lda;
+	    for (i__ = iend + 1; i__ <= i__2; ++i__) {
+		if (aa[i__ + j * aa_dim1] != as[i__ + j * as_dim1]) {
+		    goto L70;
+		}
+/* L40: */
+	    }
+/* L50: */
+	}
+    }
+
+/* L60: */
+    ret_val = TRUE_;
+    goto L80;
+L70:
+    ret_val = FALSE_;
+L80:
+    return ret_val;
+
+/*     End of LDERES. */
+
+} /* lderes_ */
+
+doublereal dbeg_(logical *reset)
+{
+    /* System generated locals */
+    doublereal ret_val;
+
+    /* Local variables */
+    static integer i__, ic, mi;
+
+
+/*  Generates random numbers uniformly distributed between -0.5 and 0.5. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Scalar Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Save statement .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Executable Statements .. */
+    if (*reset) {
+/*        Initialize local variables. */
+	mi = 891;
+	i__ = 7;
+	ic = 0;
+	*reset = FALSE_;
+    }
+
+/*     The sequence of values of I is bounded between 1 and 999. */
+/*     If initial I = 1,2,3,6,7 or 9, the period will be 50. */
+/*     If initial I = 4 or 8, the period will be 25. */
+/*     If initial I = 5, the period will be 10. */
+/*     IC is used to break up the period by skipping 1 value of I in 6. */
+
+    ++ic;
+L10:
+    i__ *= mi;
+    i__ -= i__ / 1000 * 1000;
+    if (ic >= 5) {
+	ic = 0;
+	goto L10;
+    }
+    ret_val = (doublereal) (i__ - 500) / 1001.;
+    return ret_val;
+
+/*     End of DBEG. */
+
+} /* dbeg_ */
+
+doublereal ddiff_(doublereal *x, doublereal *y)
+{
+    /* System generated locals */
+    doublereal ret_val;
+
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+
+/*     .. Scalar Arguments .. */
+/*     .. Executable Statements .. */
+    ret_val = *x - *y;
+    return ret_val;
+
+/*     End of DDIFF. */
+
+} /* ddiff_ */
+
+/* Main program alias */ int dblat2_ () { MAIN__ (); return 0; }
diff --git a/CBLAS/testing/c_dblat3.c b/CBLAS/testing/c_dblat3.c
new file mode 100644
index 0000000..ce6b6db
--- /dev/null
+++ b/CBLAS/testing/c_dblat3.c
@@ -0,0 +1,3810 @@
+/* testing/c_dblat3.f -- translated by f2c (version 20191129).
+   You must link the resulting object file with libf2c:
+        on Microsoft Windows system, link with libf2c.lib;
+        on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+        or, if you install libf2c.a in a standard place, with -lf2c -lm
+        -- in that order, at the end of the command line, as in
+                cc *.o -lf2c -lm
+        Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+                http://www.netlib.org/f2c/libf2c.zip
+*/
+
+#include "f2c.h"
+
+/* Common Block Declarations */
+
+struct {
+  integer infot, noutc;
+  logical ok;
+} infoc_;
+
+#define infoc_1 infoc_
+
+struct {
+  char srnamt[12];
+} srnamc_;
+
+#define srnamc_1 srnamc_
+
+/* Table of constant values */
+
+static integer c__9 = 9;
+static integer c__1 = 1;
+static integer c__3 = 3;
+static integer c__8 = 8;
+static integer c__5 = 5;
+static integer c__65 = 65;
+static integer c__7 = 7;
+static doublereal c_b90 = 1.;
+static doublereal c_b104 = 0.;
+static integer c__6 = 6;
+static logical c_true = TRUE_;
+static integer c__0 = 0;
+static logical c_false = FALSE_;
+
+/* Main program */ int MAIN__(void) {
+  /* Initialized data */
+
+  static char snames[12 * 6] = "cblas_dgemm "
+                               "cblas_dsymm "
+                               "cblas_dtrmm "
+                               "cblas_dtrsm "
+                               "cblas_dsyrk "
+                               "cblas_dsyr2k";
+
+  /* Format strings */
+  static char fmt_9997[] = "(\002 NUMBER OF VALUES OF \002,a,\002 IS LESS "
+                           "THAN 1 OR GREATER \002,\002THAN \002,i2)";
+  static char fmt_9996[] = "(\002 VALUE OF N IS LESS THAN 0 OR GREATER THA"
+                           "N \002,i2)";
+  static char fmt_9995[] =
+      "(\002 TESTS OF THE DOUBLE PRECISION LEVEL 3 BL"
+      "AS\002,//\002 THE F\002,\002OLLOWING PARAMETER VALUES WILL BE US"
+      "ED:\002)";
+  static char fmt_9994[] = "(\002   FOR N              \002,9i6)";
+  static char fmt_9993[] = "(\002   FOR ALPHA          \002,7f6.1)";
+  static char fmt_9992[] = "(\002   FOR BETA           \002,7f6.1)";
+  static char fmt_9984[] = "(\002 ERROR-EXITS WILL NOT BE TESTED\002)";
+  static char fmt_9999[] = "(\002 ROUTINES PASS COMPUTATIONAL TESTS IF TES"
+                           "T RATIO IS LES\002,\002S THAN\002,f8.2)";
+  static char fmt_10002[] = "(\002 COLUMN-MAJOR AND ROW-MAJOR DATA LAYOUTS"
+                            " ARE TESTED\002)";
+  static char fmt_10001[] = "(\002 ROW-MAJOR DATA LAYOUT IS TESTED\002)";
+  static char fmt_10000[] = "(\002 COLUMN-MAJOR DATA LAYOUT IS TESTED\002)";
+  static char fmt_9988[] = "(a12,l2)";
+  static char fmt_9990[] =
+      "(\002 SUBPROGRAM NAME \002,a12,\002 NOT RECOGN"
+      "IZED\002,/\002 ******* T\002,\002ESTS ABANDONED *******\002)";
+  static char fmt_9998[] = "(\002 RELATIVE MACHINE PRECISION IS TAKEN TO"
+                           " BE\002,1p,d9.1)";
+  static char fmt_9989[] =
+      "(\002 ERROR IN DMMCH -  IN-LINE DOT PRODUCTS A"
+      "RE BEING EVALU\002,\002ATED WRONGLY.\002,/\002 DMMCH WAS CALLED "
+      "WITH TRANSA = \002,a1,\002 AND TRANSB = \002,a1,/\002 AND RETURN"
+      "ED SAME = \002,l1,\002 AND \002,\002ERR = \002,f12.3,\002.\002,"
+      "/\002 THIS MAY BE DUE TO FAULTS IN THE \002,\002ARITHMETIC OR TH"
+      "E COMPILER.\002,/\002 ******* TESTS ABANDONED \002,\002******"
+      "*\002)";
+  static char fmt_9987[] = "(1x,a12,\002 WAS NOT TESTED\002)";
+  static char fmt_9986[] = "(/\002 END OF TESTS\002)";
+  static char fmt_9985[] = "(/\002 ******* FATAL ERROR - TESTS ABANDONED *"
+                           "******\002)";
+  static char fmt_9991[] =
+      "(\002 AMEND DATA FILE OR INCREASE ARRAY SIZES "
+      "IN PROGRAM\002,/\002 ******* TESTS ABANDONED *******\002)";
+
+  /* System generated locals */
+  integer i__1, i__2, i__3;
+  doublereal d__1;
+  olist o__1;
+  cllist cl__1;
+
+  /* Builtin functions */
+  integer s_rsle(cilist *), do_lio(integer *, integer *, char *, ftnlen),
+      e_rsle(void), f_open(olist *), s_wsfe(cilist *),
+      do_fio(integer *, char *, ftnlen), e_wsfe(void), s_wsle(cilist *),
+      e_wsle(void), s_rsfe(cilist *), e_rsfe(void),
+      s_cmp(char *, char *, ftnlen, ftnlen);
+  /* Subroutine */ int s_stop(char *, ftnlen);
+  integer f_clos(cllist *);
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+
+  /* Local variables */
+  doublereal c__[4225] /* was [65][65] */, g[65];
+  integer i__, j, n;
+  doublereal w[130], aa[4225], ab[8450] /* was [65][130] */, bb[4225], cc[4225],
+      as[4225], bs[4225], cs[4225], ct[65], alf[7];
+  extern logical lde_(doublereal *, doublereal *, integer *);
+  doublereal bet[7], eps, err;
+  integer nalf, idim[9];
+  logical same;
+  integer nbet, ntra;
+  logical rewi;
+  extern /* Subroutine */ int dchk1_(
+      char *, doublereal *, doublereal *, integer *, integer *, logical *,
+      logical *, logical *, integer *, integer *, integer *, doublereal *,
+      integer *, doublereal *, integer *, doublereal *, doublereal *,
+      doublereal *, doublereal *, doublereal *, doublereal *, doublereal *,
+      doublereal *, doublereal *, doublereal *, doublereal *, integer *,
+      ftnlen),
+      dchk2_(char *, doublereal *, doublereal *, integer *, integer *,
+             logical *, logical *, logical *, integer *, integer *, integer *,
+             doublereal *, integer *, doublereal *, integer *, doublereal *,
+             doublereal *, doublereal *, doublereal *, doublereal *,
+             doublereal *, doublereal *, doublereal *, doublereal *,
+             doublereal *, doublereal *, integer *, ftnlen),
+      dchk3_(char *, doublereal *, doublereal *, integer *, integer *,
+             logical *, logical *, logical *, integer *, integer *, integer *,
+             doublereal *, integer *, doublereal *, doublereal *, doublereal *,
+             doublereal *, doublereal *, doublereal *, doublereal *,
+             doublereal *, doublereal *, integer *, ftnlen),
+      dchk4_(char *, doublereal *, doublereal *, integer *, integer *,
+             logical *, logical *, logical *, integer *, integer *, integer *,
+             doublereal *, integer *, doublereal *, integer *, doublereal *,
+             doublereal *, doublereal *, doublereal *, doublereal *,
+             doublereal *, doublereal *, doublereal *, doublereal *,
+             doublereal *, doublereal *, integer *, ftnlen),
+      dchk5_(char *, doublereal *, doublereal *, integer *, integer *,
+             logical *, logical *, logical *, integer *, integer *, integer *,
+             doublereal *, integer *, doublereal *, integer *, doublereal *,
+             doublereal *, doublereal *, doublereal *, doublereal *,
+             doublereal *, doublereal *, doublereal *, doublereal *,
+             doublereal *, doublereal *, integer *, ftnlen);
+  extern doublereal ddiff_(doublereal *, doublereal *);
+  logical fatal;
+  extern /* Subroutine */ int dmmch_(
+      char *, char *, integer *, integer *, integer *, doublereal *,
+      doublereal *, integer *, doublereal *, integer *, doublereal *,
+      doublereal *, integer *, doublereal *, doublereal *, doublereal *,
+      integer *, doublereal *, doublereal *, logical *, integer *, logical *,
+      ftnlen, ftnlen);
+  logical trace;
+  integer nidim;
+  char snaps[32];
+  integer isnum;
+  logical ltest[6], sfatal, corder;
+  char snamet[12], transa[1], transb[1];
+  doublereal thresh;
+  logical rorder;
+  extern /* Subroutine */ void cd3chke_(char *);
+  integer layout;
+  logical ltestt, tsterr;
+
+  /* Fortran I/O blocks */
+  static cilist io___2 = {0, 5, 0, 0, 0};
+  static cilist io___4 = {0, 5, 0, 0, 0};
+  static cilist io___7 = {0, 5, 0, 0, 0};
+  static cilist io___9 = {0, 5, 0, 0, 0};
+  static cilist io___11 = {0, 5, 0, 0, 0};
+  static cilist io___13 = {0, 5, 0, 0, 0};
+  static cilist io___15 = {0, 5, 0, 0, 0};
+  static cilist io___17 = {0, 5, 0, 0, 0};
+  static cilist io___19 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___20 = {0, 5, 0, 0, 0};
+  static cilist io___23 = {0, 6, 0, fmt_9996, 0};
+  static cilist io___24 = {0, 5, 0, 0, 0};
+  static cilist io___26 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___27 = {0, 5, 0, 0, 0};
+  static cilist io___29 = {0, 5, 0, 0, 0};
+  static cilist io___31 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___32 = {0, 5, 0, 0, 0};
+  static cilist io___34 = {0, 6, 0, fmt_9995, 0};
+  static cilist io___35 = {0, 6, 0, fmt_9994, 0};
+  static cilist io___36 = {0, 6, 0, fmt_9993, 0};
+  static cilist io___37 = {0, 6, 0, fmt_9992, 0};
+  static cilist io___38 = {0, 6, 0, 0, 0};
+  static cilist io___39 = {0, 6, 0, fmt_9984, 0};
+  static cilist io___40 = {0, 6, 0, 0, 0};
+  static cilist io___41 = {0, 6, 0, fmt_9999, 0};
+  static cilist io___42 = {0, 6, 0, 0, 0};
+  static cilist io___45 = {0, 6, 0, fmt_10002, 0};
+  static cilist io___46 = {0, 6, 0, fmt_10001, 0};
+  static cilist io___47 = {0, 6, 0, fmt_10000, 0};
+  static cilist io___48 = {0, 6, 0, 0, 0};
+  static cilist io___50 = {0, 5, 1, fmt_9988, 0};
+  static cilist io___53 = {0, 6, 0, fmt_9990, 0};
+  static cilist io___55 = {0, 6, 0, fmt_9998, 0};
+  static cilist io___68 = {0, 6, 0, fmt_9989, 0};
+  static cilist io___69 = {0, 6, 0, fmt_9989, 0};
+  static cilist io___70 = {0, 6, 0, fmt_9989, 0};
+  static cilist io___71 = {0, 6, 0, fmt_9989, 0};
+  static cilist io___73 = {0, 6, 0, 0, 0};
+  static cilist io___74 = {0, 6, 0, fmt_9987, 0};
+  static cilist io___75 = {0, 6, 0, 0, 0};
+  static cilist io___82 = {0, 6, 0, fmt_9986, 0};
+  static cilist io___83 = {0, 6, 0, fmt_9985, 0};
+  static cilist io___84 = {0, 6, 0, fmt_9991, 0};
+
+  /*  Test program for the DOUBLE PRECISION Level 3 Blas. */
+
+  /*  The program must be driven by a short data file. The first 13 records */
+  /*  of the file are read using list-directed input, the last 6 records */
+  /*  are read using the format ( A12, L2 ). An annotated example of a data */
+  /*  file can be obtained by deleting the first 3 characters from the */
+  /*  following 19 lines: */
+  /*  'DBLAT3.SNAP'     NAME OF SNAPSHOT OUTPUT FILE */
+  /*  -1                UNIT NUMBER OF SNAPSHOT FILE (NOT USED IF .LT. 0) */
+  /*  F        LOGICAL FLAG, T TO REWIND SNAPSHOT FILE AFTER EACH RECORD. */
+  /*  F        LOGICAL FLAG, T TO STOP ON FAILURES. */
+  /*  T        LOGICAL FLAG, T TO TEST ERROR EXITS. */
+  /*  2        0 TO TEST COLUMN-MAJOR, 1 TO TEST ROW-MAJOR, 2 TO TEST BOTH */
+  /*  16.0     THRESHOLD VALUE OF TEST RATIO */
+  /*  6                 NUMBER OF VALUES OF N */
+  /*  0 1 2 3 5 9       VALUES OF N */
+  /*  3                 NUMBER OF VALUES OF ALPHA */
+  /*  0.0 1.0 0.7       VALUES OF ALPHA */
+  /*  3                 NUMBER OF VALUES OF BETA */
+  /*  0.0 1.0 1.3       VALUES OF BETA */
+  /*  cblas_dgemm  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_dsymm  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_dtrmm  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_dtrsm  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_dsyrk  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_dsyr2k T PUT F FOR NO TEST. SAME COLUMNS. */
+
+  /*  See: */
+
+  /*     Dongarra J. J., Du Croz J. J., Duff I. S. and Hammarling S. */
+  /*     A Set of Level 3 Basic Linear Algebra Subprograms. */
+
+  /*     Technical Memorandum No.88 (Revision 1), Mathematics and */
+  /*     Computer Science Division, Argonne National Laboratory, 9700 */
+  /*     South Cass Avenue, Argonne, Illinois 60439, US. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /*     .. Executable Statements .. */
+
+  /*     Read name and unit number for summary output file and open file. */
+
+  infoc_1.noutc = 6;
+  /*     Read name and unit number for snapshot output file and open file. */
+
+  s_rsle(&io___2);
+  do_lio(&c__9, &c__1, snaps, (ftnlen)32);
+  e_rsle();
+  s_rsle(&io___4);
+  do_lio(&c__3, &c__1, (char *)&ntra, (ftnlen)sizeof(integer));
+  e_rsle();
+  trace = ntra >= 0;
+  if (trace) {
+    o__1.oerr = 0;
+    o__1.ounit = ntra;
+    o__1.ofnmlen = 32;
+    o__1.ofnm = snaps;
+    o__1.orl = 0;
+    o__1.osta = "NEW";
+    o__1.oacc = 0;
+    o__1.ofm = 0;
+    o__1.oblnk = 0;
+    f_open(&o__1);
+  }
+  /*     Read the flag that directs rewinding of the snapshot file. */
+  s_rsle(&io___7);
+  do_lio(&c__8, &c__1, (char *)&rewi, (ftnlen)sizeof(logical));
+  e_rsle();
+  rewi = rewi && trace;
+  /*     Read the flag that directs stopping on any failure. */
+  s_rsle(&io___9);
+  do_lio(&c__8, &c__1, (char *)&sfatal, (ftnlen)sizeof(logical));
+  e_rsle();
+  /*     Read the flag that indicates whether error exits are to be tested. */
+  s_rsle(&io___11);
+  do_lio(&c__8, &c__1, (char *)&tsterr, (ftnlen)sizeof(logical));
+  e_rsle();
+  /*     Read the flag that indicates whether row-major data layout to be
+   * tested. */
+  s_rsle(&io___13);
+  do_lio(&c__3, &c__1, (char *)&layout, (ftnlen)sizeof(integer));
+  e_rsle();
+  /*     Read the threshold value of the test ratio */
+  s_rsle(&io___15);
+  do_lio(&c__5, &c__1, (char *)&thresh, (ftnlen)sizeof(doublereal));
+  e_rsle();
+
+  /*     Read and check the parameter values for the tests. */
+
+  /*     Values of N */
+  s_rsle(&io___17);
+  do_lio(&c__3, &c__1, (char *)&nidim, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nidim < 1 || nidim > 9) {
+    s_wsfe(&io___19);
+    do_fio(&c__1, "N", (ftnlen)1);
+    do_fio(&c__1, (char *)&c__9, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L220;
+  }
+  s_rsle(&io___20);
+  i__1 = nidim;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__3, &c__1, (char *)&idim[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_rsle();
+  i__1 = nidim;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    if (idim[i__ - 1] < 0 || idim[i__ - 1] > 65) {
+      s_wsfe(&io___23);
+      do_fio(&c__1, (char *)&c__65, (ftnlen)sizeof(integer));
+      e_wsfe();
+      goto L220;
+    }
+    /* L10: */
+  }
+  /*     Values of ALPHA */
+  s_rsle(&io___24);
+  do_lio(&c__3, &c__1, (char *)&nalf, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nalf < 1 || nalf > 7) {
+    s_wsfe(&io___26);
+    do_fio(&c__1, "ALPHA", (ftnlen)5);
+    do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L220;
+  }
+  s_rsle(&io___27);
+  i__1 = nalf;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__5, &c__1, (char *)&alf[i__ - 1], (ftnlen)sizeof(doublereal));
+  }
+  e_rsle();
+  /*     Values of BETA */
+  s_rsle(&io___29);
+  do_lio(&c__3, &c__1, (char *)&nbet, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nbet < 1 || nbet > 7) {
+    s_wsfe(&io___31);
+    do_fio(&c__1, "BETA", (ftnlen)4);
+    do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L220;
+  }
+  s_rsle(&io___32);
+  i__1 = nbet;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__5, &c__1, (char *)&bet[i__ - 1], (ftnlen)sizeof(doublereal));
+  }
+  e_rsle();
+
+  /*     Report values of parameters. */
+
+  s_wsfe(&io___34);
+  e_wsfe();
+  s_wsfe(&io___35);
+  i__1 = nidim;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__1, (char *)&idim[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_wsfe();
+  s_wsfe(&io___36);
+  i__1 = nalf;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__1, (char *)&alf[i__ - 1], (ftnlen)sizeof(doublereal));
+  }
+  e_wsfe();
+  s_wsfe(&io___37);
+  i__1 = nbet;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__1, (char *)&bet[i__ - 1], (ftnlen)sizeof(doublereal));
+  }
+  e_wsfe();
+  if (!tsterr) {
+    s_wsle(&io___38);
+    e_wsle();
+    s_wsfe(&io___39);
+    e_wsfe();
+  }
+  s_wsle(&io___40);
+  e_wsle();
+  s_wsfe(&io___41);
+  do_fio(&c__1, (char *)&thresh, (ftnlen)sizeof(doublereal));
+  e_wsfe();
+  s_wsle(&io___42);
+  e_wsle();
+  rorder = FALSE_;
+  corder = FALSE_;
+  if (layout == 2) {
+    rorder = TRUE_;
+    corder = TRUE_;
+    s_wsfe(&io___45);
+    e_wsfe();
+  } else if (layout == 1) {
+    rorder = TRUE_;
+    s_wsfe(&io___46);
+    e_wsfe();
+  } else if (layout == 0) {
+    corder = TRUE_;
+    s_wsfe(&io___47);
+    e_wsfe();
+  }
+  s_wsle(&io___48);
+  e_wsle();
+
+  /*     Read names of subroutines and flags which indicate */
+  /*     whether they are to be tested. */
+
+  for (i__ = 1; i__ <= 6; ++i__) {
+    ltest[i__ - 1] = FALSE_;
+    /* L20: */
+  }
+L30:
+  i__1 = s_rsfe(&io___50);
+  if (i__1 != 0) {
+    goto L60;
+  }
+  i__1 = do_fio(&c__1, snamet, (ftnlen)12);
+  if (i__1 != 0) {
+    goto L60;
+  }
+  i__1 = do_fio(&c__1, (char *)&ltestt, (ftnlen)sizeof(logical));
+  if (i__1 != 0) {
+    goto L60;
+  }
+  i__1 = e_rsfe();
+  if (i__1 != 0) {
+    goto L60;
+  }
+  for (i__ = 1; i__ <= 6; ++i__) {
+    if (s_cmp(snamet, snames + (i__ - 1) * 12, (ftnlen)12, (ftnlen)12) == 0) {
+      goto L50;
+    }
+    /* L40: */
+  }
+  s_wsfe(&io___53);
+  do_fio(&c__1, snamet, (ftnlen)12);
+  e_wsfe();
+  s_stop("", (ftnlen)0);
+L50:
+  ltest[i__ - 1] = ltestt;
+  goto L30;
+
+L60:
+  cl__1.cerr = 0;
+  cl__1.cunit = 5;
+  cl__1.csta = 0;
+  f_clos(&cl__1);
+
+  /*     Compute EPS (the machine precision). */
+
+  eps = 1.;
+L70:
+  d__1 = eps + 1.;
+  if (ddiff_(&d__1, &c_b90) == 0.) {
+    goto L80;
+  }
+  eps *= .5;
+  goto L70;
+L80:
+  eps += eps;
+  s_wsfe(&io___55);
+  do_fio(&c__1, (char *)&eps, (ftnlen)sizeof(doublereal));
+  e_wsfe();
+
+  /*     Check the reliability of DMMCH using exact data. */
+
+  n = 32;
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = n;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      /* Computing MAX */
+      i__3 = i__ - j + 1;
+      ab[i__ + j * 65 - 66] = (doublereal)max(i__3, 0);
+      /* L90: */
+    }
+    ab[j + 4224] = (doublereal)j;
+    ab[(j + 65) * 65 - 65] = (doublereal)j;
+    c__[j - 1] = 0.;
+    /* L100: */
+  }
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    cc[j - 1] = (doublereal)(j * ((j + 1) * j) / 2 - (j + 1) * j * (j - 1) / 3);
+    /* L110: */
+  }
+  /*     CC holds the exact result. On exit from DMMCH CT holds */
+  /*     the result computed by DMMCH. */
+  *(unsigned char *)transa = 'N';
+  *(unsigned char *)transb = 'N';
+  dmmch_(transa, transb, &n, &c__1, &n, &c_b90, ab, &c__65, &ab[4225], &c__65,
+         &c_b104, c__, &c__65, ct, g, cc, &c__65, &eps, &err, &fatal, &c__6,
+         &c_true, (ftnlen)1, (ftnlen)1);
+  same = lde_(cc, ct, &n);
+  if (!same || err != 0.) {
+    s_wsfe(&io___68);
+    do_fio(&c__1, transa, (ftnlen)1);
+    do_fio(&c__1, transb, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(doublereal));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+  *(unsigned char *)transb = 'T';
+  dmmch_(transa, transb, &n, &c__1, &n, &c_b90, ab, &c__65, &ab[4225], &c__65,
+         &c_b104, c__, &c__65, ct, g, cc, &c__65, &eps, &err, &fatal, &c__6,
+         &c_true, (ftnlen)1, (ftnlen)1);
+  same = lde_(cc, ct, &n);
+  if (!same || err != 0.) {
+    s_wsfe(&io___69);
+    do_fio(&c__1, transa, (ftnlen)1);
+    do_fio(&c__1, transb, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(doublereal));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    ab[j + 4224] = (doublereal)(n - j + 1);
+    ab[(j + 65) * 65 - 65] = (doublereal)(n - j + 1);
+    /* L120: */
+  }
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    cc[n - j] = (doublereal)(j * ((j + 1) * j) / 2 - (j + 1) * j * (j - 1) / 3);
+    /* L130: */
+  }
+  *(unsigned char *)transa = 'T';
+  *(unsigned char *)transb = 'N';
+  dmmch_(transa, transb, &n, &c__1, &n, &c_b90, ab, &c__65, &ab[4225], &c__65,
+         &c_b104, c__, &c__65, ct, g, cc, &c__65, &eps, &err, &fatal, &c__6,
+         &c_true, (ftnlen)1, (ftnlen)1);
+  same = lde_(cc, ct, &n);
+  if (!same || err != 0.) {
+    s_wsfe(&io___70);
+    do_fio(&c__1, transa, (ftnlen)1);
+    do_fio(&c__1, transb, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(doublereal));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+  *(unsigned char *)transb = 'T';
+  dmmch_(transa, transb, &n, &c__1, &n, &c_b90, ab, &c__65, &ab[4225], &c__65,
+         &c_b104, c__, &c__65, ct, g, cc, &c__65, &eps, &err, &fatal, &c__6,
+         &c_true, (ftnlen)1, (ftnlen)1);
+  same = lde_(cc, ct, &n);
+  if (!same || err != 0.) {
+    s_wsfe(&io___71);
+    do_fio(&c__1, transa, (ftnlen)1);
+    do_fio(&c__1, transb, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(doublereal));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+
+  /*     Test each subroutine in turn. */
+
+  for (isnum = 1; isnum <= 6; ++isnum) {
+    s_wsle(&io___73);
+    e_wsle();
+    if (!ltest[isnum - 1]) {
+      /*           Subprogram is not to be tested. */
+      s_wsfe(&io___74);
+      do_fio(&c__1, snames + (isnum - 1) * 12, (ftnlen)12);
+      e_wsfe();
+    } else {
+      s_copy(srnamc_1.srnamt, snames + (isnum - 1) * 12, (ftnlen)12,
+             (ftnlen)12);
+      /*           Test error exits. */
+      if (tsterr) {
+        cd3chke_(snames + (isnum - 1) * 12);
+        s_wsle(&io___75);
+        e_wsle();
+      }
+      /*           Test computations. */
+      infoc_1.infot = 0;
+      infoc_1.ok = TRUE_;
+      fatal = FALSE_;
+      switch (isnum) {
+      case 1:
+        goto L140;
+      case 2:
+        goto L150;
+      case 3:
+        goto L160;
+      case 4:
+        goto L160;
+      case 5:
+        goto L170;
+      case 6:
+        goto L180;
+      }
+    /*           Test DGEMM, 01. */
+    L140:
+      if (corder) {
+        dchk1_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__0,
+               (ftnlen)12);
+      }
+      if (rorder) {
+        dchk1_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__1,
+               (ftnlen)12);
+      }
+      goto L190;
+    /*           Test DSYMM, 02. */
+    L150:
+      if (corder) {
+        dchk2_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__0,
+               (ftnlen)12);
+      }
+      if (rorder) {
+        dchk2_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__1,
+               (ftnlen)12);
+      }
+      goto L190;
+    /*           Test DTRMM, 03, DTRSM, 04. */
+    L160:
+      if (corder) {
+        dchk3_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &c__65, ab, aa, as,
+               &ab[4225], bb, bs, ct, g, c__, &c__0, (ftnlen)12);
+      }
+      if (rorder) {
+        dchk3_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &c__65, ab, aa, as,
+               &ab[4225], bb, bs, ct, g, c__, &c__1, (ftnlen)12);
+      }
+      goto L190;
+    /*           Test DSYRK, 05. */
+    L170:
+      if (corder) {
+        dchk4_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__0,
+               (ftnlen)12);
+      }
+      if (rorder) {
+        dchk4_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__1,
+               (ftnlen)12);
+      }
+      goto L190;
+    /*           Test DSYR2K, 06. */
+    L180:
+      if (corder) {
+        dchk5_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, bb, bs, c__, cc, cs, ct, g, w, &c__0, (ftnlen)12);
+      }
+      if (rorder) {
+        dchk5_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, bb, bs, c__, cc, cs, ct, g, w, &c__1, (ftnlen)12);
+      }
+      goto L190;
+
+    L190:
+      if (fatal && sfatal) {
+        goto L210;
+      }
+    }
+    /* L200: */
+  }
+  s_wsfe(&io___82);
+  e_wsfe();
+  goto L230;
+
+L210:
+  s_wsfe(&io___83);
+  e_wsfe();
+  goto L230;
+
+L220:
+  s_wsfe(&io___84);
+  e_wsfe();
+
+L230:
+  if (trace) {
+    cl__1.cerr = 0;
+    cl__1.cunit = ntra;
+    cl__1.csta = 0;
+    f_clos(&cl__1);
+  }
+  cl__1.cerr = 0;
+  cl__1.cunit = 6;
+  cl__1.csta = 0;
+  f_clos(&cl__1);
+  s_stop("", (ftnlen)0);
+
+  /*     End of DBLAT3. */
+
+  return 0;
+} /* MAIN__ */
+
+/* Subroutine */ int
+dchk1_(char *sname, doublereal *eps, doublereal *thresh, integer *nout,
+       integer *ntra, logical *trace, logical *rewi, logical *fatal,
+       integer *nidim, integer *idim, integer *nalf, doublereal *alf,
+       integer *nbet, doublereal *bet, integer *nmax, doublereal *a,
+       doublereal *aa, doublereal *as, doublereal *b, doublereal *bb,
+       doublereal *bs, doublereal *c__, doublereal *cc, doublereal *cs,
+       doublereal *ct, doublereal *g, integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ich[3] = "NTC";
+
+  /* Format strings */
+  static char fmt_9994[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
+      i__3, i__4, i__5, i__6;
+  alist al__1;
+
+  /* Builtin functions */
+  integer f_rew(alist *), s_wsfe(cilist *), e_wsfe(void),
+      do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, k, m, n, ia, ib, ma, mb, na, nb, nc, ik, im, in, ks, ms, ns, ica,
+      icb, laa, lbb, lda, lcc, ldb, ldc;
+  extern logical lde_(doublereal *, doublereal *, integer *);
+  doublereal als, bls, err, beta;
+  integer ldas, ldbs, ldcs;
+  logical same, null;
+  extern /* Subroutine */ int dmake_(
+      char *, char *, char *, integer *, integer *, doublereal *, integer *,
+      doublereal *, integer *, logical *, doublereal *, ftnlen, ftnlen, ftnlen);
+  doublereal alpha;
+  extern /* Subroutine */ int dmmch_(
+      char *, char *, integer *, integer *, integer *, doublereal *,
+      doublereal *, integer *, doublereal *, integer *, doublereal *,
+      doublereal *, integer *, doublereal *, doublereal *, doublereal *,
+      integer *, doublereal *, doublereal *, logical *, integer *, logical *,
+      ftnlen, ftnlen);
+  logical isame[13], trana, tranb;
+  integer nargs;
+  logical reset;
+  extern /* Subroutine */ int dprcn1_(
+      integer *, integer *, char *, integer *, char *, char *, integer *,
+      integer *, integer *, doublereal *, integer *, integer *, doublereal *,
+      integer *, ftnlen, ftnlen, ftnlen);
+  extern void cdgemm_(integer *, char *, char *, integer *, integer *, integer *,
+                      doublereal *, doublereal *, integer *, doublereal *, integer *,
+                      doublereal *, doublereal *, integer *);
+  extern logical lderes_(char *, char *, integer *, integer *, doublereal *,
+                         doublereal *, integer *, ftnlen, ftnlen);
+  char tranas[1], tranbs[1], transa[1], transb[1];
+  doublereal errmax;
+
+  /* Fortran I/O blocks */
+  static cilist io___128 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___131 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___133 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___134 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___135 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___136 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___137 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests DGEMM. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --bet;
+  --g;
+  --ct;
+  --cs;
+  --cc;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --bs;
+  --bb;
+  b_dim1 = *nmax;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+
+  nargs = 13;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.;
+
+  i__1 = *nidim;
+  for (im = 1; im <= i__1; ++im) {
+    m = idim[im];
+
+    i__2 = *nidim;
+    for (in = 1; in <= i__2; ++in) {
+      n = idim[in];
+      /*           Set LDC to 1 more than minimum value if room. */
+      ldc = m;
+      if (ldc < *nmax) {
+        ++ldc;
+      }
+      /*           Skip tests if not enough room. */
+      if (ldc > *nmax) {
+        goto L100;
+      }
+      lcc = ldc * n;
+      null = n <= 0 || m <= 0;
+
+      i__3 = *nidim;
+      for (ik = 1; ik <= i__3; ++ik) {
+        k = idim[ik];
+
+        for (ica = 1; ica <= 3; ++ica) {
+          *(unsigned char *)transa = *(unsigned char *)&ich[ica - 1];
+          trana = *(unsigned char *)transa == 'T' ||
+                  *(unsigned char *)transa == 'C';
+
+          if (trana) {
+            ma = k;
+            na = m;
+          } else {
+            ma = m;
+            na = k;
+          }
+          /*                 Set LDA to 1 more than minimum value if room. */
+          lda = ma;
+          if (lda < *nmax) {
+            ++lda;
+          }
+          /*                 Skip tests if not enough room. */
+          if (lda > *nmax) {
+            goto L80;
+          }
+          laa = lda * na;
+
+          /*                 Generate the matrix A. */
+
+          dmake_("GE", " ", " ", &ma, &na, &a[a_offset], nmax, &aa[1], &lda,
+                 &reset, &c_b104, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+          for (icb = 1; icb <= 3; ++icb) {
+            *(unsigned char *)transb = *(unsigned char *)&ich[icb - 1];
+            tranb = *(unsigned char *)transb == 'T' ||
+                    *(unsigned char *)transb == 'C';
+
+            if (tranb) {
+              mb = n;
+              nb = k;
+            } else {
+              mb = k;
+              nb = n;
+            }
+            /*                    Set LDB to 1 more than minimum value if room.
+             */
+            ldb = mb;
+            if (ldb < *nmax) {
+              ++ldb;
+            }
+            /*                    Skip tests if not enough room. */
+            if (ldb > *nmax) {
+              goto L70;
+            }
+            lbb = ldb * nb;
+
+            /*                    Generate the matrix B. */
+
+            dmake_("GE", " ", " ", &mb, &nb, &b[b_offset], nmax, &bb[1], &ldb,
+                   &reset, &c_b104, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+            i__4 = *nalf;
+            for (ia = 1; ia <= i__4; ++ia) {
+              alpha = alf[ia];
+
+              i__5 = *nbet;
+              for (ib = 1; ib <= i__5; ++ib) {
+                beta = bet[ib];
+
+                /*                          Generate the matrix C. */
+
+                dmake_("GE", " ", " ", &m, &n, &c__[c_offset], nmax, &cc[1],
+                       &ldc, &reset, &c_b104, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+                ++nc;
+
+                /*                          Save every datum before calling the
+                 */
+                /*                          subroutine. */
+
+                *(unsigned char *)tranas = *(unsigned char *)transa;
+                *(unsigned char *)tranbs = *(unsigned char *)transb;
+                ms = m;
+                ns = n;
+                ks = k;
+                als = alpha;
+                i__6 = laa;
+                for (i__ = 1; i__ <= i__6; ++i__) {
+                  as[i__] = aa[i__];
+                  /* L10: */
+                }
+                ldas = lda;
+                i__6 = lbb;
+                for (i__ = 1; i__ <= i__6; ++i__) {
+                  bs[i__] = bb[i__];
+                  /* L20: */
+                }
+                ldbs = ldb;
+                bls = beta;
+                i__6 = lcc;
+                for (i__ = 1; i__ <= i__6; ++i__) {
+                  cs[i__] = cc[i__];
+                  /* L30: */
+                }
+                ldcs = ldc;
+
+                /*                          Call the subroutine. */
+
+                if (*trace) {
+                  dprcn1_(ntra, &nc, sname, iorder, transa, transb, &m, &n, &k,
+                          &alpha, &lda, &ldb, &beta, &ldc, (ftnlen)12,
+                          (ftnlen)1, (ftnlen)1);
+                }
+                if (*rewi) {
+                  al__1.aerr = 0;
+                  al__1.aunit = *ntra;
+                  f_rew(&al__1);
+                }
+                cdgemm_(iorder, transa, transb, &m, &n, &k, &alpha, &aa[1],
+                        &lda, &bb[1], &ldb, &beta, &cc[1], &ldc);
+
+                /*                          Check if error-exit was taken
+                 * incorrectly. */
+
+                if (!infoc_1.ok) {
+                  io___128.ciunit = *nout;
+                  s_wsfe(&io___128);
+                  e_wsfe();
+                  *fatal = TRUE_;
+                  goto L120;
+                }
+
+                /*                          See what data changed inside
+                 * subroutines. */
+
+                isame[0] = *(unsigned char *)transa == *(unsigned char *)tranas;
+                isame[1] = *(unsigned char *)transb == *(unsigned char *)tranbs;
+                isame[2] = ms == m;
+                isame[3] = ns == n;
+                isame[4] = ks == k;
+                isame[5] = als == alpha;
+                isame[6] = lde_(&as[1], &aa[1], &laa);
+                isame[7] = ldas == lda;
+                isame[8] = lde_(&bs[1], &bb[1], &lbb);
+                isame[9] = ldbs == ldb;
+                isame[10] = bls == beta;
+                if (null) {
+                  isame[11] = lde_(&cs[1], &cc[1], &lcc);
+                } else {
+                  isame[11] = lderes_("GE", " ", &m, &n, &cs[1], &cc[1], &ldc,
+                                      (ftnlen)2, (ftnlen)1);
+                }
+                isame[12] = ldcs == ldc;
+
+                /*                          If data was incorrectly changed,
+                 * report */
+                /*                          and return. */
+
+                same = TRUE_;
+                i__6 = nargs;
+                for (i__ = 1; i__ <= i__6; ++i__) {
+                  same = same && isame[i__ - 1];
+                  if (!isame[i__ - 1]) {
+                    io___131.ciunit = *nout;
+                    s_wsfe(&io___131);
+                    do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  /* L40: */
+                }
+                if (!same) {
+                  *fatal = TRUE_;
+                  goto L120;
+                }
+
+                if (!null) {
+
+                  /*                             Check the result. */
+
+                  dmmch_(transa, transb, &m, &n, &k, &alpha, &a[a_offset], nmax,
+                         &b[b_offset], nmax, &beta, &c__[c_offset], nmax,
+                         &ct[1], &g[1], &cc[1], &ldc, eps, &err, fatal, nout,
+                         &c_true, (ftnlen)1, (ftnlen)1);
+                  errmax = max(errmax, err);
+                  /*                             If got really bad answer,
+                   * report and */
+                  /*                             return. */
+                  if (*fatal) {
+                    goto L120;
+                  }
+                }
+
+                /* L50: */
+              }
+
+              /* L60: */
+            }
+
+          L70:;
+          }
+
+        L80:;
+        }
+
+        /* L90: */
+      }
+
+    L100:;
+    }
+
+    /* L110: */
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___133.ciunit = *nout;
+      s_wsfe(&io___133);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___134.ciunit = *nout;
+      s_wsfe(&io___134);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___135.ciunit = *nout;
+      s_wsfe(&io___135);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___136.ciunit = *nout;
+      s_wsfe(&io___136);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+  }
+  goto L130;
+
+L120:
+  io___137.ciunit = *nout;
+  s_wsfe(&io___137);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  dprcn1_(nout, &nc, sname, iorder, transa, transb, &m, &n, &k, &alpha, &lda,
+          &ldb, &beta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+
+L130:
+  return 0;
+
+  /* L9995: */
+
+  /*     End of DCHK1. */
+
+} /* dchk1_ */
+
+/* Subroutine */ int dprcn1_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *transa, char *transb,
+                             integer *m, integer *n, integer *k,
+                             doublereal *alpha, integer *lda, integer *ldb,
+                             doublereal *beta, integer *ldc, ftnlen sname_len,
+                             ftnlen transa_len, ftnlen transb_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+                           "a14,\002,\002,a14,\002,\002)";
+  static char fmt_9994[] =
+      "(20x,3(i3,\002,\002),f4.1,\002, A,\002,i3,\002"
+      ", B,\002,i3,\002,\002,f4.1,\002, \002,\002C,\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char crc[14], cta[14], ctb[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___141 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___142 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(cta, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(cta, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cta, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transb == 'N') {
+    s_copy(ctb, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transb == 'T') {
+    s_copy(ctb, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ctb, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___141.ciunit = *nout;
+  s_wsfe(&io___141);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cta, (ftnlen)14);
+  do_fio(&c__1, ctb, (ftnlen)14);
+  e_wsfe();
+  io___142.ciunit = *nout;
+  s_wsfe(&io___142);
+  do_fio(&c__1, (char *)&(*m), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*k), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*alpha), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*ldb), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*beta), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* dprcn1_ */
+
+/* Subroutine */ int
+dchk2_(char *sname, doublereal *eps, doublereal *thresh, integer *nout,
+       integer *ntra, logical *trace, logical *rewi, logical *fatal,
+       integer *nidim, integer *idim, integer *nalf, doublereal *alf,
+       integer *nbet, doublereal *bet, integer *nmax, doublereal *a,
+       doublereal *aa, doublereal *as, doublereal *b, doublereal *bb,
+       doublereal *bs, doublereal *c__, doublereal *cc, doublereal *cs,
+       doublereal *ct, doublereal *g, integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ichs[2] = "LR";
+  static char ichu[2] = "UL";
+
+  /* Format strings */
+  static char fmt_9994[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
+      i__3, i__4, i__5;
+  alist al__1;
+
+  /* Builtin functions */
+  integer f_rew(alist *), s_wsfe(cilist *), e_wsfe(void),
+      do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, m, n, ia, ib, na, nc, im, in, ms, ns, laa, lbb, lda, lcc, ldb,
+      ldc;
+  extern logical lde_(doublereal *, doublereal *, integer *);
+  integer ics;
+  doublereal als, bls;
+  integer icu;
+  doublereal err, beta;
+  integer ldas, ldbs, ldcs;
+  logical same;
+  char side[1];
+  logical left, null;
+  char uplo[1];
+  extern /* Subroutine */ int dmake_(
+      char *, char *, char *, integer *, integer *, doublereal *, integer *,
+      doublereal *, integer *, logical *, doublereal *, ftnlen, ftnlen, ftnlen);
+  doublereal alpha;
+  extern /* Subroutine */ int dmmch_(
+      char *, char *, integer *, integer *, integer *, doublereal *,
+      doublereal *, integer *, doublereal *, integer *, doublereal *,
+      doublereal *, integer *, doublereal *, doublereal *, doublereal *,
+      integer *, doublereal *, doublereal *, logical *, integer *, logical *,
+      ftnlen, ftnlen);
+  logical isame[13];
+  char sides[1];
+  integer nargs;
+  logical reset;
+  char uplos[1];
+  extern /* Subroutine */ int dprcn2_(
+      integer *, integer *, char *, integer *, char *, char *, integer *,
+      integer *, doublereal *, integer *, integer *, doublereal *, integer *,
+      ftnlen, ftnlen, ftnlen);
+  extern logical lderes_(char *, char *, integer *, integer *, doublereal *,
+                         doublereal *, integer *, ftnlen, ftnlen);
+  extern /* Subroutine */ void cdsymm_(
+      integer *, char *, char *, integer *, integer *, doublereal *,
+      doublereal *, integer *, doublereal *, integer *, doublereal *,
+      doublereal *, integer *);
+  doublereal errmax;
+
+  /* Fortran I/O blocks */
+  static cilist io___180 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___183 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___185 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___186 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___187 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___188 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___189 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests DSYMM. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --bet;
+  --g;
+  --ct;
+  --cs;
+  --cc;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --bs;
+  --bb;
+  b_dim1 = *nmax;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+
+  nargs = 12;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.;
+
+  i__1 = *nidim;
+  for (im = 1; im <= i__1; ++im) {
+    m = idim[im];
+
+    i__2 = *nidim;
+    for (in = 1; in <= i__2; ++in) {
+      n = idim[in];
+      /*           Set LDC to 1 more than minimum value if room. */
+      ldc = m;
+      if (ldc < *nmax) {
+        ++ldc;
+      }
+      /*           Skip tests if not enough room. */
+      if (ldc > *nmax) {
+        goto L90;
+      }
+      lcc = ldc * n;
+      null = n <= 0 || m <= 0;
+
+      /*           Set LDB to 1 more than minimum value if room. */
+      ldb = m;
+      if (ldb < *nmax) {
+        ++ldb;
+      }
+      /*           Skip tests if not enough room. */
+      if (ldb > *nmax) {
+        goto L90;
+      }
+      lbb = ldb * n;
+
+      /*           Generate the matrix B. */
+
+      dmake_("GE", " ", " ", &m, &n, &b[b_offset], nmax, &bb[1], &ldb, &reset,
+             &c_b104, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+      for (ics = 1; ics <= 2; ++ics) {
+        *(unsigned char *)side = *(unsigned char *)&ichs[ics - 1];
+        left = *(unsigned char *)side == 'L';
+
+        if (left) {
+          na = m;
+        } else {
+          na = n;
+        }
+        /*              Set LDA to 1 more than minimum value if room. */
+        lda = na;
+        if (lda < *nmax) {
+          ++lda;
+        }
+        /*              Skip tests if not enough room. */
+        if (lda > *nmax) {
+          goto L80;
+        }
+        laa = lda * na;
+
+        for (icu = 1; icu <= 2; ++icu) {
+          *(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+
+          /*                 Generate the symmetric matrix A. */
+
+          dmake_("SY", uplo, " ", &na, &na, &a[a_offset], nmax, &aa[1], &lda,
+                 &reset, &c_b104, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+          i__3 = *nalf;
+          for (ia = 1; ia <= i__3; ++ia) {
+            alpha = alf[ia];
+
+            i__4 = *nbet;
+            for (ib = 1; ib <= i__4; ++ib) {
+              beta = bet[ib];
+
+              /*                       Generate the matrix C. */
+
+              dmake_("GE", " ", " ", &m, &n, &c__[c_offset], nmax, &cc[1], &ldc,
+                     &reset, &c_b104, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+              ++nc;
+
+              /*                       Save every datum before calling the */
+              /*                       subroutine. */
+
+              *(unsigned char *)sides = *(unsigned char *)side;
+              *(unsigned char *)uplos = *(unsigned char *)uplo;
+              ms = m;
+              ns = n;
+              als = alpha;
+              i__5 = laa;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                as[i__] = aa[i__];
+                /* L10: */
+              }
+              ldas = lda;
+              i__5 = lbb;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                bs[i__] = bb[i__];
+                /* L20: */
+              }
+              ldbs = ldb;
+              bls = beta;
+              i__5 = lcc;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                cs[i__] = cc[i__];
+                /* L30: */
+              }
+              ldcs = ldc;
+
+              /*                       Call the subroutine. */
+
+              if (*trace) {
+                dprcn2_(ntra, &nc, sname, iorder, side, uplo, &m, &n, &alpha,
+                        &lda, &ldb, &beta, &ldc, (ftnlen)12, (ftnlen)1,
+                        (ftnlen)1);
+              }
+              if (*rewi) {
+                al__1.aerr = 0;
+                al__1.aunit = *ntra;
+                f_rew(&al__1);
+              }
+              cdsymm_(iorder, side, uplo, &m, &n, &alpha, &aa[1], &lda, &bb[1],
+                      &ldb, &beta, &cc[1], &ldc);
+
+              /*                       Check if error-exit was taken
+               * incorrectly. */
+
+              if (!infoc_1.ok) {
+                io___180.ciunit = *nout;
+                s_wsfe(&io___180);
+                e_wsfe();
+                *fatal = TRUE_;
+                goto L110;
+              }
+
+              /*                       See what data changed inside subroutines.
+               */
+
+              isame[0] = *(unsigned char *)sides == *(unsigned char *)side;
+              isame[1] = *(unsigned char *)uplos == *(unsigned char *)uplo;
+              isame[2] = ms == m;
+              isame[3] = ns == n;
+              isame[4] = als == alpha;
+              isame[5] = lde_(&as[1], &aa[1], &laa);
+              isame[6] = ldas == lda;
+              isame[7] = lde_(&bs[1], &bb[1], &lbb);
+              isame[8] = ldbs == ldb;
+              isame[9] = bls == beta;
+              if (null) {
+                isame[10] = lde_(&cs[1], &cc[1], &lcc);
+              } else {
+                isame[10] = lderes_("GE", " ", &m, &n, &cs[1], &cc[1], &ldc,
+                                    (ftnlen)2, (ftnlen)1);
+              }
+              isame[11] = ldcs == ldc;
+
+              /*                       If data was incorrectly changed, report
+               * and */
+              /*                       return. */
+
+              same = TRUE_;
+              i__5 = nargs;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                same = same && isame[i__ - 1];
+                if (!isame[i__ - 1]) {
+                  io___183.ciunit = *nout;
+                  s_wsfe(&io___183);
+                  do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                  e_wsfe();
+                }
+                /* L40: */
+              }
+              if (!same) {
+                *fatal = TRUE_;
+                goto L110;
+              }
+
+              if (!null) {
+
+                /*                          Check the result. */
+
+                if (left) {
+                  dmmch_("N", "N", &m, &n, &m, &alpha, &a[a_offset], nmax,
+                         &b[b_offset], nmax, &beta, &c__[c_offset], nmax,
+                         &ct[1], &g[1], &cc[1], &ldc, eps, &err, fatal, nout,
+                         &c_true, (ftnlen)1, (ftnlen)1);
+                } else {
+                  dmmch_("N", "N", &m, &n, &n, &alpha, &b[b_offset], nmax,
+                         &a[a_offset], nmax, &beta, &c__[c_offset], nmax,
+                         &ct[1], &g[1], &cc[1], &ldc, eps, &err, fatal, nout,
+                         &c_true, (ftnlen)1, (ftnlen)1);
+                }
+                errmax = max(errmax, err);
+                /*                          If got really bad answer, report and
+                 */
+                /*                          return. */
+                if (*fatal) {
+                  goto L110;
+                }
+              }
+
+              /* L50: */
+            }
+
+            /* L60: */
+          }
+
+          /* L70: */
+        }
+
+      L80:;
+      }
+
+    L90:;
+    }
+
+    /* L100: */
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___185.ciunit = *nout;
+      s_wsfe(&io___185);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___186.ciunit = *nout;
+      s_wsfe(&io___186);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___187.ciunit = *nout;
+      s_wsfe(&io___187);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___188.ciunit = *nout;
+      s_wsfe(&io___188);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+  }
+  goto L120;
+
+L110:
+  io___189.ciunit = *nout;
+  s_wsfe(&io___189);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  dprcn2_(nout, &nc, sname, iorder, side, uplo, &m, &n, &alpha, &lda, &ldb,
+          &beta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+
+L120:
+  return 0;
+
+  /* L9995: */
+
+  /*     End of DCHK2. */
+
+} /* dchk2_ */
+
+/* Subroutine */ int dprcn2_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *side, char *uplo,
+                             integer *m, integer *n, doublereal *alpha,
+                             integer *lda, integer *ldb, doublereal *beta,
+                             integer *ldc, ftnlen sname_len, ftnlen side_len,
+                             ftnlen uplo_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+                           "a14,\002,\002,a14,\002,\002)";
+  static char fmt_9994[] =
+      "(20x,2(i3,\002,\002),f4.1,\002, A,\002,i3,\002"
+      ", B,\002,i3,\002,\002,f4.1,\002, \002,\002C,\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char cs[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___193 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___194 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)side == 'L') {
+    s_copy(cs, "     CblasLeft", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cs, "    CblasRight", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___193.ciunit = *nout;
+  s_wsfe(&io___193);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cs, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  e_wsfe();
+  io___194.ciunit = *nout;
+  s_wsfe(&io___194);
+  do_fio(&c__1, (char *)&(*m), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*alpha), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*ldb), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*beta), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* dprcn2_ */
+
+/* Subroutine */ int
+dchk3_(char *sname, doublereal *eps, doublereal *thresh, integer *nout,
+       integer *ntra, logical *trace, logical *rewi, logical *fatal,
+       integer *nidim, integer *idim, integer *nalf, doublereal *alf,
+       integer *nmax, doublereal *a, doublereal *aa, doublereal *as,
+       doublereal *b, doublereal *bb, doublereal *bs, doublereal *ct,
+       doublereal *g, doublereal *c__, integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ichu[2] = "UL";
+  static char icht[3] = "NTC";
+  static char ichd[2] = "UN";
+  static char ichs[2] = "LR";
+
+  /* Format strings */
+  static char fmt_9994[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
+      i__3, i__4, i__5;
+  alist al__1;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen), f_rew(alist *),
+      s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, j, m, n, ia, na, nc, im, in, ms, ns, laa, icd, lbb, lda, ldb;
+  extern logical lde_(doublereal *, doublereal *, integer *);
+  integer ics;
+  doublereal als;
+  integer ict, icu;
+  doublereal err;
+  char diag[1];
+  integer ldas, ldbs;
+  logical same;
+  char side[1];
+  logical left, null;
+  char uplo[1];
+  extern /* Subroutine */ int dmake_(
+      char *, char *, char *, integer *, integer *, doublereal *, integer *,
+      doublereal *, integer *, logical *, doublereal *, ftnlen, ftnlen, ftnlen);
+  doublereal alpha;
+  char diags[1];
+  extern /* Subroutine */ int dmmch_(
+      char *, char *, integer *, integer *, integer *, doublereal *,
+      doublereal *, integer *, doublereal *, integer *, doublereal *,
+      doublereal *, integer *, doublereal *, doublereal *, doublereal *,
+      integer *, doublereal *, doublereal *, logical *, integer *, logical *,
+      ftnlen, ftnlen);
+  logical isame[13];
+  char sides[1];
+  integer nargs;
+  logical reset;
+  char uplos[1];
+  extern /* Subroutine */ int dprcn3_(
+      integer *, integer *, char *, integer *, char *, char *, char *, char *,
+      integer *, integer *, doublereal *, integer *, integer *, ftnlen, ftnlen,
+      ftnlen, ftnlen, ftnlen);
+  extern logical lderes_(char *, char *, integer *, integer *, doublereal *,
+                         doublereal *, integer *, ftnlen, ftnlen);
+  extern /* Subroutine */ void cdtrmm_(
+      integer *, char *, char *, char *, char *, integer *, integer *,
+      doublereal *, doublereal *, integer *, doublereal *, integer *);
+  char tranas[1], transa[1];
+  extern /* Subroutine */ void cdtrsm_(
+      integer *, char *, char *, char *, char *, integer *, integer *,
+      doublereal *, doublereal *, integer *, doublereal *, integer *);
+  doublereal errmax;
+
+  /* Fortran I/O blocks */
+  static cilist io___235 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___238 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___240 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___241 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___242 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___243 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___244 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests DTRMM and DTRSM. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --g;
+  --ct;
+  --bs;
+  --bb;
+  b_dim1 = *nmax;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+
+  nargs = 11;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.;
+  /*     Set up zero matrix for DMMCH. */
+  i__1 = *nmax;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = *nmax;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      c__[i__ + j * c_dim1] = 0.;
+      /* L10: */
+    }
+    /* L20: */
+  }
+
+  i__1 = *nidim;
+  for (im = 1; im <= i__1; ++im) {
+    m = idim[im];
+
+    i__2 = *nidim;
+    for (in = 1; in <= i__2; ++in) {
+      n = idim[in];
+      /*           Set LDB to 1 more than minimum value if room. */
+      ldb = m;
+      if (ldb < *nmax) {
+        ++ldb;
+      }
+      /*           Skip tests if not enough room. */
+      if (ldb > *nmax) {
+        goto L130;
+      }
+      lbb = ldb * n;
+      null = m <= 0 || n <= 0;
+
+      for (ics = 1; ics <= 2; ++ics) {
+        *(unsigned char *)side = *(unsigned char *)&ichs[ics - 1];
+        left = *(unsigned char *)side == 'L';
+        if (left) {
+          na = m;
+        } else {
+          na = n;
+        }
+        /*              Set LDA to 1 more than minimum value if room. */
+        lda = na;
+        if (lda < *nmax) {
+          ++lda;
+        }
+        /*              Skip tests if not enough room. */
+        if (lda > *nmax) {
+          goto L130;
+        }
+        laa = lda * na;
+
+        for (icu = 1; icu <= 2; ++icu) {
+          *(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+
+          for (ict = 1; ict <= 3; ++ict) {
+            *(unsigned char *)transa = *(unsigned char *)&icht[ict - 1];
+
+            for (icd = 1; icd <= 2; ++icd) {
+              *(unsigned char *)diag = *(unsigned char *)&ichd[icd - 1];
+
+              i__3 = *nalf;
+              for (ia = 1; ia <= i__3; ++ia) {
+                alpha = alf[ia];
+
+                /*                          Generate the matrix A. */
+
+                dmake_("TR", uplo, diag, &na, &na, &a[a_offset], nmax, &aa[1],
+                       &lda, &reset, &c_b104, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+                /*                          Generate the matrix B. */
+
+                dmake_("GE", " ", " ", &m, &n, &b[b_offset], nmax, &bb[1], &ldb,
+                       &reset, &c_b104, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+                ++nc;
+
+                /*                          Save every datum before calling the
+                 */
+                /*                          subroutine. */
+
+                *(unsigned char *)sides = *(unsigned char *)side;
+                *(unsigned char *)uplos = *(unsigned char *)uplo;
+                *(unsigned char *)tranas = *(unsigned char *)transa;
+                *(unsigned char *)diags = *(unsigned char *)diag;
+                ms = m;
+                ns = n;
+                als = alpha;
+                i__4 = laa;
+                for (i__ = 1; i__ <= i__4; ++i__) {
+                  as[i__] = aa[i__];
+                  /* L30: */
+                }
+                ldas = lda;
+                i__4 = lbb;
+                for (i__ = 1; i__ <= i__4; ++i__) {
+                  bs[i__] = bb[i__];
+                  /* L40: */
+                }
+                ldbs = ldb;
+
+                /*                          Call the subroutine. */
+
+                if (s_cmp(sname + 9, "mm", (ftnlen)2, (ftnlen)2) == 0) {
+                  if (*trace) {
+                    dprcn3_(ntra, &nc, sname, iorder, side, uplo, transa, diag,
+                            &m, &n, &alpha, &lda, &ldb, (ftnlen)12, (ftnlen)1,
+                            (ftnlen)1, (ftnlen)1, (ftnlen)1);
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cdtrmm_(iorder, side, uplo, transa, diag, &m, &n, &alpha,
+                          &aa[1], &lda, &bb[1], &ldb);
+                } else if (s_cmp(sname + 9, "sm", (ftnlen)2, (ftnlen)2) == 0) {
+                  if (*trace) {
+                    dprcn3_(ntra, &nc, sname, iorder, side, uplo, transa, diag,
+                            &m, &n, &alpha, &lda, &ldb, (ftnlen)12, (ftnlen)1,
+                            (ftnlen)1, (ftnlen)1, (ftnlen)1);
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cdtrsm_(iorder, side, uplo, transa, diag, &m, &n, &alpha,
+                          &aa[1], &lda, &bb[1], &ldb);
+                }
+
+                /*                          Check if error-exit was taken
+                 * incorrectly. */
+
+                if (!infoc_1.ok) {
+                  io___235.ciunit = *nout;
+                  s_wsfe(&io___235);
+                  e_wsfe();
+                  *fatal = TRUE_;
+                  goto L150;
+                }
+
+                /*                          See what data changed inside
+                 * subroutines. */
+
+                isame[0] = *(unsigned char *)sides == *(unsigned char *)side;
+                isame[1] = *(unsigned char *)uplos == *(unsigned char *)uplo;
+                isame[2] = *(unsigned char *)tranas == *(unsigned char *)transa;
+                isame[3] = *(unsigned char *)diags == *(unsigned char *)diag;
+                isame[4] = ms == m;
+                isame[5] = ns == n;
+                isame[6] = als == alpha;
+                isame[7] = lde_(&as[1], &aa[1], &laa);
+                isame[8] = ldas == lda;
+                if (null) {
+                  isame[9] = lde_(&bs[1], &bb[1], &lbb);
+                } else {
+                  isame[9] = lderes_("GE", " ", &m, &n, &bs[1], &bb[1], &ldb,
+                                     (ftnlen)2, (ftnlen)1);
+                }
+                isame[10] = ldbs == ldb;
+
+                /*                          If data was incorrectly changed,
+                 * report and */
+                /*                          return. */
+
+                same = TRUE_;
+                i__4 = nargs;
+                for (i__ = 1; i__ <= i__4; ++i__) {
+                  same = same && isame[i__ - 1];
+                  if (!isame[i__ - 1]) {
+                    io___238.ciunit = *nout;
+                    s_wsfe(&io___238);
+                    do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  /* L50: */
+                }
+                if (!same) {
+                  *fatal = TRUE_;
+                  goto L150;
+                }
+
+                if (!null) {
+                  if (s_cmp(sname + 9, "mm", (ftnlen)2, (ftnlen)2) == 0) {
+
+                    /*                                Check the result. */
+
+                    if (left) {
+                      dmmch_(transa, "N", &m, &n, &m, &alpha, &a[a_offset],
+                             nmax, &b[b_offset], nmax, &c_b104, &c__[c_offset],
+                             nmax, &ct[1], &g[1], &bb[1], &ldb, eps, &err,
+                             fatal, nout, &c_true, (ftnlen)1, (ftnlen)1);
+                    } else {
+                      dmmch_("N", transa, &m, &n, &n, &alpha, &b[b_offset],
+                             nmax, &a[a_offset], nmax, &c_b104, &c__[c_offset],
+                             nmax, &ct[1], &g[1], &bb[1], &ldb, eps, &err,
+                             fatal, nout, &c_true, (ftnlen)1, (ftnlen)1);
+                    }
+                  } else if (s_cmp(sname + 9, "sm", (ftnlen)2, (ftnlen)2) ==
+                             0) {
+
+                    /*                                Compute approximation to
+                     * original */
+                    /*                                matrix. */
+
+                    i__4 = n;
+                    for (j = 1; j <= i__4; ++j) {
+                      i__5 = m;
+                      for (i__ = 1; i__ <= i__5; ++i__) {
+                        c__[i__ + j * c_dim1] = bb[i__ + (j - 1) * ldb];
+                        bb[i__ + (j - 1) * ldb] = alpha * b[i__ + j * b_dim1];
+                        /* L60: */
+                      }
+                      /* L70: */
+                    }
+
+                    if (left) {
+                      dmmch_(transa, "N", &m, &n, &m, &c_b90, &a[a_offset],
+                             nmax, &c__[c_offset], nmax, &c_b104, &b[b_offset],
+                             nmax, &ct[1], &g[1], &bb[1], &ldb, eps, &err,
+                             fatal, nout, &c_false, (ftnlen)1, (ftnlen)1);
+                    } else {
+                      dmmch_("N", transa, &m, &n, &n, &c_b90, &c__[c_offset],
+                             nmax, &a[a_offset], nmax, &c_b104, &b[b_offset],
+                             nmax, &ct[1], &g[1], &bb[1], &ldb, eps, &err,
+                             fatal, nout, &c_false, (ftnlen)1, (ftnlen)1);
+                    }
+                  }
+                  errmax = max(errmax, err);
+                  /*                             If got really bad answer,
+                   * report and */
+                  /*                             return. */
+                  if (*fatal) {
+                    goto L150;
+                  }
+                }
+
+                /* L80: */
+              }
+
+              /* L90: */
+            }
+
+            /* L100: */
+          }
+
+          /* L110: */
+        }
+
+        /* L120: */
+      }
+
+    L130:;
+    }
+
+    /* L140: */
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___240.ciunit = *nout;
+      s_wsfe(&io___240);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___241.ciunit = *nout;
+      s_wsfe(&io___241);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___242.ciunit = *nout;
+      s_wsfe(&io___242);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___243.ciunit = *nout;
+      s_wsfe(&io___243);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+  }
+  goto L160;
+
+L150:
+  io___244.ciunit = *nout;
+  s_wsfe(&io___244);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  dprcn3_(ntra, &nc, sname, iorder, side, uplo, transa, diag, &m, &n, &alpha,
+          &lda, &ldb, (ftnlen)12, (ftnlen)1, (ftnlen)1, (ftnlen)1, (ftnlen)1);
+
+L160:
+  return 0;
+
+  /* L9995: */
+
+  /*     End of DCHK3. */
+
+} /* dchk3_ */
+
+/* Subroutine */ int dprcn3_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *side, char *uplo,
+                             char *transa, char *diag, integer *m, integer *n,
+                             doublereal *alpha, integer *lda, integer *ldb,
+                             ftnlen sname_len, ftnlen side_len, ftnlen uplo_len,
+                             ftnlen transa_len, ftnlen diag_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+                           "a14,\002,\002,a14,\002,\002)";
+  static char fmt_9994[] = "(22x,2(a14,\002,\002),2(i3,\002,\002),f4.1,"
+                           "\002, A,\002,i3,\002, B,\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char ca[14], cd[14], cs[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___250 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___251 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)side == 'L') {
+    s_copy(cs, "     CblasLeft", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cs, "    CblasRight", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(ca, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(ca, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ca, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)diag == 'N') {
+    s_copy(cd, "  CblasNonUnit", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cd, "     CblasUnit", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___250.ciunit = *nout;
+  s_wsfe(&io___250);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cs, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  e_wsfe();
+  io___251.ciunit = *nout;
+  s_wsfe(&io___251);
+  do_fio(&c__1, ca, (ftnlen)14);
+  do_fio(&c__1, cd, (ftnlen)14);
+  do_fio(&c__1, (char *)&(*m), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*alpha), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*ldb), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* dprcn3_ */
+
+/* Subroutine */ int
+dchk4_(char *sname, doublereal *eps, doublereal *thresh, integer *nout,
+       integer *ntra, logical *trace, logical *rewi, logical *fatal,
+       integer *nidim, integer *idim, integer *nalf, doublereal *alf,
+       integer *nbet, doublereal *bet, integer *nmax, doublereal *a,
+       doublereal *aa, doublereal *as, doublereal *b, doublereal *bb,
+       doublereal *bs, doublereal *c__, doublereal *cc, doublereal *cs,
+       doublereal *ct, doublereal *g, integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char icht[3] = "NTC";
+  static char ichu[2] = "UL";
+
+  /* Format strings */
+  static char fmt_9993[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+                           " \002,i3)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
+      i__3, i__4, i__5;
+  alist al__1;
+
+  /* Builtin functions */
+  integer f_rew(alist *), s_wsfe(cilist *), e_wsfe(void),
+      do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, j, k, n, ia, ib, jc, ma, na, nc, ik, in, jj, lj, ks, ns, laa,
+      lda, lcc, ldc;
+  extern logical lde_(doublereal *, doublereal *, integer *);
+  doublereal als;
+  integer ict, icu;
+  doublereal err, beta;
+  integer ldas, ldcs;
+  logical same;
+  doublereal bets;
+  logical tran, null;
+  char uplo[1];
+  extern /* Subroutine */ int dmake_(
+      char *, char *, char *, integer *, integer *, doublereal *, integer *,
+      doublereal *, integer *, logical *, doublereal *, ftnlen, ftnlen, ftnlen);
+  doublereal alpha;
+  extern /* Subroutine */ int dmmch_(
+      char *, char *, integer *, integer *, integer *, doublereal *,
+      doublereal *, integer *, doublereal *, integer *, doublereal *,
+      doublereal *, integer *, doublereal *, doublereal *, doublereal *,
+      integer *, doublereal *, doublereal *, logical *, integer *, logical *,
+      ftnlen, ftnlen);
+  logical isame[13];
+  integer nargs;
+  logical reset;
+  char trans[1];
+  logical upper;
+  char uplos[1];
+  extern /* Subroutine */ int dprcn4_(integer *, integer *, char *, integer *,
+                                      char *, char *, integer *, integer *,
+                                      doublereal *, integer *, doublereal *,
+                                      integer *, ftnlen, ftnlen, ftnlen);
+  extern logical lderes_(char *, char *, integer *, integer *, doublereal *,
+                         doublereal *, integer *, ftnlen, ftnlen);
+  doublereal errmax;
+  extern /* Subroutine */ void cdsyrk_(integer *, char *, char *, integer *,
+                                       integer *, doublereal *, doublereal *,
+                                       integer *, doublereal *, doublereal *,
+                                       integer *);
+  char transs[1];
+
+  /* Fortran I/O blocks */
+  static cilist io___288 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___291 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___297 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___298 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___299 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___300 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___301 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___302 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests DSYRK. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --bet;
+  --g;
+  --ct;
+  --cs;
+  --cc;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --bs;
+  --bb;
+  b_dim1 = *nmax;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+
+  nargs = 10;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.;
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+    /*        Set LDC to 1 more than minimum value if room. */
+    ldc = n;
+    if (ldc < *nmax) {
+      ++ldc;
+    }
+    /*        Skip tests if not enough room. */
+    if (ldc > *nmax) {
+      goto L100;
+    }
+    lcc = ldc * n;
+    null = n <= 0;
+
+    i__2 = *nidim;
+    for (ik = 1; ik <= i__2; ++ik) {
+      k = idim[ik];
+
+      for (ict = 1; ict <= 3; ++ict) {
+        *(unsigned char *)trans = *(unsigned char *)&icht[ict - 1];
+        tran = *(unsigned char *)trans == 'T' || *(unsigned char *)trans == 'C';
+        if (tran) {
+          ma = k;
+          na = n;
+        } else {
+          ma = n;
+          na = k;
+        }
+        /*              Set LDA to 1 more than minimum value if room. */
+        lda = ma;
+        if (lda < *nmax) {
+          ++lda;
+        }
+        /*              Skip tests if not enough room. */
+        if (lda > *nmax) {
+          goto L80;
+        }
+        laa = lda * na;
+
+        /*              Generate the matrix A. */
+
+        dmake_("GE", " ", " ", &ma, &na, &a[a_offset], nmax, &aa[1], &lda,
+               &reset, &c_b104, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+        for (icu = 1; icu <= 2; ++icu) {
+          *(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+          upper = *(unsigned char *)uplo == 'U';
+
+          i__3 = *nalf;
+          for (ia = 1; ia <= i__3; ++ia) {
+            alpha = alf[ia];
+
+            i__4 = *nbet;
+            for (ib = 1; ib <= i__4; ++ib) {
+              beta = bet[ib];
+
+              /*                       Generate the matrix C. */
+
+              dmake_("SY", uplo, " ", &n, &n, &c__[c_offset], nmax, &cc[1],
+                     &ldc, &reset, &c_b104, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+              ++nc;
+
+              /*                       Save every datum before calling the
+               * subroutine. */
+
+              *(unsigned char *)uplos = *(unsigned char *)uplo;
+              *(unsigned char *)transs = *(unsigned char *)trans;
+              ns = n;
+              ks = k;
+              als = alpha;
+              i__5 = laa;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                as[i__] = aa[i__];
+                /* L10: */
+              }
+              ldas = lda;
+              bets = beta;
+              i__5 = lcc;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                cs[i__] = cc[i__];
+                /* L20: */
+              }
+              ldcs = ldc;
+
+              /*                       Call the subroutine. */
+
+              if (*trace) {
+                dprcn4_(ntra, &nc, sname, iorder, uplo, trans, &n, &k, &alpha,
+                        &lda, &beta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+              }
+              if (*rewi) {
+                al__1.aerr = 0;
+                al__1.aunit = *ntra;
+                f_rew(&al__1);
+              }
+              cdsyrk_(iorder, uplo, trans, &n, &k, &alpha, &aa[1], &lda, &beta,
+                      &cc[1], &ldc);
+
+              /*                       Check if error-exit was taken
+               * incorrectly. */
+
+              if (!infoc_1.ok) {
+                io___288.ciunit = *nout;
+                s_wsfe(&io___288);
+                e_wsfe();
+                *fatal = TRUE_;
+                goto L120;
+              }
+
+              /*                       See what data changed inside subroutines.
+               */
+
+              isame[0] = *(unsigned char *)uplos == *(unsigned char *)uplo;
+              isame[1] = *(unsigned char *)transs == *(unsigned char *)trans;
+              isame[2] = ns == n;
+              isame[3] = ks == k;
+              isame[4] = als == alpha;
+              isame[5] = lde_(&as[1], &aa[1], &laa);
+              isame[6] = ldas == lda;
+              isame[7] = bets == beta;
+              if (null) {
+                isame[8] = lde_(&cs[1], &cc[1], &lcc);
+              } else {
+                isame[8] = lderes_("SY", uplo, &n, &n, &cs[1], &cc[1], &ldc,
+                                   (ftnlen)2, (ftnlen)1);
+              }
+              isame[9] = ldcs == ldc;
+
+              /*                       If data was incorrectly changed, report
+               * and */
+              /*                       return. */
+
+              same = TRUE_;
+              i__5 = nargs;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                same = same && isame[i__ - 1];
+                if (!isame[i__ - 1]) {
+                  io___291.ciunit = *nout;
+                  s_wsfe(&io___291);
+                  do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                  e_wsfe();
+                }
+                /* L30: */
+              }
+              if (!same) {
+                *fatal = TRUE_;
+                goto L120;
+              }
+
+              if (!null) {
+
+                /*                          Check the result column by column.
+                 */
+
+                jc = 1;
+                i__5 = n;
+                for (j = 1; j <= i__5; ++j) {
+                  if (upper) {
+                    jj = 1;
+                    lj = j;
+                  } else {
+                    jj = j;
+                    lj = n - j + 1;
+                  }
+                  if (tran) {
+                    dmmch_("T", "N", &lj, &c__1, &k, &alpha,
+                           &a[jj * a_dim1 + 1], nmax, &a[j * a_dim1 + 1], nmax,
+                           &beta, &c__[jj + j * c_dim1], nmax, &ct[1], &g[1],
+                           &cc[jc], &ldc, eps, &err, fatal, nout, &c_true,
+                           (ftnlen)1, (ftnlen)1);
+                  } else {
+                    dmmch_("N", "T", &lj, &c__1, &k, &alpha, &a[jj + a_dim1],
+                           nmax, &a[j + a_dim1], nmax, &beta,
+                           &c__[jj + j * c_dim1], nmax, &ct[1], &g[1], &cc[jc],
+                           &ldc, eps, &err, fatal, nout, &c_true, (ftnlen)1,
+                           (ftnlen)1);
+                  }
+                  if (upper) {
+                    jc += ldc;
+                  } else {
+                    jc = jc + ldc + 1;
+                  }
+                  errmax = max(errmax, err);
+                  /*                             If got really bad answer,
+                   * report and */
+                  /*                             return. */
+                  if (*fatal) {
+                    goto L110;
+                  }
+                  /* L40: */
+                }
+              }
+
+              /* L50: */
+            }
+
+            /* L60: */
+          }
+
+          /* L70: */
+        }
+
+      L80:;
+      }
+
+      /* L90: */
+    }
+
+  L100:;
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___297.ciunit = *nout;
+      s_wsfe(&io___297);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___298.ciunit = *nout;
+      s_wsfe(&io___298);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___299.ciunit = *nout;
+      s_wsfe(&io___299);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___300.ciunit = *nout;
+      s_wsfe(&io___300);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+  }
+  goto L130;
+
+L110:
+  if (n > 1) {
+    io___301.ciunit = *nout;
+    s_wsfe(&io___301);
+    do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L120:
+  io___302.ciunit = *nout;
+  s_wsfe(&io___302);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  dprcn4_(nout, &nc, sname, iorder, uplo, trans, &n, &k, &alpha, &lda, &beta,
+          &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+
+L130:
+  return 0;
+
+  /* L9994: */
+
+  /*     End of DCHK4. */
+
+} /* dchk4_ */
+
+/* Subroutine */ int dprcn4_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *uplo, char *transa,
+                             integer *n, integer *k, doublereal *alpha,
+                             integer *lda, doublereal *beta, integer *ldc,
+                             ftnlen sname_len, ftnlen uplo_len,
+                             ftnlen transa_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+                           "\002))";
+  static char fmt_9994[] = "(20x,2(i3,\002,\002),f4.1,\002, A,\002,i3"
+                           ",\002,\002,f4.1,\002, C,\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char ca[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___306 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___307 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(ca, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(ca, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ca, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___306.ciunit = *nout;
+  s_wsfe(&io___306);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  do_fio(&c__1, ca, (ftnlen)14);
+  e_wsfe();
+  io___307.ciunit = *nout;
+  s_wsfe(&io___307);
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*k), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*alpha), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*beta), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* dprcn4_ */
+
+/* Subroutine */ int
+dchk5_(char *sname, doublereal *eps, doublereal *thresh, integer *nout,
+       integer *ntra, logical *trace, logical *rewi, logical *fatal,
+       integer *nidim, integer *idim, integer *nalf, doublereal *alf,
+       integer *nbet, doublereal *bet, integer *nmax, doublereal *ab,
+       doublereal *aa, doublereal *as, doublereal *bb, doublereal *bs,
+       doublereal *c__, doublereal *cc, doublereal *cs, doublereal *ct,
+       doublereal *g, doublereal *w, integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char icht[3] = "NTC";
+  static char ichu[2] = "UL";
+
+  /* Format strings */
+  static char fmt_9993[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+                           " \002,i3)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer c_dim1, c_offset, i__1, i__2, i__3, i__4, i__5, i__6, i__7, i__8;
+  alist al__1;
+
+  /* Builtin functions */
+  integer f_rew(alist *), s_wsfe(cilist *), e_wsfe(void),
+      do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, j, k, n, ia, ib, jc, ma, na, nc, ik, in, jj, lj, ks, ns, laa,
+      lbb, lda, lcc, ldb, ldc;
+  extern logical lde_(doublereal *, doublereal *, integer *);
+  doublereal als;
+  integer ict, icu;
+  doublereal err;
+  integer jjab;
+  doublereal beta;
+  integer ldas, ldbs, ldcs;
+  logical same;
+  doublereal bets;
+  logical tran, null;
+  char uplo[1];
+  extern /* Subroutine */ int dmake_(
+      char *, char *, char *, integer *, integer *, doublereal *, integer *,
+      doublereal *, integer *, logical *, doublereal *, ftnlen, ftnlen, ftnlen);
+  doublereal alpha;
+  extern /* Subroutine */ int dmmch_(
+      char *, char *, integer *, integer *, integer *, doublereal *,
+      doublereal *, integer *, doublereal *, integer *, doublereal *,
+      doublereal *, integer *, doublereal *, doublereal *, doublereal *,
+      integer *, doublereal *, doublereal *, logical *, integer *, logical *,
+      ftnlen, ftnlen);
+  logical isame[13];
+  integer nargs;
+  logical reset;
+  char trans[1];
+  logical upper;
+  char uplos[1];
+  extern /* Subroutine */ int dprcn5_(
+      integer *, integer *, char *, integer *, char *, char *, integer *,
+      integer *, doublereal *, integer *, integer *, doublereal *, integer *,
+      ftnlen, ftnlen, ftnlen);
+  extern logical lderes_(char *, char *, integer *, integer *, doublereal *,
+                         doublereal *, integer *, ftnlen, ftnlen);
+  doublereal errmax;
+  char transs[1];
+  extern /* Subroutine */ void cdsyr2k_(
+      integer *, char *, char *, integer *, integer *, doublereal *,
+      doublereal *, integer *, doublereal *, integer *, doublereal *,
+      doublereal *, integer *);
+
+  /* Fortran I/O blocks */
+  static cilist io___347 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___350 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___357 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___358 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___359 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___360 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___361 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___362 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests DSYR2K. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --bet;
+  --w;
+  --g;
+  --ct;
+  --cs;
+  --cc;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --bs;
+  --bb;
+  --as;
+  --aa;
+  --ab;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+
+  nargs = 12;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.;
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+    /*        Set LDC to 1 more than minimum value if room. */
+    ldc = n;
+    if (ldc < *nmax) {
+      ++ldc;
+    }
+    /*        Skip tests if not enough room. */
+    if (ldc > *nmax) {
+      goto L130;
+    }
+    lcc = ldc * n;
+    null = n <= 0;
+
+    i__2 = *nidim;
+    for (ik = 1; ik <= i__2; ++ik) {
+      k = idim[ik];
+
+      for (ict = 1; ict <= 3; ++ict) {
+        *(unsigned char *)trans = *(unsigned char *)&icht[ict - 1];
+        tran = *(unsigned char *)trans == 'T' || *(unsigned char *)trans == 'C';
+        if (tran) {
+          ma = k;
+          na = n;
+        } else {
+          ma = n;
+          na = k;
+        }
+        /*              Set LDA to 1 more than minimum value if room. */
+        lda = ma;
+        if (lda < *nmax) {
+          ++lda;
+        }
+        /*              Skip tests if not enough room. */
+        if (lda > *nmax) {
+          goto L110;
+        }
+        laa = lda * na;
+
+        /*              Generate the matrix A. */
+
+        if (tran) {
+          i__3 = *nmax << 1;
+          dmake_("GE", " ", " ", &ma, &na, &ab[1], &i__3, &aa[1], &lda, &reset,
+                 &c_b104, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        } else {
+          dmake_("GE", " ", " ", &ma, &na, &ab[1], nmax, &aa[1], &lda, &reset,
+                 &c_b104, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        }
+
+        /*              Generate the matrix B. */
+
+        ldb = lda;
+        lbb = laa;
+        if (tran) {
+          i__3 = *nmax << 1;
+          dmake_("GE", " ", " ", &ma, &na, &ab[k + 1], &i__3, &bb[1], &ldb,
+                 &reset, &c_b104, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        } else {
+          dmake_("GE", " ", " ", &ma, &na, &ab[k * *nmax + 1], nmax, &bb[1],
+                 &ldb, &reset, &c_b104, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        }
+
+        for (icu = 1; icu <= 2; ++icu) {
+          *(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+          upper = *(unsigned char *)uplo == 'U';
+
+          i__3 = *nalf;
+          for (ia = 1; ia <= i__3; ++ia) {
+            alpha = alf[ia];
+
+            i__4 = *nbet;
+            for (ib = 1; ib <= i__4; ++ib) {
+              beta = bet[ib];
+
+              /*                       Generate the matrix C. */
+
+              dmake_("SY", uplo, " ", &n, &n, &c__[c_offset], nmax, &cc[1],
+                     &ldc, &reset, &c_b104, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+              ++nc;
+
+              /*                       Save every datum before calling the
+               * subroutine. */
+
+              *(unsigned char *)uplos = *(unsigned char *)uplo;
+              *(unsigned char *)transs = *(unsigned char *)trans;
+              ns = n;
+              ks = k;
+              als = alpha;
+              i__5 = laa;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                as[i__] = aa[i__];
+                /* L10: */
+              }
+              ldas = lda;
+              i__5 = lbb;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                bs[i__] = bb[i__];
+                /* L20: */
+              }
+              ldbs = ldb;
+              bets = beta;
+              i__5 = lcc;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                cs[i__] = cc[i__];
+                /* L30: */
+              }
+              ldcs = ldc;
+
+              /*                       Call the subroutine. */
+
+              if (*trace) {
+                dprcn5_(ntra, &nc, sname, iorder, uplo, trans, &n, &k, &alpha,
+                        &lda, &ldb, &beta, &ldc, (ftnlen)12, (ftnlen)1,
+                        (ftnlen)1);
+              }
+              if (*rewi) {
+                al__1.aerr = 0;
+                al__1.aunit = *ntra;
+                f_rew(&al__1);
+              }
+              cdsyr2k_(iorder, uplo, trans, &n, &k, &alpha, &aa[1], &lda,
+                       &bb[1], &ldb, &beta, &cc[1], &ldc);
+
+              /*                       Check if error-exit was taken
+               * incorrectly. */
+
+              if (!infoc_1.ok) {
+                io___347.ciunit = *nout;
+                s_wsfe(&io___347);
+                e_wsfe();
+                *fatal = TRUE_;
+                goto L150;
+              }
+
+              /*                       See what data changed inside subroutines.
+               */
+
+              isame[0] = *(unsigned char *)uplos == *(unsigned char *)uplo;
+              isame[1] = *(unsigned char *)transs == *(unsigned char *)trans;
+              isame[2] = ns == n;
+              isame[3] = ks == k;
+              isame[4] = als == alpha;
+              isame[5] = lde_(&as[1], &aa[1], &laa);
+              isame[6] = ldas == lda;
+              isame[7] = lde_(&bs[1], &bb[1], &lbb);
+              isame[8] = ldbs == ldb;
+              isame[9] = bets == beta;
+              if (null) {
+                isame[10] = lde_(&cs[1], &cc[1], &lcc);
+              } else {
+                isame[10] = lderes_("SY", uplo, &n, &n, &cs[1], &cc[1], &ldc,
+                                    (ftnlen)2, (ftnlen)1);
+              }
+              isame[11] = ldcs == ldc;
+
+              /*                       If data was incorrectly changed, report
+               * and */
+              /*                       return. */
+
+              same = TRUE_;
+              i__5 = nargs;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                same = same && isame[i__ - 1];
+                if (!isame[i__ - 1]) {
+                  io___350.ciunit = *nout;
+                  s_wsfe(&io___350);
+                  do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                  e_wsfe();
+                }
+                /* L40: */
+              }
+              if (!same) {
+                *fatal = TRUE_;
+                goto L150;
+              }
+
+              if (!null) {
+
+                /*                          Check the result column by column.
+                 */
+
+                jjab = 1;
+                jc = 1;
+                i__5 = n;
+                for (j = 1; j <= i__5; ++j) {
+                  if (upper) {
+                    jj = 1;
+                    lj = j;
+                  } else {
+                    jj = j;
+                    lj = n - j + 1;
+                  }
+                  if (tran) {
+                    i__6 = k;
+                    for (i__ = 1; i__ <= i__6; ++i__) {
+                      w[i__] = ab[(j - 1 << 1) * *nmax + k + i__];
+                      w[k + i__] = ab[(j - 1 << 1) * *nmax + i__];
+                      /* L50: */
+                    }
+                    i__6 = k << 1;
+                    i__7 = *nmax << 1;
+                    i__8 = *nmax << 1;
+                    dmmch_("T", "N", &lj, &c__1, &i__6, &alpha, &ab[jjab],
+                           &i__7, &w[1], &i__8, &beta, &c__[jj + j * c_dim1],
+                           nmax, &ct[1], &g[1], &cc[jc], &ldc, eps, &err, fatal,
+                           nout, &c_true, (ftnlen)1, (ftnlen)1);
+                  } else {
+                    i__6 = k;
+                    for (i__ = 1; i__ <= i__6; ++i__) {
+                      w[i__] = ab[(k + i__ - 1) * *nmax + j];
+                      w[k + i__] = ab[(i__ - 1) * *nmax + j];
+                      /* L60: */
+                    }
+                    i__6 = k << 1;
+                    i__7 = *nmax << 1;
+                    dmmch_("N", "N", &lj, &c__1, &i__6, &alpha, &ab[jj], nmax,
+                           &w[1], &i__7, &beta, &c__[jj + j * c_dim1], nmax,
+                           &ct[1], &g[1], &cc[jc], &ldc, eps, &err, fatal, nout,
+                           &c_true, (ftnlen)1, (ftnlen)1);
+                  }
+                  if (upper) {
+                    jc += ldc;
+                  } else {
+                    jc = jc + ldc + 1;
+                    if (tran) {
+                      jjab += *nmax << 1;
+                    }
+                  }
+                  errmax = max(errmax, err);
+                  /*                             If got really bad answer,
+                   * report and */
+                  /*                             return. */
+                  if (*fatal) {
+                    goto L140;
+                  }
+                  /* L70: */
+                }
+              }
+
+              /* L80: */
+            }
+
+            /* L90: */
+          }
+
+          /* L100: */
+        }
+
+      L110:;
+      }
+
+      /* L120: */
+    }
+
+  L130:;
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___357.ciunit = *nout;
+      s_wsfe(&io___357);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___358.ciunit = *nout;
+      s_wsfe(&io___358);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___359.ciunit = *nout;
+      s_wsfe(&io___359);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___360.ciunit = *nout;
+      s_wsfe(&io___360);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+  }
+  goto L160;
+
+L140:
+  if (n > 1) {
+    io___361.ciunit = *nout;
+    s_wsfe(&io___361);
+    do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L150:
+  io___362.ciunit = *nout;
+  s_wsfe(&io___362);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  dprcn5_(nout, &nc, sname, iorder, uplo, trans, &n, &k, &alpha, &lda, &ldb,
+          &beta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+
+L160:
+  return 0;
+
+  /* L9994: */
+
+  /*     End of DCHK5. */
+
+} /* dchk5_ */
+
+/* Subroutine */ int dprcn5_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *uplo, char *transa,
+                             integer *n, integer *k, doublereal *alpha,
+                             integer *lda, integer *ldb, doublereal *beta,
+                             integer *ldc, ftnlen sname_len, ftnlen uplo_len,
+                             ftnlen transa_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+                           "\002))";
+  static char fmt_9994[] =
+      "(20x,2(i3,\002,\002),f4.1,\002, A,\002,i3,\002"
+      ", B\002,i3,\002,\002,f4.1,\002, C,\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char ca[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___366 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___367 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(ca, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(ca, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ca, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___366.ciunit = *nout;
+  s_wsfe(&io___366);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  do_fio(&c__1, ca, (ftnlen)14);
+  e_wsfe();
+  io___367.ciunit = *nout;
+  s_wsfe(&io___367);
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*k), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*alpha), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*ldb), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*beta), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* dprcn5_ */
+
+/* Subroutine */ int dmake_(char *type__, char *uplo, char *diag, integer *m,
+                            integer *n, doublereal *a, integer *nmax,
+                            doublereal *aa, integer *lda, logical *reset,
+                            doublereal *transl, ftnlen type_len,
+                            ftnlen uplo_len, ftnlen diag_len) {
+  /* System generated locals */
+  integer a_dim1, a_offset, i__1, i__2;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen);
+
+  /* Local variables */
+  integer i__, j;
+  logical gen, tri, sym;
+  extern doublereal dbeg_(logical *);
+  integer ibeg, iend;
+  logical unit, lower, upper;
+
+  /*  Generates values for an M by N matrix A. */
+  /*  Stores the values in the array AA in the data structure required */
+  /*  by the routine, with unwanted elements set to rogue value. */
+
+  /*  TYPE is 'GE', 'SY' or 'TR'. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. External Functions .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --aa;
+
+  /* Function Body */
+  gen = s_cmp(type__, "GE", (ftnlen)2, (ftnlen)2) == 0;
+  sym = s_cmp(type__, "SY", (ftnlen)2, (ftnlen)2) == 0;
+  tri = s_cmp(type__, "TR", (ftnlen)2, (ftnlen)2) == 0;
+  upper = (sym || tri) && *(unsigned char *)uplo == 'U';
+  lower = (sym || tri) && *(unsigned char *)uplo == 'L';
+  unit = tri && *(unsigned char *)diag == 'U';
+
+  /*     Generate data in array A. */
+
+  i__1 = *n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = *m;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      if (gen || upper && i__ <= j || lower && i__ >= j) {
+        a[i__ + j * a_dim1] = dbeg_(reset) + *transl;
+        if (i__ != j) {
+          /*                 Set some elements to zero */
+          if (*n > 3 && j == *n / 2) {
+            a[i__ + j * a_dim1] = 0.;
+          }
+          if (sym) {
+            a[j + i__ * a_dim1] = a[i__ + j * a_dim1];
+          } else if (tri) {
+            a[j + i__ * a_dim1] = 0.;
+          }
+        }
+      }
+      /* L10: */
+    }
+    if (tri) {
+      a[j + j * a_dim1] += 1.;
+    }
+    if (unit) {
+      a[j + j * a_dim1] = 1.;
+    }
+    /* L20: */
+  }
+
+  /*     Store elements in array AS in data structure required by routine. */
+
+  if (s_cmp(type__, "GE", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      i__2 = *m;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        aa[i__ + (j - 1) * *lda] = a[i__ + j * a_dim1];
+        /* L30: */
+      }
+      i__2 = *lda;
+      for (i__ = *m + 1; i__ <= i__2; ++i__) {
+        aa[i__ + (j - 1) * *lda] = -1e10;
+        /* L40: */
+      }
+      /* L50: */
+    }
+  } else if (s_cmp(type__, "SY", (ftnlen)2, (ftnlen)2) == 0 ||
+             s_cmp(type__, "TR", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      if (upper) {
+        ibeg = 1;
+        if (unit) {
+          iend = j - 1;
+        } else {
+          iend = j;
+        }
+      } else {
+        if (unit) {
+          ibeg = j + 1;
+        } else {
+          ibeg = j;
+        }
+        iend = *n;
+      }
+      i__2 = ibeg - 1;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        aa[i__ + (j - 1) * *lda] = -1e10;
+        /* L60: */
+      }
+      i__2 = iend;
+      for (i__ = ibeg; i__ <= i__2; ++i__) {
+        aa[i__ + (j - 1) * *lda] = a[i__ + j * a_dim1];
+        /* L70: */
+      }
+      i__2 = *lda;
+      for (i__ = iend + 1; i__ <= i__2; ++i__) {
+        aa[i__ + (j - 1) * *lda] = -1e10;
+        /* L80: */
+      }
+      /* L90: */
+    }
+  }
+  return 0;
+
+  /*     End of DMAKE. */
+
+} /* dmake_ */
+
+/* Subroutine */ int dmmch_(char *transa, char *transb, integer *m, integer *n,
+                            integer *kk, doublereal *alpha, doublereal *a,
+                            integer *lda, doublereal *b, integer *ldb,
+                            doublereal *beta, doublereal *c__, integer *ldc,
+                            doublereal *ct, doublereal *g, doublereal *cc,
+                            integer *ldcc, doublereal *eps, doublereal *err,
+                            logical *fatal, integer *nout, logical *mv,
+                            ftnlen transa_len, ftnlen transb_len) {
+  /* Format strings */
+  static char fmt_9999[] =
+      "(\002 ******* FATAL ERROR - COMPUTED RESULT IS"
+      " LESS THAN HAL\002,\002F ACCURATE *******\002,/\002           EX"
+      "PECTED RESULT   COMPU\002,\002TED RESULT\002)";
+  static char fmt_9998[] = "(1x,i7,2g18.6)";
+  static char fmt_9997[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+                           " \002,i3)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, cc_dim1,
+      cc_offset, i__1, i__2, i__3;
+  doublereal d__1, d__2;
+
+  /* Builtin functions */
+  double sqrt(doublereal);
+  integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, j, k;
+  doublereal erri;
+  logical trana, tranb;
+
+  /* Fortran I/O blocks */
+  static cilist io___384 = {0, 0, 0, fmt_9999, 0};
+  static cilist io___385 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___386 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___387 = {0, 0, 0, fmt_9997, 0};
+
+  /*  Checks the results of the computational tests. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  a_dim1 = *lda;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  b_dim1 = *ldb;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  c_dim1 = *ldc;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --ct;
+  --g;
+  cc_dim1 = *ldcc;
+  cc_offset = 1 + cc_dim1;
+  cc -= cc_offset;
+
+  /* Function Body */
+  trana = *(unsigned char *)transa == 'T' || *(unsigned char *)transa == 'C';
+  tranb = *(unsigned char *)transb == 'T' || *(unsigned char *)transb == 'C';
+
+  /*     Compute expected result, one column at a time, in CT using data */
+  /*     in A, B and C. */
+  /*     Compute gauges in G. */
+
+  i__1 = *n;
+  for (j = 1; j <= i__1; ++j) {
+
+    i__2 = *m;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      ct[i__] = 0.;
+      g[i__] = 0.;
+      /* L10: */
+    }
+    if (!trana && !tranb) {
+      i__2 = *kk;
+      for (k = 1; k <= i__2; ++k) {
+        i__3 = *m;
+        for (i__ = 1; i__ <= i__3; ++i__) {
+          ct[i__] += a[i__ + k * a_dim1] * b[k + j * b_dim1];
+          g[i__] += (d__1 = a[i__ + k * a_dim1], abs(d__1)) *
+                    (d__2 = b[k + j * b_dim1], abs(d__2));
+          /* L20: */
+        }
+        /* L30: */
+      }
+    } else if (trana && !tranb) {
+      i__2 = *kk;
+      for (k = 1; k <= i__2; ++k) {
+        i__3 = *m;
+        for (i__ = 1; i__ <= i__3; ++i__) {
+          ct[i__] += a[k + i__ * a_dim1] * b[k + j * b_dim1];
+          g[i__] += (d__1 = a[k + i__ * a_dim1], abs(d__1)) *
+                    (d__2 = b[k + j * b_dim1], abs(d__2));
+          /* L40: */
+        }
+        /* L50: */
+      }
+    } else if (!trana && tranb) {
+      i__2 = *kk;
+      for (k = 1; k <= i__2; ++k) {
+        i__3 = *m;
+        for (i__ = 1; i__ <= i__3; ++i__) {
+          ct[i__] += a[i__ + k * a_dim1] * b[j + k * b_dim1];
+          g[i__] += (d__1 = a[i__ + k * a_dim1], abs(d__1)) *
+                    (d__2 = b[j + k * b_dim1], abs(d__2));
+          /* L60: */
+        }
+        /* L70: */
+      }
+    } else if (trana && tranb) {
+      i__2 = *kk;
+      for (k = 1; k <= i__2; ++k) {
+        i__3 = *m;
+        for (i__ = 1; i__ <= i__3; ++i__) {
+          ct[i__] += a[k + i__ * a_dim1] * b[j + k * b_dim1];
+          g[i__] += (d__1 = a[k + i__ * a_dim1], abs(d__1)) *
+                    (d__2 = b[j + k * b_dim1], abs(d__2));
+          /* L80: */
+        }
+        /* L90: */
+      }
+    }
+    i__2 = *m;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      ct[i__] = *alpha * ct[i__] + *beta * c__[i__ + j * c_dim1];
+      g[i__] = abs(*alpha) * g[i__] +
+               abs(*beta) * (d__1 = c__[i__ + j * c_dim1], abs(d__1));
+      /* L100: */
+    }
+
+    /*        Compute the error ratio for this result. */
+
+    *err = 0.;
+    i__2 = *m;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      erri = (d__1 = ct[i__] - cc[i__ + j * cc_dim1], abs(d__1)) / *eps;
+      if (g[i__] != 0.) {
+        erri /= g[i__];
+      }
+      *err = max(*err, erri);
+      if (*err * sqrt(*eps) >= 1.) {
+        goto L130;
+      }
+      /* L110: */
+    }
+
+    /* L120: */
+  }
+
+  /*     If the loop completes, all results are at least half accurate. */
+  goto L150;
+
+  /*     Report fatal error. */
+
+L130:
+  *fatal = TRUE_;
+  io___384.ciunit = *nout;
+  s_wsfe(&io___384);
+  e_wsfe();
+  i__1 = *m;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    if (*mv) {
+      io___385.ciunit = *nout;
+      s_wsfe(&io___385);
+      do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&ct[i__], (ftnlen)sizeof(doublereal));
+      do_fio(&c__1, (char *)&cc[i__ + j * cc_dim1], (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    } else {
+      io___386.ciunit = *nout;
+      s_wsfe(&io___386);
+      do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&cc[i__ + j * cc_dim1], (ftnlen)sizeof(doublereal));
+      do_fio(&c__1, (char *)&ct[i__], (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+    /* L140: */
+  }
+  if (*n > 1) {
+    io___387.ciunit = *nout;
+    s_wsfe(&io___387);
+    do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L150:
+  return 0;
+
+  /*     End of DMMCH. */
+
+} /* dmmch_ */
+
+logical lde_(doublereal *ri, doublereal *rj, integer *lr) {
+  /* System generated locals */
+  integer i__1;
+  logical ret_val;
+
+  /* Local variables */
+  integer i__;
+
+  /*  Tests if two arrays are identical. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  --rj;
+  --ri;
+
+  /* Function Body */
+  i__1 = *lr;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    if (ri[i__] != rj[i__]) {
+      goto L20;
+    }
+    /* L10: */
+  }
+  ret_val = TRUE_;
+  goto L30;
+L20:
+  ret_val = FALSE_;
+L30:
+  return ret_val;
+
+  /*     End of LDE. */
+
+} /* lde_ */
+
+logical lderes_(char *type__, char *uplo, integer *m, integer *n,
+                doublereal *aa, doublereal *as, integer *lda, ftnlen type_len,
+                ftnlen uplo_len) {
+  /* System generated locals */
+  integer aa_dim1, aa_offset, as_dim1, as_offset, i__1, i__2;
+  logical ret_val;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen);
+
+  /* Local variables */
+  integer i__, j, ibeg, iend;
+  logical upper;
+
+  /*  Tests if selected elements in two arrays are equal. */
+
+  /*  TYPE is 'GE' or 'SY'. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  as_dim1 = *lda;
+  as_offset = 1 + as_dim1;
+  as -= as_offset;
+  aa_dim1 = *lda;
+  aa_offset = 1 + aa_dim1;
+  aa -= aa_offset;
+
+  /* Function Body */
+  upper = *(unsigned char *)uplo == 'U';
+  if (s_cmp(type__, "GE", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      i__2 = *lda;
+      for (i__ = *m + 1; i__ <= i__2; ++i__) {
+        if (aa[i__ + j * aa_dim1] != as[i__ + j * as_dim1]) {
+          goto L70;
+        }
+        /* L10: */
+      }
+      /* L20: */
+    }
+  } else if (s_cmp(type__, "SY", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      if (upper) {
+        ibeg = 1;
+        iend = j;
+      } else {
+        ibeg = j;
+        iend = *n;
+      }
+      i__2 = ibeg - 1;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        if (aa[i__ + j * aa_dim1] != as[i__ + j * as_dim1]) {
+          goto L70;
+        }
+        /* L30: */
+      }
+      i__2 = *lda;
+      for (i__ = iend + 1; i__ <= i__2; ++i__) {
+        if (aa[i__ + j * aa_dim1] != as[i__ + j * as_dim1]) {
+          goto L70;
+        }
+        /* L40: */
+      }
+      /* L50: */
+    }
+  }
+
+  /* L60: */
+  ret_val = TRUE_;
+  goto L80;
+L70:
+  ret_val = FALSE_;
+L80:
+  return ret_val;
+
+  /*     End of LDERES. */
+
+} /* lderes_ */
+
+doublereal dbeg_(logical *reset) {
+  /* System generated locals */
+  doublereal ret_val;
+
+  /* Local variables */
+  static integer i__, ic, mi;
+
+  /*  Generates random numbers uniformly distributed between -0.5 and 0.5. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Save statement .. */
+  /*     .. Executable Statements .. */
+  if (*reset) {
+    /*        Initialize local variables. */
+    mi = 891;
+    i__ = 7;
+    ic = 0;
+    *reset = FALSE_;
+  }
+
+  /*     The sequence of values of I is bounded between 1 and 999. */
+  /*     If initial I = 1,2,3,6,7 or 9, the period will be 50. */
+  /*     If initial I = 4 or 8, the period will be 25. */
+  /*     If initial I = 5, the period will be 10. */
+  /*     IC is used to break up the period by skipping 1 value of I in 6. */
+
+  ++ic;
+L10:
+  i__ *= mi;
+  i__ -= i__ / 1000 * 1000;
+  if (ic >= 5) {
+    ic = 0;
+    goto L10;
+  }
+  ret_val = (i__ - 500) / 1001.;
+  return ret_val;
+
+  /*     End of DBEG. */
+
+} /* dbeg_ */
+
+doublereal ddiff_(doublereal *x, doublereal *y) {
+  /* System generated locals */
+  doublereal ret_val;
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Executable Statements .. */
+  ret_val = *x - *y;
+  return ret_val;
+
+  /*     End of DDIFF. */
+
+} /* ddiff_ */
+
+/* Main program alias */ int dblat3_() {
+  MAIN__();
+  return 0;
+}
diff --git a/CBLAS/testing/c_sblat1.c b/CBLAS/testing/c_sblat1.c
new file mode 100644
index 0000000..020611e
--- /dev/null
+++ b/CBLAS/testing/c_sblat1.c
@@ -0,0 +1,888 @@
+/* testing/c_sblat1.f -- translated by f2c (version 20191129).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+#include "f2c.h"
+
+/* Common Block Declarations */
+
+struct {
+    integer icase, n, incx, incy, mode;
+    logical pass;
+} combla_;
+
+#define combla_1 combla_
+
+/* Table of constant values */
+
+static integer c__1 = 1;
+static integer c__9 = 9;
+static real c_b34 = 1.f;
+static integer c__5 = 5;
+
+/* Main program */ int MAIN__(void)
+{
+    /* Initialized data */
+
+    static real sfac = 9.765625e-4f;
+
+    /* Format strings */
+    static char fmt_99999[] = "(\002 Real CBLAS Test Program Results\002,/1x)"
+	    ;
+    static char fmt_99998[] = "(\002                                    ----"
+	    "- PASS -----\002)";
+
+    /* Builtin functions */
+    integer s_wsfe(cilist *), e_wsfe(void);
+    /* Subroutine */ int s_stop(char *, ftnlen);
+
+    /* Local variables */
+    integer ic;
+    extern /* Subroutine */ int check0_(real *), check1_(real *), check2_(
+	    real *), check3_(real *), header_(void);
+
+    /* Fortran I/O blocks */
+    static cilist io___2 = { 0, 6, 0, fmt_99999, 0 };
+    static cilist io___4 = { 0, 6, 0, fmt_99998, 0 };
+
+
+/*     Test program for the REAL             Level 1 CBLAS. */
+/*     Based upon the original CBLAS test routine together with: */
+/*     F06EAF Example Program Text */
+/*     .. Parameters .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. External Subroutines .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+    s_wsfe(&io___2);
+    e_wsfe();
+    for (ic = 1; ic <= 10; ++ic) {
+	combla_1.icase = ic;
+	header_();
+
+/*        .. Initialize  PASS,  INCX,  INCY, and MODE for a new case. .. */
+/*        .. the value 9999 for INCX, INCY or MODE will appear in the .. */
+/*        .. detailed  output, if any, for cases  that do not involve .. */
+/*        .. these parameters .. */
+
+	combla_1.pass = TRUE_;
+	combla_1.incx = 9999;
+	combla_1.incy = 9999;
+	combla_1.mode = 9999;
+	if (combla_1.icase == 3) {
+	    check0_(&sfac);
+	} else if (combla_1.icase == 7 || combla_1.icase == 8 || 
+		combla_1.icase == 9 || combla_1.icase == 10) {
+	    check1_(&sfac);
+	} else if (combla_1.icase == 1 || combla_1.icase == 2 || 
+		combla_1.icase == 5 || combla_1.icase == 6) {
+	    check2_(&sfac);
+	} else if (combla_1.icase == 4) {
+	    check3_(&sfac);
+	}
+/*        -- Print */
+	if (combla_1.pass) {
+	    s_wsfe(&io___4);
+	    e_wsfe();
+	}
+/* L20: */
+    }
+    s_stop("", (ftnlen)0);
+
+    return 0;
+} /* MAIN__ */
+
+/* Subroutine */ int header_(void)
+{
+    /* Initialized data */
+
+    static char l[15*10] = "CBLAS_SDOT     " "CBLAS_SAXPY    " "CBLAS_SROTG "
+	    "   " "CBLAS_SROT     " "CBLAS_SCOPY    " "CBLAS_SSWAP    " "CBLA"
+	    "S_SNRM2    " "CBLAS_SASUM    " "CBLAS_SSCAL    " "CBLAS_ISAMAX   "
+	    ;
+
+    /* Format strings */
+    static char fmt_99999[] = "(/\002 Test of subprogram number\002,i3,9x,a1"
+	    "5)";
+
+    /* Builtin functions */
+    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+    /* Fortran I/O blocks */
+    static cilist io___6 = { 0, 6, 0, fmt_99999, 0 };
+
+
+/*     .. Parameters .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Arrays .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+    s_wsfe(&io___6);
+    do_fio(&c__1, (char *)&combla_1.icase, (ftnlen)sizeof(integer));
+    do_fio(&c__1, l + (0 + (0 + (combla_1.icase - 1) * 15)), (ftnlen)15);
+    e_wsfe();
+    return 0;
+
+} /* header_ */
+
+/* Subroutine */ int check0_(real *sfac)
+{
+    /* Initialized data */
+
+    static real ds1[8] = { .8f,.6f,.8f,-.6f,.8f,0.f,1.f,0.f };
+    static real datrue[8] = { .5f,.5f,.5f,-.5f,-.5f,0.f,1.f,1.f };
+    static real dbtrue[8] = { 0.f,.6f,0.f,-.6f,0.f,0.f,1.f,0.f };
+    static real da1[8] = { .3f,.4f,-.3f,-.4f,-.3f,0.f,0.f,1.f };
+    static real db1[8] = { .4f,.3f,.4f,.3f,-.4f,0.f,1.f,0.f };
+    static real dc1[8] = { .6f,.8f,-.6f,.8f,.6f,1.f,0.f,1.f };
+
+    /* Builtin functions */
+    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
+	    e_wsle(void);
+    /* Subroutine */ int s_stop(char *, ftnlen);
+
+    /* Local variables */
+    integer k;
+    extern /* Subroutine */ void srotgtest_(real *, real *, real *, real *);
+    real sa, sb, sc, ss;
+    extern /* Subroutine */ int stest1_(real *, real *, real *, real *);
+
+    /* Fortran I/O blocks */
+    static cilist io___18 = { 0, 6, 0, 0, 0 };
+
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Subroutines .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+
+/*     Compute true values which cannot be prestored */
+/*     in decimal notation */
+
+    dbtrue[0] = 1.6666666666666667f;
+    dbtrue[2] = -1.6666666666666667f;
+    dbtrue[4] = 1.6666666666666667f;
+
+    for (k = 1; k <= 8; ++k) {
+/*        .. Set N=K for identification in output if any .. */
+	combla_1.n = k;
+	if (combla_1.icase == 3) {
+/*           .. SROTGTEST .. */
+	    if (k > 8) {
+		goto L40;
+	    }
+	    sa = da1[k - 1];
+	    sb = db1[k - 1];
+	    srotgtest_(&sa, &sb, &sc, &ss);
+	    stest1_(&sa, &datrue[k - 1], &datrue[k - 1], sfac);
+	    stest1_(&sb, &dbtrue[k - 1], &dbtrue[k - 1], sfac);
+	    stest1_(&sc, &dc1[k - 1], &dc1[k - 1], sfac);
+	    stest1_(&ss, &ds1[k - 1], &ds1[k - 1], sfac);
+	} else {
+	    s_wsle(&io___18);
+	    do_lio(&c__9, &c__1, " Shouldn't be here in CHECK0", (ftnlen)28);
+	    e_wsle();
+	    s_stop("", (ftnlen)0);
+	}
+/* L20: */
+    }
+L40:
+    return 0;
+} /* check0_ */
+
+/* Subroutine */ int check1_(real *sfac)
+{
+    /* Initialized data */
+
+    static real sa[10] = { .3f,-1.f,0.f,1.f,.3f,.3f,.3f,.3f,.3f,.3f };
+    static real dv[80]	/* was [8][5][2] */ = { .1f,2.f,2.f,2.f,2.f,2.f,2.f,
+	    2.f,.3f,3.f,3.f,3.f,3.f,3.f,3.f,3.f,.3f,-.4f,4.f,4.f,4.f,4.f,4.f,
+	    4.f,.2f,-.6f,.3f,5.f,5.f,5.f,5.f,5.f,.1f,-.3f,.5f,-.1f,6.f,6.f,
+	    6.f,6.f,.1f,8.f,8.f,8.f,8.f,8.f,8.f,8.f,.3f,9.f,9.f,9.f,9.f,9.f,
+	    9.f,9.f,.3f,2.f,-.4f,2.f,2.f,2.f,2.f,2.f,.2f,3.f,-.6f,5.f,.3f,2.f,
+	    2.f,2.f,.1f,4.f,-.3f,6.f,-.5f,7.f,-.1f,3.f };
+    static real dtrue1[5] = { 0.f,.3f,.5f,.7f,.6f };
+    static real dtrue3[5] = { 0.f,.3f,.7f,1.1f,1.f };
+    static real dtrue5[80]	/* was [8][5][2] */ = { .1f,2.f,2.f,2.f,2.f,
+	    2.f,2.f,2.f,-.3f,3.f,3.f,3.f,3.f,3.f,3.f,3.f,0.f,0.f,4.f,4.f,4.f,
+	    4.f,4.f,4.f,.2f,-.6f,.3f,5.f,5.f,5.f,5.f,5.f,.03f,-.09f,.15f,
+	    -.03f,6.f,6.f,6.f,6.f,.1f,8.f,8.f,8.f,8.f,8.f,8.f,8.f,.09f,9.f,
+	    9.f,9.f,9.f,9.f,9.f,9.f,.09f,2.f,-.12f,2.f,2.f,2.f,2.f,2.f,.06f,
+	    3.f,-.18f,5.f,.09f,2.f,2.f,2.f,.03f,4.f,-.09f,6.f,-.15f,7.f,-.03f,
+	    3.f };
+    static integer itrue2[5] = { 0,1,2,2,3 };
+
+    /* System generated locals */
+    integer i__1;
+    real r__1;
+
+    /* Builtin functions */
+    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
+	    e_wsle(void);
+    /* Subroutine */ int s_stop(char *, ftnlen);
+
+    /* Local variables */
+    integer i__;
+    extern real snrm2test_(integer *, real *, integer *);
+    extern /* Subroutine */ void sscaltest_(integer *, real *, real *, integer 
+	    *);
+    extern real sasumtest_(integer *, real *, integer *);
+    real sx[8];
+    integer np1;
+    extern integer isamaxtest_(integer *, real *, integer *);
+    integer len;
+    real stemp[1], strue[8];
+    extern /* Subroutine */ int stest_(integer *, real *, real *, real *, 
+	    real *), itest1_(integer *, integer *), stest1_(real *, real *, 
+	    real *, real *);
+
+    /* Fortran I/O blocks */
+    static cilist io___31 = { 0, 6, 0, 0, 0 };
+
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+    for (combla_1.incx = 1; combla_1.incx <= 2; ++combla_1.incx) {
+	for (np1 = 1; np1 <= 5; ++np1) {
+	    combla_1.n = np1 - 1;
+	    len = max(combla_1.n,1) << 1;
+/*           .. Set vector arguments .. */
+	    i__1 = len;
+	    for (i__ = 1; i__ <= i__1; ++i__) {
+		sx[i__ - 1] = dv[i__ + (np1 + combla_1.incx * 5 << 3) - 49];
+/* L20: */
+	    }
+
+	    if (combla_1.icase == 7) {
+/*              .. SNRM2TEST .. */
+		stemp[0] = dtrue1[np1 - 1];
+		r__1 = snrm2test_(&combla_1.n, sx, &combla_1.incx);
+		stest1_(&r__1, stemp, stemp, sfac);
+	    } else if (combla_1.icase == 8) {
+/*              .. SASUMTEST .. */
+		stemp[0] = dtrue3[np1 - 1];
+		r__1 = sasumtest_(&combla_1.n, sx, &combla_1.incx);
+		stest1_(&r__1, stemp, stemp, sfac);
+	    } else if (combla_1.icase == 9) {
+/*              .. SSCALTEST .. */
+		sscaltest_(&combla_1.n, &sa[(combla_1.incx - 1) * 5 + np1 - 1]
+			, sx, &combla_1.incx);
+		i__1 = len;
+		for (i__ = 1; i__ <= i__1; ++i__) {
+		    strue[i__ - 1] = dtrue5[i__ + (np1 + combla_1.incx * 5 << 
+			    3) - 49];
+/* L40: */
+		}
+		stest_(&len, sx, strue, strue, sfac);
+	    } else if (combla_1.icase == 10) {
+/*              .. ISAMAXTEST .. */
+		i__1 = isamaxtest_(&combla_1.n, sx, &combla_1.incx);
+		itest1_(&i__1, &itrue2[np1 - 1]);
+	    } else {
+		s_wsle(&io___31);
+		do_lio(&c__9, &c__1, " Shouldn't be here in CHECK1", (ftnlen)
+			28);
+		e_wsle();
+		s_stop("", (ftnlen)0);
+	    }
+/* L60: */
+	}
+/* L80: */
+    }
+    return 0;
+} /* check1_ */
+
+/* Subroutine */ int check2_(real *sfac)
+{
+    /* Initialized data */
+
+    static real sa = .3f;
+    static integer incxs[4] = { 1,2,-2,-1 };
+    static integer incys[4] = { 1,-2,1,-2 };
+    static integer lens[8]	/* was [4][2] */ = { 1,1,2,4,1,1,3,7 };
+    static integer ns[4] = { 0,1,2,4 };
+    static real dx1[7] = { .6f,.1f,-.5f,.8f,.9f,-.3f,-.4f };
+    static real dy1[7] = { .5f,-.9f,.3f,.7f,-.6f,.2f,.8f };
+    static real dt7[16]	/* was [4][4] */ = { 0.f,.3f,.21f,.62f,0.f,.3f,-.07f,
+	    .85f,0.f,.3f,-.79f,-.74f,0.f,.3f,.33f,1.27f };
+    static real dt8[112]	/* was [7][4][4] */ = { .5f,0.f,0.f,0.f,0.f,
+	    0.f,0.f,.68f,0.f,0.f,0.f,0.f,0.f,0.f,.68f,-.87f,0.f,0.f,0.f,0.f,
+	    0.f,.68f,-.87f,.15f,.94f,0.f,0.f,0.f,.5f,0.f,0.f,0.f,0.f,0.f,0.f,
+	    .68f,0.f,0.f,0.f,0.f,0.f,0.f,.35f,-.9f,.48f,0.f,0.f,0.f,0.f,.38f,
+	    -.9f,.57f,.7f,-.75f,.2f,.98f,.5f,0.f,0.f,0.f,0.f,0.f,0.f,.68f,0.f,
+	    0.f,0.f,0.f,0.f,0.f,.35f,-.72f,0.f,0.f,0.f,0.f,0.f,.38f,-.63f,
+	    .15f,.88f,0.f,0.f,0.f,.5f,0.f,0.f,0.f,0.f,0.f,0.f,.68f,0.f,0.f,
+	    0.f,0.f,0.f,0.f,.68f,-.9f,.33f,0.f,0.f,0.f,0.f,.68f,-.9f,.33f,.7f,
+	    -.75f,.2f,1.04f };
+    static real dt10x[112]	/* was [7][4][4] */ = { .6f,0.f,0.f,0.f,0.f,
+	    0.f,0.f,.5f,0.f,0.f,0.f,0.f,0.f,0.f,.5f,-.9f,0.f,0.f,0.f,0.f,0.f,
+	    .5f,-.9f,.3f,.7f,0.f,0.f,0.f,.6f,0.f,0.f,0.f,0.f,0.f,0.f,.5f,0.f,
+	    0.f,0.f,0.f,0.f,0.f,.3f,.1f,.5f,0.f,0.f,0.f,0.f,.8f,.1f,-.6f,.8f,
+	    .3f,-.3f,.5f,.6f,0.f,0.f,0.f,0.f,0.f,0.f,.5f,0.f,0.f,0.f,0.f,0.f,
+	    0.f,-.9f,.1f,.5f,0.f,0.f,0.f,0.f,.7f,.1f,.3f,.8f,-.9f,-.3f,.5f,
+	    .6f,0.f,0.f,0.f,0.f,0.f,0.f,.5f,0.f,0.f,0.f,0.f,0.f,0.f,.5f,.3f,
+	    0.f,0.f,0.f,0.f,0.f,.5f,.3f,-.6f,.8f,0.f,0.f,0.f };
+    static real dt10y[112]	/* was [7][4][4] */ = { .5f,0.f,0.f,0.f,0.f,
+	    0.f,0.f,.6f,0.f,0.f,0.f,0.f,0.f,0.f,.6f,.1f,0.f,0.f,0.f,0.f,0.f,
+	    .6f,.1f,-.5f,.8f,0.f,0.f,0.f,.5f,0.f,0.f,0.f,0.f,0.f,0.f,.6f,0.f,
+	    0.f,0.f,0.f,0.f,0.f,-.5f,-.9f,.6f,0.f,0.f,0.f,0.f,-.4f,-.9f,.9f,
+	    .7f,-.5f,.2f,.6f,.5f,0.f,0.f,0.f,0.f,0.f,0.f,.6f,0.f,0.f,0.f,0.f,
+	    0.f,0.f,-.5f,.6f,0.f,0.f,0.f,0.f,0.f,-.4f,.9f,-.5f,.6f,0.f,0.f,
+	    0.f,.5f,0.f,0.f,0.f,0.f,0.f,0.f,.6f,0.f,0.f,0.f,0.f,0.f,0.f,.6f,
+	    -.9f,.1f,0.f,0.f,0.f,0.f,.6f,-.9f,.1f,.7f,-.5f,.2f,.8f };
+    static real ssize1[4] = { 0.f,.3f,1.6f,3.2f };
+    static real ssize2[28]	/* was [14][2] */ = { 0.f,0.f,0.f,0.f,0.f,0.f,
+	    0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,1.17f,1.17f,1.17f,1.17f,1.17f,
+	    1.17f,1.17f,1.17f,1.17f,1.17f,1.17f,1.17f,1.17f,1.17f };
+
+    /* System generated locals */
+    integer i__1;
+    real r__1;
+
+    /* Builtin functions */
+    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
+	    e_wsle(void);
+    /* Subroutine */ int s_stop(char *, ftnlen);
+
+    /* Local variables */
+    extern real sdottest_(integer *, real *, integer *, real *, integer *);
+    integer i__, j;
+    extern /* Subroutine */ void scopytest_(integer *, real *, integer *, real 
+	    *, integer *), sswaptest_(integer *, real *, integer *, real *, 
+	    integer *), saxpytest_(integer *, real *, real *, integer *, real 
+	    *, integer *);
+    integer ki, kn, mx, my;
+    real sx[7], sy[7], stx[7], sty[7];
+    integer lenx, leny, ksize;
+    extern /* Subroutine */ int stest_(integer *, real *, real *, real *, 
+	    real *), stest1_(real *, real *, real *, real *);
+
+    /* Fortran I/O blocks */
+    static cilist io___58 = { 0, 6, 0, 0, 0 };
+
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+
+    for (ki = 1; ki <= 4; ++ki) {
+	combla_1.incx = incxs[ki - 1];
+	combla_1.incy = incys[ki - 1];
+	mx = abs(combla_1.incx);
+	my = abs(combla_1.incy);
+
+	for (kn = 1; kn <= 4; ++kn) {
+	    combla_1.n = ns[kn - 1];
+	    ksize = min(2,kn);
+	    lenx = lens[kn + (mx << 2) - 5];
+	    leny = lens[kn + (my << 2) - 5];
+/*           .. Initialize all argument arrays .. */
+	    for (i__ = 1; i__ <= 7; ++i__) {
+		sx[i__ - 1] = dx1[i__ - 1];
+		sy[i__ - 1] = dy1[i__ - 1];
+/* L20: */
+	    }
+
+	    if (combla_1.icase == 1) {
+/*              .. SDOTTEST .. */
+		r__1 = sdottest_(&combla_1.n, sx, &combla_1.incx, sy, &
+			combla_1.incy);
+		stest1_(&r__1, &dt7[kn + (ki << 2) - 5], &ssize1[kn - 1], 
+			sfac);
+	    } else if (combla_1.icase == 2) {
+/*              .. SAXPYTEST .. */
+		saxpytest_(&combla_1.n, &sa, sx, &combla_1.incx, sy, &
+			combla_1.incy);
+		i__1 = leny;
+		for (j = 1; j <= i__1; ++j) {
+		    sty[j - 1] = dt8[j + (kn + (ki << 2)) * 7 - 36];
+/* L40: */
+		}
+		stest_(&leny, sy, sty, &ssize2[ksize * 14 - 14], sfac);
+	    } else if (combla_1.icase == 5) {
+/*              .. SCOPYTEST .. */
+		for (i__ = 1; i__ <= 7; ++i__) {
+		    sty[i__ - 1] = dt10y[i__ + (kn + (ki << 2)) * 7 - 36];
+/* L60: */
+		}
+		scopytest_(&combla_1.n, sx, &combla_1.incx, sy, &
+			combla_1.incy);
+		stest_(&leny, sy, sty, ssize2, &c_b34);
+	    } else if (combla_1.icase == 6) {
+/*              .. SSWAPTEST .. */
+		sswaptest_(&combla_1.n, sx, &combla_1.incx, sy, &
+			combla_1.incy);
+		for (i__ = 1; i__ <= 7; ++i__) {
+		    stx[i__ - 1] = dt10x[i__ + (kn + (ki << 2)) * 7 - 36];
+		    sty[i__ - 1] = dt10y[i__ + (kn + (ki << 2)) * 7 - 36];
+/* L80: */
+		}
+		stest_(&lenx, sx, stx, ssize2, &c_b34);
+		stest_(&leny, sy, sty, ssize2, &c_b34);
+	    } else {
+		s_wsle(&io___58);
+		do_lio(&c__9, &c__1, " Shouldn't be here in CHECK2", (ftnlen)
+			28);
+		e_wsle();
+		s_stop("", (ftnlen)0);
+	    }
+/* L100: */
+	}
+/* L120: */
+    }
+    return 0;
+} /* check2_ */
+
+/* Subroutine */ int check3_(real *sfac)
+{
+    /* Initialized data */
+
+    static integer incxs[4] = { 1,2,-2,-1 };
+    static integer incys[4] = { 1,-2,1,-2 };
+    static integer lens[8]	/* was [4][2] */ = { 1,1,2,4,1,1,3,7 };
+    static integer ns[4] = { 0,1,2,4 };
+    static real dx1[7] = { .6f,.1f,-.5f,.8f,.9f,-.3f,-.4f };
+    static real dy1[7] = { .5f,-.9f,.3f,.7f,-.6f,.2f,.8f };
+    static real sc = .8f;
+    static real ss = .6f;
+    static real dt9x[112]	/* was [7][4][4] */ = { .6f,0.f,0.f,0.f,0.f,
+	    0.f,0.f,.78f,0.f,0.f,0.f,0.f,0.f,0.f,.78f,-.46f,0.f,0.f,0.f,0.f,
+	    0.f,.78f,-.46f,-.22f,1.06f,0.f,0.f,0.f,.6f,0.f,0.f,0.f,0.f,0.f,
+	    0.f,.78f,0.f,0.f,0.f,0.f,0.f,0.f,.66f,.1f,-.1f,0.f,0.f,0.f,0.f,
+	    .96f,.1f,-.76f,.8f,.9f,-.3f,-.02f,.6f,0.f,0.f,0.f,0.f,0.f,0.f,
+	    .78f,0.f,0.f,0.f,0.f,0.f,0.f,-.06f,.1f,-.1f,0.f,0.f,0.f,0.f,.9f,
+	    .1f,-.22f,.8f,.18f,-.3f,-.02f,.6f,0.f,0.f,0.f,0.f,0.f,0.f,.78f,
+	    0.f,0.f,0.f,0.f,0.f,0.f,.78f,.26f,0.f,0.f,0.f,0.f,0.f,.78f,.26f,
+	    -.76f,1.12f,0.f,0.f,0.f };
+    static real dt9y[112]	/* was [7][4][4] */ = { .5f,0.f,0.f,0.f,0.f,
+	    0.f,0.f,.04f,0.f,0.f,0.f,0.f,0.f,0.f,.04f,-.78f,0.f,0.f,0.f,0.f,
+	    0.f,.04f,-.78f,.54f,.08f,0.f,0.f,0.f,.5f,0.f,0.f,0.f,0.f,0.f,0.f,
+	    .04f,0.f,0.f,0.f,0.f,0.f,0.f,.7f,-.9f,-.12f,0.f,0.f,0.f,0.f,.64f,
+	    -.9f,-.3f,.7f,-.18f,.2f,.28f,.5f,0.f,0.f,0.f,0.f,0.f,0.f,.04f,0.f,
+	    0.f,0.f,0.f,0.f,0.f,.7f,-1.08f,0.f,0.f,0.f,0.f,0.f,.64f,-1.26f,
+	    .54f,.2f,0.f,0.f,0.f,.5f,0.f,0.f,0.f,0.f,0.f,0.f,.04f,0.f,0.f,0.f,
+	    0.f,0.f,0.f,.04f,-.9f,.18f,0.f,0.f,0.f,0.f,.04f,-.9f,.18f,.7f,
+	    -.18f,.2f,.16f };
+    static real ssize2[28]	/* was [14][2] */ = { 0.f,0.f,0.f,0.f,0.f,0.f,
+	    0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,1.17f,1.17f,1.17f,1.17f,1.17f,
+	    1.17f,1.17f,1.17f,1.17f,1.17f,1.17f,1.17f,1.17f,1.17f };
+
+    /* Builtin functions */
+    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
+	    e_wsle(void);
+    /* Subroutine */ int s_stop(char *, ftnlen);
+
+    /* Local variables */
+    extern /* Subroutine */ void srottest_(integer *, real *, integer *, real *
+	    , integer *, real *, real *);
+    integer i__, k, ki, kn, mx, my;
+    real sx[7], sy[7], stx[7], sty[7];
+    integer lenx, leny;
+    real mwpc[11];
+    integer mwpn[11];
+    real mwps[11], mwpx[5], mwpy[5];
+    integer ksize;
+    real copyx[5], copyy[5];
+    extern /* Subroutine */ int stest_(integer *, real *, real *, real *, 
+	    real *);
+    real mwptx[55]	/* was [11][5] */, mwpty[55]	/* was [11][5] */;
+    integer mwpinx[11], mwpiny[11];
+    real mwpstx[5], mwpsty[5];
+
+    /* Fortran I/O blocks */
+    static cilist io___82 = { 0, 6, 0, 0, 0 };
+
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+
+    for (ki = 1; ki <= 4; ++ki) {
+	combla_1.incx = incxs[ki - 1];
+	combla_1.incy = incys[ki - 1];
+	mx = abs(combla_1.incx);
+	my = abs(combla_1.incy);
+
+	for (kn = 1; kn <= 4; ++kn) {
+	    combla_1.n = ns[kn - 1];
+	    ksize = min(2,kn);
+	    lenx = lens[kn + (mx << 2) - 5];
+	    leny = lens[kn + (my << 2) - 5];
+
+	    if (combla_1.icase == 4) {
+/*              .. SROTTEST .. */
+		for (i__ = 1; i__ <= 7; ++i__) {
+		    sx[i__ - 1] = dx1[i__ - 1];
+		    sy[i__ - 1] = dy1[i__ - 1];
+		    stx[i__ - 1] = dt9x[i__ + (kn + (ki << 2)) * 7 - 36];
+		    sty[i__ - 1] = dt9y[i__ + (kn + (ki << 2)) * 7 - 36];
+/* L20: */
+		}
+		srottest_(&combla_1.n, sx, &combla_1.incx, sy, &combla_1.incy,
+			 &sc, &ss);
+		stest_(&lenx, sx, stx, &ssize2[ksize * 14 - 14], sfac);
+		stest_(&leny, sy, sty, &ssize2[ksize * 14 - 14], sfac);
+	    } else {
+		s_wsle(&io___82);
+		do_lio(&c__9, &c__1, " Shouldn't be here in CHECK3", (ftnlen)
+			28);
+		e_wsle();
+		s_stop("", (ftnlen)0);
+	    }
+/* L40: */
+	}
+/* L60: */
+    }
+
+    mwpc[0] = 1.f;
+    for (i__ = 2; i__ <= 11; ++i__) {
+	mwpc[i__ - 1] = 0.f;
+/* L80: */
+    }
+    mwps[0] = 0.f;
+    for (i__ = 2; i__ <= 6; ++i__) {
+	mwps[i__ - 1] = 1.f;
+/* L100: */
+    }
+    for (i__ = 7; i__ <= 11; ++i__) {
+	mwps[i__ - 1] = -1.f;
+/* L120: */
+    }
+    mwpinx[0] = 1;
+    mwpinx[1] = 1;
+    mwpinx[2] = 1;
+    mwpinx[3] = -1;
+    mwpinx[4] = 1;
+    mwpinx[5] = -1;
+    mwpinx[6] = 1;
+    mwpinx[7] = 1;
+    mwpinx[8] = -1;
+    mwpinx[9] = 1;
+    mwpinx[10] = -1;
+    mwpiny[0] = 1;
+    mwpiny[1] = 1;
+    mwpiny[2] = -1;
+    mwpiny[3] = -1;
+    mwpiny[4] = 2;
+    mwpiny[5] = 1;
+    mwpiny[6] = 1;
+    mwpiny[7] = -1;
+    mwpiny[8] = -1;
+    mwpiny[9] = 2;
+    mwpiny[10] = 1;
+    for (i__ = 1; i__ <= 11; ++i__) {
+	mwpn[i__ - 1] = 5;
+/* L140: */
+    }
+    mwpn[4] = 3;
+    mwpn[9] = 3;
+    for (i__ = 1; i__ <= 5; ++i__) {
+	mwpx[i__ - 1] = (real) i__;
+	mwpy[i__ - 1] = (real) i__;
+	mwptx[i__ * 11 - 11] = (real) i__;
+	mwpty[i__ * 11 - 11] = (real) i__;
+	mwptx[i__ * 11 - 10] = (real) i__;
+	mwpty[i__ * 11 - 10] = (real) (-i__);
+	mwptx[i__ * 11 - 9] = (real) (6 - i__);
+	mwpty[i__ * 11 - 9] = (real) (i__ - 6);
+	mwptx[i__ * 11 - 8] = (real) i__;
+	mwpty[i__ * 11 - 8] = (real) (-i__);
+	mwptx[i__ * 11 - 6] = (real) (6 - i__);
+	mwpty[i__ * 11 - 6] = (real) (i__ - 6);
+	mwptx[i__ * 11 - 5] = (real) (-i__);
+	mwpty[i__ * 11 - 5] = (real) i__;
+	mwptx[i__ * 11 - 4] = (real) (i__ - 6);
+	mwpty[i__ * 11 - 4] = (real) (6 - i__);
+	mwptx[i__ * 11 - 3] = (real) (-i__);
+	mwpty[i__ * 11 - 3] = (real) i__;
+	mwptx[i__ * 11 - 1] = (real) (i__ - 6);
+	mwpty[i__ * 11 - 1] = (real) (6 - i__);
+/* L160: */
+    }
+    mwptx[4] = 1.f;
+    mwptx[15] = 3.f;
+    mwptx[26] = 5.f;
+    mwptx[37] = 4.f;
+    mwptx[48] = 5.f;
+    mwpty[4] = -1.f;
+    mwpty[15] = 2.f;
+    mwpty[26] = -2.f;
+    mwpty[37] = 4.f;
+    mwpty[48] = -3.f;
+    mwptx[9] = -1.f;
+    mwptx[20] = -3.f;
+    mwptx[31] = -5.f;
+    mwptx[42] = 4.f;
+    mwptx[53] = 5.f;
+    mwpty[9] = 1.f;
+    mwpty[20] = 2.f;
+    mwpty[31] = 2.f;
+    mwpty[42] = 4.f;
+    mwpty[53] = 3.f;
+    for (i__ = 1; i__ <= 11; ++i__) {
+	combla_1.incx = mwpinx[i__ - 1];
+	combla_1.incy = mwpiny[i__ - 1];
+	for (k = 1; k <= 5; ++k) {
+	    copyx[k - 1] = mwpx[k - 1];
+	    copyy[k - 1] = mwpy[k - 1];
+	    mwpstx[k - 1] = mwptx[i__ + k * 11 - 12];
+	    mwpsty[k - 1] = mwpty[i__ + k * 11 - 12];
+/* L180: */
+	}
+	srottest_(&mwpn[i__ - 1], copyx, &combla_1.incx, copyy, &
+		combla_1.incy, &mwpc[i__ - 1], &mwps[i__ - 1]);
+	stest_(&c__5, copyx, mwpstx, mwpstx, sfac);
+	stest_(&c__5, copyy, mwpsty, mwpsty, sfac);
+/* L200: */
+    }
+    return 0;
+} /* check3_ */
+
+/* Subroutine */ int stest_(integer *len, real *scomp, real *strue, real *
+	ssize, real *sfac)
+{
+    /* Format strings */
+    static char fmt_99999[] = "(\002                                       F"
+	    "AIL\002)";
+    static char fmt_99998[] = "(/\002 CASE  N INCX INCY MODE  I             "
+	    "               \002,\002 COMP(I)                             TRU"
+	    "E(I)  DIFFERENCE\002,\002     SIZE(I)\002,/1x)";
+    static char fmt_99997[] = "(1x,i4,i3,3i5,i3,2e36.8,2e12.4)";
+
+    /* System generated locals */
+    integer i__1;
+    real r__1, r__2, r__3, r__4, r__5;
+
+    /* Builtin functions */
+    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+    /* Local variables */
+    integer i__;
+    real sd;
+    extern real sdiff_(real *, real *);
+
+    /* Fortran I/O blocks */
+    static cilist io___99 = { 0, 6, 0, fmt_99999, 0 };
+    static cilist io___100 = { 0, 6, 0, fmt_99998, 0 };
+    static cilist io___101 = { 0, 6, 0, fmt_99997, 0 };
+
+
+/*     ********************************* STEST ************************** */
+
+/*     THIS SUBR COMPARES ARRAYS  SCOMP() AND STRUE() OF LENGTH LEN TO */
+/*     SEE IF THE TERM BY TERM DIFFERENCES, MULTIPLIED BY SFAC, ARE */
+/*     NEGLIGIBLE. */
+
+/*     C. L. LAWSON, JPL, 1974 DEC 10 */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. External Functions .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Common blocks .. */
+/*     .. Executable Statements .. */
+
+    /* Parameter adjustments */
+    --ssize;
+    --strue;
+    --scomp;
+
+    /* Function Body */
+    i__1 = *len;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	sd = scomp[i__] - strue[i__];
+	r__4 = (r__1 = ssize[i__], abs(r__1)) + (r__2 = *sfac * sd, abs(r__2))
+		;
+	r__5 = (r__3 = ssize[i__], abs(r__3));
+	if (sdiff_(&r__4, &r__5) == 0.f) {
+	    goto L40;
+	}
+
+/*                             HERE    SCOMP(I) IS NOT CLOSE TO STRUE(I). */
+
+	if (! combla_1.pass) {
+	    goto L20;
+	}
+/*                             PRINT FAIL MESSAGE AND HEADER. */
+	combla_1.pass = FALSE_;
+	s_wsfe(&io___99);
+	e_wsfe();
+	s_wsfe(&io___100);
+	e_wsfe();
+L20:
+	s_wsfe(&io___101);
+	do_fio(&c__1, (char *)&combla_1.icase, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&combla_1.n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&combla_1.incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&combla_1.incy, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&combla_1.mode, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&scomp[i__], (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&strue[i__], (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&sd, (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&ssize[i__], (ftnlen)sizeof(real));
+	e_wsfe();
+L40:
+	;
+    }
+    return 0;
+
+} /* stest_ */
+
+/* Subroutine */ int stest1_(real *scomp1, real *strue1, real *ssize, real *
+	sfac)
+{
+    real scomp[1], strue[1];
+    extern /* Subroutine */ int stest_(integer *, real *, real *, real *, 
+	    real *);
+
+/*     ************************* STEST1 ***************************** */
+
+/*     THIS IS AN INTERFACE SUBROUTINE TO ACCOMODATE THE FORTRAN */
+/*     REQUIREMENT THAT WHEN A DUMMY ARGUMENT IS AN ARRAY, THE */
+/*     ACTUAL ARGUMENT MUST ALSO BE AN ARRAY OR AN ARRAY ELEMENT. */
+
+/*     C.L. LAWSON, JPL, 1978 DEC 6 */
+
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Arrays .. */
+/*     .. External Subroutines .. */
+/*     .. Executable Statements .. */
+
+    /* Parameter adjustments */
+    --ssize;
+
+    /* Function Body */
+    scomp[0] = *scomp1;
+    strue[0] = *strue1;
+    stest_(&c__1, scomp, strue, &ssize[1], sfac);
+
+    return 0;
+} /* stest1_ */
+
+real sdiff_(real *sa, real *sb)
+{
+    /* System generated locals */
+    real ret_val;
+
+/*     ********************************* SDIFF ************************** */
+/*     COMPUTES DIFFERENCE OF TWO NUMBERS.  C. L. LAWSON, JPL 1974 FEB 15 */
+
+/*     .. Scalar Arguments .. */
+/*     .. Executable Statements .. */
+    ret_val = *sa - *sb;
+    return ret_val;
+} /* sdiff_ */
+
+/* Subroutine */ int itest1_(integer *icomp, integer *itrue)
+{
+    /* Format strings */
+    static char fmt_99999[] = "(\002                                       F"
+	    "AIL\002)";
+    static char fmt_99998[] = "(/\002 CASE  N INCX INCY MODE                "
+	    "               \002,\002 COMP                                TRU"
+	    "E     DIFFERENCE\002,/1x)";
+    static char fmt_99997[] = "(1x,i4,i3,3i5,2i36,i12)";
+
+    /* Builtin functions */
+    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+    /* Local variables */
+    integer id;
+
+    /* Fortran I/O blocks */
+    static cilist io___104 = { 0, 6, 0, fmt_99999, 0 };
+    static cilist io___105 = { 0, 6, 0, fmt_99998, 0 };
+    static cilist io___107 = { 0, 6, 0, fmt_99997, 0 };
+
+
+/*     ********************************* ITEST1 ************************* */
+
+/*     THIS SUBROUTINE COMPARES THE VARIABLES ICOMP AND ITRUE FOR */
+/*     EQUALITY. */
+/*     C. L. LAWSON, JPL, 1974 DEC 10 */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. Common blocks .. */
+/*     .. Executable Statements .. */
+
+    if (*icomp == *itrue) {
+	goto L40;
+    }
+
+/*                            HERE ICOMP IS NOT EQUAL TO ITRUE. */
+
+    if (! combla_1.pass) {
+	goto L20;
+    }
+/*                             PRINT FAIL MESSAGE AND HEADER. */
+    combla_1.pass = FALSE_;
+    s_wsfe(&io___104);
+    e_wsfe();
+    s_wsfe(&io___105);
+    e_wsfe();
+L20:
+    id = *icomp - *itrue;
+    s_wsfe(&io___107);
+    do_fio(&c__1, (char *)&combla_1.icase, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&combla_1.n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&combla_1.incx, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&combla_1.incy, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&combla_1.mode, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&(*icomp), (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&(*itrue), (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&id, (ftnlen)sizeof(integer));
+    e_wsfe();
+L40:
+    return 0;
+
+} /* itest1_ */
+
+/* Main program alias */ int scblat1_ () { MAIN__ (); return 0; }
diff --git a/CBLAS/testing/c_sblat2.c b/CBLAS/testing/c_sblat2.c
new file mode 100644
index 0000000..a9eea00
--- /dev/null
+++ b/CBLAS/testing/c_sblat2.c
@@ -0,0 +1,4733 @@
+/* testing/c_sblat2.f -- translated by f2c (version 20191129).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+#include "f2c.h"
+
+/* Common Block Declarations */
+
+struct {
+    integer infot, noutc;
+    logical ok;
+} infoc_;
+
+#define infoc_1 infoc_
+
+struct {
+    char srnamt[12];
+} srnamc_;
+
+#define srnamc_1 srnamc_
+
+/* Table of constant values */
+
+static integer c__9 = 9;
+static integer c__1 = 1;
+static integer c__3 = 3;
+static integer c__8 = 8;
+static integer c__4 = 4;
+static integer c__65 = 65;
+static integer c__7 = 7;
+static integer c__2 = 2;
+static real c_b123 = 1.f;
+static real c_b135 = 0.f;
+static integer c__6 = 6;
+static logical c_true = TRUE_;
+static integer c_n1 = -1;
+static integer c__0 = 0;
+static logical c_false = FALSE_;
+
+/* Main program */ int MAIN__(void)
+{
+    /* Initialized data */
+
+    static char snames[12*16] = "cblas_sgemv " "cblas_sgbmv " "cblas_ssymv " 
+	    "cblas_ssbmv " "cblas_sspmv " "cblas_strmv " "cblas_stbmv " "cbl"
+	    "as_stpmv " "cblas_strsv " "cblas_stbsv " "cblas_stpsv " "cblas_s"
+	    "ger  " "cblas_ssyr  " "cblas_sspr  " "cblas_ssyr2 " "cblas_sspr2 "
+	    ;
+
+    /* Format strings */
+    static char fmt_9997[] = "(\002 NUMBER OF VALUES OF \002,a,\002 IS LESS "
+	    "THAN 1 OR GREATER \002,\002THAN \002,i2)";
+    static char fmt_9996[] = "(\002 VALUE OF N IS LESS THAN 0 OR GREATER THA"
+	    "N \002,i2)";
+    static char fmt_9995[] = "(\002 VALUE OF K IS LESS THAN 0\002)";
+    static char fmt_9994[] = "(\002 ABSOLUTE VALUE OF INCX OR INCY IS 0 OR G"
+	    "REATER THAN \002,i2)";
+    static char fmt_9993[] = "(\002 TESTS OF THE REAL             LEVEL 2 BL"
+	    "AS\002,//\002 THE F\002,\002OLLOWING PARAMETER VALUES WILL BE US"
+	    "ED:\002)";
+    static char fmt_9992[] = "(\002   FOR N              \002,9i6)";
+    static char fmt_9991[] = "(\002   FOR K              \002,7i6)";
+    static char fmt_9990[] = "(\002   FOR INCX AND INCY  \002,7i6)";
+    static char fmt_9989[] = "(\002   FOR ALPHA          \002,7f6.1)";
+    static char fmt_9988[] = "(\002   FOR BETA           \002,7f6.1)";
+    static char fmt_9980[] = "(\002 ERROR-EXITS WILL NOT BE TESTED\002)";
+    static char fmt_9999[] = "(\002 ROUTINES PASS COMPUTATIONAL TESTS IF TES"
+	    "T RATIO IS LES\002,\002S THAN\002,f8.2)";
+    static char fmt_10002[] = "(\002 COLUMN-MAJOR AND ROW-MAJOR DATA LAYOUTS"
+	    " ARE TESTED\002)";
+    static char fmt_10001[] = "(\002 ROW-MAJOR DATA LAYOUT IS TESTED\002)";
+    static char fmt_10000[] = "(\002 COLUMN-MAJOR DATA LAYOUT IS TESTED\002)";
+    static char fmt_9984[] = "(a12,l2)";
+    static char fmt_9986[] = "(\002 SUBPROGRAM NAME \002,a12,\002 NOT RECOGN"
+	    "IZED\002,/\002 ******* T\002,\002ESTS ABANDONED *******\002)";
+    static char fmt_9998[] = "(\002 RELATIVE MACHINE PRECISION IS TAKEN TO"
+	    " BE\002,1p,e9.1)";
+    static char fmt_9985[] = "(\002 ERROR IN SMVCH -  IN-LINE DOT PRODUCTS A"
+	    "RE BEING EVALU\002,\002ATED WRONGLY.\002,/\002 SMVCH WAS CALLED "
+	    "WITH TRANS = \002,a1,\002 AND RETURNED SAME = \002,l1,\002 AND E"
+	    "RR = \002,f12.3,\002.\002,/\002 THIS MAY BE DUE TO FAULTS IN THE"
+	    " ARITHMETIC OR THE COMPILER.\002,/\002 ******* TESTS ABANDONED *"
+	    "******\002)";
+    static char fmt_9983[] = "(1x,a12,\002 WAS NOT TESTED\002)";
+    static char fmt_9982[] = "(/\002 END OF TESTS\002)";
+    static char fmt_9981[] = "(/\002 ******* FATAL ERROR - TESTS ABANDONED *"
+	    "******\002)";
+    static char fmt_9987[] = "(\002 AMEND DATA FILE OR INCREASE ARRAY SIZES "
+	    "IN PROGRAM\002,/\002 ******* TESTS ABANDONED *******\002)";
+
+    /* System generated locals */
+    integer i__1, i__2, i__3;
+    real r__1;
+    olist o__1;
+    cllist cl__1;
+
+    /* Builtin functions */
+    integer s_rsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
+	    e_rsle(void), f_open(olist *), s_wsfe(cilist *), do_fio(integer *,
+	     char *, ftnlen), e_wsfe(void), s_wsle(cilist *), e_wsle(void), 
+	    s_rsfe(cilist *), e_rsfe(void), s_cmp(char *, char *, ftnlen, 
+	    ftnlen);
+    /* Subroutine */ int s_stop(char *, ftnlen);
+    integer f_clos(cllist *);
+    /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+
+    /* Local variables */
+    real a[4225]	/* was [65][65] */, g[65];
+    integer i__, j, n;
+    real x[65], y[65], z__[130], aa[4225];
+    integer kb[7];
+    real as[4225], xs[130], ys[130], yt[65], xx[130], yy[130], alf[7];
+    integer inc[7], nkb;
+    real bet[7];
+    extern logical lse_(real *, real *, integer *);
+    real eps, err;
+    integer nalf, idim[9];
+    logical same;
+    integer ninc, nbet, ntra;
+    logical rewi;
+    extern /* Subroutine */ int schk1_(char *, real *, real *, integer *, 
+	    integer *, logical *, logical *, logical *, integer *, integer *, 
+	    integer *, integer *, integer *, real *, integer *, real *, 
+	    integer *, integer *, integer *, integer *, real *, real *, real *
+	    , real *, real *, real *, real *, real *, real *, real *, real *, 
+	    integer *, ftnlen), schk2_(char *, real *, real *, integer *, 
+	    integer *, logical *, logical *, logical *, integer *, integer *, 
+	    integer *, integer *, integer *, real *, integer *, real *, 
+	    integer *, integer *, integer *, integer *, real *, real *, real *
+	    , real *, real *, real *, real *, real *, real *, real *, real *, 
+	    integer *, ftnlen), schk3_(char *, real *, real *, integer *, 
+	    integer *, logical *, logical *, logical *, integer *, integer *, 
+	    integer *, integer *, integer *, integer *, integer *, integer *, 
+	    real *, real *, real *, real *, real *, real *, real *, real *, 
+	    real *, integer *, ftnlen), schk4_(char *, real *, real *, 
+	    integer *, integer *, logical *, logical *, logical *, integer *, 
+	    integer *, integer *, real *, integer *, integer *, integer *, 
+	    integer *, real *, real *, real *, real *, real *, real *, real *,
+	     real *, real *, real *, real *, real *, integer *, ftnlen), 
+	    schk5_(char *, real *, real *, integer *, integer *, logical *, 
+	    logical *, logical *, integer *, integer *, integer *, real *, 
+	    integer *, integer *, integer *, integer *, real *, real *, real *
+	    , real *, real *, real *, real *, real *, real *, real *, real *, 
+	    real *, integer *, ftnlen), schk6_(char *, real *, real *, 
+	    integer *, integer *, logical *, logical *, logical *, integer *, 
+	    integer *, integer *, real *, integer *, integer *, integer *, 
+	    integer *, real *, real *, real *, real *, real *, real *, real *,
+	     real *, real *, real *, real *, real *, integer *, ftnlen);
+    logical fatal;
+    extern real sdiff_(real *, real *);
+    logical trace;
+    integer nidim;
+    extern /* Subroutine */ int smvch_(char *, integer *, integer *, real *, 
+	    real *, integer *, real *, integer *, real *, real *, integer *, 
+	    real *, real *, real *, real *, real *, logical *, integer *, 
+	    logical *, ftnlen);
+    char snaps[32], trans[1];
+    integer isnum;
+    logical ltest[16], sfatal, corder;
+    char snamet[12];
+    real thresh;
+    logical rorder;
+    integer layout;
+    logical ltestt;
+    extern /* Subroutine */ void cs2chke_(char *);
+    logical tsterr;
+
+    /* Fortran I/O blocks */
+    static cilist io___2 = { 0, 5, 0, 0, 0 };
+    static cilist io___4 = { 0, 5, 0, 0, 0 };
+    static cilist io___7 = { 0, 5, 0, 0, 0 };
+    static cilist io___9 = { 0, 5, 0, 0, 0 };
+    static cilist io___11 = { 0, 5, 0, 0, 0 };
+    static cilist io___13 = { 0, 5, 0, 0, 0 };
+    static cilist io___15 = { 0, 5, 0, 0, 0 };
+    static cilist io___17 = { 0, 5, 0, 0, 0 };
+    static cilist io___19 = { 0, 6, 0, fmt_9997, 0 };
+    static cilist io___20 = { 0, 5, 0, 0, 0 };
+    static cilist io___23 = { 0, 6, 0, fmt_9996, 0 };
+    static cilist io___24 = { 0, 5, 0, 0, 0 };
+    static cilist io___26 = { 0, 6, 0, fmt_9997, 0 };
+    static cilist io___27 = { 0, 5, 0, 0, 0 };
+    static cilist io___29 = { 0, 6, 0, fmt_9995, 0 };
+    static cilist io___30 = { 0, 5, 0, 0, 0 };
+    static cilist io___32 = { 0, 6, 0, fmt_9997, 0 };
+    static cilist io___33 = { 0, 5, 0, 0, 0 };
+    static cilist io___35 = { 0, 6, 0, fmt_9994, 0 };
+    static cilist io___36 = { 0, 5, 0, 0, 0 };
+    static cilist io___38 = { 0, 6, 0, fmt_9997, 0 };
+    static cilist io___39 = { 0, 5, 0, 0, 0 };
+    static cilist io___41 = { 0, 5, 0, 0, 0 };
+    static cilist io___43 = { 0, 6, 0, fmt_9997, 0 };
+    static cilist io___44 = { 0, 5, 0, 0, 0 };
+    static cilist io___46 = { 0, 6, 0, fmt_9993, 0 };
+    static cilist io___47 = { 0, 6, 0, fmt_9992, 0 };
+    static cilist io___48 = { 0, 6, 0, fmt_9991, 0 };
+    static cilist io___49 = { 0, 6, 0, fmt_9990, 0 };
+    static cilist io___50 = { 0, 6, 0, fmt_9989, 0 };
+    static cilist io___51 = { 0, 6, 0, fmt_9988, 0 };
+    static cilist io___52 = { 0, 6, 0, 0, 0 };
+    static cilist io___53 = { 0, 6, 0, fmt_9980, 0 };
+    static cilist io___54 = { 0, 6, 0, 0, 0 };
+    static cilist io___55 = { 0, 6, 0, fmt_9999, 0 };
+    static cilist io___56 = { 0, 6, 0, 0, 0 };
+    static cilist io___59 = { 0, 6, 0, fmt_10002, 0 };
+    static cilist io___60 = { 0, 6, 0, fmt_10001, 0 };
+    static cilist io___61 = { 0, 6, 0, fmt_10000, 0 };
+    static cilist io___62 = { 0, 6, 0, 0, 0 };
+    static cilist io___64 = { 0, 5, 1, fmt_9984, 0 };
+    static cilist io___67 = { 0, 6, 0, fmt_9986, 0 };
+    static cilist io___69 = { 0, 6, 0, fmt_9998, 0 };
+    static cilist io___82 = { 0, 6, 0, fmt_9985, 0 };
+    static cilist io___83 = { 0, 6, 0, fmt_9985, 0 };
+    static cilist io___85 = { 0, 6, 0, 0, 0 };
+    static cilist io___86 = { 0, 6, 0, fmt_9983, 0 };
+    static cilist io___87 = { 0, 6, 0, 0, 0 };
+    static cilist io___94 = { 0, 6, 0, fmt_9982, 0 };
+    static cilist io___95 = { 0, 6, 0, fmt_9981, 0 };
+    static cilist io___96 = { 0, 6, 0, fmt_9987, 0 };
+
+
+
+/*  Test program for the REAL             Level 2 Blas. */
+
+/*  The program must be driven by a short data file. The first 17 records */
+/*  of the file are read using list-directed input, the last 16 records */
+/*  are read using the format ( A12, L2 ). An annotated example of a data */
+/*  file can be obtained by deleting the first 3 characters from the */
+/*  following 33 lines: */
+/*  'SBLAT2.SNAP'     NAME OF SNAPSHOT OUTPUT FILE */
+/*  -1                UNIT NUMBER OF SNAPSHOT FILE (NOT USED IF .LT. 0) */
+/*  F        LOGICAL FLAG, T TO REWIND SNAPSHOT FILE AFTER EACH RECORD. */
+/*  F        LOGICAL FLAG, T TO STOP ON FAILURES. */
+/*  T        LOGICAL FLAG, T TO TEST ERROR EXITS. */
+/*  2        0 TO TEST COLUMN-MAJOR, 1 TO TEST ROW-MAJOR, 2 TO TEST BOTH */
+/*  16.0     THRESHOLD VALUE OF TEST RATIO */
+/*  6                 NUMBER OF VALUES OF N */
+/*  0 1 2 3 5 9       VALUES OF N */
+/*  4                 NUMBER OF VALUES OF K */
+/*  0 1 2 4           VALUES OF K */
+/*  4                 NUMBER OF VALUES OF INCX AND INCY */
+/*  1 2 -1 -2         VALUES OF INCX AND INCY */
+/*  3                 NUMBER OF VALUES OF ALPHA */
+/*  0.0 1.0 0.7       VALUES OF ALPHA */
+/*  3                 NUMBER OF VALUES OF BETA */
+/*  0.0 1.0 0.9       VALUES OF BETA */
+/*  cblas_sgemv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_sgbmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_ssymv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_ssbmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_sspmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_strmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_stbmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_stpmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_strsv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_stbsv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_stpsv  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_sger   T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_ssyr   T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_sspr   T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_ssyr2  T PUT F FOR NO TEST. SAME COLUMNS. */
+/*  cblas_sspr2  T PUT F FOR NO TEST. SAME COLUMNS. */
+
+/*     See: */
+
+/*        Dongarra J. J., Du Croz J. J., Hammarling S.  and Hanson R. J.. */
+/*        An  extended  set of Fortran  Basic Linear Algebra Subprograms. */
+
+/*        Technical  Memoranda  Nos. 41 (revision 3) and 81,  Mathematics */
+/*        and  Computer Science  Division,  Argonne  National Laboratory, */
+/*        9700 South Cass Avenue, Argonne, Illinois 60439, US. */
+
+/*        Or */
+
+/*        NAG  Technical Reports TR3/87 and TR4/87,  Numerical Algorithms */
+/*        Group  Ltd.,  NAG  Central  Office,  256  Banbury  Road, Oxford */
+/*        OX2 7DE, UK,  and  Numerical Algorithms Group Inc.,  1101  31st */
+/*        Street,  Suite 100,  Downers Grove,  Illinois 60515-1263,  USA. */
+
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Parameters .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Scalars in Common .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+
+    infoc_1.noutc = 6;
+
+/*     Read name and unit number for snapshot output file and open file. */
+
+    s_rsle(&io___2);
+    do_lio(&c__9, &c__1, snaps, (ftnlen)32);
+    e_rsle();
+    s_rsle(&io___4);
+    do_lio(&c__3, &c__1, (char *)&ntra, (ftnlen)sizeof(integer));
+    e_rsle();
+    trace = ntra >= 0;
+    if (trace) {
+	o__1.oerr = 0;
+	o__1.ounit = ntra;
+	o__1.ofnmlen = 32;
+	o__1.ofnm = snaps;
+	o__1.orl = 0;
+	o__1.osta = 0;
+	o__1.oacc = 0;
+	o__1.ofm = 0;
+	o__1.oblnk = 0;
+	f_open(&o__1);
+    }
+/*     Read the flag that directs rewinding of the snapshot file. */
+    s_rsle(&io___7);
+    do_lio(&c__8, &c__1, (char *)&rewi, (ftnlen)sizeof(logical));
+    e_rsle();
+    rewi = rewi && trace;
+/*     Read the flag that directs stopping on any failure. */
+    s_rsle(&io___9);
+    do_lio(&c__8, &c__1, (char *)&sfatal, (ftnlen)sizeof(logical));
+    e_rsle();
+/*     Read the flag that indicates whether error exits are to be tested. */
+    s_rsle(&io___11);
+    do_lio(&c__8, &c__1, (char *)&tsterr, (ftnlen)sizeof(logical));
+    e_rsle();
+/*     Read the flag that indicates whether row-major data layout to be tested. */
+    s_rsle(&io___13);
+    do_lio(&c__3, &c__1, (char *)&layout, (ftnlen)sizeof(integer));
+    e_rsle();
+/*     Read the threshold value of the test ratio */
+    s_rsle(&io___15);
+    do_lio(&c__4, &c__1, (char *)&thresh, (ftnlen)sizeof(real));
+    e_rsle();
+
+/*     Read and check the parameter values for the tests. */
+
+/*     Values of N */
+    s_rsle(&io___17);
+    do_lio(&c__3, &c__1, (char *)&nidim, (ftnlen)sizeof(integer));
+    e_rsle();
+    if (nidim < 1 || nidim > 9) {
+	s_wsfe(&io___19);
+	do_fio(&c__1, "N", (ftnlen)1);
+	do_fio(&c__1, (char *)&c__9, (ftnlen)sizeof(integer));
+	e_wsfe();
+	goto L230;
+    }
+    s_rsle(&io___20);
+    i__1 = nidim;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_lio(&c__3, &c__1, (char *)&idim[i__ - 1], (ftnlen)sizeof(integer));
+    }
+    e_rsle();
+    i__1 = nidim;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	if (idim[i__ - 1] < 0 || idim[i__ - 1] > 65) {
+	    s_wsfe(&io___23);
+	    do_fio(&c__1, (char *)&c__65, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	    goto L230;
+	}
+/* L10: */
+    }
+/*     Values of K */
+    s_rsle(&io___24);
+    do_lio(&c__3, &c__1, (char *)&nkb, (ftnlen)sizeof(integer));
+    e_rsle();
+    if (nkb < 1 || nkb > 7) {
+	s_wsfe(&io___26);
+	do_fio(&c__1, "K", (ftnlen)1);
+	do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+	e_wsfe();
+	goto L230;
+    }
+    s_rsle(&io___27);
+    i__1 = nkb;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_lio(&c__3, &c__1, (char *)&kb[i__ - 1], (ftnlen)sizeof(integer));
+    }
+    e_rsle();
+    i__1 = nkb;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	if (kb[i__ - 1] < 0) {
+	    s_wsfe(&io___29);
+	    e_wsfe();
+	    goto L230;
+	}
+/* L20: */
+    }
+/*     Values of INCX and INCY */
+    s_rsle(&io___30);
+    do_lio(&c__3, &c__1, (char *)&ninc, (ftnlen)sizeof(integer));
+    e_rsle();
+    if (ninc < 1 || ninc > 7) {
+	s_wsfe(&io___32);
+	do_fio(&c__1, "INCX AND INCY", (ftnlen)13);
+	do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+	e_wsfe();
+	goto L230;
+    }
+    s_rsle(&io___33);
+    i__1 = ninc;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_lio(&c__3, &c__1, (char *)&inc[i__ - 1], (ftnlen)sizeof(integer));
+    }
+    e_rsle();
+    i__1 = ninc;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	if (inc[i__ - 1] == 0 || (i__2 = inc[i__ - 1], abs(i__2)) > 2) {
+	    s_wsfe(&io___35);
+	    do_fio(&c__1, (char *)&c__2, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	    goto L230;
+	}
+/* L30: */
+    }
+/*     Values of ALPHA */
+    s_rsle(&io___36);
+    do_lio(&c__3, &c__1, (char *)&nalf, (ftnlen)sizeof(integer));
+    e_rsle();
+    if (nalf < 1 || nalf > 7) {
+	s_wsfe(&io___38);
+	do_fio(&c__1, "ALPHA", (ftnlen)5);
+	do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+	e_wsfe();
+	goto L230;
+    }
+    s_rsle(&io___39);
+    i__1 = nalf;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_lio(&c__4, &c__1, (char *)&alf[i__ - 1], (ftnlen)sizeof(real));
+    }
+    e_rsle();
+/*     Values of BETA */
+    s_rsle(&io___41);
+    do_lio(&c__3, &c__1, (char *)&nbet, (ftnlen)sizeof(integer));
+    e_rsle();
+    if (nbet < 1 || nbet > 7) {
+	s_wsfe(&io___43);
+	do_fio(&c__1, "BETA", (ftnlen)4);
+	do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+	e_wsfe();
+	goto L230;
+    }
+    s_rsle(&io___44);
+    i__1 = nbet;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_lio(&c__4, &c__1, (char *)&bet[i__ - 1], (ftnlen)sizeof(real));
+    }
+    e_rsle();
+
+/*     Report values of parameters. */
+
+    s_wsfe(&io___46);
+    e_wsfe();
+    s_wsfe(&io___47);
+    i__1 = nidim;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_fio(&c__1, (char *)&idim[i__ - 1], (ftnlen)sizeof(integer));
+    }
+    e_wsfe();
+    s_wsfe(&io___48);
+    i__1 = nkb;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_fio(&c__1, (char *)&kb[i__ - 1], (ftnlen)sizeof(integer));
+    }
+    e_wsfe();
+    s_wsfe(&io___49);
+    i__1 = ninc;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_fio(&c__1, (char *)&inc[i__ - 1], (ftnlen)sizeof(integer));
+    }
+    e_wsfe();
+    s_wsfe(&io___50);
+    i__1 = nalf;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_fio(&c__1, (char *)&alf[i__ - 1], (ftnlen)sizeof(real));
+    }
+    e_wsfe();
+    s_wsfe(&io___51);
+    i__1 = nbet;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	do_fio(&c__1, (char *)&bet[i__ - 1], (ftnlen)sizeof(real));
+    }
+    e_wsfe();
+    if (! tsterr) {
+	s_wsle(&io___52);
+	e_wsle();
+	s_wsfe(&io___53);
+	e_wsfe();
+    }
+    s_wsle(&io___54);
+    e_wsle();
+    s_wsfe(&io___55);
+    do_fio(&c__1, (char *)&thresh, (ftnlen)sizeof(real));
+    e_wsfe();
+    s_wsle(&io___56);
+    e_wsle();
+    rorder = FALSE_;
+    corder = FALSE_;
+    if (layout == 2) {
+	rorder = TRUE_;
+	corder = TRUE_;
+	s_wsfe(&io___59);
+	e_wsfe();
+    } else if (layout == 1) {
+	rorder = TRUE_;
+	s_wsfe(&io___60);
+	e_wsfe();
+    } else if (layout == 0) {
+	corder = TRUE_;
+	s_wsfe(&io___61);
+	e_wsfe();
+    }
+    s_wsle(&io___62);
+    e_wsle();
+
+/*     Read names of subroutines and flags which indicate */
+/*     whether they are to be tested. */
+
+    for (i__ = 1; i__ <= 16; ++i__) {
+	ltest[i__ - 1] = FALSE_;
+/* L40: */
+    }
+L50:
+    i__1 = s_rsfe(&io___64);
+    if (i__1 != 0) {
+	goto L80;
+    }
+    i__1 = do_fio(&c__1, snamet, (ftnlen)12);
+    if (i__1 != 0) {
+	goto L80;
+    }
+    i__1 = do_fio(&c__1, (char *)&ltestt, (ftnlen)sizeof(logical));
+    if (i__1 != 0) {
+	goto L80;
+    }
+    i__1 = e_rsfe();
+    if (i__1 != 0) {
+	goto L80;
+    }
+    for (i__ = 1; i__ <= 16; ++i__) {
+	if (s_cmp(snamet, snames + (i__ - 1) * 12, (ftnlen)12, (ftnlen)12) == 
+		0) {
+	    goto L70;
+	}
+/* L60: */
+    }
+    s_wsfe(&io___67);
+    do_fio(&c__1, snamet, (ftnlen)12);
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+L70:
+    ltest[i__ - 1] = ltestt;
+    goto L50;
+
+L80:
+    cl__1.cerr = 0;
+    cl__1.cunit = 5;
+    cl__1.csta = 0;
+    f_clos(&cl__1);
+
+/*     Compute EPS (the machine precision). */
+
+    eps = 1.f;
+L90:
+    r__1 = eps + 1.f;
+    if (sdiff_(&r__1, &c_b123) == 0.f) {
+	goto L100;
+    }
+    eps *= .5f;
+    goto L90;
+L100:
+    eps += eps;
+    s_wsfe(&io___69);
+    do_fio(&c__1, (char *)&eps, (ftnlen)sizeof(real));
+    e_wsfe();
+
+/*     Check the reliability of SMVCH using exact data. */
+
+    n = 32;
+    i__1 = n;
+    for (j = 1; j <= i__1; ++j) {
+	i__2 = n;
+	for (i__ = 1; i__ <= i__2; ++i__) {
+/* Computing MAX */
+	    i__3 = i__ - j + 1;
+	    a[i__ + j * 65 - 66] = (real) max(i__3,0);
+/* L110: */
+	}
+	x[j - 1] = (real) j;
+	y[j - 1] = 0.f;
+/* L120: */
+    }
+    i__1 = n;
+    for (j = 1; j <= i__1; ++j) {
+	yy[j - 1] = (real) (j * ((j + 1) * j) / 2 - (j + 1) * j * (j - 1) / 3)
+		;
+/* L130: */
+    }
+/*     YY holds the exact result. On exit from SMVCH YT holds */
+/*     the result computed by SMVCH. */
+    *(unsigned char *)trans = 'N';
+    smvch_(trans, &n, &n, &c_b123, a, &c__65, x, &c__1, &c_b135, y, &c__1, yt,
+	     g, yy, &eps, &err, &fatal, &c__6, &c_true, (ftnlen)1);
+    same = lse_(yy, yt, &n);
+    if (! same || err != 0.f) {
+	s_wsfe(&io___82);
+	do_fio(&c__1, trans, (ftnlen)1);
+	do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+	do_fio(&c__1, (char *)&err, (ftnlen)sizeof(real));
+	e_wsfe();
+	s_stop("", (ftnlen)0);
+    }
+    *(unsigned char *)trans = 'T';
+    smvch_(trans, &n, &n, &c_b123, a, &c__65, x, &c_n1, &c_b135, y, &c_n1, yt,
+	     g, yy, &eps, &err, &fatal, &c__6, &c_true, (ftnlen)1);
+    same = lse_(yy, yt, &n);
+    if (! same || err != 0.f) {
+	s_wsfe(&io___83);
+	do_fio(&c__1, trans, (ftnlen)1);
+	do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+	do_fio(&c__1, (char *)&err, (ftnlen)sizeof(real));
+	e_wsfe();
+	s_stop("", (ftnlen)0);
+    }
+
+/*     Test each subroutine in turn. */
+
+    for (isnum = 1; isnum <= 16; ++isnum) {
+	s_wsle(&io___85);
+	e_wsle();
+	if (! ltest[isnum - 1]) {
+/*           Subprogram is not to be tested. */
+	    s_wsfe(&io___86);
+	    do_fio(&c__1, snames + (isnum - 1) * 12, (ftnlen)12);
+	    e_wsfe();
+	} else {
+	    s_copy(srnamc_1.srnamt, snames + (isnum - 1) * 12, (ftnlen)12, (
+		    ftnlen)12);
+/*           Test error exits. */
+	    if (tsterr) {
+		cs2chke_(snames + (isnum - 1) * 12);
+		s_wsle(&io___87);
+		e_wsle();
+	    }
+/*           Test computations. */
+	    infoc_1.infot = 0;
+	    infoc_1.ok = TRUE_;
+	    fatal = FALSE_;
+	    switch (isnum) {
+		case 1:  goto L140;
+		case 2:  goto L140;
+		case 3:  goto L150;
+		case 4:  goto L150;
+		case 5:  goto L150;
+		case 6:  goto L160;
+		case 7:  goto L160;
+		case 8:  goto L160;
+		case 9:  goto L160;
+		case 10:  goto L160;
+		case 11:  goto L160;
+		case 12:  goto L170;
+		case 13:  goto L180;
+		case 14:  goto L180;
+		case 15:  goto L190;
+		case 16:  goto L190;
+	    }
+/*           Test SGEMV, 01, and SGBMV, 02. */
+L140:
+	    if (corder) {
+		schk1_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nkb, kb, &nalf,
+			 alf, &nbet, bet, &ninc, inc, &c__65, &c__2, a, aa, 
+			as, x, xx, xs, y, yy, ys, yt, g, &c__0, (ftnlen)12);
+	    }
+	    if (rorder) {
+		schk1_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nkb, kb, &nalf,
+			 alf, &nbet, bet, &ninc, inc, &c__65, &c__2, a, aa, 
+			as, x, xx, xs, y, yy, ys, yt, g, &c__1, (ftnlen)12);
+	    }
+	    goto L200;
+/*           Test SSYMV, 03, SSBMV, 04, and SSPMV, 05. */
+L150:
+	    if (corder) {
+		schk2_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nkb, kb, &nalf,
+			 alf, &nbet, bet, &ninc, inc, &c__65, &c__2, a, aa, 
+			as, x, xx, xs, y, yy, ys, yt, g, &c__0, (ftnlen)12);
+	    }
+	    if (rorder) {
+		schk2_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nkb, kb, &nalf,
+			 alf, &nbet, bet, &ninc, inc, &c__65, &c__2, a, aa, 
+			as, x, xx, xs, y, yy, ys, yt, g, &c__1, (ftnlen)12);
+	    }
+	    goto L200;
+/*           Test STRMV, 06, STBMV, 07, STPMV, 08, */
+/*           STRSV, 09, STBSV, 10, and STPSV, 11. */
+L160:
+	    if (corder) {
+		schk3_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nkb, kb, &ninc,
+			 inc, &c__65, &c__2, a, aa, as, y, yy, ys, yt, g, z__,
+			 &c__0, (ftnlen)12);
+	    }
+	    if (rorder) {
+		schk3_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nkb, kb, &ninc,
+			 inc, &c__65, &c__2, a, aa, as, y, yy, ys, yt, g, z__,
+			 &c__1, (ftnlen)12);
+	    }
+	    goto L200;
+/*           Test SGER, 12. */
+L170:
+	    if (corder) {
+		schk4_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nalf, alf, &
+			ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy,
+			 ys, yt, g, z__, &c__0, (ftnlen)12);
+	    }
+	    if (rorder) {
+		schk4_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nalf, alf, &
+			ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy,
+			 ys, yt, g, z__, &c__1, (ftnlen)12);
+	    }
+	    goto L200;
+/*           Test SSYR, 13, and SSPR, 14. */
+L180:
+	    if (corder) {
+		schk5_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nalf, alf, &
+			ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy,
+			 ys, yt, g, z__, &c__0, (ftnlen)12);
+	    }
+	    if (rorder) {
+		schk5_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nalf, alf, &
+			ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy,
+			 ys, yt, g, z__, &c__1, (ftnlen)12);
+	    }
+	    goto L200;
+/*           Test SSYR2, 15, and SSPR2, 16. */
+L190:
+	    if (corder) {
+		schk6_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nalf, alf, &
+			ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy,
+			 ys, yt, g, z__, &c__0, (ftnlen)12);
+	    }
+	    if (rorder) {
+		schk6_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra,
+			 &trace, &rewi, &fatal, &nidim, idim, &nalf, alf, &
+			ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy,
+			 ys, yt, g, z__, &c__1, (ftnlen)12);
+	    }
+
+L200:
+	    if (fatal && sfatal) {
+		goto L220;
+	    }
+	}
+/* L210: */
+    }
+    s_wsfe(&io___94);
+    e_wsfe();
+    goto L240;
+
+L220:
+    s_wsfe(&io___95);
+    e_wsfe();
+    goto L240;
+
+L230:
+    s_wsfe(&io___96);
+    e_wsfe();
+
+L240:
+    if (trace) {
+	cl__1.cerr = 0;
+	cl__1.cunit = ntra;
+	cl__1.csta = 0;
+	f_clos(&cl__1);
+    }
+    cl__1.cerr = 0;
+    cl__1.cunit = 6;
+    cl__1.csta = 0;
+    f_clos(&cl__1);
+    s_stop("", (ftnlen)0);
+
+
+/*     End of SBLAT2. */
+
+    return 0;
+} /* MAIN__ */
+
+/* Subroutine */ int schk1_(char *sname, real *eps, real *thresh, integer *
+	nout, integer *ntra, logical *trace, logical *rewi, logical *fatal, 
+	integer *nidim, integer *idim, integer *nkb, integer *kb, integer *
+	nalf, real *alf, integer *nbet, real *bet, integer *ninc, integer *
+	inc, integer *nmax, integer *incmax, real *a, real *aa, real *as, 
+	real *x, real *xx, real *xs, real *y, real *yy, real *ys, real *yt, 
+	real *g, integer *iorder, ftnlen sname_len)
+{
+    /* Initialized data */
+
+    static char ich[3] = "NTC";
+
+    /* Format strings */
+    static char fmt_9994[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+	    "2(i3,\002,\002),f4.1,\002, A,\002,i3,\002, X,\002,i2,\002,\002,f"
+	    "4.1,\002, Y,\002,i2,\002) .\002)";
+    static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+	    "4(i3,\002,\002),f4.1,\002, A,\002,i3,\002,\002,/10x,\002X,\002,i"
+	    "2,\002,\002,f4.1,\002, Y,\002,i2,\002) .\002)";
+    static char fmt_9993[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+	    "N VALID CALL *\002,\002******\002)";
+    static char fmt_9998[] = "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+	    " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+    static char fmt_10000[] = "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10001[] = "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10002[] = "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+	    "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_10003[] = "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+	    "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+	    "BER:\002)";
+
+    /* System generated locals */
+    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6, i__7, i__8;
+    alist al__1;
+
+    /* Builtin functions */
+    /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+	     f_rew(alist *);
+
+    /* Local variables */
+    integer i__, m, n, ia, ib, ic, nc, nd, im, in, kl, ml, nk, nl, ku, ix, iy,
+	     ms, lx, ly, ns, laa, lda;
+    real als, bls;
+    extern logical lse_(real *, real *, integer *);
+    real err;
+    integer iku, kls, kus;
+    real beta;
+    integer ldas;
+    logical same;
+    integer incx, incy;
+    logical full, tran, null;
+    real alpha;
+    logical isame[13];
+    extern /* Subroutine */ int smake_(char *, char *, char *, integer *, 
+	    integer *, real *, integer *, real *, integer *, integer *, 
+	    integer *, logical *, real *, ftnlen, ftnlen, ftnlen);
+    integer nargs;
+    extern /* Subroutine */ int smvch_(char *, integer *, integer *, real *, 
+	    real *, integer *, real *, integer *, real *, real *, integer *, 
+	    real *, real *, real *, real *, real *, logical *, integer *, 
+	    logical *, ftnlen);
+    logical reset;
+    integer incxs, incys;
+    char trans[1];
+    logical banded;
+    extern /* Subroutine */ void csgbmv_(integer *, char *, integer *, integer 
+	    *, integer *, integer *, real *, real *, integer *, real *, 
+	    integer *, real *, real *, integer *), csgemv_(integer *, 
+	    char *, integer *, integer *, real *, real *, integer *, real *, 
+	    integer *, real *, real *, integer *);
+    char ctrans[14];
+    real errmax;
+    extern logical lseres_(char *, char *, integer *, integer *, real *, real 
+	    *, integer *, ftnlen, ftnlen);
+    real transl;
+    char transs[1];
+
+    /* Fortran I/O blocks */
+    static cilist io___144 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___145 = { 0, 0, 0, fmt_9995, 0 };
+    static cilist io___146 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___149 = { 0, 0, 0, fmt_9998, 0 };
+    static cilist io___151 = { 0, 0, 0, fmt_10000, 0 };
+    static cilist io___152 = { 0, 0, 0, fmt_10001, 0 };
+    static cilist io___153 = { 0, 0, 0, fmt_10002, 0 };
+    static cilist io___154 = { 0, 0, 0, fmt_10003, 0 };
+    static cilist io___155 = { 0, 0, 0, fmt_9996, 0 };
+    static cilist io___156 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___157 = { 0, 0, 0, fmt_9995, 0 };
+
+
+
+/*  Tests SGEMV and SGBMV. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Scalars in Common .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+    /* Parameter adjustments */
+    --idim;
+    --kb;
+    --alf;
+    --bet;
+    --inc;
+    --g;
+    --yt;
+    --y;
+    --x;
+    --as;
+    --aa;
+    a_dim1 = *nmax;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --ys;
+    --yy;
+    --xs;
+    --xx;
+
+    /* Function Body */
+/*     .. Executable Statements .. */
+    full = *(unsigned char *)&sname[8] == 'e';
+    banded = *(unsigned char *)&sname[8] == 'b';
+/*     Define the number of arguments. */
+    if (full) {
+	nargs = 11;
+    } else if (banded) {
+	nargs = 13;
+    }
+
+    nc = 0;
+    reset = TRUE_;
+    errmax = 0.f;
+
+    i__1 = *nidim;
+    for (in = 1; in <= i__1; ++in) {
+	n = idim[in];
+	nd = n / 2 + 1;
+
+	for (im = 1; im <= 2; ++im) {
+	    if (im == 1) {
+/* Computing MAX */
+		i__2 = n - nd;
+		m = max(i__2,0);
+	    }
+	    if (im == 2) {
+/* Computing MIN */
+		i__2 = n + nd;
+		m = min(i__2,*nmax);
+	    }
+
+	    if (banded) {
+		nk = *nkb;
+	    } else {
+		nk = 1;
+	    }
+	    i__2 = nk;
+	    for (iku = 1; iku <= i__2; ++iku) {
+		if (banded) {
+		    ku = kb[iku];
+/* Computing MAX */
+		    i__3 = ku - 1;
+		    kl = max(i__3,0);
+		} else {
+		    ku = n - 1;
+		    kl = m - 1;
+		}
+/*              Set LDA to 1 more than minimum value if room. */
+		if (banded) {
+		    lda = kl + ku + 1;
+		} else {
+		    lda = m;
+		}
+		if (lda < *nmax) {
+		    ++lda;
+		}
+/*              Skip tests if not enough room. */
+		if (lda > *nmax) {
+		    goto L100;
+		}
+		laa = lda * n;
+		null = n <= 0 || m <= 0;
+
+/*              Generate the matrix A. */
+
+		transl = 0.f;
+		smake_(sname + 7, " ", " ", &m, &n, &a[a_offset], nmax, &aa[1]
+			, &lda, &kl, &ku, &reset, &transl, (ftnlen)2, (ftnlen)
+			1, (ftnlen)1);
+
+		for (ic = 1; ic <= 3; ++ic) {
+		    *(unsigned char *)trans = *(unsigned char *)&ich[ic - 1];
+		    if (*(unsigned char *)trans == 'N') {
+			s_copy(ctrans, "  CblasNoTrans", (ftnlen)14, (ftnlen)
+				14);
+		    } else if (*(unsigned char *)trans == 'T') {
+			s_copy(ctrans, "    CblasTrans", (ftnlen)14, (ftnlen)
+				14);
+		    } else {
+			s_copy(ctrans, "CblasConjTrans", (ftnlen)14, (ftnlen)
+				14);
+		    }
+		    tran = *(unsigned char *)trans == 'T' || *(unsigned char *
+			    )trans == 'C';
+
+		    if (tran) {
+			ml = n;
+			nl = m;
+		    } else {
+			ml = m;
+			nl = n;
+		    }
+
+		    i__3 = *ninc;
+		    for (ix = 1; ix <= i__3; ++ix) {
+			incx = inc[ix];
+			lx = abs(incx) * nl;
+
+/*                    Generate the vector X. */
+
+			transl = .5f;
+			i__4 = abs(incx);
+			i__5 = nl - 1;
+			smake_("ge", " ", " ", &c__1, &nl, &x[1], &c__1, &xx[
+				1], &i__4, &c__0, &i__5, &reset, &transl, (
+				ftnlen)2, (ftnlen)1, (ftnlen)1);
+			if (nl > 1) {
+			    x[nl / 2] = 0.f;
+			    xx[abs(incx) * (nl / 2 - 1) + 1] = 0.f;
+			}
+
+			i__4 = *ninc;
+			for (iy = 1; iy <= i__4; ++iy) {
+			    incy = inc[iy];
+			    ly = abs(incy) * ml;
+
+			    i__5 = *nalf;
+			    for (ia = 1; ia <= i__5; ++ia) {
+				alpha = alf[ia];
+
+				i__6 = *nbet;
+				for (ib = 1; ib <= i__6; ++ib) {
+				    beta = bet[ib];
+
+/*                             Generate the vector Y. */
+
+				    transl = 0.f;
+				    i__7 = abs(incy);
+				    i__8 = ml - 1;
+				    smake_("ge", " ", " ", &c__1, &ml, &y[1], 
+					    &c__1, &yy[1], &i__7, &c__0, &
+					    i__8, &reset, &transl, (ftnlen)2, 
+					    (ftnlen)1, (ftnlen)1);
+
+				    ++nc;
+
+/*                             Save every datum before calling the */
+/*                             subroutine. */
+
+				    *(unsigned char *)transs = *(unsigned 
+					    char *)trans;
+				    ms = m;
+				    ns = n;
+				    kls = kl;
+				    kus = ku;
+				    als = alpha;
+				    i__7 = laa;
+				    for (i__ = 1; i__ <= i__7; ++i__) {
+					as[i__] = aa[i__];
+/* L10: */
+				    }
+				    ldas = lda;
+				    i__7 = lx;
+				    for (i__ = 1; i__ <= i__7; ++i__) {
+					xs[i__] = xx[i__];
+/* L20: */
+				    }
+				    incxs = incx;
+				    bls = beta;
+				    i__7 = ly;
+				    for (i__ = 1; i__ <= i__7; ++i__) {
+					ys[i__] = yy[i__];
+/* L30: */
+				    }
+				    incys = incy;
+
+/*                             Call the subroutine. */
+
+				    if (full) {
+					if (*trace) {
+					    io___144.ciunit = *ntra;
+					    s_wsfe(&io___144);
+					    do_fio(&c__1, (char *)&nc, (
+						    ftnlen)sizeof(integer));
+					    do_fio(&c__1, sname, (ftnlen)12);
+					    do_fio(&c__1, ctrans, (ftnlen)14);
+					    do_fio(&c__1, (char *)&m, (ftnlen)
+						    sizeof(integer));
+					    do_fio(&c__1, (char *)&n, (ftnlen)
+						    sizeof(integer));
+					    do_fio(&c__1, (char *)&alpha, (
+						    ftnlen)sizeof(real));
+					    do_fio(&c__1, (char *)&lda, (
+						    ftnlen)sizeof(integer));
+					    do_fio(&c__1, (char *)&incx, (
+						    ftnlen)sizeof(integer));
+					    do_fio(&c__1, (char *)&beta, (
+						    ftnlen)sizeof(real));
+					    do_fio(&c__1, (char *)&incy, (
+						    ftnlen)sizeof(integer));
+					    e_wsfe();
+					}
+					if (*rewi) {
+					    al__1.aerr = 0;
+					    al__1.aunit = *ntra;
+					    f_rew(&al__1);
+					}
+					csgemv_(iorder, trans, &m, &n, &alpha,
+						 &aa[1], &lda, &xx[1], &incx, 
+						&beta, &yy[1], &incy);
+				    } else if (banded) {
+					if (*trace) {
+					    io___145.ciunit = *ntra;
+					    s_wsfe(&io___145);
+					    do_fio(&c__1, (char *)&nc, (
+						    ftnlen)sizeof(integer));
+					    do_fio(&c__1, sname, (ftnlen)12);
+					    do_fio(&c__1, ctrans, (ftnlen)14);
+					    do_fio(&c__1, (char *)&m, (ftnlen)
+						    sizeof(integer));
+					    do_fio(&c__1, (char *)&n, (ftnlen)
+						    sizeof(integer));
+					    do_fio(&c__1, (char *)&kl, (
+						    ftnlen)sizeof(integer));
+					    do_fio(&c__1, (char *)&ku, (
+						    ftnlen)sizeof(integer));
+					    do_fio(&c__1, (char *)&alpha, (
+						    ftnlen)sizeof(real));
+					    do_fio(&c__1, (char *)&lda, (
+						    ftnlen)sizeof(integer));
+					    do_fio(&c__1, (char *)&incx, (
+						    ftnlen)sizeof(integer));
+					    do_fio(&c__1, (char *)&beta, (
+						    ftnlen)sizeof(real));
+					    do_fio(&c__1, (char *)&incy, (
+						    ftnlen)sizeof(integer));
+					    e_wsfe();
+					}
+					if (*rewi) {
+					    al__1.aerr = 0;
+					    al__1.aunit = *ntra;
+					    f_rew(&al__1);
+					}
+					csgbmv_(iorder, trans, &m, &n, &kl, &
+						ku, &alpha, &aa[1], &lda, &xx[
+						1], &incx, &beta, &yy[1], &
+						incy);
+				    }
+
+/*                             Check if error-exit was taken incorrectly. */
+
+				    if (! infoc_1.ok) {
+					io___146.ciunit = *nout;
+					s_wsfe(&io___146);
+					e_wsfe();
+					*fatal = TRUE_;
+					goto L130;
+				    }
+
+/*                             See what data changed inside subroutines. */
+
+				    isame[0] = *(unsigned char *)trans == *(
+					    unsigned char *)transs;
+				    isame[1] = ms == m;
+				    isame[2] = ns == n;
+				    if (full) {
+					isame[3] = als == alpha;
+					isame[4] = lse_(&as[1], &aa[1], &laa);
+					isame[5] = ldas == lda;
+					isame[6] = lse_(&xs[1], &xx[1], &lx);
+					isame[7] = incxs == incx;
+					isame[8] = bls == beta;
+					if (null) {
+					    isame[9] = lse_(&ys[1], &yy[1], &
+						    ly);
+					} else {
+					    i__7 = abs(incy);
+					    isame[9] = lseres_("ge", " ", &
+						    c__1, &ml, &ys[1], &yy[1],
+						     &i__7, (ftnlen)2, (
+						    ftnlen)1);
+					}
+					isame[10] = incys == incy;
+				    } else if (banded) {
+					isame[3] = kls == kl;
+					isame[4] = kus == ku;
+					isame[5] = als == alpha;
+					isame[6] = lse_(&as[1], &aa[1], &laa);
+					isame[7] = ldas == lda;
+					isame[8] = lse_(&xs[1], &xx[1], &lx);
+					isame[9] = incxs == incx;
+					isame[10] = bls == beta;
+					if (null) {
+					    isame[11] = lse_(&ys[1], &yy[1], &
+						    ly);
+					} else {
+					    i__7 = abs(incy);
+					    isame[11] = lseres_("ge", " ", &
+						    c__1, &ml, &ys[1], &yy[1],
+						     &i__7, (ftnlen)2, (
+						    ftnlen)1);
+					}
+					isame[12] = incys == incy;
+				    }
+
+/*                             If data was incorrectly changed, report */
+/*                             and return. */
+
+				    same = TRUE_;
+				    i__7 = nargs;
+				    for (i__ = 1; i__ <= i__7; ++i__) {
+					same = same && isame[i__ - 1];
+					if (! isame[i__ - 1]) {
+					    io___149.ciunit = *nout;
+					    s_wsfe(&io___149);
+					    do_fio(&c__1, (char *)&i__, (
+						    ftnlen)sizeof(integer));
+					    e_wsfe();
+					}
+/* L40: */
+				    }
+				    if (! same) {
+					*fatal = TRUE_;
+					goto L130;
+				    }
+
+				    if (! null) {
+
+/*                                Check the result. */
+
+					smvch_(trans, &m, &n, &alpha, &a[
+						a_offset], nmax, &x[1], &incx,
+						 &beta, &y[1], &incy, &yt[1], 
+						&g[1], &yy[1], eps, &err, 
+						fatal, nout, &c_true, (ftnlen)
+						1);
+					errmax = max(errmax,err);
+/*                                If got really bad answer, report and */
+/*                                return. */
+					if (*fatal) {
+					    goto L130;
+					}
+				    } else {
+/*                                Avoid repeating tests with M.le.0 or */
+/*                                N.le.0. */
+					goto L110;
+				    }
+
+/* L50: */
+				}
+
+/* L60: */
+			    }
+
+/* L70: */
+			}
+
+/* L80: */
+		    }
+
+/* L90: */
+		}
+
+L100:
+		;
+	    }
+
+L110:
+	    ;
+	}
+
+/* L120: */
+    }
+
+/*     Report result. */
+
+    if (errmax < *thresh) {
+	if (*iorder == 0) {
+	    io___151.ciunit = *nout;
+	    s_wsfe(&io___151);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___152.ciunit = *nout;
+	    s_wsfe(&io___152);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+    } else {
+	if (*iorder == 0) {
+	    io___153.ciunit = *nout;
+	    s_wsfe(&io___153);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___154.ciunit = *nout;
+	    s_wsfe(&io___154);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+	    e_wsfe();
+	}
+    }
+    goto L140;
+
+L130:
+    io___155.ciunit = *nout;
+    s_wsfe(&io___155);
+    do_fio(&c__1, sname, (ftnlen)12);
+    e_wsfe();
+    if (full) {
+	io___156.ciunit = *nout;
+	s_wsfe(&io___156);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, ctrans, (ftnlen)14);
+	do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&beta, (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+	e_wsfe();
+    } else if (banded) {
+	io___157.ciunit = *nout;
+	s_wsfe(&io___157);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, ctrans, (ftnlen)14);
+	do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&kl, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&ku, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&beta, (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+	e_wsfe();
+    }
+
+L140:
+    return 0;
+
+/* L9997: */
+
+/*     End of SCHK1. */
+
+} /* schk1_ */
+
+/* Subroutine */ int schk2_(char *sname, real *eps, real *thresh, integer *
+	nout, integer *ntra, logical *trace, logical *rewi, logical *fatal, 
+	integer *nidim, integer *idim, integer *nkb, integer *kb, integer *
+	nalf, real *alf, integer *nbet, real *bet, integer *ninc, integer *
+	inc, integer *nmax, integer *incmax, real *a, real *aa, real *as, 
+	real *x, real *xx, real *xs, real *y, real *yy, real *ys, real *yt, 
+	real *g, integer *iorder, ftnlen sname_len)
+{
+    /* Initialized data */
+
+    static char ich[2] = "UL";
+
+    /* Format strings */
+    static char fmt_9993[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+	    "i3,\002,\002,f4.1,\002, A,\002,i3,\002, X,\002,i2,\002,\002,f4.1,"
+	    "\002, Y,\002,i2,\002) .\002)";
+    static char fmt_9994[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+	    "2(i3,\002,\002),f4.1,\002, A,\002,i3,\002, X,\002,i2,\002,\002,f"
+	    "4.1,\002, Y,\002,i2,\002) .\002)";
+    static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+	    "i3,\002,\002,f4.1,\002, AP\002,\002, X,\002,i2,\002,\002,f4.1"
+	    ",\002, Y,\002,i2,\002) .\002)";
+    static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+	    "N VALID CALL *\002,\002******\002)";
+    static char fmt_9998[] = "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+	    " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+    static char fmt_10000[] = "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10001[] = "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10002[] = "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+	    "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_10003[] = "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+	    "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+	    "BER:\002)";
+
+    /* System generated locals */
+    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6, i__7, i__8;
+    alist al__1;
+
+    /* Builtin functions */
+    /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+	     f_rew(alist *);
+
+    /* Local variables */
+    integer i__, k, n, ia, ib, ic, nc, ik, in, nk, ks, ix, iy, ns, lx, ly, 
+	    laa, lda;
+    real als, bls;
+    extern logical lse_(real *, real *, integer *);
+    real err, beta;
+    integer ldas;
+    logical same;
+    integer incx, incy;
+    logical full, null;
+    char uplo[1];
+    real alpha;
+    logical isame[13];
+    extern /* Subroutine */ int smake_(char *, char *, char *, integer *, 
+	    integer *, real *, integer *, real *, integer *, integer *, 
+	    integer *, logical *, real *, ftnlen, ftnlen, ftnlen);
+    integer nargs;
+    extern /* Subroutine */ int smvch_(char *, integer *, integer *, real *, 
+	    real *, integer *, real *, integer *, real *, real *, integer *, 
+	    real *, real *, real *, real *, real *, logical *, integer *, 
+	    logical *, ftnlen);
+    logical reset;
+    char cuplo[14];
+    integer incxs, incys;
+    char uplos[1];
+    logical banded, packed;
+    real errmax;
+    extern logical lseres_(char *, char *, integer *, integer *, real *, real 
+	    *, integer *, ftnlen, ftnlen);
+    extern /* Subroutine */ void cssbmv_(integer *, char *, integer *, integer 
+	    *, real *, real *, integer *, real *, integer *, real *, real *, 
+	    integer *);
+    real transl;
+    extern /* Subroutine */ void csspmv_(integer *, char *, integer *, real *, 
+	    real *, real *, integer *, real *, real *, integer *), 
+	    cssymv_(integer *, char *, integer *, real *, real *, integer *, 
+	    real *, integer *, real *, real *, integer *);
+
+    /* Fortran I/O blocks */
+    static cilist io___197 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___198 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___199 = { 0, 0, 0, fmt_9995, 0 };
+    static cilist io___200 = { 0, 0, 0, fmt_9992, 0 };
+    static cilist io___203 = { 0, 0, 0, fmt_9998, 0 };
+    static cilist io___205 = { 0, 0, 0, fmt_10000, 0 };
+    static cilist io___206 = { 0, 0, 0, fmt_10001, 0 };
+    static cilist io___207 = { 0, 0, 0, fmt_10002, 0 };
+    static cilist io___208 = { 0, 0, 0, fmt_10003, 0 };
+    static cilist io___209 = { 0, 0, 0, fmt_9996, 0 };
+    static cilist io___210 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___211 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___212 = { 0, 0, 0, fmt_9995, 0 };
+
+
+
+/*  Tests SSYMV, SSBMV and SSPMV. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Scalars in Common .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+    /* Parameter adjustments */
+    --idim;
+    --kb;
+    --alf;
+    --bet;
+    --inc;
+    --g;
+    --yt;
+    --y;
+    --x;
+    --as;
+    --aa;
+    a_dim1 = *nmax;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --ys;
+    --yy;
+    --xs;
+    --xx;
+
+    /* Function Body */
+/*     .. Executable Statements .. */
+    full = *(unsigned char *)&sname[8] == 'y';
+    banded = *(unsigned char *)&sname[8] == 'b';
+    packed = *(unsigned char *)&sname[8] == 'p';
+/*     Define the number of arguments. */
+    if (full) {
+	nargs = 10;
+    } else if (banded) {
+	nargs = 11;
+    } else if (packed) {
+	nargs = 9;
+    }
+
+    nc = 0;
+    reset = TRUE_;
+    errmax = 0.f;
+
+    i__1 = *nidim;
+    for (in = 1; in <= i__1; ++in) {
+	n = idim[in];
+
+	if (banded) {
+	    nk = *nkb;
+	} else {
+	    nk = 1;
+	}
+	i__2 = nk;
+	for (ik = 1; ik <= i__2; ++ik) {
+	    if (banded) {
+		k = kb[ik];
+	    } else {
+		k = n - 1;
+	    }
+/*           Set LDA to 1 more than minimum value if room. */
+	    if (banded) {
+		lda = k + 1;
+	    } else {
+		lda = n;
+	    }
+	    if (lda < *nmax) {
+		++lda;
+	    }
+/*           Skip tests if not enough room. */
+	    if (lda > *nmax) {
+		goto L100;
+	    }
+	    if (packed) {
+		laa = n * (n + 1) / 2;
+	    } else {
+		laa = lda * n;
+	    }
+	    null = n <= 0;
+
+	    for (ic = 1; ic <= 2; ++ic) {
+		*(unsigned char *)uplo = *(unsigned char *)&ich[ic - 1];
+		if (*(unsigned char *)uplo == 'U') {
+		    s_copy(cuplo, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+		} else {
+		    s_copy(cuplo, "    CblasLower", (ftnlen)14, (ftnlen)14);
+		}
+
+/*              Generate the matrix A. */
+
+		transl = 0.f;
+		smake_(sname + 7, uplo, " ", &n, &n, &a[a_offset], nmax, &aa[
+			1], &lda, &k, &k, &reset, &transl, (ftnlen)2, (ftnlen)
+			1, (ftnlen)1);
+
+		i__3 = *ninc;
+		for (ix = 1; ix <= i__3; ++ix) {
+		    incx = inc[ix];
+		    lx = abs(incx) * n;
+
+/*                 Generate the vector X. */
+
+		    transl = .5f;
+		    i__4 = abs(incx);
+		    i__5 = n - 1;
+		    smake_("ge", " ", " ", &c__1, &n, &x[1], &c__1, &xx[1], &
+			    i__4, &c__0, &i__5, &reset, &transl, (ftnlen)2, (
+			    ftnlen)1, (ftnlen)1);
+		    if (n > 1) {
+			x[n / 2] = 0.f;
+			xx[abs(incx) * (n / 2 - 1) + 1] = 0.f;
+		    }
+
+		    i__4 = *ninc;
+		    for (iy = 1; iy <= i__4; ++iy) {
+			incy = inc[iy];
+			ly = abs(incy) * n;
+
+			i__5 = *nalf;
+			for (ia = 1; ia <= i__5; ++ia) {
+			    alpha = alf[ia];
+
+			    i__6 = *nbet;
+			    for (ib = 1; ib <= i__6; ++ib) {
+				beta = bet[ib];
+
+/*                          Generate the vector Y. */
+
+				transl = 0.f;
+				i__7 = abs(incy);
+				i__8 = n - 1;
+				smake_("ge", " ", " ", &c__1, &n, &y[1], &
+					c__1, &yy[1], &i__7, &c__0, &i__8, &
+					reset, &transl, (ftnlen)2, (ftnlen)1, 
+					(ftnlen)1);
+
+				++nc;
+
+/*                          Save every datum before calling the */
+/*                          subroutine. */
+
+				*(unsigned char *)uplos = *(unsigned char *)
+					uplo;
+				ns = n;
+				ks = k;
+				als = alpha;
+				i__7 = laa;
+				for (i__ = 1; i__ <= i__7; ++i__) {
+				    as[i__] = aa[i__];
+/* L10: */
+				}
+				ldas = lda;
+				i__7 = lx;
+				for (i__ = 1; i__ <= i__7; ++i__) {
+				    xs[i__] = xx[i__];
+/* L20: */
+				}
+				incxs = incx;
+				bls = beta;
+				i__7 = ly;
+				for (i__ = 1; i__ <= i__7; ++i__) {
+				    ys[i__] = yy[i__];
+/* L30: */
+				}
+				incys = incy;
+
+/*                          Call the subroutine. */
+
+				if (full) {
+				    if (*trace) {
+					io___197.ciunit = *ntra;
+					s_wsfe(&io___197);
+					do_fio(&c__1, (char *)&nc, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, sname, (ftnlen)12);
+					do_fio(&c__1, cuplo, (ftnlen)14);
+					do_fio(&c__1, (char *)&n, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&alpha, (ftnlen)
+						sizeof(real));
+					do_fio(&c__1, (char *)&lda, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&incx, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&beta, (ftnlen)
+						sizeof(real));
+					do_fio(&c__1, (char *)&incy, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+				    if (*rewi) {
+					al__1.aerr = 0;
+					al__1.aunit = *ntra;
+					f_rew(&al__1);
+				    }
+				    cssymv_(iorder, uplo, &n, &alpha, &aa[1], 
+					    &lda, &xx[1], &incx, &beta, &yy[1]
+					    , &incy);
+				} else if (banded) {
+				    if (*trace) {
+					io___198.ciunit = *ntra;
+					s_wsfe(&io___198);
+					do_fio(&c__1, (char *)&nc, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, sname, (ftnlen)12);
+					do_fio(&c__1, cuplo, (ftnlen)14);
+					do_fio(&c__1, (char *)&n, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&k, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&alpha, (ftnlen)
+						sizeof(real));
+					do_fio(&c__1, (char *)&lda, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&incx, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&beta, (ftnlen)
+						sizeof(real));
+					do_fio(&c__1, (char *)&incy, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+				    if (*rewi) {
+					al__1.aerr = 0;
+					al__1.aunit = *ntra;
+					f_rew(&al__1);
+				    }
+				    cssbmv_(iorder, uplo, &n, &k, &alpha, &aa[
+					    1], &lda, &xx[1], &incx, &beta, &
+					    yy[1], &incy);
+				} else if (packed) {
+				    if (*trace) {
+					io___199.ciunit = *ntra;
+					s_wsfe(&io___199);
+					do_fio(&c__1, (char *)&nc, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, sname, (ftnlen)12);
+					do_fio(&c__1, cuplo, (ftnlen)14);
+					do_fio(&c__1, (char *)&n, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&alpha, (ftnlen)
+						sizeof(real));
+					do_fio(&c__1, (char *)&incx, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&beta, (ftnlen)
+						sizeof(real));
+					do_fio(&c__1, (char *)&incy, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+				    if (*rewi) {
+					al__1.aerr = 0;
+					al__1.aunit = *ntra;
+					f_rew(&al__1);
+				    }
+				    csspmv_(iorder, uplo, &n, &alpha, &aa[1], 
+					    &xx[1], &incx, &beta, &yy[1], &incy);
+				}
+
+/*                          Check if error-exit was taken incorrectly. */
+
+				if (! infoc_1.ok) {
+				    io___200.ciunit = *nout;
+				    s_wsfe(&io___200);
+				    e_wsfe();
+				    *fatal = TRUE_;
+				    goto L120;
+				}
+
+/*                          See what data changed inside subroutines. */
+
+				isame[0] = *(unsigned char *)uplo == *(
+					unsigned char *)uplos;
+				isame[1] = ns == n;
+				if (full) {
+				    isame[2] = als == alpha;
+				    isame[3] = lse_(&as[1], &aa[1], &laa);
+				    isame[4] = ldas == lda;
+				    isame[5] = lse_(&xs[1], &xx[1], &lx);
+				    isame[6] = incxs == incx;
+				    isame[7] = bls == beta;
+				    if (null) {
+					isame[8] = lse_(&ys[1], &yy[1], &ly);
+				    } else {
+					i__7 = abs(incy);
+					isame[8] = lseres_("ge", " ", &c__1, &
+						n, &ys[1], &yy[1], &i__7, (
+						ftnlen)2, (ftnlen)1);
+				    }
+				    isame[9] = incys == incy;
+				} else if (banded) {
+				    isame[2] = ks == k;
+				    isame[3] = als == alpha;
+				    isame[4] = lse_(&as[1], &aa[1], &laa);
+				    isame[5] = ldas == lda;
+				    isame[6] = lse_(&xs[1], &xx[1], &lx);
+				    isame[7] = incxs == incx;
+				    isame[8] = bls == beta;
+				    if (null) {
+					isame[9] = lse_(&ys[1], &yy[1], &ly);
+				    } else {
+					i__7 = abs(incy);
+					isame[9] = lseres_("ge", " ", &c__1, &
+						n, &ys[1], &yy[1], &i__7, (
+						ftnlen)2, (ftnlen)1);
+				    }
+				    isame[10] = incys == incy;
+				} else if (packed) {
+				    isame[2] = als == alpha;
+				    isame[3] = lse_(&as[1], &aa[1], &laa);
+				    isame[4] = lse_(&xs[1], &xx[1], &lx);
+				    isame[5] = incxs == incx;
+				    isame[6] = bls == beta;
+				    if (null) {
+					isame[7] = lse_(&ys[1], &yy[1], &ly);
+				    } else {
+					i__7 = abs(incy);
+					isame[7] = lseres_("ge", " ", &c__1, &
+						n, &ys[1], &yy[1], &i__7, (
+						ftnlen)2, (ftnlen)1);
+				    }
+				    isame[8] = incys == incy;
+				}
+
+/*                          If data was incorrectly changed, report and */
+/*                          return. */
+
+				same = TRUE_;
+				i__7 = nargs;
+				for (i__ = 1; i__ <= i__7; ++i__) {
+				    same = same && isame[i__ - 1];
+				    if (! isame[i__ - 1]) {
+					io___203.ciunit = *nout;
+					s_wsfe(&io___203);
+					do_fio(&c__1, (char *)&i__, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+/* L40: */
+				}
+				if (! same) {
+				    *fatal = TRUE_;
+				    goto L120;
+				}
+
+				if (! null) {
+
+/*                             Check the result. */
+
+				    smvch_("N", &n, &n, &alpha, &a[a_offset], 
+					    nmax, &x[1], &incx, &beta, &y[1], 
+					    &incy, &yt[1], &g[1], &yy[1], eps,
+					     &err, fatal, nout, &c_true, (
+					    ftnlen)1);
+				    errmax = max(errmax,err);
+/*                             If got really bad answer, report and */
+/*                             return. */
+				    if (*fatal) {
+					goto L120;
+				    }
+				} else {
+/*                             Avoid repeating tests with N.le.0 */
+				    goto L110;
+				}
+
+/* L50: */
+			    }
+
+/* L60: */
+			}
+
+/* L70: */
+		    }
+
+/* L80: */
+		}
+
+/* L90: */
+	    }
+
+L100:
+	    ;
+	}
+
+L110:
+	;
+    }
+
+/*     Report result. */
+
+    if (errmax < *thresh) {
+	if (*iorder == 0) {
+	    io___205.ciunit = *nout;
+	    s_wsfe(&io___205);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___206.ciunit = *nout;
+	    s_wsfe(&io___206);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+    } else {
+	if (*iorder == 0) {
+	    io___207.ciunit = *nout;
+	    s_wsfe(&io___207);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___208.ciunit = *nout;
+	    s_wsfe(&io___208);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+	    e_wsfe();
+	}
+    }
+    goto L130;
+
+L120:
+    io___209.ciunit = *nout;
+    s_wsfe(&io___209);
+    do_fio(&c__1, sname, (ftnlen)12);
+    e_wsfe();
+    if (full) {
+	io___210.ciunit = *nout;
+	s_wsfe(&io___210);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&beta, (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+	e_wsfe();
+    } else if (banded) {
+	io___211.ciunit = *nout;
+	s_wsfe(&io___211);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&k, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&beta, (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+	e_wsfe();
+    } else if (packed) {
+	io___212.ciunit = *nout;
+	s_wsfe(&io___212);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&beta, (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+	e_wsfe();
+    }
+
+L130:
+    return 0;
+
+/* L9997: */
+
+/*     End of SCHK2. */
+
+} /* schk2_ */
+
+/* Subroutine */ int schk3_(char *sname, real *eps, real *thresh, integer *
+	nout, integer *ntra, logical *trace, logical *rewi, logical *fatal, 
+	integer *nidim, integer *idim, integer *nkb, integer *kb, integer *
+	ninc, integer *inc, integer *nmax, integer *incmax, real *a, real *aa,
+	 real *as, real *x, real *xx, real *xs, real *xt, real *g, real *z__, 
+	integer *iorder, ftnlen sname_len)
+{
+    /* Initialized data */
+
+    static char ichu[2] = "UL";
+    static char icht[3] = "NTC";
+    static char ichd[2] = "UN";
+
+    /* Format strings */
+    static char fmt_9993[] = "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+	    "\002),/10x,i3,\002, A,\002,i3,\002, X,\002,i2,\002) .\002)";
+    static char fmt_9994[] = "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+	    "\002),/10x,2(i3,\002,\002),\002 A,\002,i3,\002, X,\002,i2,\002) ."
+	    "\002)";
+    static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+	    "\002),/10x,i3,\002, AP, \002,\002X,\002,i2,\002) .\002)";
+    static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+	    "N VALID CALL *\002,\002******\002)";
+    static char fmt_9998[] = "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+	    " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+    static char fmt_10000[] = "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10001[] = "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10002[] = "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+	    "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_10003[] = "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+	    "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+	    "BER:\002)";
+
+    /* System generated locals */
+    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
+    alist al__1;
+
+    /* Builtin functions */
+    /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+    integer s_cmp(char *, char *, ftnlen, ftnlen), s_wsfe(cilist *), do_fio(
+	    integer *, char *, ftnlen), e_wsfe(void), f_rew(alist *);
+
+    /* Local variables */
+    integer i__, k, n, nc, ik, in, nk, ks, ix, ns, lx, laa, icd, lda, ict, 
+	    icu;
+    extern logical lse_(real *, real *, integer *);
+    real err;
+    char diag[1];
+    integer ldas;
+    logical same;
+    integer incx;
+    logical full, null;
+    char uplo[1], cdiag[14], diags[1];
+    logical isame[13];
+    extern /* Subroutine */ int smake_(char *, char *, char *, integer *, 
+	    integer *, real *, integer *, real *, integer *, integer *, 
+	    integer *, logical *, real *, ftnlen, ftnlen, ftnlen);
+    integer nargs;
+    extern /* Subroutine */ int smvch_(char *, integer *, integer *, real *, 
+	    real *, integer *, real *, integer *, real *, real *, integer *, 
+	    real *, real *, real *, real *, real *, logical *, integer *, 
+	    logical *, ftnlen);
+    logical reset;
+    char cuplo[14];
+    integer incxs;
+    char trans[1], uplos[1];
+    logical banded, packed;
+    char ctrans[14];
+    real errmax;
+    extern logical lseres_(char *, char *, integer *, integer *, real *, real 
+	    *, integer *, ftnlen, ftnlen);
+    extern /* Subroutine */ void cstbmv_(integer *, char *, char *, char *, 
+	    integer *, integer *, real *, integer *, real *, integer *);
+    real transl;
+    extern /* Subroutine */ void cstbsv_(integer *, char *, char *, char *, 
+	    integer *, integer *, real *, integer *, real *, integer *);
+    char transs[1];
+    extern /* Subroutine */ void cstpmv_(integer *, char *, char *, char *, 
+	    integer *, real *, real *, integer *), 
+	    cstrmv_(integer *, char *, char *, char *, integer *, real *, 
+	    integer *, real *, integer *), cstpsv_(
+	    integer *, char *, char *, char *, integer *, real *, real *, 
+	    integer *), cstrsv_(integer *, char *, 
+	    char *, char *, integer *, real *, integer *, real *, integer *);
+
+    /* Fortran I/O blocks */
+    static cilist io___252 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___253 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___254 = { 0, 0, 0, fmt_9995, 0 };
+    static cilist io___255 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___256 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___257 = { 0, 0, 0, fmt_9995, 0 };
+    static cilist io___258 = { 0, 0, 0, fmt_9992, 0 };
+    static cilist io___261 = { 0, 0, 0, fmt_9998, 0 };
+    static cilist io___263 = { 0, 0, 0, fmt_10000, 0 };
+    static cilist io___264 = { 0, 0, 0, fmt_10001, 0 };
+    static cilist io___265 = { 0, 0, 0, fmt_10002, 0 };
+    static cilist io___266 = { 0, 0, 0, fmt_10003, 0 };
+    static cilist io___267 = { 0, 0, 0, fmt_9996, 0 };
+    static cilist io___268 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___269 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___270 = { 0, 0, 0, fmt_9995, 0 };
+
+
+
+/*  Tests STRMV, STBMV, STPMV, STRSV, STBSV and STPSV. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Scalars in Common .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+    /* Parameter adjustments */
+    --idim;
+    --kb;
+    --inc;
+    --z__;
+    --g;
+    --xt;
+    --x;
+    --as;
+    --aa;
+    a_dim1 = *nmax;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --xs;
+    --xx;
+
+    /* Function Body */
+/*     .. Executable Statements .. */
+    full = *(unsigned char *)&sname[8] == 'r';
+    banded = *(unsigned char *)&sname[8] == 'b';
+    packed = *(unsigned char *)&sname[8] == 'p';
+/*     Define the number of arguments. */
+    if (full) {
+	nargs = 8;
+    } else if (banded) {
+	nargs = 9;
+    } else if (packed) {
+	nargs = 7;
+    }
+
+    nc = 0;
+    reset = TRUE_;
+    errmax = 0.f;
+/*     Set up zero vector for SMVCH. */
+    i__1 = *nmax;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	z__[i__] = 0.f;
+/* L10: */
+    }
+
+    i__1 = *nidim;
+    for (in = 1; in <= i__1; ++in) {
+	n = idim[in];
+
+	if (banded) {
+	    nk = *nkb;
+	} else {
+	    nk = 1;
+	}
+	i__2 = nk;
+	for (ik = 1; ik <= i__2; ++ik) {
+	    if (banded) {
+		k = kb[ik];
+	    } else {
+		k = n - 1;
+	    }
+/*           Set LDA to 1 more than minimum value if room. */
+	    if (banded) {
+		lda = k + 1;
+	    } else {
+		lda = n;
+	    }
+	    if (lda < *nmax) {
+		++lda;
+	    }
+/*           Skip tests if not enough room. */
+	    if (lda > *nmax) {
+		goto L100;
+	    }
+	    if (packed) {
+		laa = n * (n + 1) / 2;
+	    } else {
+		laa = lda * n;
+	    }
+	    null = n <= 0;
+
+	    for (icu = 1; icu <= 2; ++icu) {
+		*(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+		if (*(unsigned char *)uplo == 'U') {
+		    s_copy(cuplo, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+		} else {
+		    s_copy(cuplo, "    CblasLower", (ftnlen)14, (ftnlen)14);
+		}
+
+		for (ict = 1; ict <= 3; ++ict) {
+		    *(unsigned char *)trans = *(unsigned char *)&icht[ict - 1]
+			    ;
+		    if (*(unsigned char *)trans == 'N') {
+			s_copy(ctrans, "  CblasNoTrans", (ftnlen)14, (ftnlen)
+				14);
+		    } else if (*(unsigned char *)trans == 'T') {
+			s_copy(ctrans, "    CblasTrans", (ftnlen)14, (ftnlen)
+				14);
+		    } else {
+			s_copy(ctrans, "CblasConjTrans", (ftnlen)14, (ftnlen)
+				14);
+		    }
+
+		    for (icd = 1; icd <= 2; ++icd) {
+			*(unsigned char *)diag = *(unsigned char *)&ichd[icd 
+				- 1];
+			if (*(unsigned char *)diag == 'N') {
+			    s_copy(cdiag, "  CblasNonUnit", (ftnlen)14, (
+				    ftnlen)14);
+			} else {
+			    s_copy(cdiag, "     CblasUnit", (ftnlen)14, (
+				    ftnlen)14);
+			}
+
+/*                    Generate the matrix A. */
+
+			transl = 0.f;
+			smake_(sname + 7, uplo, diag, &n, &n, &a[a_offset], 
+				nmax, &aa[1], &lda, &k, &k, &reset, &transl, (
+				ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+			i__3 = *ninc;
+			for (ix = 1; ix <= i__3; ++ix) {
+			    incx = inc[ix];
+			    lx = abs(incx) * n;
+
+/*                       Generate the vector X. */
+
+			    transl = .5f;
+			    i__4 = abs(incx);
+			    i__5 = n - 1;
+			    smake_("ge", " ", " ", &c__1, &n, &x[1], &c__1, &
+				    xx[1], &i__4, &c__0, &i__5, &reset, &
+				    transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+			    if (n > 1) {
+				x[n / 2] = 0.f;
+				xx[abs(incx) * (n / 2 - 1) + 1] = 0.f;
+			    }
+
+			    ++nc;
+
+/*                       Save every datum before calling the subroutine. */
+
+			    *(unsigned char *)uplos = *(unsigned char *)uplo;
+			    *(unsigned char *)transs = *(unsigned char *)
+				    trans;
+			    *(unsigned char *)diags = *(unsigned char *)diag;
+			    ns = n;
+			    ks = k;
+			    i__4 = laa;
+			    for (i__ = 1; i__ <= i__4; ++i__) {
+				as[i__] = aa[i__];
+/* L20: */
+			    }
+			    ldas = lda;
+			    i__4 = lx;
+			    for (i__ = 1; i__ <= i__4; ++i__) {
+				xs[i__] = xx[i__];
+/* L30: */
+			    }
+			    incxs = incx;
+
+/*                       Call the subroutine. */
+
+			    if (s_cmp(sname + 9, "mv", (ftnlen)2, (ftnlen)2) 
+				    == 0) {
+				if (full) {
+				    if (*trace) {
+					io___252.ciunit = *ntra;
+					s_wsfe(&io___252);
+					do_fio(&c__1, (char *)&nc, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, sname, (ftnlen)12);
+					do_fio(&c__1, cuplo, (ftnlen)14);
+					do_fio(&c__1, ctrans, (ftnlen)14);
+					do_fio(&c__1, cdiag, (ftnlen)14);
+					do_fio(&c__1, (char *)&n, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&lda, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&incx, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+				    if (*rewi) {
+					al__1.aerr = 0;
+					al__1.aunit = *ntra;
+					f_rew(&al__1);
+				    }
+				    cstrmv_(iorder, uplo, trans, diag, &n, &
+					    aa[1], &lda, &xx[1], &incx);
+				} else if (banded) {
+				    if (*trace) {
+					io___253.ciunit = *ntra;
+					s_wsfe(&io___253);
+					do_fio(&c__1, (char *)&nc, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, sname, (ftnlen)12);
+					do_fio(&c__1, cuplo, (ftnlen)14);
+					do_fio(&c__1, ctrans, (ftnlen)14);
+					do_fio(&c__1, cdiag, (ftnlen)14);
+					do_fio(&c__1, (char *)&n, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&k, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&lda, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&incx, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+				    if (*rewi) {
+					al__1.aerr = 0;
+					al__1.aunit = *ntra;
+					f_rew(&al__1);
+				    }
+				    cstbmv_(iorder, uplo, trans, diag, &n, &k,
+					     &aa[1], &lda, &xx[1], &incx);
+				} else if (packed) {
+				    if (*trace) {
+					io___254.ciunit = *ntra;
+					s_wsfe(&io___254);
+					do_fio(&c__1, (char *)&nc, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, sname, (ftnlen)12);
+					do_fio(&c__1, cuplo, (ftnlen)14);
+					do_fio(&c__1, ctrans, (ftnlen)14);
+					do_fio(&c__1, cdiag, (ftnlen)14);
+					do_fio(&c__1, (char *)&n, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&incx, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+				    if (*rewi) {
+					al__1.aerr = 0;
+					al__1.aunit = *ntra;
+					f_rew(&al__1);
+				    }
+				    cstpmv_(iorder, uplo, trans, diag, &n, &
+					    aa[1], &xx[1], &incx);
+				}
+			    } else if (s_cmp(sname + 9, "sv", (ftnlen)2, (
+				    ftnlen)2) == 0) {
+				if (full) {
+				    if (*trace) {
+					io___255.ciunit = *ntra;
+					s_wsfe(&io___255);
+					do_fio(&c__1, (char *)&nc, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, sname, (ftnlen)12);
+					do_fio(&c__1, cuplo, (ftnlen)14);
+					do_fio(&c__1, ctrans, (ftnlen)14);
+					do_fio(&c__1, cdiag, (ftnlen)14);
+					do_fio(&c__1, (char *)&n, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&lda, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&incx, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+				    if (*rewi) {
+					al__1.aerr = 0;
+					al__1.aunit = *ntra;
+					f_rew(&al__1);
+				    }
+				    cstrsv_(iorder, uplo, trans, diag, &n, &
+					    aa[1], &lda, &xx[1], &incx);
+				} else if (banded) {
+				    if (*trace) {
+					io___256.ciunit = *ntra;
+					s_wsfe(&io___256);
+					do_fio(&c__1, (char *)&nc, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, sname, (ftnlen)12);
+					do_fio(&c__1, cuplo, (ftnlen)14);
+					do_fio(&c__1, ctrans, (ftnlen)14);
+					do_fio(&c__1, cdiag, (ftnlen)14);
+					do_fio(&c__1, (char *)&n, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&k, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&lda, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&incx, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+				    if (*rewi) {
+					al__1.aerr = 0;
+					al__1.aunit = *ntra;
+					f_rew(&al__1);
+				    }
+				    cstbsv_(iorder, uplo, trans, diag, &n, &k,
+					     &aa[1], &lda, &xx[1], &incx);
+				} else if (packed) {
+				    if (*trace) {
+					io___257.ciunit = *ntra;
+					s_wsfe(&io___257);
+					do_fio(&c__1, (char *)&nc, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, sname, (ftnlen)12);
+					do_fio(&c__1, cuplo, (ftnlen)14);
+					do_fio(&c__1, ctrans, (ftnlen)14);
+					do_fio(&c__1, cdiag, (ftnlen)14);
+					do_fio(&c__1, (char *)&n, (ftnlen)
+						sizeof(integer));
+					do_fio(&c__1, (char *)&incx, (ftnlen)
+						sizeof(integer));
+					e_wsfe();
+				    }
+				    if (*rewi) {
+					al__1.aerr = 0;
+					al__1.aunit = *ntra;
+					f_rew(&al__1);
+				    }
+				    cstpsv_(iorder, uplo, trans, diag, &n, &
+					    aa[1], &xx[1], &incx);
+				}
+			    }
+
+/*                       Check if error-exit was taken incorrectly. */
+
+			    if (! infoc_1.ok) {
+				io___258.ciunit = *nout;
+				s_wsfe(&io___258);
+				e_wsfe();
+				*fatal = TRUE_;
+				goto L120;
+			    }
+
+/*                       See what data changed inside subroutines. */
+
+			    isame[0] = *(unsigned char *)uplo == *(unsigned 
+				    char *)uplos;
+			    isame[1] = *(unsigned char *)trans == *(unsigned 
+				    char *)transs;
+			    isame[2] = *(unsigned char *)diag == *(unsigned 
+				    char *)diags;
+			    isame[3] = ns == n;
+			    if (full) {
+				isame[4] = lse_(&as[1], &aa[1], &laa);
+				isame[5] = ldas == lda;
+				if (null) {
+				    isame[6] = lse_(&xs[1], &xx[1], &lx);
+				} else {
+				    i__4 = abs(incx);
+				    isame[6] = lseres_("ge", " ", &c__1, &n, &
+					    xs[1], &xx[1], &i__4, (ftnlen)2, (
+					    ftnlen)1);
+				}
+				isame[7] = incxs == incx;
+			    } else if (banded) {
+				isame[4] = ks == k;
+				isame[5] = lse_(&as[1], &aa[1], &laa);
+				isame[6] = ldas == lda;
+				if (null) {
+				    isame[7] = lse_(&xs[1], &xx[1], &lx);
+				} else {
+				    i__4 = abs(incx);
+				    isame[7] = lseres_("ge", " ", &c__1, &n, &
+					    xs[1], &xx[1], &i__4, (ftnlen)2, (
+					    ftnlen)1);
+				}
+				isame[8] = incxs == incx;
+			    } else if (packed) {
+				isame[4] = lse_(&as[1], &aa[1], &laa);
+				if (null) {
+				    isame[5] = lse_(&xs[1], &xx[1], &lx);
+				} else {
+				    i__4 = abs(incx);
+				    isame[5] = lseres_("ge", " ", &c__1, &n, &
+					    xs[1], &xx[1], &i__4, (ftnlen)2, (
+					    ftnlen)1);
+				}
+				isame[6] = incxs == incx;
+			    }
+
+/*                       If data was incorrectly changed, report and */
+/*                       return. */
+
+			    same = TRUE_;
+			    i__4 = nargs;
+			    for (i__ = 1; i__ <= i__4; ++i__) {
+				same = same && isame[i__ - 1];
+				if (! isame[i__ - 1]) {
+				    io___261.ciunit = *nout;
+				    s_wsfe(&io___261);
+				    do_fio(&c__1, (char *)&i__, (ftnlen)
+					    sizeof(integer));
+				    e_wsfe();
+				}
+/* L40: */
+			    }
+			    if (! same) {
+				*fatal = TRUE_;
+				goto L120;
+			    }
+
+			    if (! null) {
+				if (s_cmp(sname + 9, "mv", (ftnlen)2, (ftnlen)
+					2) == 0) {
+
+/*                             Check the result. */
+
+				    smvch_(trans, &n, &n, &c_b123, &a[
+					    a_offset], nmax, &x[1], &incx, &
+					    c_b135, &z__[1], &incx, &xt[1], &
+					    g[1], &xx[1], eps, &err, fatal, 
+					    nout, &c_true, (ftnlen)1);
+				} else if (s_cmp(sname + 9, "sv", (ftnlen)2, (
+					ftnlen)2) == 0) {
+
+/*                             Compute approximation to original vector. */
+
+				    i__4 = n;
+				    for (i__ = 1; i__ <= i__4; ++i__) {
+					z__[i__] = xx[(i__ - 1) * abs(incx) + 
+						1];
+					xx[(i__ - 1) * abs(incx) + 1] = x[i__]
+						;
+/* L50: */
+				    }
+				    smvch_(trans, &n, &n, &c_b123, &a[
+					    a_offset], nmax, &z__[1], &incx, &
+					    c_b135, &x[1], &incx, &xt[1], &g[
+					    1], &xx[1], eps, &err, fatal, 
+					    nout, &c_false, (ftnlen)1);
+				}
+				errmax = max(errmax,err);
+/*                          If got really bad answer, report and return. */
+				if (*fatal) {
+				    goto L120;
+				}
+			    } else {
+/*                          Avoid repeating tests with N.le.0. */
+				goto L110;
+			    }
+
+/* L60: */
+			}
+
+/* L70: */
+		    }
+
+/* L80: */
+		}
+
+/* L90: */
+	    }
+
+L100:
+	    ;
+	}
+
+L110:
+	;
+    }
+
+/*     Report result. */
+
+    if (errmax < *thresh) {
+	if (*iorder == 0) {
+	    io___263.ciunit = *nout;
+	    s_wsfe(&io___263);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___264.ciunit = *nout;
+	    s_wsfe(&io___264);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+    } else {
+	if (*iorder == 0) {
+	    io___265.ciunit = *nout;
+	    s_wsfe(&io___265);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___266.ciunit = *nout;
+	    s_wsfe(&io___266);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+	    e_wsfe();
+	}
+    }
+    goto L130;
+
+L120:
+    io___267.ciunit = *nout;
+    s_wsfe(&io___267);
+    do_fio(&c__1, sname, (ftnlen)12);
+    e_wsfe();
+    if (full) {
+	io___268.ciunit = *nout;
+	s_wsfe(&io___268);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, ctrans, (ftnlen)14);
+	do_fio(&c__1, cdiag, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	e_wsfe();
+    } else if (banded) {
+	io___269.ciunit = *nout;
+	s_wsfe(&io___269);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, ctrans, (ftnlen)14);
+	do_fio(&c__1, cdiag, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&k, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	e_wsfe();
+    } else if (packed) {
+	io___270.ciunit = *nout;
+	s_wsfe(&io___270);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, ctrans, (ftnlen)14);
+	do_fio(&c__1, cdiag, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	e_wsfe();
+    }
+
+L130:
+    return 0;
+
+/* L9997: */
+
+/*     End of SCHK3. */
+
+} /* schk3_ */
+
+/* Subroutine */ int schk4_(char *sname, real *eps, real *thresh, integer *
+	nout, integer *ntra, logical *trace, logical *rewi, logical *fatal, 
+	integer *nidim, integer *idim, integer *nalf, real *alf, integer *
+	ninc, integer *inc, integer *nmax, integer *incmax, real *a, real *aa,
+	 real *as, real *x, real *xx, real *xs, real *y, real *yy, real *ys, 
+	real *yt, real *g, real *z__, integer *iorder, ftnlen sname_len)
+{
+    /* Format strings */
+    static char fmt_9994[] = "(1x,i6,\002: \002,a12,\002(\002,2(i3,\002,\002"
+	    "),f4.1,\002, X,\002,i2,\002, Y,\002,i2,\002, A,\002,i3,\002)    "
+	    "              .\002)";
+    static char fmt_9993[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+	    "N VALID CALL *\002,\002******\002)";
+    static char fmt_9998[] = "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+	    " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+    static char fmt_10000[] = "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10001[] = "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10002[] = "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+	    "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_10003[] = "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+	    "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+	    " \002,i3)";
+    static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+	    "BER:\002)";
+
+    /* System generated locals */
+    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;
+    alist al__1;
+
+    /* Builtin functions */
+    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+	     f_rew(alist *);
+
+    /* Local variables */
+    integer i__, j, m, n;
+    real w[1];
+    integer ia, nc, nd, im, in, ms, ix, iy, ns, lx, ly, laa, lda;
+    real als;
+    extern logical lse_(real *, real *, integer *);
+    real err;
+    integer ldas;
+    logical same;
+    integer incx, incy;
+    logical null;
+    real alpha;
+    logical isame[13];
+    extern /* Subroutine */ int smake_(char *, char *, char *, integer *, 
+	    integer *, real *, integer *, real *, integer *, integer *, 
+	    integer *, logical *, real *, ftnlen, ftnlen, ftnlen);
+    extern void csger_(
+	    integer *, integer *, integer *, real *, real *, integer *, real *
+	    , integer *, real *, integer *);
+    integer nargs;
+    extern /* Subroutine */ int smvch_(char *, integer *, integer *, real *, 
+	    real *, integer *, real *, integer *, real *, real *, integer *, 
+	    real *, real *, real *, real *, real *, logical *, integer *, 
+	    logical *, ftnlen);
+    logical reset;
+    integer incxs, incys;
+    real errmax;
+    extern logical lseres_(char *, char *, integer *, integer *, real *, real 
+	    *, integer *, ftnlen, ftnlen);
+    real transl;
+
+    /* Fortran I/O blocks */
+    static cilist io___299 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___300 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___303 = { 0, 0, 0, fmt_9998, 0 };
+    static cilist io___307 = { 0, 0, 0, fmt_10000, 0 };
+    static cilist io___308 = { 0, 0, 0, fmt_10001, 0 };
+    static cilist io___309 = { 0, 0, 0, fmt_10002, 0 };
+    static cilist io___310 = { 0, 0, 0, fmt_10003, 0 };
+    static cilist io___311 = { 0, 0, 0, fmt_9995, 0 };
+    static cilist io___312 = { 0, 0, 0, fmt_9996, 0 };
+    static cilist io___313 = { 0, 0, 0, fmt_9994, 0 };
+
+
+
+/*  Tests SGER. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Scalars in Common .. */
+/*     .. Common blocks .. */
+/*     .. Executable Statements .. */
+/*     Define the number of arguments. */
+    /* Parameter adjustments */
+    --idim;
+    --alf;
+    --inc;
+    --z__;
+    --g;
+    --yt;
+    --y;
+    --x;
+    --as;
+    --aa;
+    a_dim1 = *nmax;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --ys;
+    --yy;
+    --xs;
+    --xx;
+
+    /* Function Body */
+    nargs = 9;
+
+    nc = 0;
+    reset = TRUE_;
+    errmax = 0.f;
+
+    i__1 = *nidim;
+    for (in = 1; in <= i__1; ++in) {
+	n = idim[in];
+	nd = n / 2 + 1;
+
+	for (im = 1; im <= 2; ++im) {
+	    if (im == 1) {
+/* Computing MAX */
+		i__2 = n - nd;
+		m = max(i__2,0);
+	    }
+	    if (im == 2) {
+/* Computing MIN */
+		i__2 = n + nd;
+		m = min(i__2,*nmax);
+	    }
+
+/*           Set LDA to 1 more than minimum value if room. */
+	    lda = m;
+	    if (lda < *nmax) {
+		++lda;
+	    }
+/*           Skip tests if not enough room. */
+	    if (lda > *nmax) {
+		goto L110;
+	    }
+	    laa = lda * n;
+	    null = n <= 0 || m <= 0;
+
+	    i__2 = *ninc;
+	    for (ix = 1; ix <= i__2; ++ix) {
+		incx = inc[ix];
+		lx = abs(incx) * m;
+
+/*              Generate the vector X. */
+
+		transl = .5f;
+		i__3 = abs(incx);
+		i__4 = m - 1;
+		smake_("ge", " ", " ", &c__1, &m, &x[1], &c__1, &xx[1], &i__3,
+			 &c__0, &i__4, &reset, &transl, (ftnlen)2, (ftnlen)1, 
+			(ftnlen)1);
+		if (m > 1) {
+		    x[m / 2] = 0.f;
+		    xx[abs(incx) * (m / 2 - 1) + 1] = 0.f;
+		}
+
+		i__3 = *ninc;
+		for (iy = 1; iy <= i__3; ++iy) {
+		    incy = inc[iy];
+		    ly = abs(incy) * n;
+
+/*                 Generate the vector Y. */
+
+		    transl = 0.f;
+		    i__4 = abs(incy);
+		    i__5 = n - 1;
+		    smake_("ge", " ", " ", &c__1, &n, &y[1], &c__1, &yy[1], &
+			    i__4, &c__0, &i__5, &reset, &transl, (ftnlen)2, (
+			    ftnlen)1, (ftnlen)1);
+		    if (n > 1) {
+			y[n / 2] = 0.f;
+			yy[abs(incy) * (n / 2 - 1) + 1] = 0.f;
+		    }
+
+		    i__4 = *nalf;
+		    for (ia = 1; ia <= i__4; ++ia) {
+			alpha = alf[ia];
+
+/*                    Generate the matrix A. */
+
+			transl = 0.f;
+			i__5 = m - 1;
+			i__6 = n - 1;
+			smake_(sname + 7, " ", " ", &m, &n, &a[a_offset], 
+				nmax, &aa[1], &lda, &i__5, &i__6, &reset, &
+				transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+			++nc;
+
+/*                    Save every datum before calling the subroutine. */
+
+			ms = m;
+			ns = n;
+			als = alpha;
+			i__5 = laa;
+			for (i__ = 1; i__ <= i__5; ++i__) {
+			    as[i__] = aa[i__];
+/* L10: */
+			}
+			ldas = lda;
+			i__5 = lx;
+			for (i__ = 1; i__ <= i__5; ++i__) {
+			    xs[i__] = xx[i__];
+/* L20: */
+			}
+			incxs = incx;
+			i__5 = ly;
+			for (i__ = 1; i__ <= i__5; ++i__) {
+			    ys[i__] = yy[i__];
+/* L30: */
+			}
+			incys = incy;
+
+/*                    Call the subroutine. */
+
+			if (*trace) {
+			    io___299.ciunit = *ntra;
+			    s_wsfe(&io___299);
+			    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer)
+				    );
+			    do_fio(&c__1, sname, (ftnlen)12);
+			    do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer))
+				    ;
+			    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer))
+				    ;
+			    do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(real)
+				    );
+			    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(
+				    integer));
+			    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(
+				    integer));
+			    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(
+				    integer));
+			    e_wsfe();
+			}
+			if (*rewi) {
+			    al__1.aerr = 0;
+			    al__1.aunit = *ntra;
+			    f_rew(&al__1);
+			}
+			csger_(iorder, &m, &n, &alpha, &xx[1], &incx, &yy[1], 
+				&incy, &aa[1], &lda);
+
+/*                    Check if error-exit was taken incorrectly. */
+
+			if (! infoc_1.ok) {
+			    io___300.ciunit = *nout;
+			    s_wsfe(&io___300);
+			    e_wsfe();
+			    *fatal = TRUE_;
+			    goto L140;
+			}
+
+/*                    See what data changed inside subroutine. */
+
+			isame[0] = ms == m;
+			isame[1] = ns == n;
+			isame[2] = als == alpha;
+			isame[3] = lse_(&xs[1], &xx[1], &lx);
+			isame[4] = incxs == incx;
+			isame[5] = lse_(&ys[1], &yy[1], &ly);
+			isame[6] = incys == incy;
+			if (null) {
+			    isame[7] = lse_(&as[1], &aa[1], &laa);
+			} else {
+			    isame[7] = lseres_("ge", " ", &m, &n, &as[1], &aa[
+				    1], &lda, (ftnlen)2, (ftnlen)1);
+			}
+			isame[8] = ldas == lda;
+
+/*                    If data was incorrectly changed, report and return. */
+
+			same = TRUE_;
+			i__5 = nargs;
+			for (i__ = 1; i__ <= i__5; ++i__) {
+			    same = same && isame[i__ - 1];
+			    if (! isame[i__ - 1]) {
+				io___303.ciunit = *nout;
+				s_wsfe(&io___303);
+				do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(
+					integer));
+				e_wsfe();
+			    }
+/* L40: */
+			}
+			if (! same) {
+			    *fatal = TRUE_;
+			    goto L140;
+			}
+
+			if (! null) {
+
+/*                       Check the result column by column. */
+
+			    if (incx > 0) {
+				i__5 = m;
+				for (i__ = 1; i__ <= i__5; ++i__) {
+				    z__[i__] = x[i__];
+/* L50: */
+				}
+			    } else {
+				i__5 = m;
+				for (i__ = 1; i__ <= i__5; ++i__) {
+				    z__[i__] = x[m - i__ + 1];
+/* L60: */
+				}
+			    }
+			    i__5 = n;
+			    for (j = 1; j <= i__5; ++j) {
+				if (incy > 0) {
+				    w[0] = y[j];
+				} else {
+				    w[0] = y[n - j + 1];
+				}
+				smvch_("N", &m, &c__1, &alpha, &z__[1], nmax, 
+					w, &c__1, &c_b123, &a[j * a_dim1 + 1],
+					 &c__1, &yt[1], &g[1], &aa[(j - 1) * 
+					lda + 1], eps, &err, fatal, nout, &
+					c_true, (ftnlen)1);
+				errmax = max(errmax,err);
+/*                          If got really bad answer, report and return. */
+				if (*fatal) {
+				    goto L130;
+				}
+/* L70: */
+			    }
+			} else {
+/*                       Avoid repeating tests with M.le.0 or N.le.0. */
+			    goto L110;
+			}
+
+/* L80: */
+		    }
+
+/* L90: */
+		}
+
+/* L100: */
+	    }
+
+L110:
+	    ;
+	}
+
+/* L120: */
+    }
+
+/*     Report result. */
+
+    if (errmax < *thresh) {
+	if (*iorder == 0) {
+	    io___307.ciunit = *nout;
+	    s_wsfe(&io___307);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___308.ciunit = *nout;
+	    s_wsfe(&io___308);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+    } else {
+	if (*iorder == 0) {
+	    io___309.ciunit = *nout;
+	    s_wsfe(&io___309);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___310.ciunit = *nout;
+	    s_wsfe(&io___310);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+	    e_wsfe();
+	}
+    }
+    goto L150;
+
+L130:
+    io___311.ciunit = *nout;
+    s_wsfe(&io___311);
+    do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+    e_wsfe();
+
+L140:
+    io___312.ciunit = *nout;
+    s_wsfe(&io___312);
+    do_fio(&c__1, sname, (ftnlen)12);
+    e_wsfe();
+    io___313.ciunit = *nout;
+    s_wsfe(&io___313);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(real));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+    e_wsfe();
+
+L150:
+    return 0;
+
+/* L9997: */
+
+/*     End of SCHK4. */
+
+} /* schk4_ */
+
+/* Subroutine */ int schk5_(char *sname, real *eps, real *thresh, integer *
+	nout, integer *ntra, logical *trace, logical *rewi, logical *fatal, 
+	integer *nidim, integer *idim, integer *nalf, real *alf, integer *
+	ninc, integer *inc, integer *nmax, integer *incmax, real *a, real *aa,
+	 real *as, real *x, real *xx, real *xs, real *y, real *yy, real *ys, 
+	real *yt, real *g, real *z__, integer *iorder, ftnlen sname_len)
+{
+    /* Initialized data */
+
+    static char ich[2] = "UL";
+
+    /* Format strings */
+    static char fmt_9993[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+	    "i3,\002,\002,f4.1,\002, X,\002,i2,\002, A,\002,i3,\002) .\002)";
+    static char fmt_9994[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+	    "i3,\002,\002,f4.1,\002, X,\002,i2,\002, AP) .\002)";
+    static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+	    "N VALID CALL *\002,\002******\002)";
+    static char fmt_9998[] = "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+	    " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+    static char fmt_10000[] = "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10001[] = "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10002[] = "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+	    "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_10003[] = "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+	    "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+	    " \002,i3)";
+    static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+	    "BER:\002)";
+
+    /* System generated locals */
+    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
+    alist al__1;
+
+    /* Builtin functions */
+    /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+	     f_rew(alist *);
+
+    /* Local variables */
+    integer i__, j, n;
+    real w[1];
+    integer ia, ja, ic, nc, jj, lj, in, ix, ns, lx, laa, lda;
+    real als;
+    extern logical lse_(real *, real *, integer *);
+    real err;
+    integer ldas;
+    logical same;
+    integer incx;
+    logical full, null;
+    char uplo[1];
+    real alpha;
+    logical isame[13];
+    extern /* Subroutine */ int smake_(char *, char *, char *, integer *, 
+	    integer *, real *, integer *, real *, integer *, integer *, 
+	    integer *, logical *, real *, ftnlen, ftnlen, ftnlen);
+    integer nargs;
+    extern /* Subroutine */ int smvch_(char *, integer *, integer *, real *, 
+	    real *, integer *, real *, integer *, real *, real *, integer *, 
+	    real *, real *, real *, real *, real *, logical *, integer *, 
+	    logical *, ftnlen);
+    logical reset;
+    char cuplo[14];
+    integer incxs;
+    extern /* Subroutine */ void csspr_(integer *, char *, integer *, real *, 
+	    real *, integer *, real *);
+    logical upper;
+    char uplos[1];
+    extern /* Subroutine */ void cssyr_(integer *, char *, integer *, real *, 
+	    real *, integer *, real *, integer *);
+    logical packed;
+    real errmax;
+    extern logical lseres_(char *, char *, integer *, integer *, real *, real 
+	    *, integer *, ftnlen, ftnlen);
+    real transl;
+
+    /* Fortran I/O blocks */
+    static cilist io___342 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___343 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___344 = { 0, 0, 0, fmt_9992, 0 };
+    static cilist io___347 = { 0, 0, 0, fmt_9998, 0 };
+    static cilist io___354 = { 0, 0, 0, fmt_10000, 0 };
+    static cilist io___355 = { 0, 0, 0, fmt_10001, 0 };
+    static cilist io___356 = { 0, 0, 0, fmt_10002, 0 };
+    static cilist io___357 = { 0, 0, 0, fmt_10003, 0 };
+    static cilist io___358 = { 0, 0, 0, fmt_9995, 0 };
+    static cilist io___359 = { 0, 0, 0, fmt_9996, 0 };
+    static cilist io___360 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___361 = { 0, 0, 0, fmt_9994, 0 };
+
+
+
+/*  Tests SSYR and SSPR. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Scalars in Common .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+    /* Parameter adjustments */
+    --idim;
+    --alf;
+    --inc;
+    --z__;
+    --g;
+    --yt;
+    --y;
+    --x;
+    --as;
+    --aa;
+    a_dim1 = *nmax;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --ys;
+    --yy;
+    --xs;
+    --xx;
+
+    /* Function Body */
+/*     .. Executable Statements .. */
+    full = *(unsigned char *)&sname[8] == 'y';
+    packed = *(unsigned char *)&sname[8] == 'p';
+/*     Define the number of arguments. */
+    if (full) {
+	nargs = 7;
+    } else if (packed) {
+	nargs = 6;
+    }
+
+    nc = 0;
+    reset = TRUE_;
+    errmax = 0.f;
+
+    i__1 = *nidim;
+    for (in = 1; in <= i__1; ++in) {
+	n = idim[in];
+/*        Set LDA to 1 more than minimum value if room. */
+	lda = n;
+	if (lda < *nmax) {
+	    ++lda;
+	}
+/*        Skip tests if not enough room. */
+	if (lda > *nmax) {
+	    goto L100;
+	}
+	if (packed) {
+	    laa = n * (n + 1) / 2;
+	} else {
+	    laa = lda * n;
+	}
+
+	for (ic = 1; ic <= 2; ++ic) {
+	    *(unsigned char *)uplo = *(unsigned char *)&ich[ic - 1];
+	    if (*(unsigned char *)uplo == 'U') {
+		s_copy(cuplo, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+	    } else {
+		s_copy(cuplo, "    CblasLower", (ftnlen)14, (ftnlen)14);
+	    }
+	    upper = *(unsigned char *)uplo == 'U';
+
+	    i__2 = *ninc;
+	    for (ix = 1; ix <= i__2; ++ix) {
+		incx = inc[ix];
+		lx = abs(incx) * n;
+
+/*              Generate the vector X. */
+
+		transl = .5f;
+		i__3 = abs(incx);
+		i__4 = n - 1;
+		smake_("ge", " ", " ", &c__1, &n, &x[1], &c__1, &xx[1], &i__3,
+			 &c__0, &i__4, &reset, &transl, (ftnlen)2, (ftnlen)1, 
+			(ftnlen)1);
+		if (n > 1) {
+		    x[n / 2] = 0.f;
+		    xx[abs(incx) * (n / 2 - 1) + 1] = 0.f;
+		}
+
+		i__3 = *nalf;
+		for (ia = 1; ia <= i__3; ++ia) {
+		    alpha = alf[ia];
+		    null = n <= 0 || alpha == 0.f;
+
+/*                 Generate the matrix A. */
+
+		    transl = 0.f;
+		    i__4 = n - 1;
+		    i__5 = n - 1;
+		    smake_(sname + 7, uplo, " ", &n, &n, &a[a_offset], nmax, &
+			    aa[1], &lda, &i__4, &i__5, &reset, &transl, (
+			    ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+		    ++nc;
+
+/*                 Save every datum before calling the subroutine. */
+
+		    *(unsigned char *)uplos = *(unsigned char *)uplo;
+		    ns = n;
+		    als = alpha;
+		    i__4 = laa;
+		    for (i__ = 1; i__ <= i__4; ++i__) {
+			as[i__] = aa[i__];
+/* L10: */
+		    }
+		    ldas = lda;
+		    i__4 = lx;
+		    for (i__ = 1; i__ <= i__4; ++i__) {
+			xs[i__] = xx[i__];
+/* L20: */
+		    }
+		    incxs = incx;
+
+/*                 Call the subroutine. */
+
+		    if (full) {
+			if (*trace) {
+			    io___342.ciunit = *ntra;
+			    s_wsfe(&io___342);
+			    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer)
+				    );
+			    do_fio(&c__1, sname, (ftnlen)12);
+			    do_fio(&c__1, cuplo, (ftnlen)14);
+			    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer))
+				    ;
+			    do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(real)
+				    );
+			    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(
+				    integer));
+			    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(
+				    integer));
+			    e_wsfe();
+			}
+			if (*rewi) {
+			    al__1.aerr = 0;
+			    al__1.aunit = *ntra;
+			    f_rew(&al__1);
+			}
+			cssyr_(iorder, uplo, &n, &alpha, &xx[1], &incx, &aa[1]
+				, &lda);
+		    } else if (packed) {
+			if (*trace) {
+			    io___343.ciunit = *ntra;
+			    s_wsfe(&io___343);
+			    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer)
+				    );
+			    do_fio(&c__1, sname, (ftnlen)12);
+			    do_fio(&c__1, cuplo, (ftnlen)14);
+			    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer))
+				    ;
+			    do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(real)
+				    );
+			    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(
+				    integer));
+			    e_wsfe();
+			}
+			if (*rewi) {
+			    al__1.aerr = 0;
+			    al__1.aunit = *ntra;
+			    f_rew(&al__1);
+			}
+			csspr_(iorder, uplo, &n, &alpha, &xx[1], &incx, &aa[1]);
+		    }
+
+/*                 Check if error-exit was taken incorrectly. */
+
+		    if (! infoc_1.ok) {
+			io___344.ciunit = *nout;
+			s_wsfe(&io___344);
+			e_wsfe();
+			*fatal = TRUE_;
+			goto L120;
+		    }
+
+/*                 See what data changed inside subroutines. */
+
+		    isame[0] = *(unsigned char *)uplo == *(unsigned char *)
+			    uplos;
+		    isame[1] = ns == n;
+		    isame[2] = als == alpha;
+		    isame[3] = lse_(&xs[1], &xx[1], &lx);
+		    isame[4] = incxs == incx;
+		    if (null) {
+			isame[5] = lse_(&as[1], &aa[1], &laa);
+		    } else {
+			isame[5] = lseres_(sname + 7, uplo, &n, &n, &as[1], &
+				aa[1], &lda, (ftnlen)2, (ftnlen)1);
+		    }
+		    if (! packed) {
+			isame[6] = ldas == lda;
+		    }
+
+/*                 If data was incorrectly changed, report and return. */
+
+		    same = TRUE_;
+		    i__4 = nargs;
+		    for (i__ = 1; i__ <= i__4; ++i__) {
+			same = same && isame[i__ - 1];
+			if (! isame[i__ - 1]) {
+			    io___347.ciunit = *nout;
+			    s_wsfe(&io___347);
+			    do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(
+				    integer));
+			    e_wsfe();
+			}
+/* L30: */
+		    }
+		    if (! same) {
+			*fatal = TRUE_;
+			goto L120;
+		    }
+
+		    if (! null) {
+
+/*                    Check the result column by column. */
+
+			if (incx > 0) {
+			    i__4 = n;
+			    for (i__ = 1; i__ <= i__4; ++i__) {
+				z__[i__] = x[i__];
+/* L40: */
+			    }
+			} else {
+			    i__4 = n;
+			    for (i__ = 1; i__ <= i__4; ++i__) {
+				z__[i__] = x[n - i__ + 1];
+/* L50: */
+			    }
+			}
+			ja = 1;
+			i__4 = n;
+			for (j = 1; j <= i__4; ++j) {
+			    w[0] = z__[j];
+			    if (upper) {
+				jj = 1;
+				lj = j;
+			    } else {
+				jj = j;
+				lj = n - j + 1;
+			    }
+			    smvch_("N", &lj, &c__1, &alpha, &z__[jj], &lj, w, 
+				    &c__1, &c_b123, &a[jj + j * a_dim1], &
+				    c__1, &yt[1], &g[1], &aa[ja], eps, &err, 
+				    fatal, nout, &c_true, (ftnlen)1);
+			    if (full) {
+				if (upper) {
+				    ja += lda;
+				} else {
+				    ja = ja + lda + 1;
+				}
+			    } else {
+				ja += lj;
+			    }
+			    errmax = max(errmax,err);
+/*                       If got really bad answer, report and return. */
+			    if (*fatal) {
+				goto L110;
+			    }
+/* L60: */
+			}
+		    } else {
+/*                    Avoid repeating tests if N.le.0. */
+			if (n <= 0) {
+			    goto L100;
+			}
+		    }
+
+/* L70: */
+		}
+
+/* L80: */
+	    }
+
+/* L90: */
+	}
+
+L100:
+	;
+    }
+
+/*     Report result. */
+
+    if (errmax < *thresh) {
+	if (*iorder == 0) {
+	    io___354.ciunit = *nout;
+	    s_wsfe(&io___354);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___355.ciunit = *nout;
+	    s_wsfe(&io___355);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+    } else {
+	if (*iorder == 0) {
+	    io___356.ciunit = *nout;
+	    s_wsfe(&io___356);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___357.ciunit = *nout;
+	    s_wsfe(&io___357);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+	    e_wsfe();
+	}
+    }
+    goto L130;
+
+L110:
+    io___358.ciunit = *nout;
+    s_wsfe(&io___358);
+    do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+    e_wsfe();
+
+L120:
+    io___359.ciunit = *nout;
+    s_wsfe(&io___359);
+    do_fio(&c__1, sname, (ftnlen)12);
+    e_wsfe();
+    if (full) {
+	io___360.ciunit = *nout;
+	s_wsfe(&io___360);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+	e_wsfe();
+    } else if (packed) {
+	io___361.ciunit = *nout;
+	s_wsfe(&io___361);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	e_wsfe();
+    }
+
+L130:
+    return 0;
+
+/* L9997: */
+
+/*     End of SCHK5. */
+
+} /* schk5_ */
+
+/* Subroutine */ int schk6_(char *sname, real *eps, real *thresh, integer *
+	nout, integer *ntra, logical *trace, logical *rewi, logical *fatal, 
+	integer *nidim, integer *idim, integer *nalf, real *alf, integer *
+	ninc, integer *inc, integer *nmax, integer *incmax, real *a, real *aa,
+	 real *as, real *x, real *xx, real *xs, real *y, real *yy, real *ys, 
+	real *yt, real *g, real *z__, integer *iorder, ftnlen sname_len)
+{
+    /* Initialized data */
+
+    static char ich[2] = "UL";
+
+    /* Format strings */
+    static char fmt_9993[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+	    "i3,\002,\002,f4.1,\002, X,\002,i2,\002, Y,\002,i2,\002, A,\002,i"
+	    "3,\002) .\002)";
+    static char fmt_9994[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+	    "i3,\002,\002,f4.1,\002, X,\002,i2,\002, Y,\002,i2,\002, AP) ."
+	    "\002)";
+    static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+	    "N VALID CALL *\002,\002******\002)";
+    static char fmt_9998[] = "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+	    " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+    static char fmt_10000[] = "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10001[] = "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+	    "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+    static char fmt_10002[] = "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+	    "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_10003[] = "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+	    "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+	    "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+	    "ECT *******\002)";
+    static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+	    " \002,i3)";
+    static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+	    "BER:\002)";
+
+    /* System generated locals */
+    integer a_dim1, a_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4, i__5, 
+	    i__6;
+    alist al__1;
+
+    /* Builtin functions */
+    /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+	     f_rew(alist *);
+
+    /* Local variables */
+    integer i__, j, n;
+    real w[2];
+    integer ia, ja, ic, nc, jj, lj, in, ix, iy, ns, lx, ly, laa, lda;
+    real als;
+    extern logical lse_(real *, real *, integer *);
+    real err;
+    integer ldas;
+    logical same;
+    integer incx, incy;
+    logical full, null;
+    char uplo[1];
+    real alpha;
+    logical isame[13];
+    extern /* Subroutine */ int smake_(char *, char *, char *, integer *, 
+	    integer *, real *, integer *, real *, integer *, integer *, 
+	    integer *, logical *, real *, ftnlen, ftnlen, ftnlen);
+    integer nargs;
+    extern /* Subroutine */ int smvch_(char *, integer *, integer *, real *, 
+	    real *, integer *, real *, integer *, real *, real *, integer *, 
+	    real *, real *, real *, real *, real *, logical *, integer *, 
+	    logical *, ftnlen);
+    logical reset;
+    char cuplo[14];
+    integer incxs, incys;
+    logical upper;
+    char uplos[1];
+    extern /* Subroutine */ void csspr2_(integer *, char *, integer *, real *, 
+	    real *, integer *, real *, integer *, real *), cssyr2_(
+	    integer *, char *, integer *, real *, real *, integer *, real *, 
+	    integer *, real *, integer *);
+    logical packed;
+    real errmax;
+    extern logical lseres_(char *, char *, integer *, integer *, real *, real 
+	    *, integer *, ftnlen, ftnlen);
+    real transl;
+
+    /* Fortran I/O blocks */
+    static cilist io___394 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___395 = { 0, 0, 0, fmt_9994, 0 };
+    static cilist io___396 = { 0, 0, 0, fmt_9992, 0 };
+    static cilist io___399 = { 0, 0, 0, fmt_9998, 0 };
+    static cilist io___406 = { 0, 0, 0, fmt_10000, 0 };
+    static cilist io___407 = { 0, 0, 0, fmt_10001, 0 };
+    static cilist io___408 = { 0, 0, 0, fmt_10002, 0 };
+    static cilist io___409 = { 0, 0, 0, fmt_10003, 0 };
+    static cilist io___410 = { 0, 0, 0, fmt_9995, 0 };
+    static cilist io___411 = { 0, 0, 0, fmt_9996, 0 };
+    static cilist io___412 = { 0, 0, 0, fmt_9993, 0 };
+    static cilist io___413 = { 0, 0, 0, fmt_9994, 0 };
+
+
+
+/*  Tests SSYR2 and SSPR2. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Scalars in Common .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+    /* Parameter adjustments */
+    --idim;
+    --alf;
+    --inc;
+    z_dim1 = *nmax;
+    z_offset = 1 + z_dim1;
+    z__ -= z_offset;
+    --g;
+    --yt;
+    --y;
+    --x;
+    --as;
+    --aa;
+    a_dim1 = *nmax;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --ys;
+    --yy;
+    --xs;
+    --xx;
+
+    /* Function Body */
+/*     .. Executable Statements .. */
+    full = *(unsigned char *)&sname[8] == 'y';
+    packed = *(unsigned char *)&sname[8] == 'p';
+/*     Define the number of arguments. */
+    if (full) {
+	nargs = 9;
+    } else if (packed) {
+	nargs = 8;
+    }
+
+    nc = 0;
+    reset = TRUE_;
+    errmax = 0.f;
+
+    i__1 = *nidim;
+    for (in = 1; in <= i__1; ++in) {
+	n = idim[in];
+/*        Set LDA to 1 more than minimum value if room. */
+	lda = n;
+	if (lda < *nmax) {
+	    ++lda;
+	}
+/*        Skip tests if not enough room. */
+	if (lda > *nmax) {
+	    goto L140;
+	}
+	if (packed) {
+	    laa = n * (n + 1) / 2;
+	} else {
+	    laa = lda * n;
+	}
+
+	for (ic = 1; ic <= 2; ++ic) {
+	    *(unsigned char *)uplo = *(unsigned char *)&ich[ic - 1];
+	    if (*(unsigned char *)uplo == 'U') {
+		s_copy(cuplo, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+	    } else {
+		s_copy(cuplo, "    CblasLower", (ftnlen)14, (ftnlen)14);
+	    }
+	    upper = *(unsigned char *)uplo == 'U';
+
+	    i__2 = *ninc;
+	    for (ix = 1; ix <= i__2; ++ix) {
+		incx = inc[ix];
+		lx = abs(incx) * n;
+
+/*              Generate the vector X. */
+
+		transl = .5f;
+		i__3 = abs(incx);
+		i__4 = n - 1;
+		smake_("ge", " ", " ", &c__1, &n, &x[1], &c__1, &xx[1], &i__3,
+			 &c__0, &i__4, &reset, &transl, (ftnlen)2, (ftnlen)1, 
+			(ftnlen)1);
+		if (n > 1) {
+		    x[n / 2] = 0.f;
+		    xx[abs(incx) * (n / 2 - 1) + 1] = 0.f;
+		}
+
+		i__3 = *ninc;
+		for (iy = 1; iy <= i__3; ++iy) {
+		    incy = inc[iy];
+		    ly = abs(incy) * n;
+
+/*                 Generate the vector Y. */
+
+		    transl = 0.f;
+		    i__4 = abs(incy);
+		    i__5 = n - 1;
+		    smake_("ge", " ", " ", &c__1, &n, &y[1], &c__1, &yy[1], &
+			    i__4, &c__0, &i__5, &reset, &transl, (ftnlen)2, (
+			    ftnlen)1, (ftnlen)1);
+		    if (n > 1) {
+			y[n / 2] = 0.f;
+			yy[abs(incy) * (n / 2 - 1) + 1] = 0.f;
+		    }
+
+		    i__4 = *nalf;
+		    for (ia = 1; ia <= i__4; ++ia) {
+			alpha = alf[ia];
+			null = n <= 0 || alpha == 0.f;
+
+/*                    Generate the matrix A. */
+
+			transl = 0.f;
+			i__5 = n - 1;
+			i__6 = n - 1;
+			smake_(sname + 7, uplo, " ", &n, &n, &a[a_offset], 
+				nmax, &aa[1], &lda, &i__5, &i__6, &reset, &
+				transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+			++nc;
+
+/*                    Save every datum before calling the subroutine. */
+
+			*(unsigned char *)uplos = *(unsigned char *)uplo;
+			ns = n;
+			als = alpha;
+			i__5 = laa;
+			for (i__ = 1; i__ <= i__5; ++i__) {
+			    as[i__] = aa[i__];
+/* L10: */
+			}
+			ldas = lda;
+			i__5 = lx;
+			for (i__ = 1; i__ <= i__5; ++i__) {
+			    xs[i__] = xx[i__];
+/* L20: */
+			}
+			incxs = incx;
+			i__5 = ly;
+			for (i__ = 1; i__ <= i__5; ++i__) {
+			    ys[i__] = yy[i__];
+/* L30: */
+			}
+			incys = incy;
+
+/*                    Call the subroutine. */
+
+			if (full) {
+			    if (*trace) {
+				io___394.ciunit = *ntra;
+				s_wsfe(&io___394);
+				do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(
+					integer));
+				do_fio(&c__1, sname, (ftnlen)12);
+				do_fio(&c__1, cuplo, (ftnlen)14);
+				do_fio(&c__1, (char *)&n, (ftnlen)sizeof(
+					integer));
+				do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(
+					real));
+				do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(
+					integer));
+				do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(
+					integer));
+				do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(
+					integer));
+				e_wsfe();
+			    }
+			    if (*rewi) {
+				al__1.aerr = 0;
+				al__1.aunit = *ntra;
+				f_rew(&al__1);
+			    }
+			    cssyr2_(iorder, uplo, &n, &alpha, &xx[1], &incx, &
+				    yy[1], &incy, &aa[1], &lda);
+			} else if (packed) {
+			    if (*trace) {
+				io___395.ciunit = *ntra;
+				s_wsfe(&io___395);
+				do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(
+					integer));
+				do_fio(&c__1, sname, (ftnlen)12);
+				do_fio(&c__1, cuplo, (ftnlen)14);
+				do_fio(&c__1, (char *)&n, (ftnlen)sizeof(
+					integer));
+				do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(
+					real));
+				do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(
+					integer));
+				do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(
+					integer));
+				e_wsfe();
+			    }
+			    if (*rewi) {
+				al__1.aerr = 0;
+				al__1.aunit = *ntra;
+				f_rew(&al__1);
+			    }
+			    csspr2_(iorder, uplo, &n, &alpha, &xx[1], &incx, &
+				    yy[1], &incy, &aa[1]);
+			}
+
+/*                    Check if error-exit was taken incorrectly. */
+
+			if (! infoc_1.ok) {
+			    io___396.ciunit = *nout;
+			    s_wsfe(&io___396);
+			    e_wsfe();
+			    *fatal = TRUE_;
+			    goto L160;
+			}
+
+/*                    See what data changed inside subroutines. */
+
+			isame[0] = *(unsigned char *)uplo == *(unsigned char *
+				)uplos;
+			isame[1] = ns == n;
+			isame[2] = als == alpha;
+			isame[3] = lse_(&xs[1], &xx[1], &lx);
+			isame[4] = incxs == incx;
+			isame[5] = lse_(&ys[1], &yy[1], &ly);
+			isame[6] = incys == incy;
+			if (null) {
+			    isame[7] = lse_(&as[1], &aa[1], &laa);
+			} else {
+			    isame[7] = lseres_(sname + 7, uplo, &n, &n, &as[1]
+				    , &aa[1], &lda, (ftnlen)2, (ftnlen)1);
+			}
+			if (! packed) {
+			    isame[8] = ldas == lda;
+			}
+
+/*                    If data was incorrectly changed, report and return. */
+
+			same = TRUE_;
+			i__5 = nargs;
+			for (i__ = 1; i__ <= i__5; ++i__) {
+			    same = same && isame[i__ - 1];
+			    if (! isame[i__ - 1]) {
+				io___399.ciunit = *nout;
+				s_wsfe(&io___399);
+				do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(
+					integer));
+				e_wsfe();
+			    }
+/* L40: */
+			}
+			if (! same) {
+			    *fatal = TRUE_;
+			    goto L160;
+			}
+
+			if (! null) {
+
+/*                       Check the result column by column. */
+
+			    if (incx > 0) {
+				i__5 = n;
+				for (i__ = 1; i__ <= i__5; ++i__) {
+				    z__[i__ + z_dim1] = x[i__];
+/* L50: */
+				}
+			    } else {
+				i__5 = n;
+				for (i__ = 1; i__ <= i__5; ++i__) {
+				    z__[i__ + z_dim1] = x[n - i__ + 1];
+/* L60: */
+				}
+			    }
+			    if (incy > 0) {
+				i__5 = n;
+				for (i__ = 1; i__ <= i__5; ++i__) {
+				    z__[i__ + (z_dim1 << 1)] = y[i__];
+/* L70: */
+				}
+			    } else {
+				i__5 = n;
+				for (i__ = 1; i__ <= i__5; ++i__) {
+				    z__[i__ + (z_dim1 << 1)] = y[n - i__ + 1];
+/* L80: */
+				}
+			    }
+			    ja = 1;
+			    i__5 = n;
+			    for (j = 1; j <= i__5; ++j) {
+				w[0] = z__[j + (z_dim1 << 1)];
+				w[1] = z__[j + z_dim1];
+				if (upper) {
+				    jj = 1;
+				    lj = j;
+				} else {
+				    jj = j;
+				    lj = n - j + 1;
+				}
+				smvch_("N", &lj, &c__2, &alpha, &z__[jj + 
+					z_dim1], nmax, w, &c__1, &c_b123, &a[
+					jj + j * a_dim1], &c__1, &yt[1], &g[1]
+					, &aa[ja], eps, &err, fatal, nout, &
+					c_true, (ftnlen)1);
+				if (full) {
+				    if (upper) {
+					ja += lda;
+				    } else {
+					ja = ja + lda + 1;
+				    }
+				} else {
+				    ja += lj;
+				}
+				errmax = max(errmax,err);
+/*                          If got really bad answer, report and return. */
+				if (*fatal) {
+				    goto L150;
+				}
+/* L90: */
+			    }
+			} else {
+/*                       Avoid repeating tests with N.le.0. */
+			    if (n <= 0) {
+				goto L140;
+			    }
+			}
+
+/* L100: */
+		    }
+
+/* L110: */
+		}
+
+/* L120: */
+	    }
+
+/* L130: */
+	}
+
+L140:
+	;
+    }
+
+/*     Report result. */
+
+    if (errmax < *thresh) {
+	if (*iorder == 0) {
+	    io___406.ciunit = *nout;
+	    s_wsfe(&io___406);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___407.ciunit = *nout;
+	    s_wsfe(&io___407);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    e_wsfe();
+	}
+    } else {
+	if (*iorder == 0) {
+	    io___408.ciunit = *nout;
+	    s_wsfe(&io___408);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+	    e_wsfe();
+	}
+	if (*iorder == 1) {
+	    io___409.ciunit = *nout;
+	    s_wsfe(&io___409);
+	    do_fio(&c__1, sname, (ftnlen)12);
+	    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+	    e_wsfe();
+	}
+    }
+    goto L170;
+
+L150:
+    io___410.ciunit = *nout;
+    s_wsfe(&io___410);
+    do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+    e_wsfe();
+
+L160:
+    io___411.ciunit = *nout;
+    s_wsfe(&io___411);
+    do_fio(&c__1, sname, (ftnlen)12);
+    e_wsfe();
+    if (full) {
+	io___412.ciunit = *nout;
+	s_wsfe(&io___412);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+	e_wsfe();
+    } else if (packed) {
+	io___413.ciunit = *nout;
+	s_wsfe(&io___413);
+	do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+	do_fio(&c__1, sname, (ftnlen)12);
+	do_fio(&c__1, cuplo, (ftnlen)14);
+	do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&alpha, (ftnlen)sizeof(real));
+	do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+	e_wsfe();
+    }
+
+L170:
+    return 0;
+
+/* L9997: */
+
+/*     End of SCHK6. */
+
+} /* schk6_ */
+
+/* Subroutine */ int smake_(char *type__, char *uplo, char *diag, integer *m, 
+	integer *n, real *a, integer *nmax, real *aa, integer *lda, integer *
+	kl, integer *ku, logical *reset, real *transl, ftnlen type_len, 
+	ftnlen uplo_len, ftnlen diag_len)
+{
+    /* System generated locals */
+    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
+
+    /* Builtin functions */
+    integer s_cmp(char *, char *, ftnlen, ftnlen);
+
+    /* Local variables */
+    integer i__, j, i1, i2, i3, kk;
+    logical gen, tri, sym;
+    integer ibeg, iend;
+    extern real sbeg_(logical *);
+    integer ioff;
+    logical unit, lower, upper;
+
+
+/*  Generates values for an M by N matrix A within the bandwidth */
+/*  defined by KL and KU. */
+/*  Stores the values in the array AA in the data structure required */
+/*  by the routine, with unwanted elements set to rogue value. */
+
+/*  TYPE is 'ge', 'gb', 'sy', 'sb', 'sp', 'tr', 'tb' OR 'tp'. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. External Functions .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Executable Statements .. */
+    /* Parameter adjustments */
+    a_dim1 = *nmax;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --aa;
+
+    /* Function Body */
+    gen = *(unsigned char *)type__ == 'g';
+    sym = *(unsigned char *)type__ == 's';
+    tri = *(unsigned char *)type__ == 't';
+    upper = (sym || tri) && *(unsigned char *)uplo == 'U';
+    lower = (sym || tri) && *(unsigned char *)uplo == 'L';
+    unit = tri && *(unsigned char *)diag == 'U';
+
+/*     Generate data in array A. */
+
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+	i__2 = *m;
+	for (i__ = 1; i__ <= i__2; ++i__) {
+	    if (gen || upper && i__ <= j || lower && i__ >= j) {
+		if (i__ <= j && j - i__ <= *ku || i__ >= j && i__ - j <= *kl) 
+			{
+		    a[i__ + j * a_dim1] = sbeg_(reset) + *transl;
+		} else {
+		    a[i__ + j * a_dim1] = 0.f;
+		}
+		if (i__ != j) {
+		    if (sym) {
+			a[j + i__ * a_dim1] = a[i__ + j * a_dim1];
+		    } else if (tri) {
+			a[j + i__ * a_dim1] = 0.f;
+		    }
+		}
+	    }
+/* L10: */
+	}
+	if (tri) {
+	    a[j + j * a_dim1] += 1.f;
+	}
+	if (unit) {
+	    a[j + j * a_dim1] = 1.f;
+	}
+/* L20: */
+    }
+
+/*     Store elements in array AS in data structure required by routine. */
+
+    if (s_cmp(type__, "ge", (ftnlen)2, (ftnlen)2) == 0) {
+	i__1 = *n;
+	for (j = 1; j <= i__1; ++j) {
+	    i__2 = *m;
+	    for (i__ = 1; i__ <= i__2; ++i__) {
+		aa[i__ + (j - 1) * *lda] = a[i__ + j * a_dim1];
+/* L30: */
+	    }
+	    i__2 = *lda;
+	    for (i__ = *m + 1; i__ <= i__2; ++i__) {
+		aa[i__ + (j - 1) * *lda] = -1e10f;
+/* L40: */
+	    }
+/* L50: */
+	}
+    } else if (s_cmp(type__, "gb", (ftnlen)2, (ftnlen)2) == 0) {
+	i__1 = *n;
+	for (j = 1; j <= i__1; ++j) {
+	    i__2 = *ku + 1 - j;
+	    for (i1 = 1; i1 <= i__2; ++i1) {
+		aa[i1 + (j - 1) * *lda] = -1e10f;
+/* L60: */
+	    }
+/* Computing MIN */
+	    i__3 = *kl + *ku + 1, i__4 = *ku + 1 + *m - j;
+	    i__2 = min(i__3,i__4);
+	    for (i2 = i1; i2 <= i__2; ++i2) {
+		aa[i2 + (j - 1) * *lda] = a[i2 + j - *ku - 1 + j * a_dim1];
+/* L70: */
+	    }
+	    i__2 = *lda;
+	    for (i3 = i2; i3 <= i__2; ++i3) {
+		aa[i3 + (j - 1) * *lda] = -1e10f;
+/* L80: */
+	    }
+/* L90: */
+	}
+    } else if (s_cmp(type__, "sy", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(type__,
+	     "tr", (ftnlen)2, (ftnlen)2) == 0) {
+	i__1 = *n;
+	for (j = 1; j <= i__1; ++j) {
+	    if (upper) {
+		ibeg = 1;
+		if (unit) {
+		    iend = j - 1;
+		} else {
+		    iend = j;
+		}
+	    } else {
+		if (unit) {
+		    ibeg = j + 1;
+		} else {
+		    ibeg = j;
+		}
+		iend = *n;
+	    }
+	    i__2 = ibeg - 1;
+	    for (i__ = 1; i__ <= i__2; ++i__) {
+		aa[i__ + (j - 1) * *lda] = -1e10f;
+/* L100: */
+	    }
+	    i__2 = iend;
+	    for (i__ = ibeg; i__ <= i__2; ++i__) {
+		aa[i__ + (j - 1) * *lda] = a[i__ + j * a_dim1];
+/* L110: */
+	    }
+	    i__2 = *lda;
+	    for (i__ = iend + 1; i__ <= i__2; ++i__) {
+		aa[i__ + (j - 1) * *lda] = -1e10f;
+/* L120: */
+	    }
+/* L130: */
+	}
+    } else if (s_cmp(type__, "sb", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(type__,
+	     "tb", (ftnlen)2, (ftnlen)2) == 0) {
+	i__1 = *n;
+	for (j = 1; j <= i__1; ++j) {
+	    if (upper) {
+		kk = *kl + 1;
+/* Computing MAX */
+		i__2 = 1, i__3 = *kl + 2 - j;
+		ibeg = max(i__2,i__3);
+		if (unit) {
+		    iend = *kl;
+		} else {
+		    iend = *kl + 1;
+		}
+	    } else {
+		kk = 1;
+		if (unit) {
+		    ibeg = 2;
+		} else {
+		    ibeg = 1;
+		}
+/* Computing MIN */
+		i__2 = *kl + 1, i__3 = *m + 1 - j;
+		iend = min(i__2,i__3);
+	    }
+	    i__2 = ibeg - 1;
+	    for (i__ = 1; i__ <= i__2; ++i__) {
+		aa[i__ + (j - 1) * *lda] = -1e10f;
+/* L140: */
+	    }
+	    i__2 = iend;
+	    for (i__ = ibeg; i__ <= i__2; ++i__) {
+		aa[i__ + (j - 1) * *lda] = a[i__ + j - kk + j * a_dim1];
+/* L150: */
+	    }
+	    i__2 = *lda;
+	    for (i__ = iend + 1; i__ <= i__2; ++i__) {
+		aa[i__ + (j - 1) * *lda] = -1e10f;
+/* L160: */
+	    }
+/* L170: */
+	}
+    } else if (s_cmp(type__, "sp", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(type__,
+	     "tp", (ftnlen)2, (ftnlen)2) == 0) {
+	ioff = 0;
+	i__1 = *n;
+	for (j = 1; j <= i__1; ++j) {
+	    if (upper) {
+		ibeg = 1;
+		iend = j;
+	    } else {
+		ibeg = j;
+		iend = *n;
+	    }
+	    i__2 = iend;
+	    for (i__ = ibeg; i__ <= i__2; ++i__) {
+		++ioff;
+		aa[ioff] = a[i__ + j * a_dim1];
+		if (i__ == j) {
+		    if (unit) {
+			aa[ioff] = -1e10f;
+		    }
+		}
+/* L180: */
+	    }
+/* L190: */
+	}
+    }
+    return 0;
+
+/*     End of SMAKE. */
+
+} /* smake_ */
+
+/* Subroutine */ int smvch_(char *trans, integer *m, integer *n, real *alpha, 
+	real *a, integer *nmax, real *x, integer *incx, real *beta, real *y, 
+	integer *incy, real *yt, real *g, real *yy, real *eps, real *err, 
+	logical *fatal, integer *nout, logical *mv, ftnlen trans_len)
+{
+    /* Format strings */
+    static char fmt_9999[] = "(\002 ******* FATAL ERROR - COMPUTED RESULT IS"
+	    " LESS THAN HAL\002,\002F ACCURATE *******\002,/\002           EX"
+	    "PECTED RESULT   COMPU\002,\002TED RESULT\002)";
+    static char fmt_9998[] = "(1x,i7,2g18.6)";
+
+    /* System generated locals */
+    integer a_dim1, a_offset, i__1, i__2;
+    real r__1;
+
+    /* Builtin functions */
+    double sqrt(doublereal);
+    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+    /* Local variables */
+    integer i__, j, ml, nl, iy, jx, kx, ky;
+    real erri;
+    logical tran;
+    integer incxl, incyl;
+
+    /* Fortran I/O blocks */
+    static cilist io___441 = { 0, 0, 0, fmt_9999, 0 };
+    static cilist io___442 = { 0, 0, 0, fmt_9998, 0 };
+    static cilist io___443 = { 0, 0, 0, fmt_9998, 0 };
+
+
+
+/*  Checks the results of the computational tests. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Executable Statements .. */
+    /* Parameter adjustments */
+    a_dim1 = *nmax;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --x;
+    --y;
+    --yt;
+    --g;
+    --yy;
+
+    /* Function Body */
+    tran = *(unsigned char *)trans == 'T' || *(unsigned char *)trans == 'C';
+    if (tran) {
+	ml = *n;
+	nl = *m;
+    } else {
+	ml = *m;
+	nl = *n;
+    }
+    if (*incx < 0) {
+	kx = nl;
+	incxl = -1;
+    } else {
+	kx = 1;
+	incxl = 1;
+    }
+    if (*incy < 0) {
+	ky = ml;
+	incyl = -1;
+    } else {
+	ky = 1;
+	incyl = 1;
+    }
+
+/*     Compute expected result in YT using data in A, X and Y. */
+/*     Compute gauges in G. */
+
+    iy = ky;
+    i__1 = ml;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	yt[iy] = 0.f;
+	g[iy] = 0.f;
+	jx = kx;
+	if (tran) {
+	    i__2 = nl;
+	    for (j = 1; j <= i__2; ++j) {
+		yt[iy] += a[j + i__ * a_dim1] * x[jx];
+		g[iy] += (r__1 = a[j + i__ * a_dim1] * x[jx], abs(r__1));
+		jx += incxl;
+/* L10: */
+	    }
+	} else {
+	    i__2 = nl;
+	    for (j = 1; j <= i__2; ++j) {
+		yt[iy] += a[i__ + j * a_dim1] * x[jx];
+		g[iy] += (r__1 = a[i__ + j * a_dim1] * x[jx], abs(r__1));
+		jx += incxl;
+/* L20: */
+	    }
+	}
+	yt[iy] = *alpha * yt[iy] + *beta * y[iy];
+	g[iy] = abs(*alpha) * g[iy] + (r__1 = *beta * y[iy], abs(r__1));
+	iy += incyl;
+/* L30: */
+    }
+
+/*     Compute the error ratio for this result. */
+
+    *err = 0.f;
+    i__1 = ml;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	erri = (r__1 = yt[i__] - yy[(i__ - 1) * abs(*incy) + 1], abs(r__1)) / 
+		*eps;
+	if (g[i__] != 0.f) {
+	    erri /= g[i__];
+	}
+	*err = max(*err,erri);
+	if (*err * sqrt(*eps) >= 1.f) {
+	    goto L50;
+	}
+/* L40: */
+    }
+/*     If the loop completes, all results are at least half accurate. */
+    goto L70;
+
+/*     Report fatal error. */
+
+L50:
+    *fatal = TRUE_;
+    io___441.ciunit = *nout;
+    s_wsfe(&io___441);
+    e_wsfe();
+    i__1 = ml;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	if (*mv) {
+	    io___442.ciunit = *nout;
+	    s_wsfe(&io___442);
+	    do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&yt[i__], (ftnlen)sizeof(real));
+	    do_fio(&c__1, (char *)&yy[(i__ - 1) * abs(*incy) + 1], (ftnlen)
+		    sizeof(real));
+	    e_wsfe();
+	} else {
+	    io___443.ciunit = *nout;
+	    s_wsfe(&io___443);
+	    do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+	    do_fio(&c__1, (char *)&yy[(i__ - 1) * abs(*incy) + 1], (ftnlen)
+		    sizeof(real));
+	    do_fio(&c__1, (char *)&yt[i__], (ftnlen)sizeof(real));
+	    e_wsfe();
+	}
+/* L60: */
+    }
+
+L70:
+    return 0;
+
+
+/*     End of SMVCH. */
+
+} /* smvch_ */
+
+logical lse_(real *ri, real *rj, integer *lr)
+{
+    /* System generated locals */
+    integer i__1;
+    logical ret_val;
+
+    /* Local variables */
+    integer i__;
+
+
+/*  Tests if two arrays are identical. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Executable Statements .. */
+    /* Parameter adjustments */
+    --rj;
+    --ri;
+
+    /* Function Body */
+    i__1 = *lr;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	if (ri[i__] != rj[i__]) {
+	    goto L20;
+	}
+/* L10: */
+    }
+    ret_val = TRUE_;
+    goto L30;
+L20:
+    ret_val = FALSE_;
+L30:
+    return ret_val;
+
+/*     End of LSE. */
+
+} /* lse_ */
+
+logical lseres_(char *type__, char *uplo, integer *m, integer *n, real *aa, 
+	real *as, integer *lda, ftnlen type_len, ftnlen uplo_len)
+{
+    /* System generated locals */
+    integer aa_dim1, aa_offset, as_dim1, as_offset, i__1, i__2;
+    logical ret_val;
+
+    /* Builtin functions */
+    integer s_cmp(char *, char *, ftnlen, ftnlen);
+
+    /* Local variables */
+    integer i__, j, ibeg, iend;
+    logical upper;
+
+
+/*  Tests if selected elements in two arrays are equal. */
+
+/*  TYPE is 'ge', 'sy' or 'sp'. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Executable Statements .. */
+    /* Parameter adjustments */
+    as_dim1 = *lda;
+    as_offset = 1 + as_dim1;
+    as -= as_offset;
+    aa_dim1 = *lda;
+    aa_offset = 1 + aa_dim1;
+    aa -= aa_offset;
+
+    /* Function Body */
+    upper = *(unsigned char *)uplo == 'U';
+    if (s_cmp(type__, "ge", (ftnlen)2, (ftnlen)2) == 0) {
+	i__1 = *n;
+	for (j = 1; j <= i__1; ++j) {
+	    i__2 = *lda;
+	    for (i__ = *m + 1; i__ <= i__2; ++i__) {
+		if (aa[i__ + j * aa_dim1] != as[i__ + j * as_dim1]) {
+		    goto L70;
+		}
+/* L10: */
+	    }
+/* L20: */
+	}
+    } else if (s_cmp(type__, "sy", (ftnlen)2, (ftnlen)2) == 0) {
+	i__1 = *n;
+	for (j = 1; j <= i__1; ++j) {
+	    if (upper) {
+		ibeg = 1;
+		iend = j;
+	    } else {
+		ibeg = j;
+		iend = *n;
+	    }
+	    i__2 = ibeg - 1;
+	    for (i__ = 1; i__ <= i__2; ++i__) {
+		if (aa[i__ + j * aa_dim1] != as[i__ + j * as_dim1]) {
+		    goto L70;
+		}
+/* L30: */
+	    }
+	    i__2 = *lda;
+	    for (i__ = iend + 1; i__ <= i__2; ++i__) {
+		if (aa[i__ + j * aa_dim1] != as[i__ + j * as_dim1]) {
+		    goto L70;
+		}
+/* L40: */
+	    }
+/* L50: */
+	}
+    }
+
+/* L60: */
+    ret_val = TRUE_;
+    goto L80;
+L70:
+    ret_val = FALSE_;
+L80:
+    return ret_val;
+
+/*     End of LSERES. */
+
+} /* lseres_ */
+
+real sbeg_(logical *reset)
+{
+    /* System generated locals */
+    real ret_val;
+
+    /* Local variables */
+    static integer i__, ic, mi;
+
+
+/*  Generates random numbers uniformly distributed between -0.5 and 0.5. */
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+/*     Jeremy Du Croz, NAG Central Office. */
+
+/*     .. Scalar Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Save statement .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Executable Statements .. */
+    if (*reset) {
+/*        Initialize local variables. */
+	mi = 891;
+	i__ = 7;
+	ic = 0;
+	*reset = FALSE_;
+    }
+
+/*     The sequence of values of I is bounded between 1 and 999. */
+/*     If initial I = 1,2,3,6,7 or 9, the period will be 50. */
+/*     If initial I = 4 or 8, the period will be 25. */
+/*     If initial I = 5, the period will be 10. */
+/*     IC is used to break up the period by skipping 1 value of I in 6. */
+
+    ++ic;
+L10:
+    i__ *= mi;
+    i__ -= i__ / 1000 * 1000;
+    if (ic >= 5) {
+	ic = 0;
+	goto L10;
+    }
+    ret_val = (real) (i__ - 500) / 1001.f;
+    return ret_val;
+
+/*     End of SBEG. */
+
+} /* sbeg_ */
+
+real sdiff_(real *x, real *y)
+{
+    /* System generated locals */
+    real ret_val;
+
+
+/*  Auxiliary routine for test program for Level 2 Blas. */
+
+/*  -- Written on 10-August-1987. */
+/*     Richard Hanson, Sandia National Labs. */
+
+/*     .. Scalar Arguments .. */
+/*     .. Executable Statements .. */
+    ret_val = *x - *y;
+    return ret_val;
+
+/*     End of SDIFF. */
+
+} /* sdiff_ */
+
+/* Main program alias */ int sblat2_ () { MAIN__ (); return 0; }
diff --git a/CBLAS/testing/c_sblat3.c b/CBLAS/testing/c_sblat3.c
new file mode 100644
index 0000000..eb4ec4a
--- /dev/null
+++ b/CBLAS/testing/c_sblat3.c
@@ -0,0 +1,3789 @@
+/* testing/c_sblat3.f -- translated by f2c (version 20191129).
+   You must link the resulting object file with libf2c:
+        on Microsoft Windows system, link with libf2c.lib;
+        on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+        or, if you install libf2c.a in a standard place, with -lf2c -lm
+        -- in that order, at the end of the command line, as in
+                cc *.o -lf2c -lm
+        Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+                http://www.netlib.org/f2c/libf2c.zip
+*/
+
+#include "f2c.h"
+
+/* Common Block Declarations */
+
+struct {
+  integer infot, noutc;
+  logical ok;
+} infoc_;
+
+#define infoc_1 infoc_
+
+struct {
+  char srnamt[12];
+} srnamc_;
+
+#define srnamc_1 srnamc_
+
+/* Table of constant values */
+
+static integer c__9 = 9;
+static integer c__1 = 1;
+static integer c__3 = 3;
+static integer c__8 = 8;
+static integer c__4 = 4;
+static integer c__65 = 65;
+static integer c__7 = 7;
+static real c_b89 = 1.f;
+static real c_b103 = 0.f;
+static integer c__6 = 6;
+static logical c_true = TRUE_;
+static integer c__0 = 0;
+static logical c_false = FALSE_;
+
+/* Main program */ int MAIN__(void) {
+  /* Initialized data */
+
+  static char snames[12 * 6] = "cblas_sgemm "
+                               "cblas_ssymm "
+                               "cblas_strmm "
+                               "cblas_strsm "
+                               "cblas_ssyrk "
+                               "cblas_ssyr2k";
+
+  /* Format strings */
+  static char fmt_9997[] = "(\002 NUMBER OF VALUES OF \002,a,\002 IS LESS "
+                           "THAN 1 OR GREATER \002,\002THAN \002,i2)";
+  static char fmt_9996[] = "(\002 VALUE OF N IS LESS THAN 0 OR GREATER THA"
+                           "N \002,i2)";
+  static char fmt_9995[] =
+      "(\002 TESTS OF THE REAL             LEVEL 3 BL"
+      "AS\002,//\002 THE F\002,\002OLLOWING PARAMETER VALUES WILL BE US"
+      "ED:\002)";
+  static char fmt_9994[] = "(\002   FOR N              \002,9i6)";
+  static char fmt_9993[] = "(\002   FOR ALPHA          \002,7f6.1)";
+  static char fmt_9992[] = "(\002   FOR BETA           \002,7f6.1)";
+  static char fmt_9984[] = "(\002 ERROR-EXITS WILL NOT BE TESTED\002)";
+  static char fmt_9999[] = "(\002 ROUTINES PASS COMPUTATIONAL TESTS IF TES"
+                           "T RATIO IS LES\002,\002S THAN\002,f8.2)";
+  static char fmt_10002[] = "(\002 COLUMN-MAJOR AND ROW-MAJOR DATA LAYOUTS"
+                            " ARE TESTED\002)";
+  static char fmt_10001[] = "(\002 ROW-MAJOR DATA LAYOUT IS TESTED\002)";
+  static char fmt_10000[] = "(\002 COLUMN-MAJOR DATA LAYOUT IS TESTED\002)";
+  static char fmt_9988[] = "(a12,l2)";
+  static char fmt_9990[] =
+      "(\002 SUBPROGRAM NAME \002,a12,\002 NOT RECOGN"
+      "IZED\002,/\002 ******* \002,\002TESTS ABANDONED *******\002)";
+  static char fmt_9998[] = "(\002 RELATIVE MACHINE PRECISION IS TAKEN TO"
+                           " BE\002,1p,e9.1)";
+  static char fmt_9989[] =
+      "(\002 ERROR IN SMMCH -  IN-LINE DOT PRODUCTS A"
+      "RE BEING EVALU\002,\002ATED WRONGLY.\002,/\002 SMMCH WAS CALLED "
+      "WITH TRANSA = \002,a1,\002 AND TRANSB = \002,a1,/\002 AND RETURN"
+      "ED SAME = \002,l1,\002 AND \002,\002ERR = \002,f12.3,\002.\002,"
+      "/\002 THIS MAY BE DUE TO FAULTS IN THE \002,\002ARITHMETIC OR TH"
+      "E COMPILER.\002,/\002 ******* TESTS ABANDONED \002,\002******"
+      "*\002)";
+  static char fmt_9987[] = "(1x,a12,\002 WAS NOT TESTED\002)";
+  static char fmt_9986[] = "(/\002 END OF TESTS\002)";
+  static char fmt_9985[] = "(/\002 ******* FATAL ERROR - TESTS ABANDONED *"
+                           "******\002)";
+  static char fmt_9991[] =
+      "(\002 AMEND DATA FILE OR INCREASE ARRAY SIZES "
+      "IN PROGRAM\002,/\002 ******* TESTS ABANDONED *******\002)";
+
+  /* System generated locals */
+  integer i__1, i__2, i__3;
+  real r__1;
+  olist o__1;
+  cllist cl__1;
+
+  /* Builtin functions */
+  integer s_rsle(cilist *), do_lio(integer *, integer *, char *, ftnlen),
+      e_rsle(void), f_open(olist *), s_wsfe(cilist *),
+      do_fio(integer *, char *, ftnlen), e_wsfe(void), s_wsle(cilist *),
+      e_wsle(void), s_rsfe(cilist *), e_rsfe(void),
+      s_cmp(char *, char *, ftnlen, ftnlen);
+  /* Subroutine */ int s_stop(char *, ftnlen);
+  integer f_clos(cllist *);
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+
+  /* Local variables */
+  real c__[4225] /* was [65][65] */, g[65];
+  integer i__, j, n;
+  real w[130], aa[4225], ab[8450] /* was [65][130] */, bb[4225], cc[4225],
+      as[4225], bs[4225], cs[4225], ct[65], alf[7], bet[7];
+  extern logical lse_(real *, real *, integer *);
+  real eps, err;
+  integer nalf, idim[9];
+  logical same;
+  integer nbet, ntra;
+  logical rewi;
+  extern /* Subroutine */ int schk1_(
+      char *, real *, real *, integer *, integer *, logical *, logical *,
+      logical *, integer *, integer *, integer *, real *, integer *, real *,
+      integer *, real *, real *, real *, real *, real *, real *, real *, real *,
+      real *, real *, real *, integer *, ftnlen),
+      schk2_(char *, real *, real *, integer *, integer *, logical *, logical *,
+             logical *, integer *, integer *, integer *, real *, integer *,
+             real *, integer *, real *, real *, real *, real *, real *, real *,
+             real *, real *, real *, real *, real *, integer *, ftnlen),
+      schk3_(char *, real *, real *, integer *, integer *, logical *, logical *,
+             logical *, integer *, integer *, integer *, real *, integer *,
+             real *, real *, real *, real *, real *, real *, real *, real *,
+             real *, integer *, ftnlen),
+      schk4_(char *, real *, real *, integer *, integer *, logical *, logical *,
+             logical *, integer *, integer *, integer *, real *, integer *,
+             real *, integer *, real *, real *, real *, real *, real *, real *,
+             real *, real *, real *, real *, real *, integer *, ftnlen),
+      schk5_(char *, real *, real *, integer *, integer *, logical *, logical *,
+             logical *, integer *, integer *, integer *, real *, integer *,
+             real *, integer *, real *, real *, real *, real *, real *, real *,
+             real *, real *, real *, real *, real *, integer *, ftnlen);
+  logical fatal;
+  extern real sdiff_(real *, real *);
+  logical trace;
+  integer nidim;
+  extern /* Subroutine */ int smmch_(
+      char *, char *, integer *, integer *, integer *, real *, real *,
+      integer *, real *, integer *, real *, real *, integer *, real *, real *,
+      real *, integer *, real *, real *, logical *, integer *, logical *,
+      ftnlen, ftnlen);
+  char snaps[32];
+  integer isnum;
+  logical ltest[6], sfatal, corder;
+  char snamet[12], transa[1], transb[1];
+  real thresh;
+  logical rorder;
+  integer layout;
+  logical ltestt, tsterr;
+  extern /* Subroutine */ void cs3chke_(char *);
+
+  /* Fortran I/O blocks */
+  static cilist io___2 = {0, 5, 0, 0, 0};
+  static cilist io___4 = {0, 5, 0, 0, 0};
+  static cilist io___7 = {0, 5, 0, 0, 0};
+  static cilist io___9 = {0, 5, 0, 0, 0};
+  static cilist io___11 = {0, 5, 0, 0, 0};
+  static cilist io___13 = {0, 5, 0, 0, 0};
+  static cilist io___15 = {0, 5, 0, 0, 0};
+  static cilist io___17 = {0, 5, 0, 0, 0};
+  static cilist io___19 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___20 = {0, 5, 0, 0, 0};
+  static cilist io___23 = {0, 6, 0, fmt_9996, 0};
+  static cilist io___24 = {0, 5, 0, 0, 0};
+  static cilist io___26 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___27 = {0, 5, 0, 0, 0};
+  static cilist io___29 = {0, 5, 0, 0, 0};
+  static cilist io___31 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___32 = {0, 5, 0, 0, 0};
+  static cilist io___34 = {0, 6, 0, fmt_9995, 0};
+  static cilist io___35 = {0, 6, 0, fmt_9994, 0};
+  static cilist io___36 = {0, 6, 0, fmt_9993, 0};
+  static cilist io___37 = {0, 6, 0, fmt_9992, 0};
+  static cilist io___38 = {0, 6, 0, 0, 0};
+  static cilist io___39 = {0, 6, 0, fmt_9984, 0};
+  static cilist io___40 = {0, 6, 0, 0, 0};
+  static cilist io___41 = {0, 6, 0, fmt_9999, 0};
+  static cilist io___42 = {0, 6, 0, 0, 0};
+  static cilist io___45 = {0, 6, 0, fmt_10002, 0};
+  static cilist io___46 = {0, 6, 0, fmt_10001, 0};
+  static cilist io___47 = {0, 6, 0, fmt_10000, 0};
+  static cilist io___48 = {0, 6, 0, 0, 0};
+  static cilist io___50 = {0, 5, 1, fmt_9988, 0};
+  static cilist io___53 = {0, 6, 0, fmt_9990, 0};
+  static cilist io___55 = {0, 6, 0, fmt_9998, 0};
+  static cilist io___68 = {0, 6, 0, fmt_9989, 0};
+  static cilist io___69 = {0, 6, 0, fmt_9989, 0};
+  static cilist io___70 = {0, 6, 0, fmt_9989, 0};
+  static cilist io___71 = {0, 6, 0, fmt_9989, 0};
+  static cilist io___73 = {0, 6, 0, 0, 0};
+  static cilist io___74 = {0, 6, 0, fmt_9987, 0};
+  static cilist io___75 = {0, 6, 0, 0, 0};
+  static cilist io___82 = {0, 6, 0, fmt_9986, 0};
+  static cilist io___83 = {0, 6, 0, fmt_9985, 0};
+  static cilist io___84 = {0, 6, 0, fmt_9991, 0};
+
+  /*  Test program for the REAL             Level 3 Blas. */
+
+  /*  The program must be driven by a short data file. The first 13 records */
+  /*  of the file are read using list-directed input, the last 6 records */
+  /*  are read using the format ( A12, L2 ). An annotated example of a data */
+  /*  file can be obtained by deleting the first 3 characters from the */
+  /*  following 19 lines: */
+  /*  'SBLAT3.SNAP'     NAME OF SNAPSHOT OUTPUT FILE */
+  /*  -1                UNIT NUMBER OF SNAPSHOT FILE (NOT USED IF .LT. 0) */
+  /*  F        LOGICAL FLAG, T TO REWIND SNAPSHOT FILE AFTER EACH RECORD. */
+  /*  F        LOGICAL FLAG, T TO STOP ON FAILURES. */
+  /*  T        LOGICAL FLAG, T TO TEST ERROR EXITS. */
+  /*  2        0 TO TEST COLUMN-MAJOR, 1 TO TEST ROW-MAJOR, 2 TO TEST BOTH */
+  /*  16.0     THRESHOLD VALUE OF TEST RATIO */
+  /*  6                 NUMBER OF VALUES OF N */
+  /*  0 1 2 3 5 9       VALUES OF N */
+  /*  3                 NUMBER OF VALUES OF ALPHA */
+  /*  0.0 1.0 0.7       VALUES OF ALPHA */
+  /*  3                 NUMBER OF VALUES OF BETA */
+  /*  0.0 1.0 1.3       VALUES OF BETA */
+  /*  cblas_sgemm  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_ssymm  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_strmm  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_strsm  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_ssyrk  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_ssyr2k T PUT F FOR NO TEST. SAME COLUMNS. */
+
+  /*  See: */
+
+  /*     Dongarra J. J., Du Croz J. J., Duff I. S. and Hammarling S. */
+  /*     A Set of Level 3 Basic Linear Algebra Subprograms. */
+
+  /*     Technical Memorandum No.88 (Revision 1), Mathematics and */
+  /*     Computer Science Division, Argonne National Laboratory, 9700 */
+  /*     South Cass Avenue, Argonne, Illinois 60439, US. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /*     .. Executable Statements .. */
+
+  infoc_1.noutc = 6;
+  /*     Read name and unit number for summary output file and open file. */
+
+  s_rsle(&io___2);
+  do_lio(&c__9, &c__1, snaps, (ftnlen)32);
+  e_rsle();
+  s_rsle(&io___4);
+  do_lio(&c__3, &c__1, (char *)&ntra, (ftnlen)sizeof(integer));
+  e_rsle();
+  trace = ntra >= 0;
+  if (trace) {
+    /*         OPEN( NTRA, FILE = SNAPS, STATUS = 'NEW' ) */
+    o__1.oerr = 0;
+    o__1.ounit = ntra;
+    o__1.ofnmlen = 32;
+    o__1.ofnm = snaps;
+    o__1.orl = 0;
+    o__1.osta = 0;
+    o__1.oacc = 0;
+    o__1.ofm = 0;
+    o__1.oblnk = 0;
+    f_open(&o__1);
+  }
+  /*     Read the flag that directs rewinding of the snapshot file. */
+  s_rsle(&io___7);
+  do_lio(&c__8, &c__1, (char *)&rewi, (ftnlen)sizeof(logical));
+  e_rsle();
+  rewi = rewi && trace;
+  /*     Read the flag that directs stopping on any failure. */
+  s_rsle(&io___9);
+  do_lio(&c__8, &c__1, (char *)&sfatal, (ftnlen)sizeof(logical));
+  e_rsle();
+  /*     Read the flag that indicates whether error exits are to be tested. */
+  s_rsle(&io___11);
+  do_lio(&c__8, &c__1, (char *)&tsterr, (ftnlen)sizeof(logical));
+  e_rsle();
+  /*     Read the flag that indicates whether row-major data layout to be
+   * tested. */
+  s_rsle(&io___13);
+  do_lio(&c__3, &c__1, (char *)&layout, (ftnlen)sizeof(integer));
+  e_rsle();
+  /*     Read the threshold value of the test ratio */
+  s_rsle(&io___15);
+  do_lio(&c__4, &c__1, (char *)&thresh, (ftnlen)sizeof(real));
+  e_rsle();
+
+  /*     Read and check the parameter values for the tests. */
+
+  /*     Values of N */
+  s_rsle(&io___17);
+  do_lio(&c__3, &c__1, (char *)&nidim, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nidim < 1 || nidim > 9) {
+    s_wsfe(&io___19);
+    do_fio(&c__1, "N", (ftnlen)1);
+    do_fio(&c__1, (char *)&c__9, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L220;
+  }
+  s_rsle(&io___20);
+  i__1 = nidim;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__3, &c__1, (char *)&idim[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_rsle();
+  i__1 = nidim;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    if (idim[i__ - 1] < 0 || idim[i__ - 1] > 65) {
+      s_wsfe(&io___23);
+      do_fio(&c__1, (char *)&c__65, (ftnlen)sizeof(integer));
+      e_wsfe();
+      goto L220;
+    }
+    /* L10: */
+  }
+  /*     Values of ALPHA */
+  s_rsle(&io___24);
+  do_lio(&c__3, &c__1, (char *)&nalf, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nalf < 1 || nalf > 7) {
+    s_wsfe(&io___26);
+    do_fio(&c__1, "ALPHA", (ftnlen)5);
+    do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L220;
+  }
+  s_rsle(&io___27);
+  i__1 = nalf;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__4, &c__1, (char *)&alf[i__ - 1], (ftnlen)sizeof(real));
+  }
+  e_rsle();
+  /*     Values of BETA */
+  s_rsle(&io___29);
+  do_lio(&c__3, &c__1, (char *)&nbet, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nbet < 1 || nbet > 7) {
+    s_wsfe(&io___31);
+    do_fio(&c__1, "BETA", (ftnlen)4);
+    do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L220;
+  }
+  s_rsle(&io___32);
+  i__1 = nbet;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__4, &c__1, (char *)&bet[i__ - 1], (ftnlen)sizeof(real));
+  }
+  e_rsle();
+
+  /*     Report values of parameters. */
+
+  s_wsfe(&io___34);
+  e_wsfe();
+  s_wsfe(&io___35);
+  i__1 = nidim;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__1, (char *)&idim[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_wsfe();
+  s_wsfe(&io___36);
+  i__1 = nalf;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__1, (char *)&alf[i__ - 1], (ftnlen)sizeof(real));
+  }
+  e_wsfe();
+  s_wsfe(&io___37);
+  i__1 = nbet;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__1, (char *)&bet[i__ - 1], (ftnlen)sizeof(real));
+  }
+  e_wsfe();
+  if (!tsterr) {
+    s_wsle(&io___38);
+    e_wsle();
+    s_wsfe(&io___39);
+    e_wsfe();
+  }
+  s_wsle(&io___40);
+  e_wsle();
+  s_wsfe(&io___41);
+  do_fio(&c__1, (char *)&thresh, (ftnlen)sizeof(real));
+  e_wsfe();
+  s_wsle(&io___42);
+  e_wsle();
+  rorder = FALSE_;
+  corder = FALSE_;
+  if (layout == 2) {
+    rorder = TRUE_;
+    corder = TRUE_;
+    s_wsfe(&io___45);
+    e_wsfe();
+  } else if (layout == 1) {
+    rorder = TRUE_;
+    s_wsfe(&io___46);
+    e_wsfe();
+  } else if (layout == 0) {
+    corder = TRUE_;
+    s_wsfe(&io___47);
+    e_wsfe();
+  }
+  s_wsle(&io___48);
+  e_wsle();
+
+  /*     Read names of subroutines and flags which indicate */
+  /*     whether they are to be tested. */
+
+  for (i__ = 1; i__ <= 6; ++i__) {
+    ltest[i__ - 1] = FALSE_;
+    /* L20: */
+  }
+L30:
+  i__1 = s_rsfe(&io___50);
+  if (i__1 != 0) {
+    goto L60;
+  }
+  i__1 = do_fio(&c__1, snamet, (ftnlen)12);
+  if (i__1 != 0) {
+    goto L60;
+  }
+  i__1 = do_fio(&c__1, (char *)&ltestt, (ftnlen)sizeof(logical));
+  if (i__1 != 0) {
+    goto L60;
+  }
+  i__1 = e_rsfe();
+  if (i__1 != 0) {
+    goto L60;
+  }
+  for (i__ = 1; i__ <= 6; ++i__) {
+    if (s_cmp(snamet, snames + (i__ - 1) * 12, (ftnlen)12, (ftnlen)12) == 0) {
+      goto L50;
+    }
+    /* L40: */
+  }
+  s_wsfe(&io___53);
+  do_fio(&c__1, snamet, (ftnlen)12);
+  e_wsfe();
+  s_stop("", (ftnlen)0);
+L50:
+  ltest[i__ - 1] = ltestt;
+  goto L30;
+
+L60:
+  cl__1.cerr = 0;
+  cl__1.cunit = 5;
+  cl__1.csta = 0;
+  f_clos(&cl__1);
+
+  /*     Compute EPS (the machine precision). */
+
+  eps = 1.f;
+L70:
+  r__1 = eps + 1.f;
+  if (sdiff_(&r__1, &c_b89) == 0.f) {
+    goto L80;
+  }
+  eps *= .5f;
+  goto L70;
+L80:
+  eps += eps;
+  s_wsfe(&io___55);
+  do_fio(&c__1, (char *)&eps, (ftnlen)sizeof(real));
+  e_wsfe();
+
+  /*     Check the reliability of SMMCH using exact data. */
+
+  n = 32;
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = n;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      /* Computing MAX */
+      i__3 = i__ - j + 1;
+      ab[i__ + j * 65 - 66] = (real)max(i__3, 0);
+      /* L90: */
+    }
+    ab[j + 4224] = (real)j;
+    ab[(j + 65) * 65 - 65] = (real)j;
+    c__[j - 1] = 0.f;
+    /* L100: */
+  }
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    cc[j - 1] = (real)(j * ((j + 1) * j) / 2 - (j + 1) * j * (j - 1) / 3);
+    /* L110: */
+  }
+  /*     CC holds the exact result. On exit from SMMCH CT holds */
+  /*     the result computed by SMMCH. */
+  *(unsigned char *)transa = 'N';
+  *(unsigned char *)transb = 'N';
+  smmch_(transa, transb, &n, &c__1, &n, &c_b89, ab, &c__65, &ab[4225], &c__65,
+         &c_b103, c__, &c__65, ct, g, cc, &c__65, &eps, &err, &fatal, &c__6,
+         &c_true, (ftnlen)1, (ftnlen)1);
+  same = lse_(cc, ct, &n);
+  if (!same || err != 0.f) {
+    s_wsfe(&io___68);
+    do_fio(&c__1, transa, (ftnlen)1);
+    do_fio(&c__1, transb, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(real));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+  *(unsigned char *)transb = 'T';
+  smmch_(transa, transb, &n, &c__1, &n, &c_b89, ab, &c__65, &ab[4225], &c__65,
+         &c_b103, c__, &c__65, ct, g, cc, &c__65, &eps, &err, &fatal, &c__6,
+         &c_true, (ftnlen)1, (ftnlen)1);
+  same = lse_(cc, ct, &n);
+  if (!same || err != 0.f) {
+    s_wsfe(&io___69);
+    do_fio(&c__1, transa, (ftnlen)1);
+    do_fio(&c__1, transb, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(real));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    ab[j + 4224] = (real)(n - j + 1);
+    ab[(j + 65) * 65 - 65] = (real)(n - j + 1);
+    /* L120: */
+  }
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    cc[n - j] = (real)(j * ((j + 1) * j) / 2 - (j + 1) * j * (j - 1) / 3);
+    /* L130: */
+  }
+  *(unsigned char *)transa = 'T';
+  *(unsigned char *)transb = 'N';
+  smmch_(transa, transb, &n, &c__1, &n, &c_b89, ab, &c__65, &ab[4225], &c__65,
+         &c_b103, c__, &c__65, ct, g, cc, &c__65, &eps, &err, &fatal, &c__6,
+         &c_true, (ftnlen)1, (ftnlen)1);
+  same = lse_(cc, ct, &n);
+  if (!same || err != 0.f) {
+    s_wsfe(&io___70);
+    do_fio(&c__1, transa, (ftnlen)1);
+    do_fio(&c__1, transb, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(real));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+  *(unsigned char *)transb = 'T';
+  smmch_(transa, transb, &n, &c__1, &n, &c_b89, ab, &c__65, &ab[4225], &c__65,
+         &c_b103, c__, &c__65, ct, g, cc, &c__65, &eps, &err, &fatal, &c__6,
+         &c_true, (ftnlen)1, (ftnlen)1);
+  same = lse_(cc, ct, &n);
+  if (!same || err != 0.f) {
+    s_wsfe(&io___71);
+    do_fio(&c__1, transa, (ftnlen)1);
+    do_fio(&c__1, transb, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(real));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+
+  /*     Test each subroutine in turn. */
+
+  for (isnum = 1; isnum <= 6; ++isnum) {
+    s_wsle(&io___73);
+    e_wsle();
+    if (!ltest[isnum - 1]) {
+      /*           Subprogram is not to be tested. */
+      s_wsfe(&io___74);
+      do_fio(&c__1, snames + (isnum - 1) * 12, (ftnlen)12);
+      e_wsfe();
+    } else {
+      s_copy(srnamc_1.srnamt, snames + (isnum - 1) * 12, (ftnlen)12,
+             (ftnlen)12);
+      /*           Test error exits. */
+      if (tsterr) {
+        cs3chke_(snames + (isnum - 1) * 12);
+        s_wsle(&io___75);
+        e_wsle();
+      }
+      /*           Test computations. */
+      infoc_1.infot = 0;
+      infoc_1.ok = TRUE_;
+      fatal = FALSE_;
+      switch (isnum) {
+      case 1:
+        goto L140;
+      case 2:
+        goto L150;
+      case 3:
+        goto L160;
+      case 4:
+        goto L160;
+      case 5:
+        goto L170;
+      case 6:
+        goto L180;
+      }
+    /*           Test SGEMM, 01. */
+    L140:
+      if (corder) {
+        schk1_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__0,
+               (ftnlen)12);
+      }
+      if (rorder) {
+        schk1_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__1,
+               (ftnlen)12);
+      }
+      goto L190;
+    /*           Test SSYMM, 02. */
+    L150:
+      if (corder) {
+        schk2_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__0,
+               (ftnlen)12);
+      }
+      if (rorder) {
+        schk2_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__1,
+               (ftnlen)12);
+      }
+      goto L190;
+    /*           Test STRMM, 03, STRSM, 04. */
+    L160:
+      if (corder) {
+        schk3_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &c__65, ab, aa, as,
+               &ab[4225], bb, bs, ct, g, c__, &c__0, (ftnlen)12);
+      }
+      if (rorder) {
+        schk3_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &c__65, ab, aa, as,
+               &ab[4225], bb, bs, ct, g, c__, &c__1, (ftnlen)12);
+      }
+      goto L190;
+    /*           Test SSYRK, 05. */
+    L170:
+      if (corder) {
+        schk4_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__0,
+               (ftnlen)12);
+      }
+      if (rorder) {
+        schk4_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__1,
+               (ftnlen)12);
+      }
+      goto L190;
+    /*           Test SSYR2K, 06. */
+    L180:
+      if (corder) {
+        schk5_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, bb, bs, c__, cc, cs, ct, g, w, &c__0, (ftnlen)12);
+      }
+      if (rorder) {
+        schk5_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, bb, bs, c__, cc, cs, ct, g, w, &c__1, (ftnlen)12);
+      }
+      goto L190;
+
+    L190:
+      if (fatal && sfatal) {
+        goto L210;
+      }
+    }
+    /* L200: */
+  }
+  s_wsfe(&io___82);
+  e_wsfe();
+  goto L230;
+
+L210:
+  s_wsfe(&io___83);
+  e_wsfe();
+  goto L230;
+
+L220:
+  s_wsfe(&io___84);
+  e_wsfe();
+
+L230:
+  if (trace) {
+    cl__1.cerr = 0;
+    cl__1.cunit = ntra;
+    cl__1.csta = 0;
+    f_clos(&cl__1);
+  }
+  cl__1.cerr = 0;
+  cl__1.cunit = 6;
+  cl__1.csta = 0;
+  f_clos(&cl__1);
+  s_stop("", (ftnlen)0);
+
+  /*     End of SBLAT3. */
+
+  return 0;
+} /* MAIN__ */
+
+/* Subroutine */ int schk1_(char *sname, real *eps, real *thresh, integer *nout,
+                            integer *ntra, logical *trace, logical *rewi,
+                            logical *fatal, integer *nidim, integer *idim,
+                            integer *nalf, real *alf, integer *nbet, real *bet,
+                            integer *nmax, real *a, real *aa, real *as, real *b,
+                            real *bb, real *bs, real *c__, real *cc, real *cs,
+                            real *ct, real *g, integer *iorder,
+                            ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ich[3] = "NTC";
+
+  /* Format strings */
+  static char fmt_9994[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
+      i__3, i__4, i__5, i__6, i__7;
+  alist al__1;
+
+  /* Builtin functions */
+  integer f_rew(alist *), s_wsfe(cilist *), e_wsfe(void),
+      do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, k, m, n, ia, ib, ma, mb, na, nb, nc, ik, im, in, ks, ms, ns, ica,
+      icb, laa, lbb, lda, lcc, ldb, ldc;
+  real als, bls;
+  extern logical lse_(real *, real *, integer *);
+  real err, beta;
+  integer ldas, ldbs, ldcs;
+  logical same, null;
+  real alpha;
+  logical isame[13];
+  extern /* Subroutine */ int smake_(
+      char *, char *, char *, integer *, integer *, real *, integer *, real *,
+      integer *, logical *, real *, ftnlen, ftnlen, ftnlen);
+  logical trana, tranb;
+  extern /* Subroutine */ int smmch_(
+      char *, char *, integer *, integer *, integer *, real *, real *,
+      integer *, real *, integer *, real *, real *, integer *, real *, real *,
+      real *, integer *, real *, real *, logical *, integer *, logical *,
+      ftnlen, ftnlen);
+  integer nargs;
+  logical reset;
+  extern /* Subroutine */ int sprcn1_(
+      integer *, integer *, char *, integer *, char *, char *, integer *,
+      integer *, integer *, real *, integer *, integer *, real *, integer *,
+      ftnlen, ftnlen, ftnlen);
+  extern void csgemm_(integer *, char *, char *, integer *, integer *, integer *,
+                      real *, real *, integer *, real *, integer *, real *, real *,
+                      integer *);
+  char tranas[1], tranbs[1], transa[1], transb[1];
+  real errmax;
+  extern logical lseres_(char *, char *, integer *, integer *, real *, real *,
+                         integer *, ftnlen, ftnlen);
+
+  /* Fortran I/O blocks */
+  static cilist io___128 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___131 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___133 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___134 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___135 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___136 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___137 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests SGEMM. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --bet;
+  --g;
+  --ct;
+  --cs;
+  --cc;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --bs;
+  --bb;
+  b_dim1 = *nmax;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+
+  nargs = 13;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.f;
+
+  i__1 = *nidim;
+  for (im = 1; im <= i__1; ++im) {
+    m = idim[im];
+
+    i__2 = *nidim;
+    for (in = 1; in <= i__2; ++in) {
+      n = idim[in];
+      /*           Set LDC to 1 more than minimum value if room. */
+      ldc = m;
+      if (ldc < *nmax) {
+        ++ldc;
+      }
+      /*           Skip tests if not enough room. */
+      if (ldc > *nmax) {
+        goto L100;
+      }
+      lcc = ldc * n;
+      null = n <= 0 || m <= 0;
+
+      i__3 = *nidim;
+      for (ik = 1; ik <= i__3; ++ik) {
+        k = idim[ik];
+
+        for (ica = 1; ica <= 3; ++ica) {
+          *(unsigned char *)transa = *(unsigned char *)&ich[ica - 1];
+          trana = *(unsigned char *)transa == 'T' ||
+                  *(unsigned char *)transa == 'C';
+
+          if (trana) {
+            ma = k;
+            na = m;
+          } else {
+            ma = m;
+            na = k;
+          }
+          /*                 Set LDA to 1 more than minimum value if room. */
+          lda = ma;
+          if (lda < *nmax) {
+            ++lda;
+          }
+          /*                 Skip tests if not enough room. */
+          if (lda > *nmax) {
+            goto L80;
+          }
+          laa = lda * na;
+
+          /*                 Generate the matrix A. */
+
+          smake_("GE", " ", " ", &ma, &na, &a[a_offset], nmax, &aa[1], &lda,
+                 &reset, &c_b103, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+          for (icb = 1; icb <= 3; ++icb) {
+            *(unsigned char *)transb = *(unsigned char *)&ich[icb - 1];
+            tranb = *(unsigned char *)transb == 'T' ||
+                    *(unsigned char *)transb == 'C';
+
+            if (tranb) {
+              mb = n;
+              nb = k;
+            } else {
+              mb = k;
+              nb = n;
+            }
+            /*                    Set LDB to 1 more than minimum value if room.
+             */
+            ldb = mb;
+            if (ldb < *nmax) {
+              ++ldb;
+            }
+            /*                    Skip tests if not enough room. */
+            if (ldb > *nmax) {
+              goto L70;
+            }
+            lbb = ldb * nb;
+
+            /*                    Generate the matrix B. */
+
+            smake_("GE", " ", " ", &mb, &nb, &b[b_offset], nmax, &bb[1], &ldb,
+                   &reset, &c_b103, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+            i__4 = *nalf;
+            for (ia = 1; ia <= i__4; ++ia) {
+              alpha = alf[ia];
+
+              i__5 = *nbet;
+              for (ib = 1; ib <= i__5; ++ib) {
+                beta = bet[ib];
+
+                /*                          Generate the matrix C. */
+
+                smake_("GE", " ", " ", &m, &n, &c__[c_offset], nmax, &cc[1],
+                       &ldc, &reset, &c_b103, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+                ++nc;
+
+                /*                          Save every datum before calling the
+                 */
+                /*                          subroutine. */
+
+                *(unsigned char *)tranas = *(unsigned char *)transa;
+                *(unsigned char *)tranbs = *(unsigned char *)transb;
+                ms = m;
+                ns = n;
+                ks = k;
+                als = alpha;
+                i__6 = laa;
+                for (i__ = 1; i__ <= i__6; ++i__) {
+                  as[i__] = aa[i__];
+                  /* L10: */
+                }
+                ldas = lda;
+                i__6 = lbb;
+                for (i__ = 1; i__ <= i__6; ++i__) {
+                  bs[i__] = bb[i__];
+                  /* L20: */
+                }
+                ldbs = ldb;
+                bls = beta;
+                i__6 = lcc;
+                for (i__ = 1; i__ <= i__6; ++i__) {
+                  cs[i__] = cc[i__];
+                  /* L30: */
+                }
+                ldcs = ldc;
+
+                /*                          Call the subroutine. */
+
+                if (*trace) {
+                  sprcn1_(ntra, &nc, sname, iorder, transa, transb, &m, &n, &k,
+                          &alpha, &lda, &ldb, &beta, &ldc, (ftnlen)12,
+                          (ftnlen)1, (ftnlen)1);
+                }
+                if (*rewi) {
+                  al__1.aerr = 0;
+                  al__1.aunit = *ntra;
+                  f_rew(&al__1);
+                }
+                csgemm_(iorder, transa, transb, &m, &n, &k, &alpha, &aa[1],
+                        &lda, &bb[1], &ldb, &beta, &cc[1], &ldc);
+
+                /*                          Check if error-exit was taken
+                 * incorrectly. */
+
+                if (!infoc_1.ok) {
+                  io___128.ciunit = *nout;
+                  s_wsfe(&io___128);
+                  e_wsfe();
+                  *fatal = TRUE_;
+                  goto L120;
+                }
+
+                /*                          See what data changed inside
+                 * subroutines. */
+
+                isame[0] = *(unsigned char *)transa == *(unsigned char *)tranas;
+                isame[1] = *(unsigned char *)transb == *(unsigned char *)tranbs;
+                isame[2] = ms == m;
+                isame[3] = ns == n;
+                isame[4] = ks == k;
+                isame[5] = als == alpha;
+                isame[6] = lse_(&as[1], &aa[1], &laa);
+                isame[7] = ldas == lda;
+                isame[8] = lse_(&bs[1], &bb[1], &lbb);
+                isame[9] = ldbs == ldb;
+                isame[10] = bls == beta;
+                if (null) {
+                  isame[11] = lse_(&cs[1], &cc[1], &lcc);
+                } else {
+                  isame[11] = lseres_("GE", " ", &m, &n, &cs[1], &cc[1], &ldc,
+                                      (ftnlen)2, (ftnlen)1);
+                }
+                isame[12] = ldcs == ldc;
+
+                /*                          If data was incorrectly changed,
+                 * report */
+                /*                          and return. */
+
+                same = TRUE_;
+                i__6 = nargs;
+                for (i__ = 1; i__ <= i__6; ++i__) {
+                  same = same && isame[i__ - 1];
+                  if (!isame[i__ - 1]) {
+                    io___131.ciunit = *nout;
+                    s_wsfe(&io___131);
+                    i__7 = i__ + 1;
+                    do_fio(&c__1, (char *)&i__7, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  /* L40: */
+                }
+                if (!same) {
+                  *fatal = TRUE_;
+                  goto L120;
+                }
+
+                if (!null) {
+
+                  /*                             Check the result. */
+
+                  smmch_(transa, transb, &m, &n, &k, &alpha, &a[a_offset], nmax,
+                         &b[b_offset], nmax, &beta, &c__[c_offset], nmax,
+                         &ct[1], &g[1], &cc[1], &ldc, eps, &err, fatal, nout,
+                         &c_true, (ftnlen)1, (ftnlen)1);
+                  errmax = max(errmax, err);
+                  /*                             If got really bad answer,
+                   * report and */
+                  /*                             return. */
+                  if (*fatal) {
+                    goto L120;
+                  }
+                }
+
+                /* L50: */
+              }
+
+              /* L60: */
+            }
+
+          L70:;
+          }
+
+        L80:;
+        }
+
+        /* L90: */
+      }
+
+    L100:;
+    }
+
+    /* L110: */
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___133.ciunit = *nout;
+      s_wsfe(&io___133);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___134.ciunit = *nout;
+      s_wsfe(&io___134);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___135.ciunit = *nout;
+      s_wsfe(&io___135);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___136.ciunit = *nout;
+      s_wsfe(&io___136);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+  }
+  goto L130;
+
+L120:
+  io___137.ciunit = *nout;
+  s_wsfe(&io___137);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  sprcn1_(nout, &nc, sname, iorder, transa, transb, &m, &n, &k, &alpha, &lda,
+          &ldb, &beta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+
+L130:
+  return 0;
+
+  /* L9995: */
+
+  /*     End of SCHK1. */
+
+} /* schk1_ */
+
+/* Subroutine */ int sprcn1_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *transa, char *transb,
+                             integer *m, integer *n, integer *k, real *alpha,
+                             integer *lda, integer *ldb, real *beta,
+                             integer *ldc, ftnlen sname_len, ftnlen transa_len,
+                             ftnlen transb_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+                           "a14,\002,\002,a14,\002,\002)";
+  static char fmt_9994[] =
+      "(20x,3(i3,\002,\002),f4.1,\002, A,\002,i3,\002"
+      ", B,\002,i3,\002,\002,f4.1,\002, \002,\002C,\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char crc[14], cta[14], ctb[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___141 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___142 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(cta, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(cta, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cta, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transb == 'N') {
+    s_copy(ctb, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transb == 'T') {
+    s_copy(ctb, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ctb, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___141.ciunit = *nout;
+  s_wsfe(&io___141);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cta, (ftnlen)14);
+  do_fio(&c__1, ctb, (ftnlen)14);
+  e_wsfe();
+  io___142.ciunit = *nout;
+  s_wsfe(&io___142);
+  do_fio(&c__1, (char *)&(*m), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*k), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*alpha), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*ldb), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*beta), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* sprcn1_ */
+
+/* Subroutine */ int schk2_(char *sname, real *eps, real *thresh, integer *nout,
+                            integer *ntra, logical *trace, logical *rewi,
+                            logical *fatal, integer *nidim, integer *idim,
+                            integer *nalf, real *alf, integer *nbet, real *bet,
+                            integer *nmax, real *a, real *aa, real *as, real *b,
+                            real *bb, real *bs, real *c__, real *cc, real *cs,
+                            real *ct, real *g, integer *iorder,
+                            ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ichs[2] = "LR";
+  static char ichu[2] = "UL";
+
+  /* Format strings */
+  static char fmt_9994[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
+      i__3, i__4, i__5, i__6;
+  alist al__1;
+
+  /* Builtin functions */
+  integer f_rew(alist *), s_wsfe(cilist *), e_wsfe(void),
+      do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, m, n, ia, ib, na, nc, im, in, ms, ns, laa, lbb, lda, lcc, ldb,
+      ldc, ics;
+  real als, bls;
+  integer icu;
+  extern logical lse_(real *, real *, integer *);
+  real err, beta;
+  integer ldas, ldbs, ldcs;
+  logical same;
+  char side[1];
+  logical left, null;
+  char uplo[1];
+  real alpha;
+  logical isame[13];
+  extern /* Subroutine */ int smake_(
+      char *, char *, char *, integer *, integer *, real *, integer *, real *,
+      integer *, logical *, real *, ftnlen, ftnlen, ftnlen);
+  char sides[1];
+  extern /* Subroutine */ int smmch_(
+      char *, char *, integer *, integer *, integer *, real *, real *,
+      integer *, real *, integer *, real *, real *, integer *, real *, real *,
+      real *, integer *, real *, real *, logical *, integer *, logical *,
+      ftnlen, ftnlen);
+  integer nargs;
+  logical reset;
+  char uplos[1];
+  extern /* Subroutine */ int sprcn2_(integer *, integer *, char *, integer *,
+                                      char *, char *, integer *, integer *,
+                                      real *, integer *, integer *, real *,
+                                      integer *, ftnlen, ftnlen, ftnlen);
+  real errmax;
+  extern logical lseres_(char *, char *, integer *, integer *, real *, real *,
+                         integer *, ftnlen, ftnlen);
+  extern /* Subroutine */ void cssymm_(
+      integer *, char *, char *, integer *, integer *, real *, real *,
+      integer *, real *, integer *, real *, real *, integer *);
+
+  /* Fortran I/O blocks */
+  static cilist io___180 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___183 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___185 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___186 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___187 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___188 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___189 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests SSYMM. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --bet;
+  --g;
+  --ct;
+  --cs;
+  --cc;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --bs;
+  --bb;
+  b_dim1 = *nmax;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+
+  nargs = 12;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.f;
+
+  i__1 = *nidim;
+  for (im = 1; im <= i__1; ++im) {
+    m = idim[im];
+
+    i__2 = *nidim;
+    for (in = 1; in <= i__2; ++in) {
+      n = idim[in];
+      /*           Set LDC to 1 more than minimum value if room. */
+      ldc = m;
+      if (ldc < *nmax) {
+        ++ldc;
+      }
+      /*           Skip tests if not enough room. */
+      if (ldc > *nmax) {
+        goto L90;
+      }
+      lcc = ldc * n;
+      null = n <= 0 || m <= 0;
+
+      /*           Set LDB to 1 more than minimum value if room. */
+      ldb = m;
+      if (ldb < *nmax) {
+        ++ldb;
+      }
+      /*           Skip tests if not enough room. */
+      if (ldb > *nmax) {
+        goto L90;
+      }
+      lbb = ldb * n;
+
+      /*           Generate the matrix B. */
+
+      smake_("GE", " ", " ", &m, &n, &b[b_offset], nmax, &bb[1], &ldb, &reset,
+             &c_b103, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+      for (ics = 1; ics <= 2; ++ics) {
+        *(unsigned char *)side = *(unsigned char *)&ichs[ics - 1];
+        left = *(unsigned char *)side == 'L';
+
+        if (left) {
+          na = m;
+        } else {
+          na = n;
+        }
+        /*              Set LDA to 1 more than minimum value if room. */
+        lda = na;
+        if (lda < *nmax) {
+          ++lda;
+        }
+        /*              Skip tests if not enough room. */
+        if (lda > *nmax) {
+          goto L80;
+        }
+        laa = lda * na;
+
+        for (icu = 1; icu <= 2; ++icu) {
+          *(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+
+          /*                 Generate the symmetric matrix A. */
+
+          smake_("SY", uplo, " ", &na, &na, &a[a_offset], nmax, &aa[1], &lda,
+                 &reset, &c_b103, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+          i__3 = *nalf;
+          for (ia = 1; ia <= i__3; ++ia) {
+            alpha = alf[ia];
+
+            i__4 = *nbet;
+            for (ib = 1; ib <= i__4; ++ib) {
+              beta = bet[ib];
+
+              /*                       Generate the matrix C. */
+
+              smake_("GE", " ", " ", &m, &n, &c__[c_offset], nmax, &cc[1], &ldc,
+                     &reset, &c_b103, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+              ++nc;
+
+              /*                       Save every datum before calling the */
+              /*                       subroutine. */
+
+              *(unsigned char *)sides = *(unsigned char *)side;
+              *(unsigned char *)uplos = *(unsigned char *)uplo;
+              ms = m;
+              ns = n;
+              als = alpha;
+              i__5 = laa;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                as[i__] = aa[i__];
+                /* L10: */
+              }
+              ldas = lda;
+              i__5 = lbb;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                bs[i__] = bb[i__];
+                /* L20: */
+              }
+              ldbs = ldb;
+              bls = beta;
+              i__5 = lcc;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                cs[i__] = cc[i__];
+                /* L30: */
+              }
+              ldcs = ldc;
+
+              /*                       Call the subroutine. */
+
+              if (*trace) {
+                sprcn2_(ntra, &nc, sname, iorder, side, uplo, &m, &n, &alpha,
+                        &lda, &ldb, &beta, &ldc, (ftnlen)12, (ftnlen)1,
+                        (ftnlen)1);
+              }
+              if (*rewi) {
+                al__1.aerr = 0;
+                al__1.aunit = *ntra;
+                f_rew(&al__1);
+              }
+              cssymm_(iorder, side, uplo, &m, &n, &alpha, &aa[1], &lda, &bb[1],
+                      &ldb, &beta, &cc[1], &ldc);
+
+              /*                       Check if error-exit was taken
+               * incorrectly. */
+
+              if (!infoc_1.ok) {
+                io___180.ciunit = *nout;
+                s_wsfe(&io___180);
+                e_wsfe();
+                *fatal = TRUE_;
+                goto L110;
+              }
+
+              /*                       See what data changed inside subroutines.
+               */
+
+              isame[0] = *(unsigned char *)sides == *(unsigned char *)side;
+              isame[1] = *(unsigned char *)uplos == *(unsigned char *)uplo;
+              isame[2] = ms == m;
+              isame[3] = ns == n;
+              isame[4] = als == alpha;
+              isame[5] = lse_(&as[1], &aa[1], &laa);
+              isame[6] = ldas == lda;
+              isame[7] = lse_(&bs[1], &bb[1], &lbb);
+              isame[8] = ldbs == ldb;
+              isame[9] = bls == beta;
+              if (null) {
+                isame[10] = lse_(&cs[1], &cc[1], &lcc);
+              } else {
+                isame[10] = lseres_("GE", " ", &m, &n, &cs[1], &cc[1], &ldc,
+                                    (ftnlen)2, (ftnlen)1);
+              }
+              isame[11] = ldcs == ldc;
+
+              /*                       If data was incorrectly changed, report
+               * and */
+              /*                       return. */
+
+              same = TRUE_;
+              i__5 = nargs;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                same = same && isame[i__ - 1];
+                if (!isame[i__ - 1]) {
+                  io___183.ciunit = *nout;
+                  s_wsfe(&io___183);
+                  i__6 = i__ + 1;
+                  do_fio(&c__1, (char *)&i__6, (ftnlen)sizeof(integer));
+                  e_wsfe();
+                }
+                /* L40: */
+              }
+              if (!same) {
+                *fatal = TRUE_;
+                goto L110;
+              }
+
+              if (!null) {
+
+                /*                          Check the result. */
+
+                if (left) {
+                  smmch_("N", "N", &m, &n, &m, &alpha, &a[a_offset], nmax,
+                         &b[b_offset], nmax, &beta, &c__[c_offset], nmax,
+                         &ct[1], &g[1], &cc[1], &ldc, eps, &err, fatal, nout,
+                         &c_true, (ftnlen)1, (ftnlen)1);
+                } else {
+                  smmch_("N", "N", &m, &n, &n, &alpha, &b[b_offset], nmax,
+                         &a[a_offset], nmax, &beta, &c__[c_offset], nmax,
+                         &ct[1], &g[1], &cc[1], &ldc, eps, &err, fatal, nout,
+                         &c_true, (ftnlen)1, (ftnlen)1);
+                }
+                errmax = max(errmax, err);
+                /*                          If got really bad answer, report and
+                 */
+                /*                          return. */
+                if (*fatal) {
+                  goto L110;
+                }
+              }
+
+              /* L50: */
+            }
+
+            /* L60: */
+          }
+
+          /* L70: */
+        }
+
+      L80:;
+      }
+
+    L90:;
+    }
+
+    /* L100: */
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___185.ciunit = *nout;
+      s_wsfe(&io___185);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___186.ciunit = *nout;
+      s_wsfe(&io___186);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___187.ciunit = *nout;
+      s_wsfe(&io___187);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___188.ciunit = *nout;
+      s_wsfe(&io___188);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+  }
+  goto L120;
+
+L110:
+  io___189.ciunit = *nout;
+  s_wsfe(&io___189);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  sprcn2_(nout, &nc, sname, iorder, side, uplo, &m, &n, &alpha, &lda, &ldb,
+          &beta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+
+L120:
+  return 0;
+
+  /* L9995: */
+
+  /*     End of SCHK2. */
+
+} /* schk2_ */
+
+/* Subroutine */ int sprcn2_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *side, char *uplo,
+                             integer *m, integer *n, real *alpha, integer *lda,
+                             integer *ldb, real *beta, integer *ldc,
+                             ftnlen sname_len, ftnlen side_len,
+                             ftnlen uplo_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+                           "a14,\002,\002,a14,\002,\002)";
+  static char fmt_9994[] =
+      "(20x,2(i3,\002,\002),f4.1,\002, A,\002,i3,\002"
+      ", B,\002,i3,\002,\002,f4.1,\002, \002,\002C,\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char cs[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___193 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___194 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)side == 'L') {
+    s_copy(cs, "     CblasLeft", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cs, "    CblasRight", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___193.ciunit = *nout;
+  s_wsfe(&io___193);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cs, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  e_wsfe();
+  io___194.ciunit = *nout;
+  s_wsfe(&io___194);
+  do_fio(&c__1, (char *)&(*m), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*alpha), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*ldb), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*beta), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* sprcn2_ */
+
+/* Subroutine */ int schk3_(char *sname, real *eps, real *thresh, integer *nout,
+                            integer *ntra, logical *trace, logical *rewi,
+                            logical *fatal, integer *nidim, integer *idim,
+                            integer *nalf, real *alf, integer *nmax, real *a,
+                            real *aa, real *as, real *b, real *bb, real *bs,
+                            real *ct, real *g, real *c__, integer *iorder,
+                            ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ichu[2] = "UL";
+  static char icht[3] = "NTC";
+  static char ichd[2] = "UN";
+  static char ichs[2] = "LR";
+
+  /* Format strings */
+  static char fmt_9994[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
+      i__3, i__4, i__5;
+  alist al__1;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen), f_rew(alist *),
+      s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, j, m, n, ia, na, nc, im, in, ms, ns, laa, icd, lbb, lda, ldb,
+      ics;
+  real als;
+  integer ict, icu;
+  extern logical lse_(real *, real *, integer *);
+  real err;
+  char diag[1];
+  integer ldas, ldbs;
+  logical same;
+  char side[1];
+  logical left, null;
+  char uplo[1];
+  real alpha;
+  char diags[1];
+  logical isame[13];
+  extern /* Subroutine */ int smake_(
+      char *, char *, char *, integer *, integer *, real *, integer *, real *,
+      integer *, logical *, real *, ftnlen, ftnlen, ftnlen);
+  char sides[1];
+  extern /* Subroutine */ int smmch_(
+      char *, char *, integer *, integer *, integer *, real *, real *,
+      integer *, real *, integer *, real *, real *, integer *, real *, real *,
+      real *, integer *, real *, real *, logical *, integer *, logical *,
+      ftnlen, ftnlen);
+  integer nargs;
+  logical reset;
+  char uplos[1];
+  extern /* Subroutine */ int sprcn3_(integer *, integer *, char *, integer *,
+                                      char *, char *, char *, char *, integer *,
+                                      integer *, real *, integer *, integer *,
+                                      ftnlen, ftnlen, ftnlen, ftnlen, ftnlen);
+  char tranas[1], transa[1];
+  real errmax;
+  extern logical lseres_(char *, char *, integer *, integer *, real *, real *,
+                         integer *, ftnlen, ftnlen);
+  extern /* Subroutine */ void cstrmm_(
+      integer *, char *, char *, char *, char *, integer *, integer *, real *,
+      real *, integer *, real *, integer *),
+      cstrsm_(integer *, char *, char *, char *, char *, integer *, integer *,
+              real *, real *, integer *, real *, integer *);
+
+  /* Fortran I/O blocks */
+  static cilist io___235 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___238 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___240 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___241 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___242 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___243 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___244 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests STRMM and STRSM. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --g;
+  --ct;
+  --bs;
+  --bb;
+  b_dim1 = *nmax;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+
+  nargs = 11;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.f;
+  /*     Set up zero matrix for SMMCH. */
+  i__1 = *nmax;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = *nmax;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      c__[i__ + j * c_dim1] = 0.f;
+      /* L10: */
+    }
+    /* L20: */
+  }
+
+  i__1 = *nidim;
+  for (im = 1; im <= i__1; ++im) {
+    m = idim[im];
+
+    i__2 = *nidim;
+    for (in = 1; in <= i__2; ++in) {
+      n = idim[in];
+      /*           Set LDB to 1 more than minimum value if room. */
+      ldb = m;
+      if (ldb < *nmax) {
+        ++ldb;
+      }
+      /*           Skip tests if not enough room. */
+      if (ldb > *nmax) {
+        goto L130;
+      }
+      lbb = ldb * n;
+      null = m <= 0 || n <= 0;
+
+      for (ics = 1; ics <= 2; ++ics) {
+        *(unsigned char *)side = *(unsigned char *)&ichs[ics - 1];
+        left = *(unsigned char *)side == 'L';
+        if (left) {
+          na = m;
+        } else {
+          na = n;
+        }
+        /*              Set LDA to 1 more than minimum value if room. */
+        lda = na;
+        if (lda < *nmax) {
+          ++lda;
+        }
+        /*              Skip tests if not enough room. */
+        if (lda > *nmax) {
+          goto L130;
+        }
+        laa = lda * na;
+
+        for (icu = 1; icu <= 2; ++icu) {
+          *(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+
+          for (ict = 1; ict <= 3; ++ict) {
+            *(unsigned char *)transa = *(unsigned char *)&icht[ict - 1];
+
+            for (icd = 1; icd <= 2; ++icd) {
+              *(unsigned char *)diag = *(unsigned char *)&ichd[icd - 1];
+
+              i__3 = *nalf;
+              for (ia = 1; ia <= i__3; ++ia) {
+                alpha = alf[ia];
+
+                /*                          Generate the matrix A. */
+
+                smake_("TR", uplo, diag, &na, &na, &a[a_offset], nmax, &aa[1],
+                       &lda, &reset, &c_b103, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+                /*                          Generate the matrix B. */
+
+                smake_("GE", " ", " ", &m, &n, &b[b_offset], nmax, &bb[1], &ldb,
+                       &reset, &c_b103, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+                ++nc;
+
+                /*                          Save every datum before calling the
+                 */
+                /*                          subroutine. */
+
+                *(unsigned char *)sides = *(unsigned char *)side;
+                *(unsigned char *)uplos = *(unsigned char *)uplo;
+                *(unsigned char *)tranas = *(unsigned char *)transa;
+                *(unsigned char *)diags = *(unsigned char *)diag;
+                ms = m;
+                ns = n;
+                als = alpha;
+                i__4 = laa;
+                for (i__ = 1; i__ <= i__4; ++i__) {
+                  as[i__] = aa[i__];
+                  /* L30: */
+                }
+                ldas = lda;
+                i__4 = lbb;
+                for (i__ = 1; i__ <= i__4; ++i__) {
+                  bs[i__] = bb[i__];
+                  /* L40: */
+                }
+                ldbs = ldb;
+
+                /*                          Call the subroutine. */
+
+                if (s_cmp(sname + 9, "mm", (ftnlen)2, (ftnlen)2) == 0) {
+                  if (*trace) {
+                    sprcn3_(ntra, &nc, sname, iorder, side, uplo, transa, diag,
+                            &m, &n, &alpha, &lda, &ldb, (ftnlen)12, (ftnlen)1,
+                            (ftnlen)1, (ftnlen)1, (ftnlen)1);
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cstrmm_(iorder, side, uplo, transa, diag, &m, &n, &alpha,
+                          &aa[1], &lda, &bb[1], &ldb);
+                } else if (s_cmp(sname + 9, "sm", (ftnlen)2, (ftnlen)2) == 0) {
+                  if (*trace) {
+                    sprcn3_(ntra, &nc, sname, iorder, side, uplo, transa, diag,
+                            &m, &n, &alpha, &lda, &ldb, (ftnlen)12, (ftnlen)1,
+                            (ftnlen)1, (ftnlen)1, (ftnlen)1);
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cstrsm_(iorder, side, uplo, transa, diag, &m, &n, &alpha,
+                          &aa[1], &lda, &bb[1], &ldb);
+                }
+
+                /*                          Check if error-exit was taken
+                 * incorrectly. */
+
+                if (!infoc_1.ok) {
+                  io___235.ciunit = *nout;
+                  s_wsfe(&io___235);
+                  e_wsfe();
+                  *fatal = TRUE_;
+                  goto L150;
+                }
+
+                /*                          See what data changed inside
+                 * subroutines. */
+
+                isame[0] = *(unsigned char *)sides == *(unsigned char *)side;
+                isame[1] = *(unsigned char *)uplos == *(unsigned char *)uplo;
+                isame[2] = *(unsigned char *)tranas == *(unsigned char *)transa;
+                isame[3] = *(unsigned char *)diags == *(unsigned char *)diag;
+                isame[4] = ms == m;
+                isame[5] = ns == n;
+                isame[6] = als == alpha;
+                isame[7] = lse_(&as[1], &aa[1], &laa);
+                isame[8] = ldas == lda;
+                if (null) {
+                  isame[9] = lse_(&bs[1], &bb[1], &lbb);
+                } else {
+                  isame[9] = lseres_("GE", " ", &m, &n, &bs[1], &bb[1], &ldb,
+                                     (ftnlen)2, (ftnlen)1);
+                }
+                isame[10] = ldbs == ldb;
+
+                /*                          If data was incorrectly changed,
+                 * report and */
+                /*                          return. */
+
+                same = TRUE_;
+                i__4 = nargs;
+                for (i__ = 1; i__ <= i__4; ++i__) {
+                  same = same && isame[i__ - 1];
+                  if (!isame[i__ - 1]) {
+                    io___238.ciunit = *nout;
+                    s_wsfe(&io___238);
+                    i__5 = i__ + 1;
+                    do_fio(&c__1, (char *)&i__5, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  /* L50: */
+                }
+                if (!same) {
+                  *fatal = TRUE_;
+                  goto L150;
+                }
+
+                if (!null) {
+                  if (s_cmp(sname + 9, "mm", (ftnlen)2, (ftnlen)2) == 0) {
+
+                    /*                                Check the result. */
+
+                    if (left) {
+                      smmch_(transa, "N", &m, &n, &m, &alpha, &a[a_offset],
+                             nmax, &b[b_offset], nmax, &c_b103, &c__[c_offset],
+                             nmax, &ct[1], &g[1], &bb[1], &ldb, eps, &err,
+                             fatal, nout, &c_true, (ftnlen)1, (ftnlen)1);
+                    } else {
+                      smmch_("N", transa, &m, &n, &n, &alpha, &b[b_offset],
+                             nmax, &a[a_offset], nmax, &c_b103, &c__[c_offset],
+                             nmax, &ct[1], &g[1], &bb[1], &ldb, eps, &err,
+                             fatal, nout, &c_true, (ftnlen)1, (ftnlen)1);
+                    }
+                  } else if (s_cmp(sname + 9, "sm", (ftnlen)2, (ftnlen)2) ==
+                             0) {
+
+                    /*                                Compute approximation to
+                     * original */
+                    /*                                matrix. */
+
+                    i__4 = n;
+                    for (j = 1; j <= i__4; ++j) {
+                      i__5 = m;
+                      for (i__ = 1; i__ <= i__5; ++i__) {
+                        c__[i__ + j * c_dim1] = bb[i__ + (j - 1) * ldb];
+                        bb[i__ + (j - 1) * ldb] = alpha * b[i__ + j * b_dim1];
+                        /* L60: */
+                      }
+                      /* L70: */
+                    }
+
+                    if (left) {
+                      smmch_(transa, "N", &m, &n, &m, &c_b89, &a[a_offset],
+                             nmax, &c__[c_offset], nmax, &c_b103, &b[b_offset],
+                             nmax, &ct[1], &g[1], &bb[1], &ldb, eps, &err,
+                             fatal, nout, &c_false, (ftnlen)1, (ftnlen)1);
+                    } else {
+                      smmch_("N", transa, &m, &n, &n, &c_b89, &c__[c_offset],
+                             nmax, &a[a_offset], nmax, &c_b103, &b[b_offset],
+                             nmax, &ct[1], &g[1], &bb[1], &ldb, eps, &err,
+                             fatal, nout, &c_false, (ftnlen)1, (ftnlen)1);
+                    }
+                  }
+                  errmax = max(errmax, err);
+                  /*                             If got really bad answer,
+                   * report and */
+                  /*                             return. */
+                  if (*fatal) {
+                    goto L150;
+                  }
+                }
+
+                /* L80: */
+              }
+
+              /* L90: */
+            }
+
+            /* L100: */
+          }
+
+          /* L110: */
+        }
+
+        /* L120: */
+      }
+
+    L130:;
+    }
+
+    /* L140: */
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___240.ciunit = *nout;
+      s_wsfe(&io___240);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___241.ciunit = *nout;
+      s_wsfe(&io___241);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___242.ciunit = *nout;
+      s_wsfe(&io___242);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___243.ciunit = *nout;
+      s_wsfe(&io___243);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+  }
+  goto L160;
+
+L150:
+  io___244.ciunit = *nout;
+  s_wsfe(&io___244);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  sprcn3_(ntra, &nc, sname, iorder, side, uplo, transa, diag, &m, &n, &alpha,
+          &lda, &ldb, (ftnlen)12, (ftnlen)1, (ftnlen)1, (ftnlen)1, (ftnlen)1);
+
+L160:
+  return 0;
+
+  /* L9995: */
+
+  /*     End of SCHK3. */
+
+} /* schk3_ */
+
+/* Subroutine */ int sprcn3_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *side, char *uplo,
+                             char *transa, char *diag, integer *m, integer *n,
+                             real *alpha, integer *lda, integer *ldb,
+                             ftnlen sname_len, ftnlen side_len, ftnlen uplo_len,
+                             ftnlen transa_len, ftnlen diag_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+                           "a14,\002,\002,a14,\002,\002)";
+  static char fmt_9994[] = "(22x,2(a14,\002,\002),2(i3,\002,\002),f4.1,"
+                           "\002, A,\002,i3,\002, B,\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char ca[14], cd[14], cs[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___250 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___251 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)side == 'L') {
+    s_copy(cs, "     CblasLeft", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cs, "    CblasRight", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(ca, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(ca, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ca, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)diag == 'N') {
+    s_copy(cd, "  CblasNonUnit", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cd, "     CblasUnit", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, "CblasRowMajor", (ftnlen)14, (ftnlen)13);
+  } else {
+    s_copy(crc, "CblasColMajor", (ftnlen)14, (ftnlen)13);
+  }
+  io___250.ciunit = *nout;
+  s_wsfe(&io___250);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cs, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  e_wsfe();
+  io___251.ciunit = *nout;
+  s_wsfe(&io___251);
+  do_fio(&c__1, ca, (ftnlen)14);
+  do_fio(&c__1, cd, (ftnlen)14);
+  do_fio(&c__1, (char *)&(*m), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*alpha), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*ldb), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* sprcn3_ */
+
+/* Subroutine */ int schk4_(char *sname, real *eps, real *thresh, integer *nout,
+                            integer *ntra, logical *trace, logical *rewi,
+                            logical *fatal, integer *nidim, integer *idim,
+                            integer *nalf, real *alf, integer *nbet, real *bet,
+                            integer *nmax, real *a, real *aa, real *as, real *b,
+                            real *bb, real *bs, real *c__, real *cc, real *cs,
+                            real *ct, real *g, integer *iorder,
+                            ftnlen sname_len) {
+  /* Initialized data */
+
+  static char icht[3] = "NTC";
+  static char ichu[2] = "UL";
+
+  /* Format strings */
+  static char fmt_9993[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+                           " \002,i3)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
+      i__3, i__4, i__5, i__6;
+  alist al__1;
+
+  /* Builtin functions */
+  integer f_rew(alist *), s_wsfe(cilist *), e_wsfe(void),
+      do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, j, k, n, ia, ib, jc, ma, na, nc, ik, in, jj, lj, ks, ns, laa,
+      lda, lcc, ldc;
+  real als;
+  integer ict, icu;
+  extern logical lse_(real *, real *, integer *);
+  real err, beta;
+  integer ldas, ldcs;
+  logical same;
+  real bets;
+  logical tran, null;
+  char uplo[1];
+  real alpha;
+  logical isame[13];
+  extern /* Subroutine */ int smake_(
+      char *, char *, char *, integer *, integer *, real *, integer *, real *,
+      integer *, logical *, real *, ftnlen, ftnlen, ftnlen),
+      smmch_(char *, char *, integer *, integer *, integer *, real *, real *,
+             integer *, real *, integer *, real *, real *, integer *, real *,
+             real *, real *, integer *, real *, real *, logical *, integer *,
+             logical *, ftnlen, ftnlen);
+  integer nargs;
+  logical reset;
+  char trans[1];
+  logical upper;
+  char uplos[1];
+  extern /* Subroutine */ int sprcn4_(
+      integer *, integer *, char *, integer *, char *, char *, integer *,
+      integer *, real *, integer *, real *, integer *, ftnlen, ftnlen, ftnlen);
+  real errmax;
+  extern logical lseres_(char *, char *, integer *, integer *, real *, real *,
+                         integer *, ftnlen, ftnlen);
+  char transs[1];
+  extern /* Subroutine */ void cssyrk_(
+      integer *, char *, char *, integer *, integer *, real *, real *,
+      integer *, real *, real *, integer *);
+
+  /* Fortran I/O blocks */
+  static cilist io___288 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___291 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___297 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___298 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___299 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___300 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___301 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___302 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests SSYRK. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --bet;
+  --g;
+  --ct;
+  --cs;
+  --cc;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --bs;
+  --bb;
+  b_dim1 = *nmax;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+
+  nargs = 10;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.f;
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+    /*        Set LDC to 1 more than minimum value if room. */
+    ldc = n;
+    if (ldc < *nmax) {
+      ++ldc;
+    }
+    /*        Skip tests if not enough room. */
+    if (ldc > *nmax) {
+      goto L100;
+    }
+    lcc = ldc * n;
+    null = n <= 0;
+
+    i__2 = *nidim;
+    for (ik = 1; ik <= i__2; ++ik) {
+      k = idim[ik];
+
+      for (ict = 1; ict <= 3; ++ict) {
+        *(unsigned char *)trans = *(unsigned char *)&icht[ict - 1];
+        tran = *(unsigned char *)trans == 'T' || *(unsigned char *)trans == 'C';
+        if (tran) {
+          ma = k;
+          na = n;
+        } else {
+          ma = n;
+          na = k;
+        }
+        /*              Set LDA to 1 more than minimum value if room. */
+        lda = ma;
+        if (lda < *nmax) {
+          ++lda;
+        }
+        /*              Skip tests if not enough room. */
+        if (lda > *nmax) {
+          goto L80;
+        }
+        laa = lda * na;
+
+        /*              Generate the matrix A. */
+
+        smake_("GE", " ", " ", &ma, &na, &a[a_offset], nmax, &aa[1], &lda,
+               &reset, &c_b103, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+        for (icu = 1; icu <= 2; ++icu) {
+          *(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+          upper = *(unsigned char *)uplo == 'U';
+
+          i__3 = *nalf;
+          for (ia = 1; ia <= i__3; ++ia) {
+            alpha = alf[ia];
+
+            i__4 = *nbet;
+            for (ib = 1; ib <= i__4; ++ib) {
+              beta = bet[ib];
+
+              /*                       Generate the matrix C. */
+
+              smake_("SY", uplo, " ", &n, &n, &c__[c_offset], nmax, &cc[1],
+                     &ldc, &reset, &c_b103, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+              ++nc;
+
+              /*                       Save every datum before calling the
+               * subroutine. */
+
+              *(unsigned char *)uplos = *(unsigned char *)uplo;
+              *(unsigned char *)transs = *(unsigned char *)trans;
+              ns = n;
+              ks = k;
+              als = alpha;
+              i__5 = laa;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                as[i__] = aa[i__];
+                /* L10: */
+              }
+              ldas = lda;
+              bets = beta;
+              i__5 = lcc;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                cs[i__] = cc[i__];
+                /* L20: */
+              }
+              ldcs = ldc;
+
+              /*                       Call the subroutine. */
+
+              if (*trace) {
+                sprcn4_(ntra, &nc, sname, iorder, uplo, trans, &n, &k, &alpha,
+                        &lda, &beta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+              }
+              if (*rewi) {
+                al__1.aerr = 0;
+                al__1.aunit = *ntra;
+                f_rew(&al__1);
+              }
+              cssyrk_(iorder, uplo, trans, &n, &k, &alpha, &aa[1], &lda, &beta,
+                      &cc[1], &ldc);
+
+              /*                       Check if error-exit was taken
+               * incorrectly. */
+
+              if (!infoc_1.ok) {
+                io___288.ciunit = *nout;
+                s_wsfe(&io___288);
+                e_wsfe();
+                *fatal = TRUE_;
+                goto L120;
+              }
+
+              /*                       See what data changed inside subroutines.
+               */
+
+              isame[0] = *(unsigned char *)uplos == *(unsigned char *)uplo;
+              isame[1] = *(unsigned char *)transs == *(unsigned char *)trans;
+              isame[2] = ns == n;
+              isame[3] = ks == k;
+              isame[4] = als == alpha;
+              isame[5] = lse_(&as[1], &aa[1], &laa);
+              isame[6] = ldas == lda;
+              isame[7] = bets == beta;
+              if (null) {
+                isame[8] = lse_(&cs[1], &cc[1], &lcc);
+              } else {
+                isame[8] = lseres_("SY", uplo, &n, &n, &cs[1], &cc[1], &ldc,
+                                   (ftnlen)2, (ftnlen)1);
+              }
+              isame[9] = ldcs == ldc;
+
+              /*                       If data was incorrectly changed, report
+               * and */
+              /*                       return. */
+
+              same = TRUE_;
+              i__5 = nargs;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                same = same && isame[i__ - 1];
+                if (!isame[i__ - 1]) {
+                  io___291.ciunit = *nout;
+                  s_wsfe(&io___291);
+                  i__6 = i__ + 1;
+                  do_fio(&c__1, (char *)&i__6, (ftnlen)sizeof(integer));
+                  e_wsfe();
+                }
+                /* L30: */
+              }
+              if (!same) {
+                *fatal = TRUE_;
+                goto L120;
+              }
+
+              if (!null) {
+
+                /*                          Check the result column by column.
+                 */
+
+                jc = 1;
+                i__5 = n;
+                for (j = 1; j <= i__5; ++j) {
+                  if (upper) {
+                    jj = 1;
+                    lj = j;
+                  } else {
+                    jj = j;
+                    lj = n - j + 1;
+                  }
+                  if (tran) {
+                    smmch_("T", "N", &lj, &c__1, &k, &alpha,
+                           &a[jj * a_dim1 + 1], nmax, &a[j * a_dim1 + 1], nmax,
+                           &beta, &c__[jj + j * c_dim1], nmax, &ct[1], &g[1],
+                           &cc[jc], &ldc, eps, &err, fatal, nout, &c_true,
+                           (ftnlen)1, (ftnlen)1);
+                  } else {
+                    smmch_("N", "T", &lj, &c__1, &k, &alpha, &a[jj + a_dim1],
+                           nmax, &a[j + a_dim1], nmax, &beta,
+                           &c__[jj + j * c_dim1], nmax, &ct[1], &g[1], &cc[jc],
+                           &ldc, eps, &err, fatal, nout, &c_true, (ftnlen)1,
+                           (ftnlen)1);
+                  }
+                  if (upper) {
+                    jc += ldc;
+                  } else {
+                    jc = jc + ldc + 1;
+                  }
+                  errmax = max(errmax, err);
+                  /*                             If got really bad answer,
+                   * report and */
+                  /*                             return. */
+                  if (*fatal) {
+                    goto L110;
+                  }
+                  /* L40: */
+                }
+              }
+
+              /* L50: */
+            }
+
+            /* L60: */
+          }
+
+          /* L70: */
+        }
+
+      L80:;
+      }
+
+      /* L90: */
+    }
+
+  L100:;
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___297.ciunit = *nout;
+      s_wsfe(&io___297);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___298.ciunit = *nout;
+      s_wsfe(&io___298);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___299.ciunit = *nout;
+      s_wsfe(&io___299);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___300.ciunit = *nout;
+      s_wsfe(&io___300);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+  }
+  goto L130;
+
+L110:
+  if (n > 1) {
+    io___301.ciunit = *nout;
+    s_wsfe(&io___301);
+    do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L120:
+  io___302.ciunit = *nout;
+  s_wsfe(&io___302);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  sprcn4_(nout, &nc, sname, iorder, uplo, trans, &n, &k, &alpha, &lda, &beta,
+          &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+
+L130:
+  return 0;
+
+  /* L9994: */
+
+  /*     End of SCHK4. */
+
+} /* schk4_ */
+
+/* Subroutine */ int sprcn4_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *uplo, char *transa,
+                             integer *n, integer *k, real *alpha, integer *lda,
+                             real *beta, integer *ldc, ftnlen sname_len,
+                             ftnlen uplo_len, ftnlen transa_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+                           "\002))";
+  static char fmt_9994[] = "(20x,2(i3,\002,\002),f4.1,\002, A,\002,i3"
+                           ",\002,\002,f4.1,\002, C,\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char ca[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___306 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___307 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(ca, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(ca, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ca, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___306.ciunit = *nout;
+  s_wsfe(&io___306);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  do_fio(&c__1, ca, (ftnlen)14);
+  e_wsfe();
+  io___307.ciunit = *nout;
+  s_wsfe(&io___307);
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*k), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*alpha), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*beta), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* sprcn4_ */
+
+/* Subroutine */ int schk5_(char *sname, real *eps, real *thresh, integer *nout,
+                            integer *ntra, logical *trace, logical *rewi,
+                            logical *fatal, integer *nidim, integer *idim,
+                            integer *nalf, real *alf, integer *nbet, real *bet,
+                            integer *nmax, real *ab, real *aa, real *as,
+                            real *bb, real *bs, real *c__, real *cc, real *cs,
+                            real *ct, real *g, real *w, integer *iorder,
+                            ftnlen sname_len) {
+  /* Initialized data */
+
+  static char icht[3] = "NTC";
+  static char ichu[2] = "UL";
+
+  /* Format strings */
+  static char fmt_9993[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+                           " \002,i3)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer c_dim1, c_offset, i__1, i__2, i__3, i__4, i__5, i__6, i__7, i__8;
+  alist al__1;
+
+  /* Builtin functions */
+  integer f_rew(alist *), s_wsfe(cilist *), e_wsfe(void),
+      do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, j, k, n, ia, ib, jc, ma, na, nc, ik, in, jj, lj, ks, ns, laa,
+      lbb, lda, lcc, ldb, ldc;
+  real als;
+  integer ict, icu;
+  extern logical lse_(real *, real *, integer *);
+  real err;
+  integer jjab;
+  real beta;
+  integer ldas, ldbs, ldcs;
+  logical same;
+  real bets;
+  logical tran, null;
+  char uplo[1];
+  real alpha;
+  logical isame[13];
+  extern /* Subroutine */ int smake_(
+      char *, char *, char *, integer *, integer *, real *, integer *, real *,
+      integer *, logical *, real *, ftnlen, ftnlen, ftnlen),
+      smmch_(char *, char *, integer *, integer *, integer *, real *, real *,
+             integer *, real *, integer *, real *, real *, integer *, real *,
+             real *, real *, integer *, real *, real *, logical *, integer *,
+             logical *, ftnlen, ftnlen);
+  integer nargs;
+  logical reset;
+  char trans[1];
+  logical upper;
+  char uplos[1];
+  extern /* Subroutine */ int sprcn5_(integer *, integer *, char *, integer *,
+                                      char *, char *, integer *, integer *,
+                                      real *, integer *, integer *, real *,
+                                      integer *, ftnlen, ftnlen, ftnlen);
+  real errmax;
+  extern logical lseres_(char *, char *, integer *, integer *, real *, real *,
+                         integer *, ftnlen, ftnlen);
+  char transs[1];
+  extern /* Subroutine */ void cssyr2k_(
+      integer *, char *, char *, integer *, integer *, real *, real *,
+      integer *, real *, integer *, real *, real *, integer *);
+
+  /* Fortran I/O blocks */
+  static cilist io___347 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___350 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___357 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___358 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___359 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___360 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___361 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___362 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests SSYR2K. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --bet;
+  --w;
+  --g;
+  --ct;
+  --cs;
+  --cc;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --bs;
+  --bb;
+  --as;
+  --aa;
+  --ab;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+
+  nargs = 12;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.f;
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+    /*        Set LDC to 1 more than minimum value if room. */
+    ldc = n;
+    if (ldc < *nmax) {
+      ++ldc;
+    }
+    /*        Skip tests if not enough room. */
+    if (ldc > *nmax) {
+      goto L130;
+    }
+    lcc = ldc * n;
+    null = n <= 0;
+
+    i__2 = *nidim;
+    for (ik = 1; ik <= i__2; ++ik) {
+      k = idim[ik];
+
+      for (ict = 1; ict <= 3; ++ict) {
+        *(unsigned char *)trans = *(unsigned char *)&icht[ict - 1];
+        tran = *(unsigned char *)trans == 'T' || *(unsigned char *)trans == 'C';
+        if (tran) {
+          ma = k;
+          na = n;
+        } else {
+          ma = n;
+          na = k;
+        }
+        /*              Set LDA to 1 more than minimum value if room. */
+        lda = ma;
+        if (lda < *nmax) {
+          ++lda;
+        }
+        /*              Skip tests if not enough room. */
+        if (lda > *nmax) {
+          goto L110;
+        }
+        laa = lda * na;
+
+        /*              Generate the matrix A. */
+
+        if (tran) {
+          i__3 = *nmax << 1;
+          smake_("GE", " ", " ", &ma, &na, &ab[1], &i__3, &aa[1], &lda, &reset,
+                 &c_b103, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        } else {
+          smake_("GE", " ", " ", &ma, &na, &ab[1], nmax, &aa[1], &lda, &reset,
+                 &c_b103, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        }
+
+        /*              Generate the matrix B. */
+
+        ldb = lda;
+        lbb = laa;
+        if (tran) {
+          i__3 = *nmax << 1;
+          smake_("GE", " ", " ", &ma, &na, &ab[k + 1], &i__3, &bb[1], &ldb,
+                 &reset, &c_b103, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        } else {
+          smake_("GE", " ", " ", &ma, &na, &ab[k * *nmax + 1], nmax, &bb[1],
+                 &ldb, &reset, &c_b103, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        }
+
+        for (icu = 1; icu <= 2; ++icu) {
+          *(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+          upper = *(unsigned char *)uplo == 'U';
+
+          i__3 = *nalf;
+          for (ia = 1; ia <= i__3; ++ia) {
+            alpha = alf[ia];
+
+            i__4 = *nbet;
+            for (ib = 1; ib <= i__4; ++ib) {
+              beta = bet[ib];
+
+              /*                       Generate the matrix C. */
+
+              smake_("SY", uplo, " ", &n, &n, &c__[c_offset], nmax, &cc[1],
+                     &ldc, &reset, &c_b103, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+              ++nc;
+
+              /*                       Save every datum before calling the
+               * subroutine. */
+
+              *(unsigned char *)uplos = *(unsigned char *)uplo;
+              *(unsigned char *)transs = *(unsigned char *)trans;
+              ns = n;
+              ks = k;
+              als = alpha;
+              i__5 = laa;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                as[i__] = aa[i__];
+                /* L10: */
+              }
+              ldas = lda;
+              i__5 = lbb;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                bs[i__] = bb[i__];
+                /* L20: */
+              }
+              ldbs = ldb;
+              bets = beta;
+              i__5 = lcc;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                cs[i__] = cc[i__];
+                /* L30: */
+              }
+              ldcs = ldc;
+
+              /*                       Call the subroutine. */
+
+              if (*trace) {
+                sprcn5_(ntra, &nc, sname, iorder, uplo, trans, &n, &k, &alpha,
+                        &lda, &ldb, &beta, &ldc, (ftnlen)12, (ftnlen)1,
+                        (ftnlen)1);
+              }
+              if (*rewi) {
+                al__1.aerr = 0;
+                al__1.aunit = *ntra;
+                f_rew(&al__1);
+              }
+              cssyr2k_(iorder, uplo, trans, &n, &k, &alpha, &aa[1], &lda,
+                       &bb[1], &ldb, &beta, &cc[1], &ldc);
+
+              /*                       Check if error-exit was taken
+               * incorrectly. */
+
+              if (!infoc_1.ok) {
+                io___347.ciunit = *nout;
+                s_wsfe(&io___347);
+                e_wsfe();
+                *fatal = TRUE_;
+                goto L150;
+              }
+
+              /*                       See what data changed inside subroutines.
+               */
+
+              isame[0] = *(unsigned char *)uplos == *(unsigned char *)uplo;
+              isame[1] = *(unsigned char *)transs == *(unsigned char *)trans;
+              isame[2] = ns == n;
+              isame[3] = ks == k;
+              isame[4] = als == alpha;
+              isame[5] = lse_(&as[1], &aa[1], &laa);
+              isame[6] = ldas == lda;
+              isame[7] = lse_(&bs[1], &bb[1], &lbb);
+              isame[8] = ldbs == ldb;
+              isame[9] = bets == beta;
+              if (null) {
+                isame[10] = lse_(&cs[1], &cc[1], &lcc);
+              } else {
+                isame[10] = lseres_("SY", uplo, &n, &n, &cs[1], &cc[1], &ldc,
+                                    (ftnlen)2, (ftnlen)1);
+              }
+              isame[11] = ldcs == ldc;
+
+              /*                       If data was incorrectly changed, report
+               * and */
+              /*                       return. */
+
+              same = TRUE_;
+              i__5 = nargs;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                same = same && isame[i__ - 1];
+                if (!isame[i__ - 1]) {
+                  io___350.ciunit = *nout;
+                  s_wsfe(&io___350);
+                  i__6 = i__ + 1;
+                  do_fio(&c__1, (char *)&i__6, (ftnlen)sizeof(integer));
+                  e_wsfe();
+                }
+                /* L40: */
+              }
+              if (!same) {
+                *fatal = TRUE_;
+                goto L150;
+              }
+
+              if (!null) {
+
+                /*                          Check the result column by column.
+                 */
+
+                jjab = 1;
+                jc = 1;
+                i__5 = n;
+                for (j = 1; j <= i__5; ++j) {
+                  if (upper) {
+                    jj = 1;
+                    lj = j;
+                  } else {
+                    jj = j;
+                    lj = n - j + 1;
+                  }
+                  if (tran) {
+                    i__6 = k;
+                    for (i__ = 1; i__ <= i__6; ++i__) {
+                      w[i__] = ab[(j - 1 << 1) * *nmax + k + i__];
+                      w[k + i__] = ab[(j - 1 << 1) * *nmax + i__];
+                      /* L50: */
+                    }
+                    i__6 = k << 1;
+                    i__7 = *nmax << 1;
+                    i__8 = *nmax << 1;
+                    smmch_("T", "N", &lj, &c__1, &i__6, &alpha, &ab[jjab],
+                           &i__7, &w[1], &i__8, &beta, &c__[jj + j * c_dim1],
+                           nmax, &ct[1], &g[1], &cc[jc], &ldc, eps, &err, fatal,
+                           nout, &c_true, (ftnlen)1, (ftnlen)1);
+                  } else {
+                    i__6 = k;
+                    for (i__ = 1; i__ <= i__6; ++i__) {
+                      w[i__] = ab[(k + i__ - 1) * *nmax + j];
+                      w[k + i__] = ab[(i__ - 1) * *nmax + j];
+                      /* L60: */
+                    }
+                    i__6 = k << 1;
+                    i__7 = *nmax << 1;
+                    smmch_("N", "N", &lj, &c__1, &i__6, &alpha, &ab[jj], nmax,
+                           &w[1], &i__7, &beta, &c__[jj + j * c_dim1], nmax,
+                           &ct[1], &g[1], &cc[jc], &ldc, eps, &err, fatal, nout,
+                           &c_true, (ftnlen)1, (ftnlen)1);
+                  }
+                  if (upper) {
+                    jc += ldc;
+                  } else {
+                    jc = jc + ldc + 1;
+                    if (tran) {
+                      jjab += *nmax << 1;
+                    }
+                  }
+                  errmax = max(errmax, err);
+                  /*                             If got really bad answer,
+                   * report and */
+                  /*                             return. */
+                  if (*fatal) {
+                    goto L140;
+                  }
+                  /* L70: */
+                }
+              }
+
+              /* L80: */
+            }
+
+            /* L90: */
+          }
+
+          /* L100: */
+        }
+
+      L110:;
+      }
+
+      /* L120: */
+    }
+
+  L130:;
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___357.ciunit = *nout;
+      s_wsfe(&io___357);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___358.ciunit = *nout;
+      s_wsfe(&io___358);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___359.ciunit = *nout;
+      s_wsfe(&io___359);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___360.ciunit = *nout;
+      s_wsfe(&io___360);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+  }
+  goto L160;
+
+L140:
+  if (n > 1) {
+    io___361.ciunit = *nout;
+    s_wsfe(&io___361);
+    do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L150:
+  io___362.ciunit = *nout;
+  s_wsfe(&io___362);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  sprcn5_(nout, &nc, sname, iorder, uplo, trans, &n, &k, &alpha, &lda, &ldb,
+          &beta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+
+L160:
+  return 0;
+
+  /* L9994: */
+
+  /*     End of SCHK5. */
+
+} /* schk5_ */
+
+/* Subroutine */ int sprcn5_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *uplo, char *transa,
+                             integer *n, integer *k, real *alpha, integer *lda,
+                             integer *ldb, real *beta, integer *ldc,
+                             ftnlen sname_len, ftnlen uplo_len,
+                             ftnlen transa_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+                           "\002))";
+  static char fmt_9994[] =
+      "(20x,2(i3,\002,\002),f4.1,\002, A,\002,i3,\002"
+      ", B\002,i3,\002,\002,f4.1,\002, C,\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char ca[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___366 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___367 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(ca, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(ca, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ca, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___366.ciunit = *nout;
+  s_wsfe(&io___366);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  do_fio(&c__1, ca, (ftnlen)14);
+  e_wsfe();
+  io___367.ciunit = *nout;
+  s_wsfe(&io___367);
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*k), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*alpha), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*ldb), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*beta), (ftnlen)sizeof(real));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* sprcn5_ */
+
+/* Subroutine */ int smake_(char *type__, char *uplo, char *diag, integer *m,
+                            integer *n, real *a, integer *nmax, real *aa,
+                            integer *lda, logical *reset, real *transl,
+                            ftnlen type_len, ftnlen uplo_len, ftnlen diag_len) {
+  /* System generated locals */
+  integer a_dim1, a_offset, i__1, i__2;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen);
+
+  /* Local variables */
+  integer i__, j;
+  logical gen, tri, sym;
+  integer ibeg, iend;
+  extern real sbeg_(logical *);
+  logical unit, lower, upper;
+
+  /*  Generates values for an M by N matrix A. */
+  /*  Stores the values in the array AA in the data structure required */
+  /*  by the routine, with unwanted elements set to rogue value. */
+
+  /*  TYPE is 'GE', 'SY' or 'TR'. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. External Functions .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --aa;
+
+  /* Function Body */
+  gen = s_cmp(type__, "GE", (ftnlen)2, (ftnlen)2) == 0;
+  sym = s_cmp(type__, "SY", (ftnlen)2, (ftnlen)2) == 0;
+  tri = s_cmp(type__, "TR", (ftnlen)2, (ftnlen)2) == 0;
+  upper = (sym || tri) && *(unsigned char *)uplo == 'U';
+  lower = (sym || tri) && *(unsigned char *)uplo == 'L';
+  unit = tri && *(unsigned char *)diag == 'U';
+
+  /*     Generate data in array A. */
+
+  i__1 = *n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = *m;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      if (gen || upper && i__ <= j || lower && i__ >= j) {
+        a[i__ + j * a_dim1] = sbeg_(reset) + *transl;
+        if (i__ != j) {
+          /*                 Set some elements to zero */
+          if (*n > 3 && j == *n / 2) {
+            a[i__ + j * a_dim1] = 0.f;
+          }
+          if (sym) {
+            a[j + i__ * a_dim1] = a[i__ + j * a_dim1];
+          } else if (tri) {
+            a[j + i__ * a_dim1] = 0.f;
+          }
+        }
+      }
+      /* L10: */
+    }
+    if (tri) {
+      a[j + j * a_dim1] += 1.f;
+    }
+    if (unit) {
+      a[j + j * a_dim1] = 1.f;
+    }
+    /* L20: */
+  }
+
+  /*     Store elements in array AS in data structure required by routine. */
+
+  if (s_cmp(type__, "GE", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      i__2 = *m;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        aa[i__ + (j - 1) * *lda] = a[i__ + j * a_dim1];
+        /* L30: */
+      }
+      i__2 = *lda;
+      for (i__ = *m + 1; i__ <= i__2; ++i__) {
+        aa[i__ + (j - 1) * *lda] = -1e10f;
+        /* L40: */
+      }
+      /* L50: */
+    }
+  } else if (s_cmp(type__, "SY", (ftnlen)2, (ftnlen)2) == 0 ||
+             s_cmp(type__, "TR", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      if (upper) {
+        ibeg = 1;
+        if (unit) {
+          iend = j - 1;
+        } else {
+          iend = j;
+        }
+      } else {
+        if (unit) {
+          ibeg = j + 1;
+        } else {
+          ibeg = j;
+        }
+        iend = *n;
+      }
+      i__2 = ibeg - 1;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        aa[i__ + (j - 1) * *lda] = -1e10f;
+        /* L60: */
+      }
+      i__2 = iend;
+      for (i__ = ibeg; i__ <= i__2; ++i__) {
+        aa[i__ + (j - 1) * *lda] = a[i__ + j * a_dim1];
+        /* L70: */
+      }
+      i__2 = *lda;
+      for (i__ = iend + 1; i__ <= i__2; ++i__) {
+        aa[i__ + (j - 1) * *lda] = -1e10f;
+        /* L80: */
+      }
+      /* L90: */
+    }
+  }
+  return 0;
+
+  /*     End of SMAKE. */
+
+} /* smake_ */
+
+/* Subroutine */ int smmch_(char *transa, char *transb, integer *m, integer *n,
+                            integer *kk, real *alpha, real *a, integer *lda,
+                            real *b, integer *ldb, real *beta, real *c__,
+                            integer *ldc, real *ct, real *g, real *cc,
+                            integer *ldcc, real *eps, real *err, logical *fatal,
+                            integer *nout, logical *mv, ftnlen transa_len,
+                            ftnlen transb_len) {
+  /* Format strings */
+  static char fmt_9999[] =
+      "(\002 ******* FATAL ERROR - COMPUTED RESULT IS"
+      " LESS THAN HAL\002,\002F ACCURATE *******\002,/\002           EX"
+      "PECTED RESULT   COMPU\002,\002TED RESULT\002)";
+  static char fmt_9998[] = "(1x,i7,2g18.6)";
+  static char fmt_9997[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+                           " \002,i3)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, cc_dim1,
+      cc_offset, i__1, i__2, i__3;
+  real r__1, r__2;
+
+  /* Builtin functions */
+  double sqrt(doublereal);
+  integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, j, k;
+  real erri;
+  logical trana, tranb;
+
+  /* Fortran I/O blocks */
+  static cilist io___384 = {0, 0, 0, fmt_9999, 0};
+  static cilist io___385 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___386 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___387 = {0, 0, 0, fmt_9997, 0};
+
+  /*  Checks the results of the computational tests. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  a_dim1 = *lda;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  b_dim1 = *ldb;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  c_dim1 = *ldc;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --ct;
+  --g;
+  cc_dim1 = *ldcc;
+  cc_offset = 1 + cc_dim1;
+  cc -= cc_offset;
+
+  /* Function Body */
+  trana = *(unsigned char *)transa == 'T' || *(unsigned char *)transa == 'C';
+  tranb = *(unsigned char *)transb == 'T' || *(unsigned char *)transb == 'C';
+
+  /*     Compute expected result, one column at a time, in CT using data */
+  /*     in A, B and C. */
+  /*     Compute gauges in G. */
+
+  i__1 = *n;
+  for (j = 1; j <= i__1; ++j) {
+
+    i__2 = *m;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      ct[i__] = 0.f;
+      g[i__] = 0.f;
+      /* L10: */
+    }
+    if (!trana && !tranb) {
+      i__2 = *kk;
+      for (k = 1; k <= i__2; ++k) {
+        i__3 = *m;
+        for (i__ = 1; i__ <= i__3; ++i__) {
+          ct[i__] += a[i__ + k * a_dim1] * b[k + j * b_dim1];
+          g[i__] += (r__1 = a[i__ + k * a_dim1], abs(r__1)) *
+                    (r__2 = b[k + j * b_dim1], abs(r__2));
+          /* L20: */
+        }
+        /* L30: */
+      }
+    } else if (trana && !tranb) {
+      i__2 = *kk;
+      for (k = 1; k <= i__2; ++k) {
+        i__3 = *m;
+        for (i__ = 1; i__ <= i__3; ++i__) {
+          ct[i__] += a[k + i__ * a_dim1] * b[k + j * b_dim1];
+          g[i__] += (r__1 = a[k + i__ * a_dim1], abs(r__1)) *
+                    (r__2 = b[k + j * b_dim1], abs(r__2));
+          /* L40: */
+        }
+        /* L50: */
+      }
+    } else if (!trana && tranb) {
+      i__2 = *kk;
+      for (k = 1; k <= i__2; ++k) {
+        i__3 = *m;
+        for (i__ = 1; i__ <= i__3; ++i__) {
+          ct[i__] += a[i__ + k * a_dim1] * b[j + k * b_dim1];
+          g[i__] += (r__1 = a[i__ + k * a_dim1], abs(r__1)) *
+                    (r__2 = b[j + k * b_dim1], abs(r__2));
+          /* L60: */
+        }
+        /* L70: */
+      }
+    } else if (trana && tranb) {
+      i__2 = *kk;
+      for (k = 1; k <= i__2; ++k) {
+        i__3 = *m;
+        for (i__ = 1; i__ <= i__3; ++i__) {
+          ct[i__] += a[k + i__ * a_dim1] * b[j + k * b_dim1];
+          g[i__] += (r__1 = a[k + i__ * a_dim1], abs(r__1)) *
+                    (r__2 = b[j + k * b_dim1], abs(r__2));
+          /* L80: */
+        }
+        /* L90: */
+      }
+    }
+    i__2 = *m;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      ct[i__] = *alpha * ct[i__] + *beta * c__[i__ + j * c_dim1];
+      g[i__] = abs(*alpha) * g[i__] +
+               abs(*beta) * (r__1 = c__[i__ + j * c_dim1], abs(r__1));
+      /* L100: */
+    }
+
+    /*        Compute the error ratio for this result. */
+
+    *err = 0.f;
+    i__2 = *m;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      erri = (r__1 = ct[i__] - cc[i__ + j * cc_dim1], abs(r__1)) / *eps;
+      if (g[i__] != 0.f) {
+        erri /= g[i__];
+      }
+      *err = max(*err, erri);
+      if (*err * sqrt(*eps) >= 1.f) {
+        goto L130;
+      }
+      /* L110: */
+    }
+
+    /* L120: */
+  }
+
+  /*     If the loop completes, all results are at least half accurate. */
+  goto L150;
+
+  /*     Report fatal error. */
+
+L130:
+  *fatal = TRUE_;
+  io___384.ciunit = *nout;
+  s_wsfe(&io___384);
+  e_wsfe();
+  i__1 = *m;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    if (*mv) {
+      io___385.ciunit = *nout;
+      s_wsfe(&io___385);
+      do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&ct[i__], (ftnlen)sizeof(real));
+      do_fio(&c__1, (char *)&cc[i__ + j * cc_dim1], (ftnlen)sizeof(real));
+      e_wsfe();
+    } else {
+      io___386.ciunit = *nout;
+      s_wsfe(&io___386);
+      do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&cc[i__ + j * cc_dim1], (ftnlen)sizeof(real));
+      do_fio(&c__1, (char *)&ct[i__], (ftnlen)sizeof(real));
+      e_wsfe();
+    }
+    /* L140: */
+  }
+  if (*n > 1) {
+    io___387.ciunit = *nout;
+    s_wsfe(&io___387);
+    do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L150:
+  return 0;
+
+  /*     End of SMMCH. */
+
+} /* smmch_ */
+
+logical lse_(real *ri, real *rj, integer *lr) {
+  /* System generated locals */
+  integer i__1;
+  logical ret_val;
+
+  /* Local variables */
+  integer i__;
+
+  /*  Tests if two arrays are identical. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  --rj;
+  --ri;
+
+  /* Function Body */
+  i__1 = *lr;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    if (ri[i__] != rj[i__]) {
+      goto L20;
+    }
+    /* L10: */
+  }
+  ret_val = TRUE_;
+  goto L30;
+L20:
+  ret_val = FALSE_;
+L30:
+  return ret_val;
+
+  /*     End of LSE. */
+
+} /* lse_ */
+
+logical lseres_(char *type__, char *uplo, integer *m, integer *n, real *aa,
+                real *as, integer *lda, ftnlen type_len, ftnlen uplo_len) {
+  /* System generated locals */
+  integer aa_dim1, aa_offset, as_dim1, as_offset, i__1, i__2;
+  logical ret_val;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen);
+
+  /* Local variables */
+  integer i__, j, ibeg, iend;
+  logical upper;
+
+  /*  Tests if selected elements in two arrays are equal. */
+
+  /*  TYPE is 'GE' or 'SY'. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  as_dim1 = *lda;
+  as_offset = 1 + as_dim1;
+  as -= as_offset;
+  aa_dim1 = *lda;
+  aa_offset = 1 + aa_dim1;
+  aa -= aa_offset;
+
+  /* Function Body */
+  upper = *(unsigned char *)uplo == 'U';
+  if (s_cmp(type__, "GE", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      i__2 = *lda;
+      for (i__ = *m + 1; i__ <= i__2; ++i__) {
+        if (aa[i__ + j * aa_dim1] != as[i__ + j * as_dim1]) {
+          goto L70;
+        }
+        /* L10: */
+      }
+      /* L20: */
+    }
+  } else if (s_cmp(type__, "SY", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      if (upper) {
+        ibeg = 1;
+        iend = j;
+      } else {
+        ibeg = j;
+        iend = *n;
+      }
+      i__2 = ibeg - 1;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        if (aa[i__ + j * aa_dim1] != as[i__ + j * as_dim1]) {
+          goto L70;
+        }
+        /* L30: */
+      }
+      i__2 = *lda;
+      for (i__ = iend + 1; i__ <= i__2; ++i__) {
+        if (aa[i__ + j * aa_dim1] != as[i__ + j * as_dim1]) {
+          goto L70;
+        }
+        /* L40: */
+      }
+      /* L50: */
+    }
+  }
+
+  /* L60: */
+  ret_val = TRUE_;
+  goto L80;
+L70:
+  ret_val = FALSE_;
+L80:
+  return ret_val;
+
+  /*     End of LSERES. */
+
+} /* lseres_ */
+
+real sbeg_(logical *reset) {
+  /* System generated locals */
+  real ret_val;
+
+  /* Local variables */
+  static integer i__, ic, mi;
+
+  /*  Generates random numbers uniformly distributed between -0.5 and 0.5. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Save statement .. */
+  /*     .. Executable Statements .. */
+  if (*reset) {
+    /*        Initialize local variables. */
+    mi = 891;
+    i__ = 7;
+    ic = 0;
+    *reset = FALSE_;
+  }
+
+  /*     The sequence of values of I is bounded between 1 and 999. */
+  /*     If initial I = 1,2,3,6,7 or 9, the period will be 50. */
+  /*     If initial I = 4 or 8, the period will be 25. */
+  /*     If initial I = 5, the period will be 10. */
+  /*     IC is used to break up the period by skipping 1 value of I in 6. */
+
+  ++ic;
+L10:
+  i__ *= mi;
+  i__ -= i__ / 1000 * 1000;
+  if (ic >= 5) {
+    ic = 0;
+    goto L10;
+  }
+  ret_val = (i__ - 500) / 1001.f;
+  return ret_val;
+
+  /*     End of SBEG. */
+
+} /* sbeg_ */
+
+real sdiff_(real *x, real *y) {
+  /* System generated locals */
+  real ret_val;
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Executable Statements .. */
+  ret_val = *x - *y;
+  return ret_val;
+
+  /*     End of SDIFF. */
+
+} /* sdiff_ */
+
+/* Main program alias */ int sblat3_() {
+  MAIN__();
+  return 0;
+}
diff --git a/CBLAS/testing/c_xerbla.c b/CBLAS/testing/c_xerbla.c
index cc5eda4..916b2e3 100644
--- a/CBLAS/testing/c_xerbla.c
+++ b/CBLAS/testing/c_xerbla.c
@@ -1,7 +1,7 @@
 #include <stdio.h>
-#include <ctype.h>
 #include <stdarg.h>
 #include <string.h>
+// #include <ctype.h>
 #include "cblas.h"
 #include "cblas_test.h"
 
@@ -84,6 +84,13 @@ void cblas_xerbla(int info, const char *rout, const char *form, ...)
    } else cblas_lerr = FAILED;
 }
 
+
+int tolower(int c) {
+    if (c < 91 && c > 65)
+        return c + 32;
+    return c;
+}
+
 #ifdef F77_Char
 void F77_xerbla(F77_Char F77_srname, void *vinfo)
 #else
diff --git a/CBLAS/testing/c_zblat1.c b/CBLAS/testing/c_zblat1.c
new file mode 100644
index 0000000..1a41b81
--- /dev/null
+++ b/CBLAS/testing/c_zblat1.c
@@ -0,0 +1,779 @@
+/* testing/c_zblat1.f -- translated by f2c (version 20191129).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+#include "f2c.h"
+
+/* Common Block Declarations */
+
+struct {
+    integer icase, n, incx, incy, mode;
+    logical pass;
+} combla_;
+
+#define combla_1 combla_
+
+/* Table of constant values */
+
+static integer c__1 = 1;
+static integer c__9 = 9;
+static integer c__5 = 5;
+static doublereal c_b43 = 1.;
+
+/* Main program */ int MAIN__(void)
+{
+    /* Initialized data */
+
+    static doublereal sfac = 9.765625e-4;
+
+    /* Format strings */
+    static char fmt_99999[] = "(\002 Complex CBLAS Test Program Results\002,"
+	    "/1x)";
+    static char fmt_99998[] = "(\002                                    ----"
+	    "- PASS -----\002)";
+
+    /* Builtin functions */
+    integer s_wsfe(cilist *), e_wsfe(void);
+    /* Subroutine */ int s_stop(char *, ftnlen);
+
+    /* Local variables */
+    integer ic;
+    extern /* Subroutine */ int check1_(doublereal *), check2_(doublereal *), 
+	    header_(void);
+
+    /* Fortran I/O blocks */
+    static cilist io___2 = { 0, 6, 0, fmt_99999, 0 };
+    static cilist io___4 = { 0, 6, 0, fmt_99998, 0 };
+
+
+/*     Test program for the COMPLEX*16 Level 1 CBLAS. */
+/*     Based upon the original CBLAS test routine together with: */
+/*     F06GAF Example Program Text */
+/*     .. Parameters .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. External Subroutines .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+    s_wsfe(&io___2);
+    e_wsfe();
+    for (ic = 1; ic <= 10; ++ic) {
+	combla_1.icase = ic;
+	header_();
+
+/*        Initialize PASS, INCX, INCY, and MODE for a new case. */
+/*        The value 9999 for INCX, INCY or MODE will appear in the */
+/*        detailed  output, if any, for cases that do not involve */
+/*        these parameters. */
+
+	combla_1.pass = TRUE_;
+	combla_1.incx = 9999;
+	combla_1.incy = 9999;
+	combla_1.mode = 9999;
+	if (combla_1.icase <= 5) {
+	    check2_(&sfac);
+	} else if (combla_1.icase >= 6) {
+	    check1_(&sfac);
+	}
+/*        -- Print */
+	if (combla_1.pass) {
+	    s_wsfe(&io___4);
+	    e_wsfe();
+	}
+/* L20: */
+    }
+    s_stop("", (ftnlen)0);
+
+    return 0;
+} /* MAIN__ */
+
+/* Subroutine */ int header_(void)
+{
+    /* Initialized data */
+
+    static char l[15*10] = "CBLAS_ZDOTC    " "CBLAS_ZDOTU    " "CBLAS_ZAXPY "
+	    "   " "CBLAS_ZCOPY    " "CBLAS_ZSWAP    " "CBLAS_DZNRM2   " "CBLA"
+	    "S_DZASUM   " "CBLAS_ZSCAL    " "CBLAS_ZDSCAL   " "CBLAS_IZAMAX   "
+	    ;
+
+    /* Format strings */
+    static char fmt_99999[] = "(/\002 Test of subprogram number\002,i3,9x,a1"
+	    "5)";
+
+    /* Builtin functions */
+    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+    /* Fortran I/O blocks */
+    static cilist io___6 = { 0, 6, 0, fmt_99999, 0 };
+
+
+/*     .. Parameters .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Arrays .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+    s_wsfe(&io___6);
+    do_fio(&c__1, (char *)&combla_1.icase, (ftnlen)sizeof(integer));
+    do_fio(&c__1, l + (0 + (0 + (combla_1.icase - 1) * 15)), (ftnlen)15);
+    e_wsfe();
+    return 0;
+
+} /* header_ */
+
+/* Subroutine */ int check1_(doublereal *sfac)
+{
+    /* Initialized data */
+
+    static doublereal strue2[5] = { 0.,.5,.6,.7,.7 };
+    static doublereal strue4[5] = { 0.,.7,1.,1.3,1.7 };
+    static doublecomplex ctrue5[80]	/* was [8][5][2] */ = { {.1,.1},{1.,
+	    2.},{1.,2.},{1.,2.},{1.,2.},{1.,2.},{1.,2.},{1.,2.},{-.16,-.37},{
+	    3.,4.},{3.,4.},{3.,4.},{3.,4.},{3.,4.},{3.,4.},{3.,4.},{-.17,-.19}
+	    ,{.13,-.39},{5.,6.},{5.,6.},{5.,6.},{5.,6.},{5.,6.},{5.,6.},{.11,
+	    -.03},{-.17,.46},{-.17,-.19},{7.,8.},{7.,8.},{7.,8.},{7.,8.},{7.,
+	    8.},{.19,-.17},{.32,.09},{.23,-.24},{.18,.01},{2.,3.},{2.,3.},{2.,
+	    3.},{2.,3.},{.1,.1},{4.,5.},{4.,5.},{4.,5.},{4.,5.},{4.,5.},{4.,
+	    5.},{4.,5.},{-.16,-.37},{6.,7.},{6.,7.},{6.,7.},{6.,7.},{6.,7.},{
+	    6.,7.},{6.,7.},{-.17,-.19},{8.,9.},{.13,-.39},{2.,5.},{2.,5.},{2.,
+	    5.},{2.,5.},{2.,5.},{.11,-.03},{3.,6.},{-.17,.46},{4.,7.},{-.17,
+	    -.19},{7.,2.},{7.,2.},{7.,2.},{.19,-.17},{5.,8.},{.32,.09},{6.,9.}
+	    ,{.23,-.24},{8.,3.},{.18,.01},{9.,4.} };
+    static doublecomplex ctrue6[80]	/* was [8][5][2] */ = { {.1,.1},{1.,
+	    2.},{1.,2.},{1.,2.},{1.,2.},{1.,2.},{1.,2.},{1.,2.},{.09,-.12},{
+	    3.,4.},{3.,4.},{3.,4.},{3.,4.},{3.,4.},{3.,4.},{3.,4.},{.03,-.09},
+	    {.15,-.03},{5.,6.},{5.,6.},{5.,6.},{5.,6.},{5.,6.},{5.,6.},{.03,
+	    .03},{-.18,.03},{.03,-.09},{7.,8.},{7.,8.},{7.,8.},{7.,8.},{7.,8.}
+	    ,{.09,.03},{.03,.12},{.12,.03},{.03,.06},{2.,3.},{2.,3.},{2.,3.},{
+	    2.,3.},{.1,.1},{4.,5.},{4.,5.},{4.,5.},{4.,5.},{4.,5.},{4.,5.},{
+	    4.,5.},{.09,-.12},{6.,7.},{6.,7.},{6.,7.},{6.,7.},{6.,7.},{6.,7.},
+	    {6.,7.},{.03,-.09},{8.,9.},{.15,-.03},{2.,5.},{2.,5.},{2.,5.},{2.,
+	    5.},{2.,5.},{.03,.03},{3.,6.},{-.18,.03},{4.,7.},{.03,-.09},{7.,
+	    2.},{7.,2.},{7.,2.},{.09,.03},{5.,8.},{.03,.12},{6.,9.},{.12,.03},
+	    {8.,3.},{.03,.06},{9.,4.} };
+    static integer itrue3[5] = { 0,1,2,2,2 };
+    static doublereal sa = .3;
+    static doublecomplex ca = {.4,-.7};
+    static doublecomplex cv[80]	/* was [8][5][2] */ = { {.1,.1},{1.,2.},{1.,
+	    2.},{1.,2.},{1.,2.},{1.,2.},{1.,2.},{1.,2.},{.3,-.4},{3.,4.},{3.,
+	    4.},{3.,4.},{3.,4.},{3.,4.},{3.,4.},{3.,4.},{.1,-.3},{.5,-.1},{5.,
+	    6.},{5.,6.},{5.,6.},{5.,6.},{5.,6.},{5.,6.},{.1,.1},{-.6,.1},{.1,
+	    -.3},{7.,8.},{7.,8.},{7.,8.},{7.,8.},{7.,8.},{.3,.1},{.1,.4},{.4,
+	    .1},{.1,.2},{2.,3.},{2.,3.},{2.,3.},{2.,3.},{.1,.1},{4.,5.},{4.,
+	    5.},{4.,5.},{4.,5.},{4.,5.},{4.,5.},{4.,5.},{.3,-.4},{6.,7.},{6.,
+	    7.},{6.,7.},{6.,7.},{6.,7.},{6.,7.},{6.,7.},{.1,-.3},{8.,9.},{.5,
+	    -.1},{2.,5.},{2.,5.},{2.,5.},{2.,5.},{2.,5.},{.1,.1},{3.,6.},{-.6,
+	    .1},{4.,7.},{.1,-.3},{7.,2.},{7.,2.},{7.,2.},{.3,.1},{5.,8.},{.1,
+	    .4},{6.,9.},{.4,.1},{8.,3.},{.1,.2},{9.,4.} };
+
+    /* System generated locals */
+    integer i__1, i__2, i__3;
+    doublereal d__1;
+    doublecomplex z__1;
+
+    /* Builtin functions */
+    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
+	    e_wsle(void);
+    /* Subroutine */ int s_stop(char *, ftnlen);
+
+    /* Local variables */
+    integer i__;
+    extern /* Subroutine */ void zscaltest_(integer *, doublecomplex *, 
+	    doublecomplex *, integer *);
+    doublecomplex cx[8];
+    extern doublereal dznrm2test_(integer *, doublecomplex *, integer *);
+    integer np1;
+    extern /* Subroutine */ void zdscaltest_(integer *, doublereal *, 
+	    doublecomplex *, integer *);
+    extern integer izamaxtest_(integer *, doublecomplex *, integer *);
+    extern doublereal dzasumtest_(integer *, doublecomplex *, integer *);
+    integer len;
+    extern /* Subroutine */ int ctest_(integer *, doublecomplex *, 
+	    doublecomplex *, doublecomplex *, doublereal *);
+    doublecomplex mwpcs[5], mwpct[5];
+    extern /* Subroutine */ int itest1_(integer *, integer *), stest1_(
+	    doublereal *, doublereal *, doublereal *, doublereal *);
+
+    /* Fortran I/O blocks */
+    static cilist io___19 = { 0, 6, 0, 0, 0 };
+
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+    for (combla_1.incx = 1; combla_1.incx <= 2; ++combla_1.incx) {
+	for (np1 = 1; np1 <= 5; ++np1) {
+	    combla_1.n = np1 - 1;
+	    len = max(combla_1.n,1) << 1;
+/*           .. Set vector arguments .. */
+	    i__1 = len;
+	    for (i__ = 1; i__ <= i__1; ++i__) {
+		i__2 = i__ - 1;
+		i__3 = i__ + (np1 + combla_1.incx * 5 << 3) - 49;
+		cx[i__2].r = cv[i__3].r, cx[i__2].i = cv[i__3].i;
+/* L20: */
+	    }
+	    if (combla_1.icase == 6) {
+/*              .. DZNRM2TEST .. */
+		d__1 = dznrm2test_(&combla_1.n, cx, &combla_1.incx);
+		stest1_(&d__1, &strue2[np1 - 1], &strue2[np1 - 1], sfac);
+	    } else if (combla_1.icase == 7) {
+/*              .. DZASUMTEST .. */
+		d__1 = dzasumtest_(&combla_1.n, cx, &combla_1.incx);
+		stest1_(&d__1, &strue4[np1 - 1], &strue4[np1 - 1], sfac);
+	    } else if (combla_1.icase == 8) {
+/*              .. ZSCALTEST .. */
+		zscaltest_(&combla_1.n, &ca, cx, &combla_1.incx);
+		ctest_(&len, cx, &ctrue5[(np1 + combla_1.incx * 5 << 3) - 48],
+			 &ctrue5[(np1 + combla_1.incx * 5 << 3) - 48], sfac);
+	    } else if (combla_1.icase == 9) {
+/*              .. ZDSCALTEST .. */
+		zdscaltest_(&combla_1.n, &sa, cx, &combla_1.incx);
+		ctest_(&len, cx, &ctrue6[(np1 + combla_1.incx * 5 << 3) - 48],
+			 &ctrue6[(np1 + combla_1.incx * 5 << 3) - 48], sfac);
+	    } else if (combla_1.icase == 10) {
+/*              .. IZAMAXTEST .. */
+		i__1 = izamaxtest_(&combla_1.n, cx, &combla_1.incx);
+		itest1_(&i__1, &itrue3[np1 - 1]);
+	    } else {
+		s_wsle(&io___19);
+		do_lio(&c__9, &c__1, " Shouldn't be here in CHECK1", (ftnlen)
+			28);
+		e_wsle();
+		s_stop("", (ftnlen)0);
+	    }
+
+/* L40: */
+	}
+/* L60: */
+    }
+
+    combla_1.incx = 1;
+    if (combla_1.icase == 8) {
+/*        ZSCALTEST */
+/*        Add a test for alpha equal to zero. */
+	ca.r = 0., ca.i = 0.;
+	for (i__ = 1; i__ <= 5; ++i__) {
+	    i__1 = i__ - 1;
+	    mwpct[i__1].r = 0., mwpct[i__1].i = 0.;
+	    i__1 = i__ - 1;
+	    mwpcs[i__1].r = 1., mwpcs[i__1].i = 1.;
+/* L80: */
+	}
+	zscaltest_(&c__5, &ca, cx, &combla_1.incx);
+	ctest_(&c__5, cx, mwpct, mwpcs, sfac);
+    } else if (combla_1.icase == 9) {
+/*        ZDSCALTEST */
+/*        Add a test for alpha equal to zero. */
+	sa = 0.;
+	for (i__ = 1; i__ <= 5; ++i__) {
+	    i__1 = i__ - 1;
+	    mwpct[i__1].r = 0., mwpct[i__1].i = 0.;
+	    i__1 = i__ - 1;
+	    mwpcs[i__1].r = 1., mwpcs[i__1].i = 1.;
+/* L100: */
+	}
+	zdscaltest_(&c__5, &sa, cx, &combla_1.incx);
+	ctest_(&c__5, cx, mwpct, mwpcs, sfac);
+/*        Add a test for alpha equal to one. */
+	sa = 1.;
+	for (i__ = 1; i__ <= 5; ++i__) {
+	    i__1 = i__ - 1;
+	    i__2 = i__ - 1;
+	    mwpct[i__1].r = cx[i__2].r, mwpct[i__1].i = cx[i__2].i;
+	    i__1 = i__ - 1;
+	    i__2 = i__ - 1;
+	    mwpcs[i__1].r = cx[i__2].r, mwpcs[i__1].i = cx[i__2].i;
+/* L120: */
+	}
+	zdscaltest_(&c__5, &sa, cx, &combla_1.incx);
+	ctest_(&c__5, cx, mwpct, mwpcs, sfac);
+/*        Add a test for alpha equal to minus one. */
+	sa = -1.;
+	for (i__ = 1; i__ <= 5; ++i__) {
+	    i__1 = i__ - 1;
+	    i__2 = i__ - 1;
+	    z__1.r = -cx[i__2].r, z__1.i = -cx[i__2].i;
+	    mwpct[i__1].r = z__1.r, mwpct[i__1].i = z__1.i;
+	    i__1 = i__ - 1;
+	    i__2 = i__ - 1;
+	    z__1.r = -cx[i__2].r, z__1.i = -cx[i__2].i;
+	    mwpcs[i__1].r = z__1.r, mwpcs[i__1].i = z__1.i;
+/* L140: */
+	}
+	zdscaltest_(&c__5, &sa, cx, &combla_1.incx);
+	ctest_(&c__5, cx, mwpct, mwpcs, sfac);
+    }
+    return 0;
+} /* check1_ */
+
+/* Subroutine */ int check2_(doublereal *sfac)
+{
+    /* Initialized data */
+
+    static doublecomplex ca = {.4,-.7};
+    static integer incxs[4] = { 1,2,-2,-1 };
+    static integer incys[4] = { 1,-2,1,-2 };
+    static integer lens[8]	/* was [4][2] */ = { 1,1,2,4,1,1,3,7 };
+    static integer ns[4] = { 0,1,2,4 };
+    static doublecomplex cx1[7] = { {.7,-.8},{-.4,-.7},{-.1,-.9},{.2,-.8},{
+	    -.9,-.4},{.1,.4},{-.6,.6} };
+    static doublecomplex cy1[7] = { {.6,-.6},{-.9,.5},{.7,-.6},{.1,-.5},{-.1,
+	    -.2},{-.5,-.3},{.8,-.7} };
+    static doublecomplex ct8[112]	/* was [7][4][4] */ = { {.6,-.6},{0.,
+	    0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{.32,-1.41},{0.,0.},{
+	    0.,0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{.32,-1.41},{-1.55,.5},{0.,
+	    0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{.32,-1.41},{-1.55,.5},{.03,
+	    -.89},{-.38,-.96},{0.,0.},{0.,0.},{0.,0.},{.6,-.6},{0.,0.},{0.,0.}
+	    ,{0.,0.},{0.,0.},{0.,0.},{0.,0.},{.32,-1.41},{0.,0.},{0.,0.},{0.,
+	    0.},{0.,0.},{0.,0.},{0.,0.},{-.07,-.89},{-.9,.5},{.42,-1.41},{0.,
+	    0.},{0.,0.},{0.,0.},{0.,0.},{.78,.06},{-.9,.5},{.06,-.13},{.1,-.5}
+	    ,{-.77,-.49},{-.5,-.3},{.52,-1.51},{.6,-.6},{0.,0.},{0.,0.},{0.,
+	    0.},{0.,0.},{0.,0.},{0.,0.},{.32,-1.41},{0.,0.},{0.,0.},{0.,0.},{
+	    0.,0.},{0.,0.},{0.,0.},{-.07,-.89},{-1.18,-.31},{0.,0.},{0.,0.},{
+	    0.,0.},{0.,0.},{0.,0.},{.78,.06},{-1.54,.97},{.03,-.89},{-.18,
+	    -1.31},{0.,0.},{0.,0.},{0.,0.},{.6,-.6},{0.,0.},{0.,0.},{0.,0.},{
+	    0.,0.},{0.,0.},{0.,0.},{.32,-1.41},{0.,0.},{0.,0.},{0.,0.},{0.,0.}
+	    ,{0.,0.},{0.,0.},{.32,-1.41},{-.9,.5},{.05,-.6},{0.,0.},{0.,0.},{
+	    0.,0.},{0.,0.},{.32,-1.41},{-.9,.5},{.05,-.6},{.1,-.5},{-.77,-.49}
+	    ,{-.5,-.3},{.32,-1.16} };
+    static doublecomplex ct7[16]	/* was [4][4] */ = { {0.,0.},{-.06,
+	    -.9},{.65,-.47},{-.34,-1.22},{0.,0.},{-.06,-.9},{-.59,-1.46},{
+	    -1.04,-.04},{0.,0.},{-.06,-.9},{-.83,.59},{.07,-.37},{0.,0.},{
+	    -.06,-.9},{-.76,-1.15},{-1.33,-1.82} };
+    static doublecomplex ct6[16]	/* was [4][4] */ = { {0.,0.},{.9,.06},
+	    {.91,-.77},{1.8,-.1},{0.,0.},{.9,.06},{1.45,.74},{.2,.9},{0.,0.},{
+	    .9,.06},{-.55,.23},{.83,-.39},{0.,0.},{.9,.06},{1.04,.79},{1.95,
+	    1.22} };
+    static doublecomplex ct10x[112]	/* was [7][4][4] */ = { {.7,-.8},{0.,
+	    0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{.6,-.6},{0.,0.},{0.,
+	    0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{.6,-.6},{-.9,.5},{0.,0.},{0.,
+	    0.},{0.,0.},{0.,0.},{0.,0.},{.6,-.6},{-.9,.5},{.7,-.6},{.1,-.5},{
+	    0.,0.},{0.,0.},{0.,0.},{.7,-.8},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{
+	    0.,0.},{0.,0.},{.6,-.6},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{
+	    0.,0.},{.7,-.6},{-.4,-.7},{.6,-.6},{0.,0.},{0.,0.},{0.,0.},{0.,0.}
+	    ,{.8,-.7},{-.4,-.7},{-.1,-.2},{.2,-.8},{.7,-.6},{.1,.4},{.6,-.6},{
+	    .7,-.8},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{.6,-.6},{
+	    0.,0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{-.9,.5},{-.4,-.7},
+	    {.6,-.6},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{.1,-.5},{-.4,-.7},{.7,
+	    -.6},{.2,-.8},{-.9,.5},{.1,.4},{.6,-.6},{.7,-.8},{0.,0.},{0.,0.},{
+	    0.,0.},{0.,0.},{0.,0.},{0.,0.},{.6,-.6},{0.,0.},{0.,0.},{0.,0.},{
+	    0.,0.},{0.,0.},{0.,0.},{.6,-.6},{.7,-.6},{0.,0.},{0.,0.},{0.,0.},{
+	    0.,0.},{0.,0.},{.6,-.6},{.7,-.6},{-.1,-.2},{.8,-.7},{0.,0.},{0.,
+	    0.},{0.,0.} };
+    static doublecomplex ct10y[112]	/* was [7][4][4] */ = { {.6,-.6},{0.,
+	    0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{.7,-.8},{0.,0.},{0.,
+	    0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{.7,-.8},{-.4,-.7},{0.,0.},{
+	    0.,0.},{0.,0.},{0.,0.},{0.,0.},{.7,-.8},{-.4,-.7},{-.1,-.9},{.2,
+	    -.8},{0.,0.},{0.,0.},{0.,0.},{.6,-.6},{0.,0.},{0.,0.},{0.,0.},{0.,
+	    0.},{0.,0.},{0.,0.},{.7,-.8},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{0.,
+	    0.},{0.,0.},{-.1,-.9},{-.9,.5},{.7,-.8},{0.,0.},{0.,0.},{0.,0.},{
+	    0.,0.},{-.6,.6},{-.9,.5},{-.9,-.4},{.1,-.5},{-.1,-.9},{-.5,-.3},{
+	    .7,-.8},{.6,-.6},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{
+	    .7,-.8},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{-.1,-.9},
+	    {.7,-.8},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{-.6,.6},{-.9,
+	    -.4},{-.1,-.9},{.7,-.8},{0.,0.},{0.,0.},{0.,0.},{.6,-.6},{0.,0.},{
+	    0.,0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{.7,-.8},{0.,0.},{0.,0.},{
+	    0.,0.},{0.,0.},{0.,0.},{0.,0.},{.7,-.8},{-.9,.5},{-.4,-.7},{0.,0.}
+	    ,{0.,0.},{0.,0.},{0.,0.},{.7,-.8},{-.9,.5},{-.4,-.7},{.1,-.5},{
+	    -.1,-.9},{-.5,-.3},{.2,-.8} };
+    static doublecomplex csize1[4] = { {0.,0.},{.9,.9},{1.63,1.73},{2.9,2.78} 
+	    };
+    static doublecomplex csize3[14] = { {0.,0.},{0.,0.},{0.,0.},{0.,0.},{0.,
+	    0.},{0.,0.},{0.,0.},{1.17,1.17},{1.17,1.17},{1.17,1.17},{1.17,
+	    1.17},{1.17,1.17},{1.17,1.17},{1.17,1.17} };
+    static doublecomplex csize2[14]	/* was [7][2] */ = { {0.,0.},{0.,0.},{
+	    0.,0.},{0.,0.},{0.,0.},{0.,0.},{0.,0.},{1.54,1.54},{1.54,1.54},{
+	    1.54,1.54},{1.54,1.54},{1.54,1.54},{1.54,1.54},{1.54,1.54} };
+
+    /* System generated locals */
+    integer i__1, i__2;
+
+    /* Builtin functions */
+    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
+	    e_wsle(void);
+    /* Subroutine */ int s_stop(char *, ftnlen);
+
+    /* Local variables */
+    integer i__;
+    extern /* Subroutine */ void zdotctest_(integer *, doublecomplex *, 
+	    integer *, doublecomplex *, integer *, doublecomplex *), 
+	    zcopytest_(integer *, doublecomplex *, integer *, doublecomplex *,
+	     integer *);
+    integer ki;
+    extern /* Subroutine */ void zdotutest_(integer *, doublecomplex *, 
+	    integer *, doublecomplex *, integer *, doublecomplex *), 
+	    zswaptest_(integer *, doublecomplex *, integer *, doublecomplex *,
+	     integer *);
+    integer kn;
+    extern /* Subroutine */ void zaxpytest_(integer *, doublecomplex *, 
+	    doublecomplex *, integer *, doublecomplex *, integer *);
+    doublecomplex cx[7], cy[7];
+    integer mx, my;
+    doublecomplex cdot[1];
+    integer lenx, leny;
+    extern /* Subroutine */ int ctest_(integer *, doublecomplex *, 
+	    doublecomplex *, doublecomplex *, doublereal *);
+    integer ksize;
+    doublecomplex ztemp;
+
+    /* Fortran I/O blocks */
+    static cilist io___49 = { 0, 6, 0, 0, 0 };
+
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Functions .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Common blocks .. */
+/*     .. Data statements .. */
+/*     .. Executable Statements .. */
+    for (ki = 1; ki <= 4; ++ki) {
+	combla_1.incx = incxs[ki - 1];
+	combla_1.incy = incys[ki - 1];
+	mx = abs(combla_1.incx);
+	my = abs(combla_1.incy);
+
+	for (kn = 1; kn <= 4; ++kn) {
+	    combla_1.n = ns[kn - 1];
+	    ksize = min(2,kn);
+	    lenx = lens[kn + (mx << 2) - 5];
+	    leny = lens[kn + (my << 2) - 5];
+/*           .. initialize all argument arrays .. */
+	    for (i__ = 1; i__ <= 7; ++i__) {
+		i__1 = i__ - 1;
+		i__2 = i__ - 1;
+		cx[i__1].r = cx1[i__2].r, cx[i__1].i = cx1[i__2].i;
+		i__1 = i__ - 1;
+		i__2 = i__ - 1;
+		cy[i__1].r = cy1[i__2].r, cy[i__1].i = cy1[i__2].i;
+/* L20: */
+	    }
+	    if (combla_1.icase == 1) {
+/*              .. ZDOTCTEST .. */
+		zdotctest_(&combla_1.n, cx, &combla_1.incx, cy, &
+			combla_1.incy, &ztemp);
+		cdot[0].r = ztemp.r, cdot[0].i = ztemp.i;
+		ctest_(&c__1, cdot, &ct6[kn + (ki << 2) - 5], &csize1[kn - 1],
+			 sfac);
+	    } else if (combla_1.icase == 2) {
+/*              .. ZDOTUTEST .. */
+		zdotutest_(&combla_1.n, cx, &combla_1.incx, cy, &
+			combla_1.incy, &ztemp);
+		cdot[0].r = ztemp.r, cdot[0].i = ztemp.i;
+		ctest_(&c__1, cdot, &ct7[kn + (ki << 2) - 5], &csize1[kn - 1],
+			 sfac);
+	    } else if (combla_1.icase == 3) {
+/*              .. ZAXPYTEST .. */
+		zaxpytest_(&combla_1.n, &ca, cx, &combla_1.incx, cy, &
+			combla_1.incy);
+		ctest_(&leny, cy, &ct8[(kn + (ki << 2)) * 7 - 35], &csize2[
+			ksize * 7 - 7], sfac);
+	    } else if (combla_1.icase == 4) {
+/*              .. ZCOPYTEST .. */
+		zcopytest_(&combla_1.n, cx, &combla_1.incx, cy, &
+			combla_1.incy);
+		ctest_(&leny, cy, &ct10y[(kn + (ki << 2)) * 7 - 35], csize3, &
+			c_b43);
+	    } else if (combla_1.icase == 5) {
+/*              .. ZSWAPTEST .. */
+		zswaptest_(&combla_1.n, cx, &combla_1.incx, cy, &
+			combla_1.incy);
+		ctest_(&lenx, cx, &ct10x[(kn + (ki << 2)) * 7 - 35], csize3, &
+			c_b43);
+		ctest_(&leny, cy, &ct10y[(kn + (ki << 2)) * 7 - 35], csize3, &
+			c_b43);
+	    } else {
+		s_wsle(&io___49);
+		do_lio(&c__9, &c__1, " Shouldn't be here in CHECK2", (ftnlen)
+			28);
+		e_wsle();
+		s_stop("", (ftnlen)0);
+	    }
+
+/* L40: */
+	}
+/* L60: */
+    }
+    return 0;
+} /* check2_ */
+
+/* Subroutine */ int stest_(integer *len, doublereal *scomp, doublereal *
+	strue, doublereal *ssize, doublereal *sfac)
+{
+    /* Format strings */
+    static char fmt_99999[] = "(\002                                       F"
+	    "AIL\002)";
+    static char fmt_99998[] = "(/\002 CASE  N INCX INCY MODE  I             "
+	    "               \002,\002 COMP(I)                             TRU"
+	    "E(I)  DIFFERENCE\002,\002     SIZE(I)\002,/1x)";
+    static char fmt_99997[] = "(1x,i4,i3,3i5,i3,2d36.8,2d12.4)";
+
+    /* System generated locals */
+    integer i__1;
+    doublereal d__1, d__2, d__3, d__4, d__5;
+
+    /* Builtin functions */
+    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+    /* Local variables */
+    integer i__;
+    doublereal sd;
+    extern doublereal sdiff_(doublereal *, doublereal *);
+
+    /* Fortran I/O blocks */
+    static cilist io___52 = { 0, 6, 0, fmt_99999, 0 };
+    static cilist io___53 = { 0, 6, 0, fmt_99998, 0 };
+    static cilist io___54 = { 0, 6, 0, fmt_99997, 0 };
+
+
+/*     ********************************* STEST ************************** */
+
+/*     THIS SUBR COMPARES ARRAYS  SCOMP() AND STRUE() OF LENGTH LEN TO */
+/*     SEE IF THE TERM BY TERM DIFFERENCES, MULTIPLIED BY SFAC, ARE */
+/*     NEGLIGIBLE. */
+
+/*     C. L. LAWSON, JPL, 1974 DEC 10 */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. External Functions .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Common blocks .. */
+/*     .. Executable Statements .. */
+
+    /* Parameter adjustments */
+    --ssize;
+    --strue;
+    --scomp;
+
+    /* Function Body */
+    i__1 = *len;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	sd = scomp[i__] - strue[i__];
+	d__4 = (d__1 = ssize[i__], abs(d__1)) + (d__2 = *sfac * sd, abs(d__2))
+		;
+	d__5 = (d__3 = ssize[i__], abs(d__3));
+	if (sdiff_(&d__4, &d__5) == 0.) {
+	    goto L40;
+	}
+
+/*                             HERE    SCOMP(I) IS NOT CLOSE TO STRUE(I). */
+
+	if (! combla_1.pass) {
+	    goto L20;
+	}
+/*                             PRINT FAIL MESSAGE AND HEADER. */
+	combla_1.pass = FALSE_;
+	s_wsfe(&io___52);
+	e_wsfe();
+	s_wsfe(&io___53);
+	e_wsfe();
+L20:
+	s_wsfe(&io___54);
+	do_fio(&c__1, (char *)&combla_1.icase, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&combla_1.n, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&combla_1.incx, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&combla_1.incy, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&combla_1.mode, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+	do_fio(&c__1, (char *)&scomp[i__], (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&strue[i__], (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&sd, (ftnlen)sizeof(doublereal));
+	do_fio(&c__1, (char *)&ssize[i__], (ftnlen)sizeof(doublereal));
+	e_wsfe();
+L40:
+	;
+    }
+    return 0;
+
+} /* stest_ */
+
+/* Subroutine */ int stest1_(doublereal *scomp1, doublereal *strue1, 
+	doublereal *ssize, doublereal *sfac)
+{
+    doublereal scomp[1], strue[1];
+    extern /* Subroutine */ int stest_(integer *, doublereal *, doublereal *, 
+	    doublereal *, doublereal *);
+
+/*     ************************* STEST1 ***************************** */
+
+/*     THIS IS AN INTERFACE SUBROUTINE TO ACCOMODATE THE FORTRAN */
+/*     REQUIREMENT THAT WHEN A DUMMY ARGUMENT IS AN ARRAY, THE */
+/*     ACTUAL ARGUMENT MUST ALSO BE AN ARRAY OR AN ARRAY ELEMENT. */
+
+/*     C.L. LAWSON, JPL, 1978 DEC 6 */
+
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Arrays .. */
+/*     .. External Subroutines .. */
+/*     .. Executable Statements .. */
+
+    /* Parameter adjustments */
+    --ssize;
+
+    /* Function Body */
+    scomp[0] = *scomp1;
+    strue[0] = *strue1;
+    stest_(&c__1, scomp, strue, &ssize[1], sfac);
+
+    return 0;
+} /* stest1_ */
+
+doublereal sdiff_(doublereal *sa, doublereal *sb)
+{
+    /* System generated locals */
+    doublereal ret_val;
+
+/*     ********************************* SDIFF ************************** */
+/*     COMPUTES DIFFERENCE OF TWO NUMBERS.  C. L. LAWSON, JPL 1974 FEB 15 */
+
+/*     .. Scalar Arguments .. */
+/*     .. Executable Statements .. */
+    ret_val = *sa - *sb;
+    return ret_val;
+} /* sdiff_ */
+
+/* Subroutine */ int ctest_(integer *len, doublecomplex *ccomp, doublecomplex 
+	*ctrue, doublecomplex *csize, doublereal *sfac)
+{
+    /* System generated locals */
+    integer i__1, i__2;
+
+    /* Builtin functions */
+    double d_imag(doublecomplex *);
+
+    /* Local variables */
+    integer i__;
+    doublereal scomp[20], ssize[20], strue[20];
+    extern /* Subroutine */ int stest_(integer *, doublereal *, doublereal *, 
+	    doublereal *, doublereal *);
+
+/*     **************************** CTEST ***************************** */
+
+/*     C.L. LAWSON, JPL, 1978 DEC 6 */
+
+/*     .. Scalar Arguments .. */
+/*     .. Array Arguments .. */
+/*     .. Local Scalars .. */
+/*     .. Local Arrays .. */
+/*     .. External Subroutines .. */
+/*     .. Intrinsic Functions .. */
+/*     .. Executable Statements .. */
+    /* Parameter adjustments */
+    --csize;
+    --ctrue;
+    --ccomp;
+
+    /* Function Body */
+    i__1 = *len;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	i__2 = i__;
+	scomp[(i__ << 1) - 2] = ccomp[i__2].r;
+	scomp[(i__ << 1) - 1] = d_imag(&ccomp[i__]);
+	i__2 = i__;
+	strue[(i__ << 1) - 2] = ctrue[i__2].r;
+	strue[(i__ << 1) - 1] = d_imag(&ctrue[i__]);
+	i__2 = i__;
+	ssize[(i__ << 1) - 2] = csize[i__2].r;
+	ssize[(i__ << 1) - 1] = d_imag(&csize[i__]);
+/* L20: */
+    }
+
+    i__1 = *len << 1;
+    stest_(&i__1, scomp, strue, ssize, sfac);
+    return 0;
+} /* ctest_ */
+
+/* Subroutine */ int itest1_(integer *icomp, integer *itrue)
+{
+    /* Format strings */
+    static char fmt_99999[] = "(\002                                       F"
+	    "AIL\002)";
+    static char fmt_99998[] = "(/\002 CASE  N INCX INCY MODE                "
+	    "               \002,\002 COMP                                TRU"
+	    "E     DIFFERENCE\002,/1x)";
+    static char fmt_99997[] = "(1x,i4,i3,3i5,2i36,i12)";
+
+    /* Builtin functions */
+    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+    /* Local variables */
+    integer id;
+
+    /* Fortran I/O blocks */
+    static cilist io___61 = { 0, 6, 0, fmt_99999, 0 };
+    static cilist io___62 = { 0, 6, 0, fmt_99998, 0 };
+    static cilist io___64 = { 0, 6, 0, fmt_99997, 0 };
+
+
+/*     ********************************* ITEST1 ************************* */
+
+/*     THIS SUBROUTINE COMPARES THE VARIABLES ICOMP AND ITRUE FOR */
+/*     EQUALITY. */
+/*     C. L. LAWSON, JPL, 1974 DEC 10 */
+
+/*     .. Parameters .. */
+/*     .. Scalar Arguments .. */
+/*     .. Scalars in Common .. */
+/*     .. Local Scalars .. */
+/*     .. Common blocks .. */
+/*     .. Executable Statements .. */
+    if (*icomp == *itrue) {
+	goto L40;
+    }
+
+/*                            HERE ICOMP IS NOT EQUAL TO ITRUE. */
+
+    if (! combla_1.pass) {
+	goto L20;
+    }
+/*                             PRINT FAIL MESSAGE AND HEADER. */
+    combla_1.pass = FALSE_;
+    s_wsfe(&io___61);
+    e_wsfe();
+    s_wsfe(&io___62);
+    e_wsfe();
+L20:
+    id = *icomp - *itrue;
+    s_wsfe(&io___64);
+    do_fio(&c__1, (char *)&combla_1.icase, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&combla_1.n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&combla_1.incx, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&combla_1.incy, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&combla_1.mode, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&(*icomp), (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&(*itrue), (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&id, (ftnlen)sizeof(integer));
+    e_wsfe();
+L40:
+    return 0;
+
+} /* itest1_ */
+
+/* Main program alias */ int zcblat1_ () { MAIN__ (); return 0; }
diff --git a/CBLAS/testing/c_zblat2.c b/CBLAS/testing/c_zblat2.c
new file mode 100644
index 0000000..92c8534
--- /dev/null
+++ b/CBLAS/testing/c_zblat2.c
@@ -0,0 +1,4771 @@
+/* testing/c_zblat2.f -- translated by f2c (version 20191129).
+   You must link the resulting object file with libf2c:
+        on Microsoft Windows system, link with libf2c.lib;
+        on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+        or, if you install libf2c.a in a standard place, with -lf2c -lm
+        -- in that order, at the end of the command line, as in
+                cc *.o -lf2c -lm
+        Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+                http://www.netlib.org/f2c/libf2c.zip
+*/
+
+#include "f2c.h"
+
+/* Common Block Declarations */
+
+struct {
+  integer infot, noutc;
+  logical ok;
+} infoc_;
+
+#define infoc_1 infoc_
+
+struct {
+  char srnamt[12];
+} srnamc_;
+
+#define srnamc_1 srnamc_
+
+/* Table of constant values */
+
+static doublecomplex c_b1 = {0., 0.};
+static doublecomplex c_b2 = {1., 0.};
+static integer c__9 = 9;
+static integer c__1 = 1;
+static integer c__3 = 3;
+static integer c__8 = 8;
+static integer c__5 = 5;
+static integer c__65 = 65;
+static integer c__7 = 7;
+static integer c__2 = 2;
+static doublereal c_b125 = 1.;
+static integer c__6 = 6;
+static logical c_true = TRUE_;
+static integer c_n1 = -1;
+static integer c__0 = 0;
+static logical c_false = FALSE_;
+
+/* Main program */ int MAIN__(void) {
+  /* Initialized data */
+
+  static char snames[12 * 17] = "cblas_zgemv "
+                                "cblas_zgbmv "
+                                "cblas_zhemv "
+                                "cblas_zhbmv "
+                                "cblas_zhpmv "
+                                "cblas_ztrmv "
+                                "cblas_ztbmv "
+                                "cbl"
+                                "as_ztpmv "
+                                "cblas_ztrsv "
+                                "cblas_ztbsv "
+                                "cblas_ztpsv "
+                                "cblas_z"
+                                "gerc "
+                                "cblas_zgeru "
+                                "cblas_zher  "
+                                "cblas_zhpr  "
+                                "cblas_zher2 "
+                                "cblas_zhpr2 ";
+
+  /* Format strings */
+  static char fmt_9997[] = "(\002 NUMBER OF VALUES OF \002,a,\002 IS LESS "
+                           "THAN 1 OR GREATER \002,\002THAN \002,i2)";
+  static char fmt_9996[] = "(\002 VALUE OF N IS LESS THAN 0 OR GREATER THA"
+                           "N \002,i2)";
+  static char fmt_9995[] = "(\002 VALUE OF K IS LESS THAN 0\002)";
+  static char fmt_9994[] = "(\002 ABSOLUTE VALUE OF INCX OR INCY IS 0 OR G"
+                           "REATER THAN \002,i2)";
+  static char fmt_9993[] =
+      "(\002 TESTS OF THE COMPLEX*16      LEVEL 2 B"
+      "LAS\002,//\002 THE F\002,\002OLLOWING PARAMETER VALUES WILL BE U"
+      "SED:\002)";
+  static char fmt_9992[] = "(\002   FOR N              \002,9i6)";
+  static char fmt_9991[] = "(\002   FOR K              \002,7i6)";
+  static char fmt_9990[] = "(\002   FOR INCX AND INCY  \002,7i6)";
+  static char fmt_9989[] = "(\002   FOR ALPHA          \002,7(\002(\002,f4"
+                           ".1,\002,\002,f4.1,\002)  \002,:))";
+  static char fmt_9988[] = "(\002   FOR BETA           \002,7(\002(\002,f4"
+                           ".1,\002,\002,f4.1,\002)  \002,:))";
+  static char fmt_9980[] = "(\002 ERROR-EXITS WILL NOT BE TESTED\002)";
+  static char fmt_9999[] = "(\002 ROUTINES PASS COMPUTATIONAL TESTS IF TES"
+                           "T RATIO IS LES\002,\002S THAN\002,f8.2)";
+  static char fmt_10002[] = "(\002 COLUMN-MAJOR AND ROW-MAJOR DATA LAYOUTS"
+                            " ARE TESTED\002)";
+  static char fmt_10001[] = "(\002 ROW-MAJOR DATA LAYOUT IS TESTED\002)";
+  static char fmt_10000[] = "(\002 COLUMN-MAJOR DATA LAYOUT IS TESTED\002)";
+  static char fmt_9984[] = "(a12,l2)";
+  static char fmt_9986[] =
+      "(\002 SUBPROGRAM NAME \002,a12,\002 NOT RECOGN"
+      "IZED\002,/\002 ******* T\002,\002ESTS ABANDONED *******\002)";
+  static char fmt_9998[] = "(\002 RELATIVE MACHINE PRECISION IS TAKEN TO"
+                           " BE\002,1p,e9.1)";
+  static char fmt_9985[] =
+      "(\002 ERROR IN CMVCH -  IN-LINE DOT PRODUCTS A"
+      "RE BEING EVALU\002,\002ATED WRONGLY.\002,/\002 CMVCH WAS CALLED "
+      "WITH TRANS = \002,a1,\002 AND RETURNED SAME = \002,l1,\002 AND E"
+      "RR = \002,f12.3,\002.\002,/\002 THIS MAY BE DUE TO FAULTS IN THE"
+      " ARITHMETIC OR THE COMPILER.\002,/\002 ******* TESTS ABANDONED *"
+      "******\002)";
+  static char fmt_9983[] = "(1x,a12,\002 WAS NOT TESTED\002)";
+  static char fmt_9982[] = "(/\002 END OF TESTS\002)";
+  static char fmt_9981[] = "(/\002 ******* FATAL ERROR - TESTS ABANDONED *"
+                           "******\002)";
+  static char fmt_9987[] =
+      "(\002 AMEND DATA FILE OR INCREASE ARRAY SIZES "
+      "IN PROGRAM\002,/\002 ******* TESTS ABANDONED *******\002)";
+
+  /* System generated locals */
+  integer i__1, i__2, i__3, i__4, i__5;
+  doublereal d__1;
+  olist o__1;
+  cllist cl__1;
+
+  /* Builtin functions */
+  integer s_rsle(cilist *), do_lio(integer *, integer *, char *, ftnlen),
+      e_rsle(void), f_open(olist *), s_wsfe(cilist *),
+      do_fio(integer *, char *, ftnlen), e_wsfe(void), s_wsle(cilist *),
+      e_wsle(void), s_rsfe(cilist *), e_rsfe(void),
+      s_cmp(char *, char *, ftnlen, ftnlen);
+  /* Subroutine */ int s_stop(char *, ftnlen);
+  integer f_clos(cllist *);
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+
+  /* Local variables */
+  doublecomplex a[4225] /* was [65][65] */;
+  doublereal g[65];
+  integer i__, j, n;
+  doublecomplex x[65], y[65], z__[130], aa[4225];
+  integer kb[7];
+  doublecomplex as[4225], xs[130], ys[130], yt[65], xx[130], yy[130], alf[7];
+  integer inc[7], nkb;
+  doublecomplex bet[7];
+  doublereal eps, err;
+  extern logical lze_(doublecomplex *, doublecomplex *, integer *);
+  integer nalf, idim[9];
+  logical same;
+  integer ninc, nbet, ntra;
+  logical rewi;
+  extern /* Subroutine */ int zchk1_(
+      char *, doublereal *, doublereal *, integer *, integer *, logical *,
+      logical *, logical *, integer *, integer *, integer *, integer *,
+      integer *, doublecomplex *, integer *, doublecomplex *, integer *,
+      integer *, integer *, integer *, doublecomplex *, doublecomplex *,
+      doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+      doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+      doublereal *, integer *, ftnlen),
+      zchk2_(char *, doublereal *, doublereal *, integer *, integer *,
+             logical *, logical *, logical *, integer *, integer *, integer *,
+             integer *, integer *, doublecomplex *, integer *, doublecomplex *,
+             integer *, integer *, integer *, integer *, doublecomplex *,
+             doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+             doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+             doublecomplex *, doublereal *, integer *, ftnlen),
+      zchk3_(char *, doublereal *, doublereal *, integer *, integer *,
+             logical *, logical *, logical *, integer *, integer *, integer *,
+             integer *, integer *, integer *, integer *, integer *,
+             doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+             doublecomplex *, doublecomplex *, doublecomplex *, doublereal *,
+             doublecomplex *, integer *, ftnlen),
+      zchk4_(char *, doublereal *, doublereal *, integer *, integer *,
+             logical *, logical *, logical *, integer *, integer *, integer *,
+             doublecomplex *, integer *, integer *, integer *, integer *,
+             doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+             doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+             doublecomplex *, doublecomplex *, doublereal *, doublecomplex *,
+             integer *, ftnlen),
+      zchk5_(char *, doublereal *, doublereal *, integer *, integer *,
+             logical *, logical *, logical *, integer *, integer *, integer *,
+             doublecomplex *, integer *, integer *, integer *, integer *,
+             doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+             doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+             doublecomplex *, doublecomplex *, doublereal *, doublecomplex *,
+             integer *, ftnlen),
+      zchk6_(char *, doublereal *, doublereal *, integer *, integer *,
+             logical *, logical *, logical *, integer *, integer *, integer *,
+             doublecomplex *, integer *, integer *, integer *, integer *,
+             doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+             doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+             doublecomplex *, doublecomplex *, doublereal *, doublecomplex *,
+             integer *, ftnlen);
+  extern doublereal ddiff_(doublereal *, doublereal *);
+  logical fatal, trace;
+  integer nidim;
+  char snaps[32], trans[1];
+  extern /* Subroutine */ int zmvch_(
+      char *, integer *, integer *, doublecomplex *, doublecomplex *, integer *,
+      doublecomplex *, integer *, doublecomplex *, doublecomplex *, integer *,
+      doublecomplex *, doublereal *, doublecomplex *, doublereal *,
+      doublereal *, logical *, integer *, logical *, ftnlen);
+  integer isnum;
+  logical ltest[17], sfatal, corder;
+  char snamet[12];
+  doublereal thresh;
+  logical rorder;
+  integer layout;
+  logical ltestt, tsterr;
+  extern /* Subroutine */ void cz2chke_(char *);
+
+  /* Fortran I/O blocks */
+  static cilist io___2 = {0, 5, 0, 0, 0};
+  static cilist io___4 = {0, 5, 0, 0, 0};
+  static cilist io___7 = {0, 5, 0, 0, 0};
+  static cilist io___9 = {0, 5, 0, 0, 0};
+  static cilist io___11 = {0, 5, 0, 0, 0};
+  static cilist io___13 = {0, 5, 0, 0, 0};
+  static cilist io___15 = {0, 5, 0, 0, 0};
+  static cilist io___17 = {0, 5, 0, 0, 0};
+  static cilist io___19 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___20 = {0, 5, 0, 0, 0};
+  static cilist io___23 = {0, 6, 0, fmt_9996, 0};
+  static cilist io___24 = {0, 5, 0, 0, 0};
+  static cilist io___26 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___27 = {0, 5, 0, 0, 0};
+  static cilist io___29 = {0, 6, 0, fmt_9995, 0};
+  static cilist io___30 = {0, 5, 0, 0, 0};
+  static cilist io___32 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___33 = {0, 5, 0, 0, 0};
+  static cilist io___35 = {0, 6, 0, fmt_9994, 0};
+  static cilist io___36 = {0, 5, 0, 0, 0};
+  static cilist io___38 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___39 = {0, 5, 0, 0, 0};
+  static cilist io___41 = {0, 5, 0, 0, 0};
+  static cilist io___43 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___44 = {0, 5, 0, 0, 0};
+  static cilist io___46 = {0, 6, 0, fmt_9993, 0};
+  static cilist io___47 = {0, 6, 0, fmt_9992, 0};
+  static cilist io___48 = {0, 6, 0, fmt_9991, 0};
+  static cilist io___49 = {0, 6, 0, fmt_9990, 0};
+  static cilist io___50 = {0, 6, 0, fmt_9989, 0};
+  static cilist io___51 = {0, 6, 0, fmt_9988, 0};
+  static cilist io___52 = {0, 6, 0, 0, 0};
+  static cilist io___53 = {0, 6, 0, fmt_9980, 0};
+  static cilist io___54 = {0, 6, 0, 0, 0};
+  static cilist io___55 = {0, 6, 0, fmt_9999, 0};
+  static cilist io___56 = {0, 6, 0, 0, 0};
+  static cilist io___59 = {0, 6, 0, fmt_10002, 0};
+  static cilist io___60 = {0, 6, 0, fmt_10001, 0};
+  static cilist io___61 = {0, 6, 0, fmt_10000, 0};
+  static cilist io___62 = {0, 6, 0, 0, 0};
+  static cilist io___64 = {0, 5, 1, fmt_9984, 0};
+  static cilist io___67 = {0, 6, 0, fmt_9986, 0};
+  static cilist io___69 = {0, 6, 0, fmt_9998, 0};
+  static cilist io___82 = {0, 6, 0, fmt_9985, 0};
+  static cilist io___83 = {0, 6, 0, fmt_9985, 0};
+  static cilist io___85 = {0, 6, 0, 0, 0};
+  static cilist io___86 = {0, 6, 0, fmt_9983, 0};
+  static cilist io___87 = {0, 6, 0, 0, 0};
+  static cilist io___94 = {0, 6, 0, fmt_9982, 0};
+  static cilist io___95 = {0, 6, 0, fmt_9981, 0};
+  static cilist io___96 = {0, 6, 0, fmt_9987, 0};
+
+  /*  Test program for the COMPLEX*16          Level 2 Blas. */
+
+  /*  The program must be driven by a short data file. The first 17 records */
+  /*  of the file are read using list-directed input, the last 17 records */
+  /*  are read using the format ( A12, L2 ). An annotated example of a data */
+  /*  file can be obtained by deleting the first 3 characters from the */
+  /*  following 34 lines: */
+  /*  'CBLAT2.SNAP'     NAME OF SNAPSHOT OUTPUT FILE */
+  /*  -1                UNIT NUMBER OF SNAPSHOT FILE (NOT USED IF .LT. 0) */
+  /*  F        LOGICAL FLAG, T TO REWIND SNAPSHOT FILE AFTER EACH RECORD. */
+  /*  F        LOGICAL FLAG, T TO STOP ON FAILURES. */
+  /*  T        LOGICAL FLAG, T TO TEST ERROR EXITS. */
+  /*  2        0 TO TEST COLUMN-MAJOR, 1 TO TEST ROW-MAJOR, 2 TO TEST BOTH */
+  /*  16.0     THRESHOLD VALUE OF TEST RATIO */
+  /*  6                 NUMBER OF VALUES OF N */
+  /*  0 1 2 3 5 9       VALUES OF N */
+  /*  4                 NUMBER OF VALUES OF K */
+  /*  0 1 2 4           VALUES OF K */
+  /*  4                 NUMBER OF VALUES OF INCX AND INCY */
+  /*  1 2 -1 -2         VALUES OF INCX AND INCY */
+  /*  3                 NUMBER OF VALUES OF ALPHA */
+  /*  (0.0,0.0) (1.0,0.0) (0.7,-0.9)       VALUES OF ALPHA */
+  /*  3                 NUMBER OF VALUES OF BETA */
+  /*  (0.0,0.0) (1.0,0.0) (1.3,-1.1)       VALUES OF BETA */
+  /*  cblas_zgemv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_zgbmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_zhemv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_zhbmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_zhpmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_ztrmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_ztbmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_ztpmv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_ztrsv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_ztbsv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_ztpsv  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_zgerc  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_zgeru  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_zher   T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_zhpr   T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_zher2  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  cblas_zhpr2  T PUT F FOR NO TEST. SAME COLUMNS. */
+
+  /*     See: */
+
+  /*        Dongarra J. J., Du Croz J. J., Hammarling S.  and Hanson R. J.. */
+  /*        An  extended  set of Fortran  Basic Linear Algebra Subprograms. */
+
+  /*        Technical  Memoranda  Nos. 41 (revision 3) and 81,  Mathematics */
+  /*        and  Computer Science  Division,  Argonne  National Laboratory, */
+  /*        9700 South Cass Avenue, Argonne, Illinois 60439, US. */
+
+  /*        Or */
+
+  /*        NAG  Technical Reports TR3/87 and TR4/87,  Numerical Algorithms */
+  /*        Group  Ltd.,  NAG  Central  Office,  256  Banbury  Road, Oxford */
+  /*        OX2 7DE, UK,  and  Numerical Algorithms Group Inc.,  1101  31st */
+  /*        Street,  Suite 100,  Downers Grove,  Illinois 60515-1263,  USA. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Parameters .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /*     .. Executable Statements .. */
+
+  infoc_1.noutc = 6;
+
+  /*     Read name and unit number for summary output file and open file. */
+
+  s_rsle(&io___2);
+  do_lio(&c__9, &c__1, snaps, (ftnlen)32);
+  e_rsle();
+  s_rsle(&io___4);
+  do_lio(&c__3, &c__1, (char *)&ntra, (ftnlen)sizeof(integer));
+  e_rsle();
+  trace = ntra >= 0;
+  if (trace) {
+    o__1.oerr = 0;
+    o__1.ounit = ntra;
+    o__1.ofnmlen = 32;
+    o__1.ofnm = snaps;
+    o__1.orl = 0;
+    o__1.osta = 0;
+    o__1.oacc = 0;
+    o__1.ofm = 0;
+    o__1.oblnk = 0;
+    f_open(&o__1);
+  }
+  /*     Read the flag that directs rewinding of the snapshot file. */
+  s_rsle(&io___7);
+  do_lio(&c__8, &c__1, (char *)&rewi, (ftnlen)sizeof(logical));
+  e_rsle();
+  rewi = rewi && trace;
+  /*     Read the flag that directs stopping on any failure. */
+  s_rsle(&io___9);
+  do_lio(&c__8, &c__1, (char *)&sfatal, (ftnlen)sizeof(logical));
+  e_rsle();
+  /*     Read the flag that indicates whether error exits are to be tested. */
+  s_rsle(&io___11);
+  do_lio(&c__8, &c__1, (char *)&tsterr, (ftnlen)sizeof(logical));
+  e_rsle();
+  /*     Read the flag that indicates whether row-major data layout to be
+   * tested. */
+  s_rsle(&io___13);
+  do_lio(&c__3, &c__1, (char *)&layout, (ftnlen)sizeof(integer));
+  e_rsle();
+  /*     Read the threshold value of the test ratio */
+  s_rsle(&io___15);
+  do_lio(&c__5, &c__1, (char *)&thresh, (ftnlen)sizeof(doublereal));
+  e_rsle();
+
+  /*     Read and check the parameter values for the tests. */
+
+  /*     Values of N */
+  s_rsle(&io___17);
+  do_lio(&c__3, &c__1, (char *)&nidim, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nidim < 1 || nidim > 9) {
+    s_wsfe(&io___19);
+    do_fio(&c__1, "N", (ftnlen)1);
+    do_fio(&c__1, (char *)&c__9, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L230;
+  }
+  s_rsle(&io___20);
+  i__1 = nidim;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__3, &c__1, (char *)&idim[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_rsle();
+  i__1 = nidim;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    if (idim[i__ - 1] < 0 || idim[i__ - 1] > 65) {
+      s_wsfe(&io___23);
+      do_fio(&c__1, (char *)&c__65, (ftnlen)sizeof(integer));
+      e_wsfe();
+      goto L230;
+    }
+    /* L10: */
+  }
+  /*     Values of K */
+  s_rsle(&io___24);
+  do_lio(&c__3, &c__1, (char *)&nkb, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nkb < 1 || nkb > 7) {
+    s_wsfe(&io___26);
+    do_fio(&c__1, "K", (ftnlen)1);
+    do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L230;
+  }
+  s_rsle(&io___27);
+  i__1 = nkb;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__3, &c__1, (char *)&kb[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_rsle();
+  i__1 = nkb;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    if (kb[i__ - 1] < 0) {
+      s_wsfe(&io___29);
+      e_wsfe();
+      goto L230;
+    }
+    /* L20: */
+  }
+  /*     Values of INCX and INCY */
+  s_rsle(&io___30);
+  do_lio(&c__3, &c__1, (char *)&ninc, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (ninc < 1 || ninc > 7) {
+    s_wsfe(&io___32);
+    do_fio(&c__1, "INCX AND INCY", (ftnlen)13);
+    do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L230;
+  }
+  s_rsle(&io___33);
+  i__1 = ninc;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__3, &c__1, (char *)&inc[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_rsle();
+  i__1 = ninc;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    if (inc[i__ - 1] == 0 || (i__2 = inc[i__ - 1], abs(i__2)) > 2) {
+      s_wsfe(&io___35);
+      do_fio(&c__1, (char *)&c__2, (ftnlen)sizeof(integer));
+      e_wsfe();
+      goto L230;
+    }
+    /* L30: */
+  }
+  /*     Values of ALPHA */
+  s_rsle(&io___36);
+  do_lio(&c__3, &c__1, (char *)&nalf, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nalf < 1 || nalf > 7) {
+    s_wsfe(&io___38);
+    do_fio(&c__1, "ALPHA", (ftnlen)5);
+    do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L230;
+  }
+  s_rsle(&io___39);
+  i__1 = nalf;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__7, &c__1, (char *)&alf[i__ - 1], (ftnlen)sizeof(doublecomplex));
+  }
+  e_rsle();
+  /*     Values of BETA */
+  s_rsle(&io___41);
+  do_lio(&c__3, &c__1, (char *)&nbet, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nbet < 1 || nbet > 7) {
+    s_wsfe(&io___43);
+    do_fio(&c__1, "BETA", (ftnlen)4);
+    do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L230;
+  }
+  s_rsle(&io___44);
+  i__1 = nbet;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__7, &c__1, (char *)&bet[i__ - 1], (ftnlen)sizeof(doublecomplex));
+  }
+  e_rsle();
+
+  /*     Report values of parameters. */
+
+  s_wsfe(&io___46);
+  e_wsfe();
+  s_wsfe(&io___47);
+  i__1 = nidim;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__1, (char *)&idim[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_wsfe();
+  s_wsfe(&io___48);
+  i__1 = nkb;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__1, (char *)&kb[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_wsfe();
+  s_wsfe(&io___49);
+  i__1 = ninc;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__1, (char *)&inc[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_wsfe();
+  s_wsfe(&io___50);
+  i__1 = nalf;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__2, (char *)&alf[i__ - 1], (ftnlen)sizeof(doublereal));
+  }
+  e_wsfe();
+  s_wsfe(&io___51);
+  i__1 = nbet;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__2, (char *)&bet[i__ - 1], (ftnlen)sizeof(doublereal));
+  }
+  e_wsfe();
+  if (!tsterr) {
+    s_wsle(&io___52);
+    e_wsle();
+    s_wsfe(&io___53);
+    e_wsfe();
+  }
+  s_wsle(&io___54);
+  e_wsle();
+  s_wsfe(&io___55);
+  do_fio(&c__1, (char *)&thresh, (ftnlen)sizeof(doublereal));
+  e_wsfe();
+  s_wsle(&io___56);
+  e_wsle();
+  rorder = FALSE_;
+  corder = FALSE_;
+  if (layout == 2) {
+    rorder = TRUE_;
+    corder = TRUE_;
+    s_wsfe(&io___59);
+    e_wsfe();
+  } else if (layout == 1) {
+    rorder = TRUE_;
+    s_wsfe(&io___60);
+    e_wsfe();
+  } else if (layout == 0) {
+    corder = TRUE_;
+    s_wsfe(&io___61);
+    e_wsfe();
+  }
+  s_wsle(&io___62);
+  e_wsle();
+
+  /*     Read names of subroutines and flags which indicate */
+  /*     whether they are to be tested. */
+
+  for (i__ = 1; i__ <= 17; ++i__) {
+    ltest[i__ - 1] = FALSE_;
+    /* L40: */
+  }
+L50:
+  i__1 = s_rsfe(&io___64);
+  if (i__1 != 0) {
+    goto L80;
+  }
+  i__1 = do_fio(&c__1, snamet, (ftnlen)12);
+  if (i__1 != 0) {
+    goto L80;
+  }
+  i__1 = do_fio(&c__1, (char *)&ltestt, (ftnlen)sizeof(logical));
+  if (i__1 != 0) {
+    goto L80;
+  }
+  i__1 = e_rsfe();
+  if (i__1 != 0) {
+    goto L80;
+  }
+  for (i__ = 1; i__ <= 17; ++i__) {
+    if (s_cmp(snamet, snames + (i__ - 1) * 12, (ftnlen)12, (ftnlen)12) == 0) {
+      goto L70;
+    }
+    /* L60: */
+  }
+  s_wsfe(&io___67);
+  do_fio(&c__1, snamet, (ftnlen)12);
+  e_wsfe();
+  s_stop("", (ftnlen)0);
+L70:
+  ltest[i__ - 1] = ltestt;
+  goto L50;
+
+L80:
+  cl__1.cerr = 0;
+  cl__1.cunit = 5;
+  cl__1.csta = 0;
+  f_clos(&cl__1);
+
+  /*     Compute EPS (the machine precision). */
+
+  eps = 1.;
+L90:
+  d__1 = eps + 1.;
+  if (ddiff_(&d__1, &c_b125) == 0.) {
+    goto L100;
+  }
+  eps *= .5;
+  goto L90;
+L100:
+  eps += eps;
+  s_wsfe(&io___69);
+  do_fio(&c__1, (char *)&eps, (ftnlen)sizeof(doublereal));
+  e_wsfe();
+
+  /*     Check the reliability of ZMVCH using exact data. */
+
+  n = 32;
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = n;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      i__3 = i__ + j * 65 - 66;
+      /* Computing MAX */
+      i__5 = i__ - j + 1;
+      i__4 = max(i__5, 0);
+      a[i__3].r = (doublereal)i__4, a[i__3].i = 0.;
+      /* L110: */
+    }
+    i__2 = j - 1;
+    x[i__2].r = (doublereal)j, x[i__2].i = 0.;
+    i__2 = j - 1;
+    y[i__2].r = 0., y[i__2].i = 0.;
+    /* L120: */
+  }
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = j - 1;
+    i__3 = j * ((j + 1) * j) / 2 - (j + 1) * j * (j - 1) / 3;
+    yy[i__2].r = (doublereal)i__3, yy[i__2].i = 0.;
+    /* L130: */
+  }
+  /*     YY holds the exact result. On exit from CMVCH YT holds */
+  /*     the result computed by CMVCH. */
+  *(unsigned char *)trans = 'N';
+  zmvch_(trans, &n, &n, &c_b2, a, &c__65, x, &c__1, &c_b1, y, &c__1, yt, g, yy,
+         &eps, &err, &fatal, &c__6, &c_true, (ftnlen)1);
+  same = lze_(yy, yt, &n);
+  if (!same || err != 0.) {
+    s_wsfe(&io___82);
+    do_fio(&c__1, trans, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(doublereal));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+  *(unsigned char *)trans = 'T';
+  zmvch_(trans, &n, &n, &c_b2, a, &c__65, x, &c_n1, &c_b1, y, &c_n1, yt, g, yy,
+         &eps, &err, &fatal, &c__6, &c_true, (ftnlen)1);
+  same = lze_(yy, yt, &n);
+  if (!same || err != 0.) {
+    s_wsfe(&io___83);
+    do_fio(&c__1, trans, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(doublereal));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+
+  /*     Test each subroutine in turn. */
+
+  for (isnum = 1; isnum <= 17; ++isnum) {
+    s_wsle(&io___85);
+    e_wsle();
+    if (!ltest[isnum - 1]) {
+      /*           Subprogram is not to be tested. */
+      s_wsfe(&io___86);
+      do_fio(&c__1, snames + (isnum - 1) * 12, (ftnlen)12);
+      e_wsfe();
+    } else {
+      s_copy(srnamc_1.srnamt, snames + (isnum - 1) * 12, (ftnlen)12,
+             (ftnlen)12);
+      /*           Test error exits. */
+      if (tsterr) {
+        cz2chke_(snames + (isnum - 1) * 12);
+        s_wsle(&io___87);
+        e_wsle();
+      }
+      /*           Test computations. */
+      infoc_1.infot = 0;
+      infoc_1.ok = TRUE_;
+      fatal = FALSE_;
+      switch (isnum) {
+      case 1:
+        goto L140;
+      case 2:
+        goto L140;
+      case 3:
+        goto L150;
+      case 4:
+        goto L150;
+      case 5:
+        goto L150;
+      case 6:
+        goto L160;
+      case 7:
+        goto L160;
+      case 8:
+        goto L160;
+      case 9:
+        goto L160;
+      case 10:
+        goto L160;
+      case 11:
+        goto L160;
+      case 12:
+        goto L170;
+      case 13:
+        goto L170;
+      case 14:
+        goto L180;
+      case 15:
+        goto L180;
+      case 16:
+        goto L190;
+      case 17:
+        goto L190;
+      }
+    /*           Test ZGEMV, 01, and ZGBMV, 02. */
+    L140:
+      if (corder) {
+        zchk1_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nkb, kb, &nalf, alf, &nbet, bet,
+               &ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt,
+               g, &c__0, (ftnlen)12);
+      }
+      if (rorder) {
+        zchk1_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nkb, kb, &nalf, alf, &nbet, bet,
+               &ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt,
+               g, &c__1, (ftnlen)12);
+      }
+      goto L200;
+    /*           Test ZHEMV, 03, ZHBMV, 04, and ZHPMV, 05. */
+    L150:
+      if (corder) {
+        zchk2_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nkb, kb, &nalf, alf, &nbet, bet,
+               &ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt,
+               g, &c__0, (ftnlen)12);
+      }
+      if (rorder) {
+        zchk2_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nkb, kb, &nalf, alf, &nbet, bet,
+               &ninc, inc, &c__65, &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt,
+               g, &c__1, (ftnlen)12);
+      }
+      goto L200;
+    /*           Test ZTRMV, 06, ZTBMV, 07, ZTPMV, 08, */
+    /*           ZTRSV, 09, ZTBSV, 10, and ZTPSV, 11. */
+    L160:
+      if (corder) {
+        zchk3_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nkb, kb, &ninc, inc, &c__65, &c__2,
+               a, aa, as, y, yy, ys, yt, g, z__, &c__0, (ftnlen)12);
+      }
+      if (rorder) {
+        zchk3_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nkb, kb, &ninc, inc, &c__65, &c__2,
+               a, aa, as, y, yy, ys, yt, g, z__, &c__1, (ftnlen)12);
+      }
+      goto L200;
+    /*           Test ZGERC, 12, ZGERU, 13. */
+    L170:
+      if (corder) {
+        zchk4_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &ninc, inc, &c__65,
+               &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt, g, z__, &c__0,
+               (ftnlen)12);
+      }
+      if (rorder) {
+        zchk4_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &ninc, inc, &c__65,
+               &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt, g, z__, &c__1,
+               (ftnlen)12);
+      }
+      goto L200;
+    /*           Test ZHER, 14, and ZHPR, 15. */
+    L180:
+      if (corder) {
+        zchk5_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &ninc, inc, &c__65,
+               &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt, g, z__, &c__0,
+               (ftnlen)12);
+      }
+      if (rorder) {
+        zchk5_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &ninc, inc, &c__65,
+               &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt, g, z__, &c__1,
+               (ftnlen)12);
+      }
+      goto L200;
+    /*           Test ZHER2, 16, and ZHPR2, 17. */
+    L190:
+      if (corder) {
+        zchk6_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &ninc, inc, &c__65,
+               &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt, g, z__, &c__0,
+               (ftnlen)12);
+      }
+      if (rorder) {
+        zchk6_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &ninc, inc, &c__65,
+               &c__2, a, aa, as, x, xx, xs, y, yy, ys, yt, g, z__, &c__1,
+               (ftnlen)12);
+      }
+
+    L200:
+      if (fatal && sfatal) {
+        goto L220;
+      }
+    }
+    /* L210: */
+  }
+  s_wsfe(&io___94);
+  e_wsfe();
+  goto L240;
+
+L220:
+  s_wsfe(&io___95);
+  e_wsfe();
+  goto L240;
+
+L230:
+  s_wsfe(&io___96);
+  e_wsfe();
+
+L240:
+  if (trace) {
+    cl__1.cerr = 0;
+    cl__1.cunit = ntra;
+    cl__1.csta = 0;
+    f_clos(&cl__1);
+  }
+  cl__1.cerr = 0;
+  cl__1.cunit = 6;
+  cl__1.csta = 0;
+  f_clos(&cl__1);
+  s_stop("", (ftnlen)0);
+
+  /*     End of ZBLAT2. */
+
+  return 0;
+} /* MAIN__ */
+
+/* Subroutine */ int
+zchk1_(char *sname, doublereal *eps, doublereal *thresh, integer *nout,
+       integer *ntra, logical *trace, logical *rewi, logical *fatal,
+       integer *nidim, integer *idim, integer *nkb, integer *kb, integer *nalf,
+       doublecomplex *alf, integer *nbet, doublecomplex *bet, integer *ninc,
+       integer *inc, integer *nmax, integer *incmax, doublecomplex *a,
+       doublecomplex *aa, doublecomplex *as, doublecomplex *x,
+       doublecomplex *xx, doublecomplex *xs, doublecomplex *y,
+       doublecomplex *yy, doublecomplex *ys, doublecomplex *yt, doublereal *g,
+       integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ich[3] = "NTC";
+
+  /* Format strings */
+  static char fmt_9994[] =
+      "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+      "2(i3,\002,\002),\002(\002,f4.1,\002,\002,f4.1,\002), A,\002,/10x"
+      ",i3,\002, X,\002,i2,\002,(\002,f4.1,\002,\002,f4.1,\002), Y,\002"
+      ",i2,\002) .\002)";
+  static char fmt_9995[] =
+      "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+      "4(i3,\002,\002),\002(\002,f4.1,\002,\002,f4.1,\002), A,\002,/10x"
+      ",i3,\002, X,\002,i2,\002,(\002,f4.1,\002,\002,f4.1,\002), Y,\002"
+      ",i2,\002) .\002)";
+  static char fmt_9993[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_9999[] = "(\002 \002,a12,\002 PASSED THE COMPUTATIONAL T"
+                           "ESTS (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_9997[] =
+      "(\002 \002,a12,\002 COMPLETED THE COMPUTATIONA"
+      "L TESTS (\002,i6,\002 C\002,\002ALLS)\002,/\002 ******* BUT WITH"
+      " MAXIMUM TEST RATIO\002,f8.2,\002 - SUSPECT *******\002)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6, i__7, i__8,
+      i__9;
+  alist al__1;
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+      f_rew(alist *);
+
+  /* Local variables */
+  integer i__, m, n, ia, ib, ic, nc, nd, im, in, kl, ml, nk, nl, ku, ix, iy, ms,
+      lx, ly, ns, laa, lda;
+  doublecomplex als, bls;
+  doublereal err;
+  integer iku, kls;
+  extern logical lze_(doublecomplex *, doublecomplex *, integer *);
+  integer kus;
+  doublecomplex beta;
+  integer ldas;
+  logical same;
+  integer incx, incy;
+  logical full, tran, null;
+  doublecomplex alpha;
+  logical isame[13];
+  extern /* Subroutine */ int zmake_(
+      char *, char *, char *, integer *, integer *, doublecomplex *, integer *,
+      doublecomplex *, integer *, integer *, integer *, logical *,
+      doublecomplex *, ftnlen, ftnlen, ftnlen);
+  integer nargs;
+  logical reset;
+  integer incxs, incys;
+  char trans[1];
+  extern /* Subroutine */ int zmvch_(
+      char *, integer *, integer *, doublecomplex *, doublecomplex *, integer *,
+      doublecomplex *, integer *, doublecomplex *, doublecomplex *, integer *,
+      doublecomplex *, doublereal *, doublecomplex *, doublereal *,
+      doublereal *, logical *, integer *, logical *, ftnlen);
+  logical banded;
+  extern /* Subroutine */ void czgbmv_(
+      integer *, char *, integer *, integer *, integer *, integer *,
+      doublecomplex *, doublecomplex *, integer *, doublecomplex *, integer *,
+      doublecomplex *, doublecomplex *, integer *);
+  char ctrans[14];
+  extern /* Subroutine */ void czgemv_(
+      integer *, char *, integer *, integer *, doublecomplex *, doublecomplex *,
+      integer *, doublecomplex *, integer *, doublecomplex *, doublecomplex *,
+      integer *);
+  doublereal errmax;
+  doublecomplex transl;
+  extern logical lzeres_(char *, char *, integer *, integer *, doublecomplex *,
+                         doublecomplex *, integer *, ftnlen, ftnlen);
+  char transs[1];
+
+  /* Fortran I/O blocks */
+  static cilist io___144 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___145 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___146 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___149 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___151 = {0, 0, 0, fmt_9999, 0};
+  static cilist io___152 = {0, 0, 0, fmt_9997, 0};
+  static cilist io___153 = {0, 0, 0, fmt_9996, 0};
+  static cilist io___154 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___155 = {0, 0, 0, fmt_9995, 0};
+
+  /*  Tests CGEMV and CGBMV. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --kb;
+  --alf;
+  --bet;
+  --inc;
+  --g;
+  --yt;
+  --y;
+  --x;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --ys;
+  --yy;
+  --xs;
+  --xx;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+  full = *(unsigned char *)&sname[8] == 'e';
+  banded = *(unsigned char *)&sname[8] == 'b';
+  /*     Define the number of arguments. */
+  if (full) {
+    nargs = 11;
+  } else if (banded) {
+    nargs = 13;
+  }
+
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.;
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+    nd = n / 2 + 1;
+
+    for (im = 1; im <= 2; ++im) {
+      if (im == 1) {
+        /* Computing MAX */
+        i__2 = n - nd;
+        m = max(i__2, 0);
+      }
+      if (im == 2) {
+        /* Computing MIN */
+        i__2 = n + nd;
+        m = min(i__2, *nmax);
+      }
+
+      if (banded) {
+        nk = *nkb;
+      } else {
+        nk = 1;
+      }
+      i__2 = nk;
+      for (iku = 1; iku <= i__2; ++iku) {
+        if (banded) {
+          ku = kb[iku];
+          /* Computing MAX */
+          i__3 = ku - 1;
+          kl = max(i__3, 0);
+        } else {
+          ku = n - 1;
+          kl = m - 1;
+        }
+        /*              Set LDA to 1 more than minimum value if room. */
+        if (banded) {
+          lda = kl + ku + 1;
+        } else {
+          lda = m;
+        }
+        if (lda < *nmax) {
+          ++lda;
+        }
+        /*              Skip tests if not enough room. */
+        if (lda > *nmax) {
+          goto L100;
+        }
+        laa = lda * n;
+        null = n <= 0 || m <= 0;
+
+        /*              Generate the matrix A. */
+
+        transl.r = 0., transl.i = 0.;
+        zmake_(sname + 7, " ", " ", &m, &n, &a[a_offset], nmax, &aa[1], &lda,
+               &kl, &ku, &reset, &transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+        for (ic = 1; ic <= 3; ++ic) {
+          *(unsigned char *)trans = *(unsigned char *)&ich[ic - 1];
+          if (*(unsigned char *)trans == 'N') {
+            s_copy(ctrans, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+          } else if (*(unsigned char *)trans == 'T') {
+            s_copy(ctrans, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+          } else {
+            s_copy(ctrans, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+          }
+          tran =
+              *(unsigned char *)trans == 'T' || *(unsigned char *)trans == 'C';
+
+          if (tran) {
+            ml = n;
+            nl = m;
+          } else {
+            ml = m;
+            nl = n;
+          }
+
+          i__3 = *ninc;
+          for (ix = 1; ix <= i__3; ++ix) {
+            incx = inc[ix];
+            lx = abs(incx) * nl;
+
+            /*                    Generate the vector X. */
+
+            transl.r = .5, transl.i = 0.;
+            i__4 = abs(incx);
+            i__5 = nl - 1;
+            zmake_("ge", " ", " ", &c__1, &nl, &x[1], &c__1, &xx[1], &i__4,
+                   &c__0, &i__5, &reset, &transl, (ftnlen)2, (ftnlen)1,
+                   (ftnlen)1);
+            if (nl > 1) {
+              i__4 = nl / 2;
+              x[i__4].r = 0., x[i__4].i = 0.;
+              i__4 = abs(incx) * (nl / 2 - 1) + 1;
+              xx[i__4].r = 0., xx[i__4].i = 0.;
+            }
+
+            i__4 = *ninc;
+            for (iy = 1; iy <= i__4; ++iy) {
+              incy = inc[iy];
+              ly = abs(incy) * ml;
+
+              i__5 = *nalf;
+              for (ia = 1; ia <= i__5; ++ia) {
+                i__6 = ia;
+                alpha.r = alf[i__6].r, alpha.i = alf[i__6].i;
+
+                i__6 = *nbet;
+                for (ib = 1; ib <= i__6; ++ib) {
+                  i__7 = ib;
+                  beta.r = bet[i__7].r, beta.i = bet[i__7].i;
+
+                  /*                             Generate the vector Y. */
+
+                  transl.r = 0., transl.i = 0.;
+                  i__7 = abs(incy);
+                  i__8 = ml - 1;
+                  zmake_("ge", " ", " ", &c__1, &ml, &y[1], &c__1, &yy[1],
+                         &i__7, &c__0, &i__8, &reset, &transl, (ftnlen)2,
+                         (ftnlen)1, (ftnlen)1);
+
+                  ++nc;
+
+                  /*                             Save every datum before calling
+                   * the */
+                  /*                             subroutine. */
+
+                  *(unsigned char *)transs = *(unsigned char *)trans;
+                  ms = m;
+                  ns = n;
+                  kls = kl;
+                  kus = ku;
+                  als.r = alpha.r, als.i = alpha.i;
+                  i__7 = laa;
+                  for (i__ = 1; i__ <= i__7; ++i__) {
+                    i__8 = i__;
+                    i__9 = i__;
+                    as[i__8].r = aa[i__9].r, as[i__8].i = aa[i__9].i;
+                    /* L10: */
+                  }
+                  ldas = lda;
+                  i__7 = lx;
+                  for (i__ = 1; i__ <= i__7; ++i__) {
+                    i__8 = i__;
+                    i__9 = i__;
+                    xs[i__8].r = xx[i__9].r, xs[i__8].i = xx[i__9].i;
+                    /* L20: */
+                  }
+                  incxs = incx;
+                  bls.r = beta.r, bls.i = beta.i;
+                  i__7 = ly;
+                  for (i__ = 1; i__ <= i__7; ++i__) {
+                    i__8 = i__;
+                    i__9 = i__;
+                    ys[i__8].r = yy[i__9].r, ys[i__8].i = yy[i__9].i;
+                    /* L30: */
+                  }
+                  incys = incy;
+
+                  /*                             Call the subroutine. */
+
+                  if (full) {
+                    if (*trace) {
+                      io___144.ciunit = *ntra;
+                      s_wsfe(&io___144);
+                      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                      do_fio(&c__1, sname, (ftnlen)12);
+                      do_fio(&c__1, ctrans, (ftnlen)14);
+                      do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer));
+                      do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                      do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(doublereal));
+                      do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+                      do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                      do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(doublereal));
+                      do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+                      e_wsfe();
+                    }
+                    if (*rewi) {
+                      al__1.aerr = 0;
+                      al__1.aunit = *ntra;
+                      f_rew(&al__1);
+                    }
+                    czgemv_(iorder, trans, &m, &n, &alpha, &aa[1], &lda, &xx[1],
+                            &incx, &beta, &yy[1], &incy);
+                  } else if (banded) {
+                    if (*trace) {
+                      io___145.ciunit = *ntra;
+                      s_wsfe(&io___145);
+                      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                      do_fio(&c__1, sname, (ftnlen)12);
+                      do_fio(&c__1, ctrans, (ftnlen)14);
+                      do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer));
+                      do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                      do_fio(&c__1, (char *)&kl, (ftnlen)sizeof(integer));
+                      do_fio(&c__1, (char *)&ku, (ftnlen)sizeof(integer));
+                      do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(doublereal));
+                      do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+                      do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                      do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(doublereal));
+                      do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+                      e_wsfe();
+                    }
+                    if (*rewi) {
+                      al__1.aerr = 0;
+                      al__1.aunit = *ntra;
+                      f_rew(&al__1);
+                    }
+                    czgbmv_(iorder, trans, &m, &n, &kl, &ku, &alpha, &aa[1],
+                            &lda, &xx[1], &incx, &beta, &yy[1], &incy);
+                  }
+
+                  /*                            Check if error-exit was taken
+                   * incorrectly. */
+
+                  if (!infoc_1.ok) {
+                    io___146.ciunit = *nout;
+                    s_wsfe(&io___146);
+                    e_wsfe();
+                    *fatal = TRUE_;
+                    goto L130;
+                  }
+
+                  /*                             See what data changed inside
+                   * subroutines. */
+
+                  /*        IF(TRANS .NE. 'C' .OR. (INCX .GT. 0 .AND. INCY .GT.
+                   * 0)) THEN */
+                  isame[0] =
+                      *(unsigned char *)trans == *(unsigned char *)transs;
+                  isame[1] = ms == m;
+                  isame[2] = ns == n;
+                  if (full) {
+                    isame[3] = als.r == alpha.r && als.i == alpha.i;
+                    isame[4] = lze_(&as[1], &aa[1], &laa);
+                    isame[5] = ldas == lda;
+                    isame[6] = lze_(&xs[1], &xx[1], &lx);
+                    isame[7] = incxs == incx;
+                    isame[8] = bls.r == beta.r && bls.i == beta.i;
+                    if (null) {
+                      isame[9] = lze_(&ys[1], &yy[1], &ly);
+                    } else {
+                      i__7 = abs(incy);
+                      isame[9] = lzeres_("ge", " ", &c__1, &ml, &ys[1], &yy[1],
+                                         &i__7, (ftnlen)2, (ftnlen)1);
+                    }
+                    isame[10] = incys == incy;
+                  } else if (banded) {
+                    isame[3] = kls == kl;
+                    isame[4] = kus == ku;
+                    isame[5] = als.r == alpha.r && als.i == alpha.i;
+                    isame[6] = lze_(&as[1], &aa[1], &laa);
+                    isame[7] = ldas == lda;
+                    isame[8] = lze_(&xs[1], &xx[1], &lx);
+                    isame[9] = incxs == incx;
+                    isame[10] = bls.r == beta.r && bls.i == beta.i;
+                    if (null) {
+                      isame[11] = lze_(&ys[1], &yy[1], &ly);
+                    } else {
+                      i__7 = abs(incy);
+                      isame[11] = lzeres_("ge", " ", &c__1, &ml, &ys[1], &yy[1],
+                                          &i__7, (ftnlen)2, (ftnlen)1);
+                    }
+                    isame[12] = incys == incy;
+                  }
+
+                  /*                             If data was incorrectly
+                   * changed, report */
+                  /*                             and return. */
+
+                  same = TRUE_;
+                  i__7 = nargs;
+                  for (i__ = 1; i__ <= i__7; ++i__) {
+                    same = same && isame[i__ - 1];
+                    if (!isame[i__ - 1]) {
+                      io___149.ciunit = *nout;
+                      s_wsfe(&io___149);
+                      do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                      e_wsfe();
+                    }
+                    /* L40: */
+                  }
+                  if (!same) {
+                    *fatal = TRUE_;
+                    goto L130;
+                  }
+
+                  if (!null) {
+
+                    /*                                Check the result. */
+
+                    zmvch_(trans, &m, &n, &alpha, &a[a_offset], nmax, &x[1],
+                           &incx, &beta, &y[1], &incy, &yt[1], &g[1], &yy[1],
+                           eps, &err, fatal, nout, &c_true, (ftnlen)1);
+                    errmax = max(errmax, err);
+                    /*                                If got really bad answer,
+                     * report and */
+                    /*                                return. */
+                    if (*fatal) {
+                      goto L130;
+                    }
+                  } else {
+                    /*                                Avoid repeating tests with
+                     * M.le.0 or */
+                    /*                                N.le.0. */
+                    goto L110;
+                  }
+                  /*                          END IF */
+
+                  /* L50: */
+                }
+
+                /* L60: */
+              }
+
+              /* L70: */
+            }
+
+            /* L80: */
+          }
+
+          /* L90: */
+        }
+
+      L100:;
+      }
+
+    L110:;
+    }
+
+    /* L120: */
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    io___151.ciunit = *nout;
+    s_wsfe(&io___151);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else {
+    io___152.ciunit = *nout;
+    s_wsfe(&io___152);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+    e_wsfe();
+  }
+  goto L140;
+
+L130:
+  io___153.ciunit = *nout;
+  s_wsfe(&io___153);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  if (full) {
+    io___154.ciunit = *nout;
+    s_wsfe(&io___154);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, ctrans, (ftnlen)14);
+    do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(doublereal));
+    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(doublereal));
+    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else if (banded) {
+    io___155.ciunit = *nout;
+    s_wsfe(&io___155);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, ctrans, (ftnlen)14);
+    do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&kl, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&ku, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(doublereal));
+    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(doublereal));
+    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L140:
+  return 0;
+
+  /*     End of ZCHK1. */
+
+} /* zchk1_ */
+
+/* Subroutine */ int
+zchk2_(char *sname, doublereal *eps, doublereal *thresh, integer *nout,
+       integer *ntra, logical *trace, logical *rewi, logical *fatal,
+       integer *nidim, integer *idim, integer *nkb, integer *kb, integer *nalf,
+       doublecomplex *alf, integer *nbet, doublecomplex *bet, integer *ninc,
+       integer *inc, integer *nmax, integer *incmax, doublecomplex *a,
+       doublecomplex *aa, doublecomplex *as, doublecomplex *x,
+       doublecomplex *xx, doublecomplex *xs, doublecomplex *y,
+       doublecomplex *yy, doublecomplex *ys, doublecomplex *yt, doublereal *g,
+       integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ich[2] = "UL";
+
+  /* Format strings */
+  static char fmt_9993[] =
+      "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+      "i3,\002,(\002,f4.1,\002,\002,f4.1,\002), A,\002,i3,\002, X,\002,"
+      "/10x,i2,\002,(\002,f4.1,\002,\002,f4.1,\002), \002,\002Y,\002,i2,"
+      "\002) .\002)";
+  static char fmt_9994[] =
+      "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+      "2(i3,\002,\002),\002(\002,f4.1,\002,\002,f4.1,\002), A,\002,i3"
+      ",\002, X,\002,/10x,i2,\002,(\002,f4.1,\002,\002,f4.1,\002), Y"
+      ",\002,i2,\002) .\002)";
+  static char fmt_9995[] =
+      "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+      "i3,\002,(\002,f4.1,\002,\002,f4.1,\002), AP, X,\002,/10x,i2,\002"
+      ",(\002,f4.1,\002,\002,f4.1,\002), Y,\002,i2,\002) .\002)";
+  static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_9999[] = "(\002 \002,a12,\002 PASSED THE COMPUTATIONAL T"
+                           "ESTS (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_9997[] =
+      "(\002 \002,a12,\002 COMPLETED THE COMPUTATIONA"
+      "L TESTS (\002,i6,\002 C\002,\002ALLS)\002,/\002 ******* BUT WITH"
+      " MAXIMUM TEST RATIO\002,f8.2,\002 - SUSPECT *******\002)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6, i__7, i__8,
+      i__9;
+  alist al__1;
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+      f_rew(alist *);
+
+  /* Local variables */
+  integer i__, k, n, ia, ib, ic, nc, ik, in, nk, ks, ix, iy, ns, lx, ly, laa,
+      lda;
+  doublecomplex als, bls;
+  doublereal err;
+  extern logical lze_(doublecomplex *, doublecomplex *, integer *);
+  doublecomplex beta;
+  integer ldas;
+  logical same;
+  integer incx, incy;
+  logical full, null;
+  char uplo[1];
+  doublecomplex alpha;
+  logical isame[13];
+  extern /* Subroutine */ int zmake_(
+      char *, char *, char *, integer *, integer *, doublecomplex *, integer *,
+      doublecomplex *, integer *, integer *, integer *, logical *,
+      doublecomplex *, ftnlen, ftnlen, ftnlen);
+  integer nargs;
+  logical reset;
+  char cuplo[14];
+  integer incxs, incys;
+  extern /* Subroutine */ int zmvch_(
+      char *, integer *, integer *, doublecomplex *, doublecomplex *, integer *,
+      doublecomplex *, integer *, doublecomplex *, doublecomplex *, integer *,
+      doublecomplex *, doublereal *, doublecomplex *, doublereal *,
+      doublereal *, logical *, integer *, logical *, ftnlen);
+  char uplos[1];
+  logical banded, packed;
+  extern /* Subroutine */ void czhbmv_(
+      integer *, char *, integer *, integer *, doublecomplex *, doublecomplex *,
+      integer *, doublecomplex *, integer *, doublecomplex *, doublecomplex *,
+      integer *),
+      czhemv_(integer *, char *, integer *, doublecomplex *, doublecomplex *,
+              integer *, doublecomplex *, integer *, doublecomplex *,
+              doublecomplex *, integer *);
+  doublereal errmax;
+  doublecomplex transl;
+  extern logical lzeres_(char *, char *, integer *, integer *, doublecomplex *,
+                         doublecomplex *, integer *, ftnlen, ftnlen);
+  extern /* Subroutine */ void czhpmv_(
+      integer *, char *, integer *, doublecomplex *, doublecomplex *,
+      doublecomplex *, integer *, doublecomplex *, doublecomplex *, integer *);
+
+  /* Fortran I/O blocks */
+  static cilist io___195 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___196 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___197 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___198 = {0, 0, 0, fmt_9992, 0};
+  static cilist io___201 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___203 = {0, 0, 0, fmt_9999, 0};
+  static cilist io___204 = {0, 0, 0, fmt_9997, 0};
+  static cilist io___205 = {0, 0, 0, fmt_9996, 0};
+  static cilist io___206 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___207 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___208 = {0, 0, 0, fmt_9995, 0};
+
+  /*  Tests CHEMV, CHBMV and CHPMV. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --kb;
+  --alf;
+  --bet;
+  --inc;
+  --g;
+  --yt;
+  --y;
+  --x;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --ys;
+  --yy;
+  --xs;
+  --xx;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+  full = *(unsigned char *)&sname[8] == 'e';
+  banded = *(unsigned char *)&sname[8] == 'b';
+  packed = *(unsigned char *)&sname[8] == 'p';
+  /*     Define the number of arguments. */
+  if (full) {
+    nargs = 10;
+  } else if (banded) {
+    nargs = 11;
+  } else if (packed) {
+    nargs = 9;
+  }
+
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.;
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+
+    if (banded) {
+      nk = *nkb;
+    } else {
+      nk = 1;
+    }
+    i__2 = nk;
+    for (ik = 1; ik <= i__2; ++ik) {
+      if (banded) {
+        k = kb[ik];
+      } else {
+        k = n - 1;
+      }
+      /*           Set LDA to 1 more than minimum value if room. */
+      if (banded) {
+        lda = k + 1;
+      } else {
+        lda = n;
+      }
+      if (lda < *nmax) {
+        ++lda;
+      }
+      /*           Skip tests if not enough room. */
+      if (lda > *nmax) {
+        goto L100;
+      }
+      if (packed) {
+        laa = n * (n + 1) / 2;
+      } else {
+        laa = lda * n;
+      }
+      null = n <= 0;
+
+      for (ic = 1; ic <= 2; ++ic) {
+        *(unsigned char *)uplo = *(unsigned char *)&ich[ic - 1];
+        if (*(unsigned char *)uplo == 'U') {
+          s_copy(cuplo, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+        } else {
+          s_copy(cuplo, "    CblasLower", (ftnlen)14, (ftnlen)14);
+        }
+
+        /*              Generate the matrix A. */
+
+        transl.r = 0., transl.i = 0.;
+        zmake_(sname + 7, uplo, " ", &n, &n, &a[a_offset], nmax, &aa[1], &lda,
+               &k, &k, &reset, &transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+        i__3 = *ninc;
+        for (ix = 1; ix <= i__3; ++ix) {
+          incx = inc[ix];
+          lx = abs(incx) * n;
+
+          /*                 Generate the vector X. */
+
+          transl.r = .5, transl.i = 0.;
+          i__4 = abs(incx);
+          i__5 = n - 1;
+          zmake_("ge", " ", " ", &c__1, &n, &x[1], &c__1, &xx[1], &i__4, &c__0,
+                 &i__5, &reset, &transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+          if (n > 1) {
+            i__4 = n / 2;
+            x[i__4].r = 0., x[i__4].i = 0.;
+            i__4 = abs(incx) * (n / 2 - 1) + 1;
+            xx[i__4].r = 0., xx[i__4].i = 0.;
+          }
+
+          i__4 = *ninc;
+          for (iy = 1; iy <= i__4; ++iy) {
+            incy = inc[iy];
+            ly = abs(incy) * n;
+
+            i__5 = *nalf;
+            for (ia = 1; ia <= i__5; ++ia) {
+              i__6 = ia;
+              alpha.r = alf[i__6].r, alpha.i = alf[i__6].i;
+
+              i__6 = *nbet;
+              for (ib = 1; ib <= i__6; ++ib) {
+                i__7 = ib;
+                beta.r = bet[i__7].r, beta.i = bet[i__7].i;
+
+                /*                          Generate the vector Y. */
+
+                transl.r = 0., transl.i = 0.;
+                i__7 = abs(incy);
+                i__8 = n - 1;
+                zmake_("ge", " ", " ", &c__1, &n, &y[1], &c__1, &yy[1], &i__7,
+                       &c__0, &i__8, &reset, &transl, (ftnlen)2, (ftnlen)1,
+                       (ftnlen)1);
+
+                ++nc;
+
+                /*                          Save every datum before calling the
+                 */
+                /*                          subroutine. */
+
+                *(unsigned char *)uplos = *(unsigned char *)uplo;
+                ns = n;
+                ks = k;
+                als.r = alpha.r, als.i = alpha.i;
+                i__7 = laa;
+                for (i__ = 1; i__ <= i__7; ++i__) {
+                  i__8 = i__;
+                  i__9 = i__;
+                  as[i__8].r = aa[i__9].r, as[i__8].i = aa[i__9].i;
+                  /* L10: */
+                }
+                ldas = lda;
+                i__7 = lx;
+                for (i__ = 1; i__ <= i__7; ++i__) {
+                  i__8 = i__;
+                  i__9 = i__;
+                  xs[i__8].r = xx[i__9].r, xs[i__8].i = xx[i__9].i;
+                  /* L20: */
+                }
+                incxs = incx;
+                bls.r = beta.r, bls.i = beta.i;
+                i__7 = ly;
+                for (i__ = 1; i__ <= i__7; ++i__) {
+                  i__8 = i__;
+                  i__9 = i__;
+                  ys[i__8].r = yy[i__9].r, ys[i__8].i = yy[i__9].i;
+                  /* L30: */
+                }
+                incys = incy;
+
+                /*                          Call the subroutine. */
+
+                if (full) {
+                  if (*trace) {
+                    io___195.ciunit = *ntra;
+                    s_wsfe(&io___195);
+                    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, sname, (ftnlen)12);
+                    do_fio(&c__1, cuplo, (ftnlen)14);
+                    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(doublereal));
+                    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                    do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(doublereal));
+                    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  czhemv_(iorder, uplo, &n, &alpha, &aa[1], &lda, &xx[1], &incx,
+                          &beta, &yy[1], &incy);
+                } else if (banded) {
+                  if (*trace) {
+                    io___196.ciunit = *ntra;
+                    s_wsfe(&io___196);
+                    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, sname, (ftnlen)12);
+                    do_fio(&c__1, cuplo, (ftnlen)14);
+                    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&k, (ftnlen)sizeof(integer));
+                    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(doublereal));
+                    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                    do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(doublereal));
+                    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  czhbmv_(iorder, uplo, &n, &k, &alpha, &aa[1], &lda, &xx[1],
+                          &incx, &beta, &yy[1], &incy);
+                } else if (packed) {
+                  if (*trace) {
+                    io___197.ciunit = *ntra;
+                    s_wsfe(&io___197);
+                    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, sname, (ftnlen)12);
+                    do_fio(&c__1, cuplo, (ftnlen)14);
+                    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(doublereal));
+                    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                    do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(doublereal));
+                    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  czhpmv_(iorder, uplo, &n, &alpha, &aa[1], &xx[1], &incx,
+                          &beta, &yy[1], &incy);
+                }
+
+                /*                          Check if error-exit was taken
+                 * incorrectly. */
+
+                if (!infoc_1.ok) {
+                  io___198.ciunit = *nout;
+                  s_wsfe(&io___198);
+                  e_wsfe();
+                  *fatal = TRUE_;
+                  goto L120;
+                }
+
+                /*                          See what data changed inside
+                 * subroutines. */
+
+                isame[0] = *(unsigned char *)uplo == *(unsigned char *)uplos;
+                isame[1] = ns == n;
+                if (full) {
+                  isame[2] = als.r == alpha.r && als.i == alpha.i;
+                  isame[3] = lze_(&as[1], &aa[1], &laa);
+                  isame[4] = ldas == lda;
+                  isame[5] = lze_(&xs[1], &xx[1], &lx);
+                  isame[6] = incxs == incx;
+                  isame[7] = bls.r == beta.r && bls.i == beta.i;
+                  if (null) {
+                    isame[8] = lze_(&ys[1], &yy[1], &ly);
+                  } else {
+                    i__7 = abs(incy);
+                    isame[8] = lzeres_("ge", " ", &c__1, &n, &ys[1], &yy[1],
+                                       &i__7, (ftnlen)2, (ftnlen)1);
+                  }
+                  isame[9] = incys == incy;
+                } else if (banded) {
+                  isame[2] = ks == k;
+                  isame[3] = als.r == alpha.r && als.i == alpha.i;
+                  isame[4] = lze_(&as[1], &aa[1], &laa);
+                  isame[5] = ldas == lda;
+                  isame[6] = lze_(&xs[1], &xx[1], &lx);
+                  isame[7] = incxs == incx;
+                  isame[8] = bls.r == beta.r && bls.i == beta.i;
+                  if (null) {
+                    isame[9] = lze_(&ys[1], &yy[1], &ly);
+                  } else {
+                    i__7 = abs(incy);
+                    isame[9] = lzeres_("ge", " ", &c__1, &n, &ys[1], &yy[1],
+                                       &i__7, (ftnlen)2, (ftnlen)1);
+                  }
+                  isame[10] = incys == incy;
+                } else if (packed) {
+                  isame[2] = als.r == alpha.r && als.i == alpha.i;
+                  isame[3] = lze_(&as[1], &aa[1], &laa);
+                  isame[4] = lze_(&xs[1], &xx[1], &lx);
+                  isame[5] = incxs == incx;
+                  isame[6] = bls.r == beta.r && bls.i == beta.i;
+                  if (null) {
+                    isame[7] = lze_(&ys[1], &yy[1], &ly);
+                  } else {
+                    i__7 = abs(incy);
+                    isame[7] = lzeres_("ge", " ", &c__1, &n, &ys[1], &yy[1],
+                                       &i__7, (ftnlen)2, (ftnlen)1);
+                  }
+                  isame[8] = incys == incy;
+                }
+
+                /*                          If data was incorrectly changed,
+                 * report and */
+                /*                          return. */
+
+                same = TRUE_;
+                i__7 = nargs;
+                for (i__ = 1; i__ <= i__7; ++i__) {
+                  same = same && isame[i__ - 1];
+                  if (!isame[i__ - 1]) {
+                    io___201.ciunit = *nout;
+                    s_wsfe(&io___201);
+                    do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  /* L40: */
+                }
+                if (!same) {
+                  *fatal = TRUE_;
+                  goto L120;
+                }
+
+                if (!null) {
+
+                  /*                             Check the result. */
+
+                  zmvch_("N", &n, &n, &alpha, &a[a_offset], nmax, &x[1], &incx,
+                         &beta, &y[1], &incy, &yt[1], &g[1], &yy[1], eps, &err,
+                         fatal, nout, &c_true, (ftnlen)1);
+                  errmax = max(errmax, err);
+                  /*                             If got really bad answer,
+                   * report and */
+                  /*                             return. */
+                  if (*fatal) {
+                    goto L120;
+                  }
+                } else {
+                  /*                             Avoid repeating tests with
+                   * N.le.0 */
+                  goto L110;
+                }
+
+                /* L50: */
+              }
+
+              /* L60: */
+            }
+
+            /* L70: */
+          }
+
+          /* L80: */
+        }
+
+        /* L90: */
+      }
+
+    L100:;
+    }
+
+  L110:;
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    io___203.ciunit = *nout;
+    s_wsfe(&io___203);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else {
+    io___204.ciunit = *nout;
+    s_wsfe(&io___204);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+    e_wsfe();
+  }
+  goto L130;
+
+L120:
+  io___205.ciunit = *nout;
+  s_wsfe(&io___205);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  if (full) {
+    io___206.ciunit = *nout;
+    s_wsfe(&io___206);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(doublereal));
+    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(doublereal));
+    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else if (banded) {
+    io___207.ciunit = *nout;
+    s_wsfe(&io___207);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&k, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(doublereal));
+    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(doublereal));
+    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else if (packed) {
+    io___208.ciunit = *nout;
+    s_wsfe(&io___208);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(doublereal));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&beta, (ftnlen)sizeof(doublereal));
+    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L130:
+  return 0;
+
+  /*     End of CZHK2. */
+
+} /* zchk2_ */
+
+/* Subroutine */ int
+zchk3_(char *sname, doublereal *eps, doublereal *thresh, integer *nout,
+       integer *ntra, logical *trace, logical *rewi, logical *fatal,
+       integer *nidim, integer *idim, integer *nkb, integer *kb, integer *ninc,
+       integer *inc, integer *nmax, integer *incmax, doublecomplex *a,
+       doublecomplex *aa, doublecomplex *as, doublecomplex *x,
+       doublecomplex *xx, doublecomplex *xs, doublecomplex *xt, doublereal *g,
+       doublecomplex *z__, integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ichu[2] = "UL";
+  static char icht[3] = "NTC";
+  static char ichd[2] = "UN";
+
+  /* Format strings */
+  static char fmt_9993[] =
+      "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+      "\002),/10x,i3,\002, A,\002,i3,\002, X,\002,i2,\002) .\002)";
+  static char fmt_9994[] =
+      "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+      "\002),/10x,2(i3,\002,\002),\002 A,\002,i3,\002, X,\002,i2,\002) ."
+      "\002)";
+  static char fmt_9995[] =
+      "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+      "\002),/10x,i3,\002, AP, \002,\002X,\002,i2,\002) .\002)";
+  static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_9999[] = "(\002 \002,a12,\002 PASSED THE COMPUTATIONAL T"
+                           "ESTS (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_9997[] =
+      "(\002 \002,a12,\002 COMPLETED THE COMPUTATIONA"
+      "L TESTS (\002,i6,\002 C\002,\002ALLS)\002,/\002 ******* BUT WITH"
+      " MAXIMUM TEST RATIO\002,f8.2,\002 - SUSPECT *******\002)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;
+  alist al__1;
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_cmp(char *, char *, ftnlen, ftnlen), s_wsfe(cilist *),
+      do_fio(integer *, char *, ftnlen), e_wsfe(void), f_rew(alist *);
+
+  /* Local variables */
+  integer i__, k, n, nc, ik, in, nk, ks, ix, ns, lx, laa, icd, lda, ict, icu;
+  doublereal err;
+  extern logical lze_(doublecomplex *, doublecomplex *, integer *);
+  char diag[1];
+  integer ldas;
+  logical same;
+  integer incx;
+  logical full, null;
+  char uplo[1], cdiag[14], diags[1];
+  logical isame[13];
+  extern /* Subroutine */ int zmake_(
+      char *, char *, char *, integer *, integer *, doublecomplex *, integer *,
+      doublecomplex *, integer *, integer *, integer *, logical *,
+      doublecomplex *, ftnlen, ftnlen, ftnlen);
+  integer nargs;
+  logical reset;
+  char cuplo[14];
+  integer incxs;
+  char trans[1];
+  extern /* Subroutine */ int zmvch_(
+      char *, integer *, integer *, doublecomplex *, doublecomplex *, integer *,
+      doublecomplex *, integer *, doublecomplex *, doublecomplex *, integer *,
+      doublecomplex *, doublereal *, doublecomplex *, doublereal *,
+      doublereal *, logical *, integer *, logical *, ftnlen);
+  char uplos[1];
+  logical banded, packed;
+  char ctrans[14];
+  doublereal errmax;
+  doublecomplex transl;
+  extern logical lzeres_(char *, char *, integer *, integer *, doublecomplex *,
+                         doublecomplex *, integer *, ftnlen, ftnlen);
+  extern /* Subroutine */ void cztbmv_(
+      integer *, char *, char *, char *, integer *, integer *, doublecomplex *,
+      integer *, doublecomplex *, integer *);
+  char transs[1];
+  extern /* Subroutine */ void cztbsv_(
+      integer *, char *, char *, char *, integer *, integer *, doublecomplex *,
+      integer *, doublecomplex *, integer *),
+      cztpmv_(integer *, char *, char *, char *, integer *, doublecomplex *,
+              doublecomplex *, integer *),
+      cztrmv_(integer *, char *, char *, char *, integer *, doublecomplex *,
+              integer *, doublecomplex *, integer *),
+      cztpsv_(integer *, char *, char *, char *, integer *, doublecomplex *,
+              doublecomplex *, integer *),
+      cztrsv_(integer *, char *, char *, char *, integer *, doublecomplex *,
+              integer *, doublecomplex *, integer *);
+
+  /* Fortran I/O blocks */
+  static cilist io___248 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___249 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___250 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___251 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___252 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___253 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___254 = {0, 0, 0, fmt_9992, 0};
+  static cilist io___257 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___259 = {0, 0, 0, fmt_9999, 0};
+  static cilist io___260 = {0, 0, 0, fmt_9997, 0};
+  static cilist io___261 = {0, 0, 0, fmt_9996, 0};
+  static cilist io___262 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___263 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___264 = {0, 0, 0, fmt_9995, 0};
+
+  /*  Tests ZTRMV, ZTBMV, ZTPMV, ZTRSV, ZTBSV and ZTPSV. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --kb;
+  --inc;
+  --z__;
+  --g;
+  --xt;
+  --x;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --xs;
+  --xx;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+  full = *(unsigned char *)&sname[8] == 'r';
+  banded = *(unsigned char *)&sname[8] == 'b';
+  packed = *(unsigned char *)&sname[8] == 'p';
+  /*     Define the number of arguments. */
+  if (full) {
+    nargs = 8;
+  } else if (banded) {
+    nargs = 9;
+  } else if (packed) {
+    nargs = 7;
+  }
+
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.;
+  /*     Set up zero vector for ZMVCH. */
+  i__1 = *nmax;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    i__2 = i__;
+    z__[i__2].r = 0., z__[i__2].i = 0.;
+    /* L10: */
+  }
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+
+    if (banded) {
+      nk = *nkb;
+    } else {
+      nk = 1;
+    }
+    i__2 = nk;
+    for (ik = 1; ik <= i__2; ++ik) {
+      if (banded) {
+        k = kb[ik];
+      } else {
+        k = n - 1;
+      }
+      /*           Set LDA to 1 more than minimum value if room. */
+      if (banded) {
+        lda = k + 1;
+      } else {
+        lda = n;
+      }
+      if (lda < *nmax) {
+        ++lda;
+      }
+      /*           Skip tests if not enough room. */
+      if (lda > *nmax) {
+        goto L100;
+      }
+      if (packed) {
+        laa = n * (n + 1) / 2;
+      } else {
+        laa = lda * n;
+      }
+      null = n <= 0;
+
+      for (icu = 1; icu <= 2; ++icu) {
+        *(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+        if (*(unsigned char *)uplo == 'U') {
+          s_copy(cuplo, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+        } else {
+          s_copy(cuplo, "    CblasLower", (ftnlen)14, (ftnlen)14);
+        }
+
+        for (ict = 1; ict <= 3; ++ict) {
+          *(unsigned char *)trans = *(unsigned char *)&icht[ict - 1];
+          if (*(unsigned char *)trans == 'N') {
+            s_copy(ctrans, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+          } else if (*(unsigned char *)trans == 'T') {
+            s_copy(ctrans, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+          } else {
+            s_copy(ctrans, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+          }
+
+          for (icd = 1; icd <= 2; ++icd) {
+            *(unsigned char *)diag = *(unsigned char *)&ichd[icd - 1];
+            if (*(unsigned char *)diag == 'N') {
+              s_copy(cdiag, "  CblasNonUnit", (ftnlen)14, (ftnlen)14);
+            } else {
+              s_copy(cdiag, "     CblasUnit", (ftnlen)14, (ftnlen)14);
+            }
+
+            /*                    Generate the matrix A. */
+
+            transl.r = 0., transl.i = 0.;
+            zmake_(sname + 7, uplo, diag, &n, &n, &a[a_offset], nmax, &aa[1],
+                   &lda, &k, &k, &reset, &transl, (ftnlen)2, (ftnlen)1,
+                   (ftnlen)1);
+
+            i__3 = *ninc;
+            for (ix = 1; ix <= i__3; ++ix) {
+              incx = inc[ix];
+              lx = abs(incx) * n;
+
+              /*                       Generate the vector X. */
+
+              transl.r = .5, transl.i = 0.;
+              i__4 = abs(incx);
+              i__5 = n - 1;
+              zmake_("ge", " ", " ", &c__1, &n, &x[1], &c__1, &xx[1], &i__4,
+                     &c__0, &i__5, &reset, &transl, (ftnlen)2, (ftnlen)1,
+                     (ftnlen)1);
+              if (n > 1) {
+                i__4 = n / 2;
+                x[i__4].r = 0., x[i__4].i = 0.;
+                i__4 = abs(incx) * (n / 2 - 1) + 1;
+                xx[i__4].r = 0., xx[i__4].i = 0.;
+              }
+
+              ++nc;
+
+              /*                       Save every datum before calling the
+               * subroutine. */
+
+              *(unsigned char *)uplos = *(unsigned char *)uplo;
+              *(unsigned char *)transs = *(unsigned char *)trans;
+              *(unsigned char *)diags = *(unsigned char *)diag;
+              ns = n;
+              ks = k;
+              i__4 = laa;
+              for (i__ = 1; i__ <= i__4; ++i__) {
+                i__5 = i__;
+                i__6 = i__;
+                as[i__5].r = aa[i__6].r, as[i__5].i = aa[i__6].i;
+                /* L20: */
+              }
+              ldas = lda;
+              i__4 = lx;
+              for (i__ = 1; i__ <= i__4; ++i__) {
+                i__5 = i__;
+                i__6 = i__;
+                xs[i__5].r = xx[i__6].r, xs[i__5].i = xx[i__6].i;
+                /* L30: */
+              }
+              incxs = incx;
+
+              /*                       Call the subroutine. */
+
+              if (s_cmp(sname + 3, "mv", (ftnlen)2, (ftnlen)2) == 0) {
+                if (full) {
+                  if (*trace) {
+                    io___248.ciunit = *ntra;
+                    s_wsfe(&io___248);
+                    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, sname, (ftnlen)12);
+                    do_fio(&c__1, cuplo, (ftnlen)14);
+                    do_fio(&c__1, ctrans, (ftnlen)14);
+                    do_fio(&c__1, cdiag, (ftnlen)14);
+                    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cztrmv_(iorder, uplo, trans, diag, &n, &aa[1], &lda, &xx[1],
+                          &incx);
+                } else if (banded) {
+                  if (*trace) {
+                    io___249.ciunit = *ntra;
+                    s_wsfe(&io___249);
+                    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, sname, (ftnlen)12);
+                    do_fio(&c__1, cuplo, (ftnlen)14);
+                    do_fio(&c__1, ctrans, (ftnlen)14);
+                    do_fio(&c__1, cdiag, (ftnlen)14);
+                    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&k, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cztbmv_(iorder, uplo, trans, diag, &n, &k, &aa[1], &lda,
+                          &xx[1], &incx);
+                } else if (packed) {
+                  if (*trace) {
+                    io___250.ciunit = *ntra;
+                    s_wsfe(&io___250);
+                    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, sname, (ftnlen)12);
+                    do_fio(&c__1, cuplo, (ftnlen)14);
+                    do_fio(&c__1, ctrans, (ftnlen)14);
+                    do_fio(&c__1, cdiag, (ftnlen)14);
+                    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cztpmv_(iorder, uplo, trans, diag, &n, &aa[1], &xx[1], &incx);
+                }
+              } else if (s_cmp(sname + 3, "sv", (ftnlen)2, (ftnlen)2) == 0) {
+                if (full) {
+                  if (*trace) {
+                    io___251.ciunit = *ntra;
+                    s_wsfe(&io___251);
+                    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, sname, (ftnlen)12);
+                    do_fio(&c__1, cuplo, (ftnlen)14);
+                    do_fio(&c__1, ctrans, (ftnlen)14);
+                    do_fio(&c__1, cdiag, (ftnlen)14);
+                    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cztrsv_(iorder, uplo, trans, diag, &n, &aa[1], &lda, &xx[1],
+                          &incx);
+                } else if (banded) {
+                  if (*trace) {
+                    io___252.ciunit = *ntra;
+                    s_wsfe(&io___252);
+                    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, sname, (ftnlen)12);
+                    do_fio(&c__1, cuplo, (ftnlen)14);
+                    do_fio(&c__1, ctrans, (ftnlen)14);
+                    do_fio(&c__1, cdiag, (ftnlen)14);
+                    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&k, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cztbsv_(iorder, uplo, trans, diag, &n, &k, &aa[1], &lda,
+                          &xx[1], &incx);
+                } else if (packed) {
+                  if (*trace) {
+                    io___253.ciunit = *ntra;
+                    s_wsfe(&io___253);
+                    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, sname, (ftnlen)12);
+                    do_fio(&c__1, cuplo, (ftnlen)14);
+                    do_fio(&c__1, ctrans, (ftnlen)14);
+                    do_fio(&c__1, cdiag, (ftnlen)14);
+                    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cztpsv_(iorder, uplo, trans, diag, &n, &aa[1], &xx[1], &incx);
+                }
+              }
+
+              /*                       Check if error-exit was taken
+               * incorrectly. */
+
+              if (!infoc_1.ok) {
+                io___254.ciunit = *nout;
+                s_wsfe(&io___254);
+                e_wsfe();
+                *fatal = TRUE_;
+                goto L120;
+              }
+
+              /*                       See what data changed inside subroutines.
+               */
+
+              isame[0] = *(unsigned char *)uplo == *(unsigned char *)uplos;
+              isame[1] = *(unsigned char *)trans == *(unsigned char *)transs;
+              isame[2] = *(unsigned char *)diag == *(unsigned char *)diags;
+              isame[3] = ns == n;
+              if (full) {
+                isame[4] = lze_(&as[1], &aa[1], &laa);
+                isame[5] = ldas == lda;
+                if (null) {
+                  isame[6] = lze_(&xs[1], &xx[1], &lx);
+                } else {
+                  i__4 = abs(incx);
+                  isame[6] = lzeres_("ge", " ", &c__1, &n, &xs[1], &xx[1],
+                                     &i__4, (ftnlen)2, (ftnlen)1);
+                }
+                isame[7] = incxs == incx;
+              } else if (banded) {
+                isame[4] = ks == k;
+                isame[5] = lze_(&as[1], &aa[1], &laa);
+                isame[6] = ldas == lda;
+                if (null) {
+                  isame[7] = lze_(&xs[1], &xx[1], &lx);
+                } else {
+                  i__4 = abs(incx);
+                  isame[7] = lzeres_("ge", " ", &c__1, &n, &xs[1], &xx[1],
+                                     &i__4, (ftnlen)2, (ftnlen)1);
+                }
+                isame[8] = incxs == incx;
+              } else if (packed) {
+                isame[4] = lze_(&as[1], &aa[1], &laa);
+                if (null) {
+                  isame[5] = lze_(&xs[1], &xx[1], &lx);
+                } else {
+                  i__4 = abs(incx);
+                  isame[5] = lzeres_("ge", " ", &c__1, &n, &xs[1], &xx[1],
+                                     &i__4, (ftnlen)2, (ftnlen)1);
+                }
+                isame[6] = incxs == incx;
+              }
+
+              /*                       If data was incorrectly changed, report
+               * and */
+              /*                       return. */
+
+              same = TRUE_;
+              i__4 = nargs;
+              for (i__ = 1; i__ <= i__4; ++i__) {
+                same = same && isame[i__ - 1];
+                if (!isame[i__ - 1]) {
+                  io___257.ciunit = *nout;
+                  s_wsfe(&io___257);
+                  do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                  e_wsfe();
+                }
+                /* L40: */
+              }
+              if (!same) {
+                *fatal = TRUE_;
+                goto L120;
+              }
+
+              if (!null) {
+                if (s_cmp(sname + 3, "mv", (ftnlen)2, (ftnlen)2) == 0) {
+
+                  /*                             Check the result. */
+
+                  zmvch_(trans, &n, &n, &c_b2, &a[a_offset], nmax, &x[1], &incx,
+                         &c_b1, &z__[1], &incx, &xt[1], &g[1], &xx[1], eps,
+                         &err, fatal, nout, &c_true, (ftnlen)1);
+                } else if (s_cmp(sname + 3, "sv", (ftnlen)2, (ftnlen)2) == 0) {
+
+                  /*                             Compute approximation to
+                   * original vector. */
+
+                  i__4 = n;
+                  for (i__ = 1; i__ <= i__4; ++i__) {
+                    i__5 = i__;
+                    i__6 = (i__ - 1) * abs(incx) + 1;
+                    z__[i__5].r = xx[i__6].r, z__[i__5].i = xx[i__6].i;
+                    i__5 = (i__ - 1) * abs(incx) + 1;
+                    i__6 = i__;
+                    xx[i__5].r = x[i__6].r, xx[i__5].i = x[i__6].i;
+                    /* L50: */
+                  }
+                  zmvch_(trans, &n, &n, &c_b2, &a[a_offset], nmax, &z__[1],
+                         &incx, &c_b1, &x[1], &incx, &xt[1], &g[1], &xx[1], eps,
+                         &err, fatal, nout, &c_false, (ftnlen)1);
+                }
+                errmax = max(errmax, err);
+                /*                          If got really bad answer, report and
+                 * return. */
+                if (*fatal) {
+                  goto L120;
+                }
+              } else {
+                /*                          Avoid repeating tests with N.le.0.
+                 */
+                goto L110;
+              }
+
+              /* L60: */
+            }
+
+            /* L70: */
+          }
+
+          /* L80: */
+        }
+
+        /* L90: */
+      }
+
+    L100:;
+    }
+
+  L110:;
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    io___259.ciunit = *nout;
+    s_wsfe(&io___259);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else {
+    io___260.ciunit = *nout;
+    s_wsfe(&io___260);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+    e_wsfe();
+  }
+  goto L130;
+
+L120:
+  io___261.ciunit = *nout;
+  s_wsfe(&io___261);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  if (full) {
+    io___262.ciunit = *nout;
+    s_wsfe(&io___262);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, ctrans, (ftnlen)14);
+    do_fio(&c__1, cdiag, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else if (banded) {
+    io___263.ciunit = *nout;
+    s_wsfe(&io___263);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, ctrans, (ftnlen)14);
+    do_fio(&c__1, cdiag, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&k, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else if (packed) {
+    io___264.ciunit = *nout;
+    s_wsfe(&io___264);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, ctrans, (ftnlen)14);
+    do_fio(&c__1, cdiag, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L130:
+  return 0;
+
+  /*     End of ZCHK3. */
+
+} /* zchk3_ */
+
+/* Subroutine */ int
+zchk4_(char *sname, doublereal *eps, doublereal *thresh, integer *nout,
+       integer *ntra, logical *trace, logical *rewi, logical *fatal,
+       integer *nidim, integer *idim, integer *nalf, doublecomplex *alf,
+       integer *ninc, integer *inc, integer *nmax, integer *incmax,
+       doublecomplex *a, doublecomplex *aa, doublecomplex *as, doublecomplex *x,
+       doublecomplex *xx, doublecomplex *xs, doublecomplex *y,
+       doublecomplex *yy, doublecomplex *ys, doublecomplex *yt, doublereal *g,
+       doublecomplex *z__, integer *iorder, ftnlen sname_len) {
+  /* Format strings */
+  static char fmt_9994[] =
+      "(1x,i6,\002: \002,a12,\002(\002,2(i3,\002,\002"
+      "),\002(\002,f4.1,\002,\002,f4.1,\002), X,\002,i2,\002, Y,\002,i2,"
+      "\002, A,\002,i3,\002) .\002)";
+  static char fmt_9993[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_9999[] = "(\002 \002,a12,\002 PASSED THE COMPUTATIONAL T"
+                           "ESTS (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_9997[] =
+      "(\002 \002,a12,\002 COMPLETED THE COMPUTATIONA"
+      "L TESTS (\002,i6,\002 C\002,\002ALLS)\002,/\002 ******* BUT WITH"
+      " MAXIMUM TEST RATIO\002,f8.2,\002 - SUSPECT *******\002)";
+  static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+                           " \002,i3)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6, i__7;
+  doublecomplex z__1;
+  alist al__1;
+
+  /* Builtin functions */
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+      f_rew(alist *);
+  void d_cnjg(doublecomplex *, doublecomplex *);
+
+  /* Local variables */
+  integer i__, j, m, n;
+  doublecomplex w[1];
+  integer ia, nc, nd, im, in, ms, ix, iy, ns, lx, ly, laa, lda;
+  doublecomplex als;
+  doublereal err;
+  extern logical lze_(doublecomplex *, doublecomplex *, integer *);
+  integer ldas;
+  logical same, conj;
+  integer incx, incy;
+  logical null;
+  doublecomplex alpha;
+  logical isame[13];
+  extern /* Subroutine */ int zmake_(
+      char *, char *, char *, integer *, integer *, doublecomplex *, integer *,
+      doublecomplex *, integer *, integer *, integer *, logical *,
+      doublecomplex *, ftnlen, ftnlen, ftnlen);
+  integer nargs;
+  logical reset;
+  integer incxs, incys;
+  extern /* Subroutine */ int zmvch_(
+      char *, integer *, integer *, doublecomplex *, doublecomplex *, integer *,
+      doublecomplex *, integer *, doublecomplex *, doublecomplex *, integer *,
+      doublecomplex *, doublereal *, doublecomplex *, doublereal *,
+      doublereal *, logical *, integer *, logical *, ftnlen);
+      
+  extern void czgerc_(integer *, integer *, integer *, doublecomplex *, doublecomplex *,
+                      integer *, doublecomplex *, integer *, doublecomplex *,
+                      integer *);
+  doublereal errmax;
+  extern /* Subroutine */ void czgeru_(
+      integer *, integer *, integer *, doublecomplex *, doublecomplex *,
+      integer *, doublecomplex *, integer *, doublecomplex *, integer *);
+  doublecomplex transl;
+  extern logical lzeres_(char *, char *, integer *, integer *, doublecomplex *,
+                         doublecomplex *, integer *, ftnlen, ftnlen);
+
+  /* Fortran I/O blocks */
+  static cilist io___294 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___295 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___298 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___302 = {0, 0, 0, fmt_9999, 0};
+  static cilist io___303 = {0, 0, 0, fmt_9997, 0};
+  static cilist io___304 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___305 = {0, 0, 0, fmt_9996, 0};
+  static cilist io___306 = {0, 0, 0, fmt_9994, 0};
+
+  /*  Tests ZGERC and ZGERU. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --inc;
+  --z__;
+  --g;
+  --yt;
+  --y;
+  --x;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --ys;
+  --yy;
+  --xs;
+  --xx;
+
+  /* Function Body */
+  conj = *(unsigned char *)&sname[4] == 'c';
+  /*     Define the number of arguments. */
+  nargs = 9;
+
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.;
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+    nd = n / 2 + 1;
+
+    for (im = 1; im <= 2; ++im) {
+      if (im == 1) {
+        /* Computing MAX */
+        i__2 = n - nd;
+        m = max(i__2, 0);
+      }
+      if (im == 2) {
+        /* Computing MIN */
+        i__2 = n + nd;
+        m = min(i__2, *nmax);
+      }
+
+      /*           Set LDA to 1 more than minimum value if room. */
+      lda = m;
+      if (lda < *nmax) {
+        ++lda;
+      }
+      /*           Skip tests if not enough room. */
+      if (lda > *nmax) {
+        goto L110;
+      }
+      laa = lda * n;
+      null = n <= 0 || m <= 0;
+
+      i__2 = *ninc;
+      for (ix = 1; ix <= i__2; ++ix) {
+        incx = inc[ix];
+        lx = abs(incx) * m;
+
+        /*              Generate the vector X. */
+
+        transl.r = .5, transl.i = 0.;
+        i__3 = abs(incx);
+        i__4 = m - 1;
+        zmake_("ge", " ", " ", &c__1, &m, &x[1], &c__1, &xx[1], &i__3, &c__0,
+               &i__4, &reset, &transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        if (m > 1) {
+          i__3 = m / 2;
+          x[i__3].r = 0., x[i__3].i = 0.;
+          i__3 = abs(incx) * (m / 2 - 1) + 1;
+          xx[i__3].r = 0., xx[i__3].i = 0.;
+        }
+
+        i__3 = *ninc;
+        for (iy = 1; iy <= i__3; ++iy) {
+          incy = inc[iy];
+          ly = abs(incy) * n;
+
+          /*                 Generate the vector Y. */
+
+          transl.r = 0., transl.i = 0.;
+          i__4 = abs(incy);
+          i__5 = n - 1;
+          zmake_("ge", " ", " ", &c__1, &n, &y[1], &c__1, &yy[1], &i__4, &c__0,
+                 &i__5, &reset, &transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+          if (n > 1) {
+            i__4 = n / 2;
+            y[i__4].r = 0., y[i__4].i = 0.;
+            i__4 = abs(incy) * (n / 2 - 1) + 1;
+            yy[i__4].r = 0., yy[i__4].i = 0.;
+          }
+
+          i__4 = *nalf;
+          for (ia = 1; ia <= i__4; ++ia) {
+            i__5 = ia;
+            alpha.r = alf[i__5].r, alpha.i = alf[i__5].i;
+
+            /*                    Generate the matrix A. */
+
+            transl.r = 0., transl.i = 0.;
+            i__5 = m - 1;
+            i__6 = n - 1;
+            zmake_(sname + 7, " ", " ", &m, &n, &a[a_offset], nmax, &aa[1],
+                   &lda, &i__5, &i__6, &reset, &transl, (ftnlen)2, (ftnlen)1,
+                   (ftnlen)1);
+
+            ++nc;
+
+            /*                    Save every datum before calling the
+             * subroutine. */
+
+            ms = m;
+            ns = n;
+            als.r = alpha.r, als.i = alpha.i;
+            i__5 = laa;
+            for (i__ = 1; i__ <= i__5; ++i__) {
+              i__6 = i__;
+              i__7 = i__;
+              as[i__6].r = aa[i__7].r, as[i__6].i = aa[i__7].i;
+              /* L10: */
+            }
+            ldas = lda;
+            i__5 = lx;
+            for (i__ = 1; i__ <= i__5; ++i__) {
+              i__6 = i__;
+              i__7 = i__;
+              xs[i__6].r = xx[i__7].r, xs[i__6].i = xx[i__7].i;
+              /* L20: */
+            }
+            incxs = incx;
+            i__5 = ly;
+            for (i__ = 1; i__ <= i__5; ++i__) {
+              i__6 = i__;
+              i__7 = i__;
+              ys[i__6].r = yy[i__7].r, ys[i__6].i = yy[i__7].i;
+              /* L30: */
+            }
+            incys = incy;
+
+            /*                    Call the subroutine. */
+
+            if (*trace) {
+              io___294.ciunit = *ntra;
+              s_wsfe(&io___294);
+              do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+              do_fio(&c__1, sname, (ftnlen)12);
+              do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer));
+              do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+              do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(doublereal));
+              do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+              do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+              do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+              e_wsfe();
+            }
+            if (conj) {
+              if (*rewi) {
+                al__1.aerr = 0;
+                al__1.aunit = *ntra;
+                f_rew(&al__1);
+              }
+              czgerc_(iorder, &m, &n, &alpha, &xx[1], &incx, &yy[1], &incy,
+                      &aa[1], &lda);
+            } else {
+              if (*rewi) {
+                al__1.aerr = 0;
+                al__1.aunit = *ntra;
+                f_rew(&al__1);
+              }
+              czgeru_(iorder, &m, &n, &alpha, &xx[1], &incx, &yy[1], &incy,
+                      &aa[1], &lda);
+            }
+
+            /*                    Check if error-exit was taken incorrectly. */
+
+            if (!infoc_1.ok) {
+              io___295.ciunit = *nout;
+              s_wsfe(&io___295);
+              e_wsfe();
+              *fatal = TRUE_;
+              goto L140;
+            }
+
+            /*                    See what data changed inside subroutine. */
+
+            isame[0] = ms == m;
+            isame[1] = ns == n;
+            isame[2] = als.r == alpha.r && als.i == alpha.i;
+            isame[3] = lze_(&xs[1], &xx[1], &lx);
+            isame[4] = incxs == incx;
+            isame[5] = lze_(&ys[1], &yy[1], &ly);
+            isame[6] = incys == incy;
+            if (null) {
+              isame[7] = lze_(&as[1], &aa[1], &laa);
+            } else {
+              isame[7] = lzeres_("ge", " ", &m, &n, &as[1], &aa[1], &lda,
+                                 (ftnlen)2, (ftnlen)1);
+            }
+            isame[8] = ldas == lda;
+
+            /*                   If data was incorrectly changed, report and
+             * return. */
+
+            same = TRUE_;
+            i__5 = nargs;
+            for (i__ = 1; i__ <= i__5; ++i__) {
+              same = same && isame[i__ - 1];
+              if (!isame[i__ - 1]) {
+                io___298.ciunit = *nout;
+                s_wsfe(&io___298);
+                do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                e_wsfe();
+              }
+              /* L40: */
+            }
+            if (!same) {
+              *fatal = TRUE_;
+              goto L140;
+            }
+
+            if (!null) {
+
+              /*                       Check the result column by column. */
+
+              if (incx > 0) {
+                i__5 = m;
+                for (i__ = 1; i__ <= i__5; ++i__) {
+                  i__6 = i__;
+                  i__7 = i__;
+                  z__[i__6].r = x[i__7].r, z__[i__6].i = x[i__7].i;
+                  /* L50: */
+                }
+              } else {
+                i__5 = m;
+                for (i__ = 1; i__ <= i__5; ++i__) {
+                  i__6 = i__;
+                  i__7 = m - i__ + 1;
+                  z__[i__6].r = x[i__7].r, z__[i__6].i = x[i__7].i;
+                  /* L60: */
+                }
+              }
+              i__5 = n;
+              for (j = 1; j <= i__5; ++j) {
+                if (incy > 0) {
+                  i__6 = j;
+                  w[0].r = y[i__6].r, w[0].i = y[i__6].i;
+                } else {
+                  i__6 = n - j + 1;
+                  w[0].r = y[i__6].r, w[0].i = y[i__6].i;
+                }
+                if (conj) {
+                  d_cnjg(&z__1, w);
+                  w[0].r = z__1.r, w[0].i = z__1.i;
+                }
+                zmvch_("N", &m, &c__1, &alpha, &z__[1], nmax, w, &c__1, &c_b2,
+                       &a[j * a_dim1 + 1], &c__1, &yt[1], &g[1],
+                       &aa[(j - 1) * lda + 1], eps, &err, fatal, nout, &c_true,
+                       (ftnlen)1);
+                errmax = max(errmax, err);
+                /*                          If got really bad answer, report and
+                 * return. */
+                if (*fatal) {
+                  goto L130;
+                }
+                /* L70: */
+              }
+            } else {
+              /*                       Avoid repeating tests with M.le.0 or
+               * N.le.0. */
+              goto L110;
+            }
+
+            /* L80: */
+          }
+
+          /* L90: */
+        }
+
+        /* L100: */
+      }
+
+    L110:;
+    }
+
+    /* L120: */
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    io___302.ciunit = *nout;
+    s_wsfe(&io___302);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else {
+    io___303.ciunit = *nout;
+    s_wsfe(&io___303);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+    e_wsfe();
+  }
+  goto L150;
+
+L130:
+  io___304.ciunit = *nout;
+  s_wsfe(&io___304);
+  do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+  e_wsfe();
+
+L140:
+  io___305.ciunit = *nout;
+  s_wsfe(&io___305);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  io___306.ciunit = *nout;
+  s_wsfe(&io___306);
+  do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, (char *)&m, (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+  e_wsfe();
+
+L150:
+  return 0;
+
+  /*     End of ZCHK4. */
+
+} /* zchk4_ */
+
+/* Subroutine */ int
+zchk5_(char *sname, doublereal *eps, doublereal *thresh, integer *nout,
+       integer *ntra, logical *trace, logical *rewi, logical *fatal,
+       integer *nidim, integer *idim, integer *nalf, doublecomplex *alf,
+       integer *ninc, integer *inc, integer *nmax, integer *incmax,
+       doublecomplex *a, doublecomplex *aa, doublecomplex *as, doublecomplex *x,
+       doublecomplex *xx, doublecomplex *xs, doublecomplex *y,
+       doublecomplex *yy, doublecomplex *ys, doublecomplex *yt, doublereal *g,
+       doublecomplex *z__, integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ich[2] = "UL";
+
+  /* Format strings */
+  static char fmt_9993[] =
+      "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+      "i3,\002,\002,f4.1,\002, X,\002,i2,\002, A,\002,i3,\002) .\002)";
+  static char fmt_9994[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+                           "i3,\002,\002,f4.1,\002, X,\002,i2,\002, AP) .\002)";
+  static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_9999[] = "(\002 \002,a12,\002 PASSED THE COMPUTATIONAL T"
+                           "ESTS (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_9997[] =
+      "(\002 \002,a12,\002 COMPLETED THE COMPUTATIONA"
+      "L TESTS (\002,i6,\002 C\002,\002ALLS)\002,/\002 ******* BUT WITH"
+      " MAXIMUM TEST RATIO\002,f8.2,\002 - SUSPECT *******\002)";
+  static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+                           " \002,i3)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;
+  doublecomplex z__1;
+  alist al__1;
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+      f_rew(alist *);
+  void d_cnjg(doublecomplex *, doublecomplex *);
+
+  /* Local variables */
+  integer i__, j, n;
+  doublecomplex w[1];
+  integer ia, ja, ic, nc, jj, lj, in, ix, ns, lx, laa, lda;
+  doublereal err;
+  extern logical lze_(doublecomplex *, doublecomplex *, integer *);
+  integer ldas;
+  logical same;
+  doublereal rals;
+  integer incx;
+  logical full, null;
+  char uplo[1];
+  doublecomplex alpha;
+  logical isame[13];
+  extern /* Subroutine */ int zmake_(
+      char *, char *, char *, integer *, integer *, doublecomplex *, integer *,
+      doublecomplex *, integer *, integer *, integer *, logical *,
+      doublecomplex *, ftnlen, ftnlen, ftnlen);
+  integer nargs;
+  extern /* Subroutine */ void czher_(integer *, char *, integer *, doublereal *,
+                                     doublecomplex *, integer *,
+                                     doublecomplex *, integer *);
+  logical reset;
+  char cuplo[14];
+  integer incxs;
+  extern /* Subroutine */ void czhpr_(integer *, char *, integer *, doublereal *,
+                                     doublecomplex *, integer *,
+                                     doublecomplex *);
+  extern int zmvch_(char *, integer *, integer *, doublecomplex *, doublecomplex *,
+                    integer *, doublecomplex *, integer *, doublecomplex *,
+                    doublecomplex *, integer *, doublecomplex *, doublereal *,
+                    doublecomplex *, doublereal *, doublereal *, logical *, integer *,
+                    logical *, ftnlen);
+  logical upper;
+  char uplos[1];
+  logical packed;
+  doublereal ralpha, errmax;
+  doublecomplex transl;
+  extern logical lzeres_(char *, char *, integer *, integer *, doublecomplex *,
+                         doublecomplex *, integer *, ftnlen, ftnlen);
+
+  /* Fortran I/O blocks */
+  static cilist io___336 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___337 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___338 = {0, 0, 0, fmt_9992, 0};
+  static cilist io___341 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___348 = {0, 0, 0, fmt_9999, 0};
+  static cilist io___349 = {0, 0, 0, fmt_9997, 0};
+  static cilist io___350 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___351 = {0, 0, 0, fmt_9996, 0};
+  static cilist io___352 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___353 = {0, 0, 0, fmt_9994, 0};
+
+  /*  Tests ZHER and ZHPR. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --inc;
+  --z__;
+  --g;
+  --yt;
+  --y;
+  --x;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --ys;
+  --yy;
+  --xs;
+  --xx;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+  full = *(unsigned char *)&sname[8] == 'e';
+  packed = *(unsigned char *)&sname[8] == 'p';
+  /*     Define the number of arguments. */
+  if (full) {
+    nargs = 7;
+  } else if (packed) {
+    nargs = 6;
+  }
+
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.;
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+    /*        Set LDA to 1 more than minimum value if room. */
+    lda = n;
+    if (lda < *nmax) {
+      ++lda;
+    }
+    /*        Skip tests if not enough room. */
+    if (lda > *nmax) {
+      goto L100;
+    }
+    if (packed) {
+      laa = n * (n + 1) / 2;
+    } else {
+      laa = lda * n;
+    }
+
+    for (ic = 1; ic <= 2; ++ic) {
+      *(unsigned char *)uplo = *(unsigned char *)&ich[ic - 1];
+      if (*(unsigned char *)uplo == 'U') {
+        s_copy(cuplo, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+      } else {
+        s_copy(cuplo, "    CblasLower", (ftnlen)14, (ftnlen)14);
+      }
+      upper = *(unsigned char *)uplo == 'U';
+
+      i__2 = *ninc;
+      for (ix = 1; ix <= i__2; ++ix) {
+        incx = inc[ix];
+        lx = abs(incx) * n;
+
+        /*              Generate the vector X. */
+
+        transl.r = .5, transl.i = 0.;
+        i__3 = abs(incx);
+        i__4 = n - 1;
+        zmake_("ge", " ", " ", &c__1, &n, &x[1], &c__1, &xx[1], &i__3, &c__0,
+               &i__4, &reset, &transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        if (n > 1) {
+          i__3 = n / 2;
+          x[i__3].r = 0., x[i__3].i = 0.;
+          i__3 = abs(incx) * (n / 2 - 1) + 1;
+          xx[i__3].r = 0., xx[i__3].i = 0.;
+        }
+
+        i__3 = *nalf;
+        for (ia = 1; ia <= i__3; ++ia) {
+          i__4 = ia;
+          ralpha = alf[i__4].r;
+          z__1.r = ralpha, z__1.i = 0.;
+          alpha.r = z__1.r, alpha.i = z__1.i;
+          null = n <= 0 || ralpha == 0.;
+
+          /*                 Generate the matrix A. */
+
+          transl.r = 0., transl.i = 0.;
+          i__4 = n - 1;
+          i__5 = n - 1;
+          zmake_(sname + 7, uplo, " ", &n, &n, &a[a_offset], nmax, &aa[1], &lda,
+                 &i__4, &i__5, &reset, &transl, (ftnlen)2, (ftnlen)1,
+                 (ftnlen)1);
+
+          ++nc;
+
+          /*                 Save every datum before calling the subroutine. */
+
+          *(unsigned char *)uplos = *(unsigned char *)uplo;
+          ns = n;
+          rals = ralpha;
+          i__4 = laa;
+          for (i__ = 1; i__ <= i__4; ++i__) {
+            i__5 = i__;
+            i__6 = i__;
+            as[i__5].r = aa[i__6].r, as[i__5].i = aa[i__6].i;
+            /* L10: */
+          }
+          ldas = lda;
+          i__4 = lx;
+          for (i__ = 1; i__ <= i__4; ++i__) {
+            i__5 = i__;
+            i__6 = i__;
+            xs[i__5].r = xx[i__6].r, xs[i__5].i = xx[i__6].i;
+            /* L20: */
+          }
+          incxs = incx;
+
+          /*                 Call the subroutine. */
+
+          if (full) {
+            if (*trace) {
+              io___336.ciunit = *ntra;
+              s_wsfe(&io___336);
+              do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+              do_fio(&c__1, sname, (ftnlen)12);
+              do_fio(&c__1, cuplo, (ftnlen)14);
+              do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+              do_fio(&c__1, (char *)&ralpha, (ftnlen)sizeof(doublereal));
+              do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+              do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+              e_wsfe();
+            }
+            if (*rewi) {
+              al__1.aerr = 0;
+              al__1.aunit = *ntra;
+              f_rew(&al__1);
+            }
+            czher_(iorder, uplo, &n, &ralpha, &xx[1], &incx, &aa[1], &lda);
+          } else if (packed) {
+            if (*trace) {
+              io___337.ciunit = *ntra;
+              s_wsfe(&io___337);
+              do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+              do_fio(&c__1, sname, (ftnlen)12);
+              do_fio(&c__1, cuplo, (ftnlen)14);
+              do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+              do_fio(&c__1, (char *)&ralpha, (ftnlen)sizeof(doublereal));
+              do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+              e_wsfe();
+            }
+            if (*rewi) {
+              al__1.aerr = 0;
+              al__1.aunit = *ntra;
+              f_rew(&al__1);
+            }
+            czhpr_(iorder, uplo, &n, &ralpha, &xx[1], &incx, &aa[1]);
+          }
+
+          /*                 Check if error-exit was taken incorrectly. */
+
+          if (!infoc_1.ok) {
+            io___338.ciunit = *nout;
+            s_wsfe(&io___338);
+            e_wsfe();
+            *fatal = TRUE_;
+            goto L120;
+          }
+
+          /*                 See what data changed inside subroutines. */
+
+          isame[0] = *(unsigned char *)uplo == *(unsigned char *)uplos;
+          isame[1] = ns == n;
+          isame[2] = rals == ralpha;
+          isame[3] = lze_(&xs[1], &xx[1], &lx);
+          isame[4] = incxs == incx;
+          if (null) {
+            isame[5] = lze_(&as[1], &aa[1], &laa);
+          } else {
+            isame[5] = lzeres_(sname + 7, uplo, &n, &n, &as[1], &aa[1], &lda,
+                               (ftnlen)2, (ftnlen)1);
+          }
+          if (!packed) {
+            isame[6] = ldas == lda;
+          }
+
+          /*                 If data was incorrectly changed, report and return.
+           */
+
+          same = TRUE_;
+          i__4 = nargs;
+          for (i__ = 1; i__ <= i__4; ++i__) {
+            same = same && isame[i__ - 1];
+            if (!isame[i__ - 1]) {
+              io___341.ciunit = *nout;
+              s_wsfe(&io___341);
+              do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+              e_wsfe();
+            }
+            /* L30: */
+          }
+          if (!same) {
+            *fatal = TRUE_;
+            goto L120;
+          }
+
+          if (!null) {
+
+            /*                    Check the result column by column. */
+
+            if (incx > 0) {
+              i__4 = n;
+              for (i__ = 1; i__ <= i__4; ++i__) {
+                i__5 = i__;
+                i__6 = i__;
+                z__[i__5].r = x[i__6].r, z__[i__5].i = x[i__6].i;
+                /* L40: */
+              }
+            } else {
+              i__4 = n;
+              for (i__ = 1; i__ <= i__4; ++i__) {
+                i__5 = i__;
+                i__6 = n - i__ + 1;
+                z__[i__5].r = x[i__6].r, z__[i__5].i = x[i__6].i;
+                /* L50: */
+              }
+            }
+            ja = 1;
+            i__4 = n;
+            for (j = 1; j <= i__4; ++j) {
+              d_cnjg(&z__1, &z__[j]);
+              w[0].r = z__1.r, w[0].i = z__1.i;
+              if (upper) {
+                jj = 1;
+                lj = j;
+              } else {
+                jj = j;
+                lj = n - j + 1;
+              }
+              zmvch_("N", &lj, &c__1, &alpha, &z__[jj], &lj, w, &c__1, &c_b2,
+                     &a[jj + j * a_dim1], &c__1, &yt[1], &g[1], &aa[ja], eps,
+                     &err, fatal, nout, &c_true, (ftnlen)1);
+              if (full) {
+                if (upper) {
+                  ja += lda;
+                } else {
+                  ja = ja + lda + 1;
+                }
+              } else {
+                ja += lj;
+              }
+              errmax = max(errmax, err);
+              /*                       If got really bad answer, report and
+               * return. */
+              if (*fatal) {
+                goto L110;
+              }
+              /* L60: */
+            }
+          } else {
+            /*                    Avoid repeating tests if N.le.0. */
+            if (n <= 0) {
+              goto L100;
+            }
+          }
+
+          /* L70: */
+        }
+
+        /* L80: */
+      }
+
+      /* L90: */
+    }
+
+  L100:;
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    io___348.ciunit = *nout;
+    s_wsfe(&io___348);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else {
+    io___349.ciunit = *nout;
+    s_wsfe(&io___349);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+    e_wsfe();
+  }
+  goto L130;
+
+L110:
+  io___350.ciunit = *nout;
+  s_wsfe(&io___350);
+  do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+  e_wsfe();
+
+L120:
+  io___351.ciunit = *nout;
+  s_wsfe(&io___351);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  if (full) {
+    io___352.ciunit = *nout;
+    s_wsfe(&io___352);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&ralpha, (ftnlen)sizeof(doublereal));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else if (packed) {
+    io___353.ciunit = *nout;
+    s_wsfe(&io___353);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&ralpha, (ftnlen)sizeof(doublereal));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L130:
+  return 0;
+
+  /*     End of CZHK5. */
+
+} /* zchk5_ */
+
+/* Subroutine */ int
+zchk6_(char *sname, doublereal *eps, doublereal *thresh, integer *nout,
+       integer *ntra, logical *trace, logical *rewi, logical *fatal,
+       integer *nidim, integer *idim, integer *nalf, doublecomplex *alf,
+       integer *ninc, integer *inc, integer *nmax, integer *incmax,
+       doublecomplex *a, doublecomplex *aa, doublecomplex *as, doublecomplex *x,
+       doublecomplex *xx, doublecomplex *xs, doublecomplex *y,
+       doublecomplex *yy, doublecomplex *ys, doublecomplex *yt, doublereal *g,
+       doublecomplex *z__, integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ich[2] = "UL";
+
+  /* Format strings */
+  static char fmt_9993[] =
+      "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+      "i3,\002,(\002,f4.1,\002,\002,f4.1,\002), X,\002,i2,\002, Y,\002,"
+      "i2,\002, A,\002,i3,\002) .\002)";
+  static char fmt_9994[] =
+      "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+      "i3,\002,(\002,f4.1,\002,\002,f4.1,\002), X,\002,i2,\002, Y,\002,"
+      "i2,\002, AP) .\002)";
+  static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_9999[] = "(\002 \002,a12,\002 PASSED THE COMPUTATIONAL T"
+                           "ESTS (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_9997[] =
+      "(\002 \002,a12,\002 COMPLETED THE COMPUTATIONA"
+      "L TESTS (\002,i6,\002 C\002,\002ALLS)\002,/\002 ******* BUT WITH"
+      " MAXIMUM TEST RATIO\002,f8.2,\002 - SUSPECT *******\002)";
+  static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+                           " \002,i3)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4, i__5,
+      i__6, i__7;
+  doublecomplex z__1, z__2, z__3;
+  alist al__1;
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),
+      f_rew(alist *);
+  void d_cnjg(doublecomplex *, doublecomplex *);
+
+  /* Local variables */
+  integer i__, j, n;
+  doublecomplex w[2];
+  integer ia, ja, ic, nc, jj, lj, in, ix, iy, ns, lx, ly, laa, lda;
+  doublecomplex als;
+  doublereal err;
+  extern logical lze_(doublecomplex *, doublecomplex *, integer *);
+  integer ldas;
+  logical same;
+  integer incx, incy;
+  logical full, null;
+  char uplo[1];
+  doublecomplex alpha;
+  logical isame[13];
+  extern /* Subroutine */ int zmake_(
+      char *, char *, char *, integer *, integer *, doublecomplex *, integer *,
+      doublecomplex *, integer *, integer *, integer *, logical *,
+      doublecomplex *, ftnlen, ftnlen, ftnlen);
+  integer nargs;
+  logical reset;
+  char cuplo[14];
+  integer incxs, incys;
+  extern /* Subroutine */ int zmvch_(
+      char *, integer *, integer *, doublecomplex *, doublecomplex *, integer *,
+      doublecomplex *, integer *, doublecomplex *, doublecomplex *, integer *,
+      doublecomplex *, doublereal *, doublecomplex *, doublereal *,
+      doublereal *, logical *, integer *, logical *, ftnlen);
+  logical upper;
+  char uplos[1];
+  extern /* Subroutine */ void czher2_(
+      integer *, char *, integer *, doublecomplex *, doublecomplex *, integer *,
+      doublecomplex *, integer *, doublecomplex *, integer *),
+      czhpr2_(integer *, char *, integer *, doublecomplex *, doublecomplex *,
+              integer *, doublecomplex *, integer *, doublecomplex *);
+  logical packed;
+  doublereal errmax;
+  doublecomplex transl;
+  extern logical lzeres_(char *, char *, integer *, integer *, doublecomplex *,
+                         doublecomplex *, integer *, ftnlen, ftnlen);
+
+  /* Fortran I/O blocks */
+  static cilist io___386 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___387 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___388 = {0, 0, 0, fmt_9992, 0};
+  static cilist io___391 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___398 = {0, 0, 0, fmt_9999, 0};
+  static cilist io___399 = {0, 0, 0, fmt_9997, 0};
+  static cilist io___400 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___401 = {0, 0, 0, fmt_9996, 0};
+  static cilist io___402 = {0, 0, 0, fmt_9993, 0};
+  static cilist io___403 = {0, 0, 0, fmt_9994, 0};
+
+  /*  Tests ZHER2 and ZHPR2. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --inc;
+  z_dim1 = *nmax;
+  z_offset = 1 + z_dim1;
+  z__ -= z_offset;
+  --g;
+  --yt;
+  --y;
+  --x;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --ys;
+  --yy;
+  --xs;
+  --xx;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+  full = *(unsigned char *)&sname[8] == 'e';
+  packed = *(unsigned char *)&sname[8] == 'p';
+  /*     Define the number of arguments. */
+  if (full) {
+    nargs = 9;
+  } else if (packed) {
+    nargs = 8;
+  }
+
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.;
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+    /*        Set LDA to 1 more than minimum value if room. */
+    lda = n;
+    if (lda < *nmax) {
+      ++lda;
+    }
+    /*        Skip tests if not enough room. */
+    if (lda > *nmax) {
+      goto L140;
+    }
+    if (packed) {
+      laa = n * (n + 1) / 2;
+    } else {
+      laa = lda * n;
+    }
+
+    for (ic = 1; ic <= 2; ++ic) {
+      *(unsigned char *)uplo = *(unsigned char *)&ich[ic - 1];
+      if (*(unsigned char *)uplo == 'U') {
+        s_copy(cuplo, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+      } else {
+        s_copy(cuplo, "    CblasLower", (ftnlen)14, (ftnlen)14);
+      }
+      upper = *(unsigned char *)uplo == 'U';
+
+      i__2 = *ninc;
+      for (ix = 1; ix <= i__2; ++ix) {
+        incx = inc[ix];
+        lx = abs(incx) * n;
+
+        /*              Generate the vector X. */
+
+        transl.r = .5, transl.i = 0.;
+        i__3 = abs(incx);
+        i__4 = n - 1;
+        zmake_("ge", " ", " ", &c__1, &n, &x[1], &c__1, &xx[1], &i__3, &c__0,
+               &i__4, &reset, &transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        if (n > 1) {
+          i__3 = n / 2;
+          x[i__3].r = 0., x[i__3].i = 0.;
+          i__3 = abs(incx) * (n / 2 - 1) + 1;
+          xx[i__3].r = 0., xx[i__3].i = 0.;
+        }
+
+        i__3 = *ninc;
+        for (iy = 1; iy <= i__3; ++iy) {
+          incy = inc[iy];
+          ly = abs(incy) * n;
+
+          /*                 Generate the vector Y. */
+
+          transl.r = 0., transl.i = 0.;
+          i__4 = abs(incy);
+          i__5 = n - 1;
+          zmake_("ge", " ", " ", &c__1, &n, &y[1], &c__1, &yy[1], &i__4, &c__0,
+                 &i__5, &reset, &transl, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+          if (n > 1) {
+            i__4 = n / 2;
+            y[i__4].r = 0., y[i__4].i = 0.;
+            i__4 = abs(incy) * (n / 2 - 1) + 1;
+            yy[i__4].r = 0., yy[i__4].i = 0.;
+          }
+
+          i__4 = *nalf;
+          for (ia = 1; ia <= i__4; ++ia) {
+            i__5 = ia;
+            alpha.r = alf[i__5].r, alpha.i = alf[i__5].i;
+            null = n <= 0 || alpha.r == 0. && alpha.i == 0.;
+
+            /*                    Generate the matrix A. */
+
+            transl.r = 0., transl.i = 0.;
+            i__5 = n - 1;
+            i__6 = n - 1;
+            zmake_(sname + 7, uplo, " ", &n, &n, &a[a_offset], nmax, &aa[1],
+                   &lda, &i__5, &i__6, &reset, &transl, (ftnlen)2, (ftnlen)1,
+                   (ftnlen)1);
+
+            ++nc;
+
+            /*                    Save every datum before calling the
+             * subroutine. */
+
+            *(unsigned char *)uplos = *(unsigned char *)uplo;
+            ns = n;
+            als.r = alpha.r, als.i = alpha.i;
+            i__5 = laa;
+            for (i__ = 1; i__ <= i__5; ++i__) {
+              i__6 = i__;
+              i__7 = i__;
+              as[i__6].r = aa[i__7].r, as[i__6].i = aa[i__7].i;
+              /* L10: */
+            }
+            ldas = lda;
+            i__5 = lx;
+            for (i__ = 1; i__ <= i__5; ++i__) {
+              i__6 = i__;
+              i__7 = i__;
+              xs[i__6].r = xx[i__7].r, xs[i__6].i = xx[i__7].i;
+              /* L20: */
+            }
+            incxs = incx;
+            i__5 = ly;
+            for (i__ = 1; i__ <= i__5; ++i__) {
+              i__6 = i__;
+              i__7 = i__;
+              ys[i__6].r = yy[i__7].r, ys[i__6].i = yy[i__7].i;
+              /* L30: */
+            }
+            incys = incy;
+
+            /*                    Call the subroutine. */
+
+            if (full) {
+              if (*trace) {
+                io___386.ciunit = *ntra;
+                s_wsfe(&io___386);
+                do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                do_fio(&c__1, sname, (ftnlen)12);
+                do_fio(&c__1, cuplo, (ftnlen)14);
+                do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(doublereal));
+                do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+                do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+                e_wsfe();
+              }
+              if (*rewi) {
+                al__1.aerr = 0;
+                al__1.aunit = *ntra;
+                f_rew(&al__1);
+              }
+              czher2_(iorder, uplo, &n, &alpha, &xx[1], &incx, &yy[1], &incy,
+                      &aa[1], &lda);
+            } else if (packed) {
+              if (*trace) {
+                io___387.ciunit = *ntra;
+                s_wsfe(&io___387);
+                do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+                do_fio(&c__1, sname, (ftnlen)12);
+                do_fio(&c__1, cuplo, (ftnlen)14);
+                do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+                do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(doublereal));
+                do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+                do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+                e_wsfe();
+              }
+              if (*rewi) {
+                al__1.aerr = 0;
+                al__1.aunit = *ntra;
+                f_rew(&al__1);
+              }
+              czhpr2_(iorder, uplo, &n, &alpha, &xx[1], &incx, &yy[1], &incy,
+                      &aa[1]);
+            }
+
+            /*                    Check if error-exit was taken incorrectly. */
+
+            if (!infoc_1.ok) {
+              io___388.ciunit = *nout;
+              s_wsfe(&io___388);
+              e_wsfe();
+              *fatal = TRUE_;
+              goto L160;
+            }
+
+            /*                    See what data changed inside subroutines. */
+
+            isame[0] = *(unsigned char *)uplo == *(unsigned char *)uplos;
+            isame[1] = ns == n;
+            isame[2] = als.r == alpha.r && als.i == alpha.i;
+            isame[3] = lze_(&xs[1], &xx[1], &lx);
+            isame[4] = incxs == incx;
+            isame[5] = lze_(&ys[1], &yy[1], &ly);
+            isame[6] = incys == incy;
+            if (null) {
+              isame[7] = lze_(&as[1], &aa[1], &laa);
+            } else {
+              isame[7] = lzeres_(sname + 7, uplo, &n, &n, &as[1], &aa[1], &lda,
+                                 (ftnlen)2, (ftnlen)1);
+            }
+            if (!packed) {
+              isame[8] = ldas == lda;
+            }
+
+            /*                   If data was incorrectly changed, report and
+             * return. */
+
+            same = TRUE_;
+            i__5 = nargs;
+            for (i__ = 1; i__ <= i__5; ++i__) {
+              same = same && isame[i__ - 1];
+              if (!isame[i__ - 1]) {
+                io___391.ciunit = *nout;
+                s_wsfe(&io___391);
+                do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                e_wsfe();
+              }
+              /* L40: */
+            }
+            if (!same) {
+              *fatal = TRUE_;
+              goto L160;
+            }
+
+            if (!null) {
+
+              /*                       Check the result column by column. */
+
+              if (incx > 0) {
+                i__5 = n;
+                for (i__ = 1; i__ <= i__5; ++i__) {
+                  i__6 = i__ + z_dim1;
+                  i__7 = i__;
+                  z__[i__6].r = x[i__7].r, z__[i__6].i = x[i__7].i;
+                  /* L50: */
+                }
+              } else {
+                i__5 = n;
+                for (i__ = 1; i__ <= i__5; ++i__) {
+                  i__6 = i__ + z_dim1;
+                  i__7 = n - i__ + 1;
+                  z__[i__6].r = x[i__7].r, z__[i__6].i = x[i__7].i;
+                  /* L60: */
+                }
+              }
+              if (incy > 0) {
+                i__5 = n;
+                for (i__ = 1; i__ <= i__5; ++i__) {
+                  i__6 = i__ + (z_dim1 << 1);
+                  i__7 = i__;
+                  z__[i__6].r = y[i__7].r, z__[i__6].i = y[i__7].i;
+                  /* L70: */
+                }
+              } else {
+                i__5 = n;
+                for (i__ = 1; i__ <= i__5; ++i__) {
+                  i__6 = i__ + (z_dim1 << 1);
+                  i__7 = n - i__ + 1;
+                  z__[i__6].r = y[i__7].r, z__[i__6].i = y[i__7].i;
+                  /* L80: */
+                }
+              }
+              ja = 1;
+              i__5 = n;
+              for (j = 1; j <= i__5; ++j) {
+                d_cnjg(&z__2, &z__[j + (z_dim1 << 1)]);
+                z__1.r = alpha.r * z__2.r - alpha.i * z__2.i,
+                z__1.i = alpha.r * z__2.i + alpha.i * z__2.r;
+                w[0].r = z__1.r, w[0].i = z__1.i;
+                d_cnjg(&z__2, &alpha);
+                d_cnjg(&z__3, &z__[j + z_dim1]);
+                z__1.r = z__2.r * z__3.r - z__2.i * z__3.i,
+                z__1.i = z__2.r * z__3.i + z__2.i * z__3.r;
+                w[1].r = z__1.r, w[1].i = z__1.i;
+                if (upper) {
+                  jj = 1;
+                  lj = j;
+                } else {
+                  jj = j;
+                  lj = n - j + 1;
+                }
+                zmvch_("N", &lj, &c__2, &c_b2, &z__[jj + z_dim1], nmax, w,
+                       &c__1, &c_b2, &a[jj + j * a_dim1], &c__1, &yt[1], &g[1],
+                       &aa[ja], eps, &err, fatal, nout, &c_true, (ftnlen)1);
+                if (full) {
+                  if (upper) {
+                    ja += lda;
+                  } else {
+                    ja = ja + lda + 1;
+                  }
+                } else {
+                  ja += lj;
+                }
+                errmax = max(errmax, err);
+                /*                          If got really bad answer, report and
+                 * return. */
+                if (*fatal) {
+                  goto L150;
+                }
+                /* L90: */
+              }
+            } else {
+              /*                       Avoid repeating tests with N.le.0. */
+              if (n <= 0) {
+                goto L140;
+              }
+            }
+
+            /* L100: */
+          }
+
+          /* L110: */
+        }
+
+        /* L120: */
+      }
+
+      /* L130: */
+    }
+
+  L140:;
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    io___398.ciunit = *nout;
+    s_wsfe(&io___398);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else {
+    io___399.ciunit = *nout;
+    s_wsfe(&io___399);
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+    e_wsfe();
+  }
+  goto L170;
+
+L150:
+  io___400.ciunit = *nout;
+  s_wsfe(&io___400);
+  do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+  e_wsfe();
+
+L160:
+  io___401.ciunit = *nout;
+  s_wsfe(&io___401);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  if (full) {
+    io___402.ciunit = *nout;
+    s_wsfe(&io___402);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(doublereal));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&lda, (ftnlen)sizeof(integer));
+    e_wsfe();
+  } else if (packed) {
+    io___403.ciunit = *nout;
+    s_wsfe(&io___403);
+    do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+    do_fio(&c__1, sname, (ftnlen)12);
+    do_fio(&c__1, cuplo, (ftnlen)14);
+    do_fio(&c__1, (char *)&n, (ftnlen)sizeof(integer));
+    do_fio(&c__2, (char *)&alpha, (ftnlen)sizeof(doublereal));
+    do_fio(&c__1, (char *)&incx, (ftnlen)sizeof(integer));
+    do_fio(&c__1, (char *)&incy, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L170:
+  return 0;
+
+  /*     End of ZCHK6. */
+
+} /* zchk6_ */
+
+/* Subroutine */ int
+zmvch_(char *trans, integer *m, integer *n, doublecomplex *alpha,
+       doublecomplex *a, integer *nmax, doublecomplex *x, integer *incx,
+       doublecomplex *beta, doublecomplex *y, integer *incy, doublecomplex *yt,
+       doublereal *g, doublecomplex *yy, doublereal *eps, doublereal *err,
+       logical *fatal, integer *nout, logical *mv, ftnlen trans_len) {
+  /* Format strings */
+  static char fmt_9999[] =
+      "(\002 ******* FATAL ERROR - COMPUTED RESULT IS"
+      " LESS THAN HAL\002,\002F ACCURATE *******\002,/\002             "
+      "          EXPECTED RE\002,\002SULT                    COMPUTED R"
+      "ESULT\002)";
+  static char fmt_9998[] = "(1x,i7,2(\002  (\002,g15.6,\002,\002,g15.6,"
+                           "\002)\002))";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;
+  doublereal d__1, d__2, d__3, d__4, d__5, d__6;
+  doublecomplex z__1, z__2, z__3;
+
+  /* Builtin functions */
+  double d_imag(doublecomplex *);
+  void d_cnjg(doublecomplex *, doublecomplex *);
+  double z_abs(doublecomplex *), sqrt(doublereal);
+  integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, j, ml, nl, iy, jx, kx, ky;
+  doublereal erri;
+  logical tran, ctran;
+  integer incxl, incyl;
+
+  /* Fortran I/O blocks */
+  static cilist io___417 = {0, 0, 0, fmt_9999, 0};
+  static cilist io___418 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___419 = {0, 0, 0, fmt_9998, 0};
+
+  /*  Checks the results of the computational tests. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Statement Functions .. */
+  /*     .. Statement Function definitions .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --x;
+  --y;
+  --yt;
+  --g;
+  --yy;
+
+  /* Function Body */
+  tran = *(unsigned char *)trans == 'T';
+  ctran = *(unsigned char *)trans == 'C';
+  if (tran || ctran) {
+    ml = *n;
+    nl = *m;
+  } else {
+    ml = *m;
+    nl = *n;
+  }
+  if (*incx < 0) {
+    kx = nl;
+    incxl = -1;
+  } else {
+    kx = 1;
+    incxl = 1;
+  }
+  if (*incy < 0) {
+    ky = ml;
+    incyl = -1;
+  } else {
+    ky = 1;
+    incyl = 1;
+  }
+
+  /*     Compute expected result in YT using data in A, X and Y. */
+  /*     Compute gauges in G. */
+
+  iy = ky;
+  i__1 = ml;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    i__2 = iy;
+    yt[i__2].r = 0., yt[i__2].i = 0.;
+    g[iy] = 0.;
+    jx = kx;
+    if (tran) {
+      i__2 = nl;
+      for (j = 1; j <= i__2; ++j) {
+        i__3 = iy;
+        i__4 = iy;
+        i__5 = j + i__ * a_dim1;
+        i__6 = jx;
+        z__2.r = a[i__5].r * x[i__6].r - a[i__5].i * x[i__6].i,
+        z__2.i = a[i__5].r * x[i__6].i + a[i__5].i * x[i__6].r;
+        z__1.r = yt[i__4].r + z__2.r, z__1.i = yt[i__4].i + z__2.i;
+        yt[i__3].r = z__1.r, yt[i__3].i = z__1.i;
+        i__3 = j + i__ * a_dim1;
+        i__4 = jx;
+        g[iy] += ((d__1 = a[i__3].r, abs(d__1)) +
+                  (d__2 = d_imag(&a[j + i__ * a_dim1]), abs(d__2))) *
+                 ((d__3 = x[i__4].r, abs(d__3)) +
+                  (d__4 = d_imag(&x[jx]), abs(d__4)));
+        jx += incxl;
+        /* L10: */
+      }
+    } else if (ctran) {
+      i__2 = nl;
+      for (j = 1; j <= i__2; ++j) {
+        i__3 = iy;
+        i__4 = iy;
+        d_cnjg(&z__3, &a[j + i__ * a_dim1]);
+        i__5 = jx;
+        z__2.r = z__3.r * x[i__5].r - z__3.i * x[i__5].i,
+        z__2.i = z__3.r * x[i__5].i + z__3.i * x[i__5].r;
+        z__1.r = yt[i__4].r + z__2.r, z__1.i = yt[i__4].i + z__2.i;
+        yt[i__3].r = z__1.r, yt[i__3].i = z__1.i;
+        i__3 = j + i__ * a_dim1;
+        i__4 = jx;
+        g[iy] += ((d__1 = a[i__3].r, abs(d__1)) +
+                  (d__2 = d_imag(&a[j + i__ * a_dim1]), abs(d__2))) *
+                 ((d__3 = x[i__4].r, abs(d__3)) +
+                  (d__4 = d_imag(&x[jx]), abs(d__4)));
+        jx += incxl;
+        /* L20: */
+      }
+    } else {
+      i__2 = nl;
+      for (j = 1; j <= i__2; ++j) {
+        i__3 = iy;
+        i__4 = iy;
+        i__5 = i__ + j * a_dim1;
+        i__6 = jx;
+        z__2.r = a[i__5].r * x[i__6].r - a[i__5].i * x[i__6].i,
+        z__2.i = a[i__5].r * x[i__6].i + a[i__5].i * x[i__6].r;
+        z__1.r = yt[i__4].r + z__2.r, z__1.i = yt[i__4].i + z__2.i;
+        yt[i__3].r = z__1.r, yt[i__3].i = z__1.i;
+        i__3 = i__ + j * a_dim1;
+        i__4 = jx;
+        g[iy] += ((d__1 = a[i__3].r, abs(d__1)) +
+                  (d__2 = d_imag(&a[i__ + j * a_dim1]), abs(d__2))) *
+                 ((d__3 = x[i__4].r, abs(d__3)) +
+                  (d__4 = d_imag(&x[jx]), abs(d__4)));
+        jx += incxl;
+        /* L30: */
+      }
+    }
+    i__2 = iy;
+    i__3 = iy;
+    z__2.r = alpha->r * yt[i__3].r - alpha->i * yt[i__3].i,
+    z__2.i = alpha->r * yt[i__3].i + alpha->i * yt[i__3].r;
+    i__4 = iy;
+    z__3.r = beta->r * y[i__4].r - beta->i * y[i__4].i,
+    z__3.i = beta->r * y[i__4].i + beta->i * y[i__4].r;
+    z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
+    yt[i__2].r = z__1.r, yt[i__2].i = z__1.i;
+    i__2 = iy;
+    g[iy] = ((d__1 = alpha->r, abs(d__1)) + (d__2 = d_imag(alpha), abs(d__2))) *
+                g[iy] +
+            ((d__3 = beta->r, abs(d__3)) + (d__4 = d_imag(beta), abs(d__4))) *
+                ((d__5 = y[i__2].r, abs(d__5)) +
+                 (d__6 = d_imag(&y[iy]), abs(d__6)));
+    iy += incyl;
+    /* L40: */
+  }
+
+  /*     Compute the error ratio for this result. */
+
+  *err = 0.;
+  i__1 = ml;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    i__2 = i__;
+    i__3 = (i__ - 1) * abs(*incy) + 1;
+    z__1.r = yt[i__2].r - yy[i__3].r, z__1.i = yt[i__2].i - yy[i__3].i;
+    erri = z_abs(&z__1) / *eps;
+    if (g[i__] != 0.) {
+      erri /= g[i__];
+    }
+    *err = max(*err, erri);
+    if (*err * sqrt(*eps) >= 1.) {
+      goto L60;
+    }
+    /* L50: */
+  }
+  /*     If the loop completes, all results are at least half accurate. */
+  goto L80;
+
+  /*     Report fatal error. */
+
+L60:
+  *fatal = TRUE_;
+  io___417.ciunit = *nout;
+  s_wsfe(&io___417);
+  e_wsfe();
+  i__1 = ml;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    if (*mv) {
+      io___418.ciunit = *nout;
+      s_wsfe(&io___418);
+      do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+      do_fio(&c__2, (char *)&yt[i__], (ftnlen)sizeof(doublereal));
+      do_fio(&c__2, (char *)&yy[(i__ - 1) * abs(*incy) + 1],
+             (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    } else {
+      io___419.ciunit = *nout;
+      s_wsfe(&io___419);
+      do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+      do_fio(&c__2, (char *)&yy[(i__ - 1) * abs(*incy) + 1],
+             (ftnlen)sizeof(doublereal));
+      do_fio(&c__2, (char *)&yt[i__], (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+    /* L70: */
+  }
+
+L80:
+  return 0;
+
+  /*     End of ZMVCH. */
+
+} /* zmvch_ */
+
+logical lze_(doublecomplex *ri, doublecomplex *rj, integer *lr) {
+  /* System generated locals */
+  integer i__1, i__2, i__3;
+  logical ret_val;
+
+  /* Local variables */
+  integer i__;
+
+  /*  Tests if two arrays are identical. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  --rj;
+  --ri;
+
+  /* Function Body */
+  i__1 = *lr;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    i__2 = i__;
+    i__3 = i__;
+    if (ri[i__2].r != rj[i__3].r || ri[i__2].i != rj[i__3].i) {
+      goto L20;
+    }
+    /* L10: */
+  }
+  ret_val = TRUE_;
+  goto L30;
+L20:
+  ret_val = FALSE_;
+L30:
+  return ret_val;
+
+  /*     End of LZE. */
+
+} /* lze_ */
+
+logical lzeres_(char *type__, char *uplo, integer *m, integer *n,
+                doublecomplex *aa, doublecomplex *as, integer *lda,
+                ftnlen type_len, ftnlen uplo_len) {
+  /* System generated locals */
+  integer aa_dim1, aa_offset, as_dim1, as_offset, i__1, i__2, i__3, i__4;
+  logical ret_val;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen);
+
+  /* Local variables */
+  integer i__, j, ibeg, iend;
+  logical upper;
+
+  /*  Tests if selected elements in two arrays are equal. */
+
+  /*  TYPE is 'ge', 'he' or 'hp'. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  as_dim1 = *lda;
+  as_offset = 1 + as_dim1;
+  as -= as_offset;
+  aa_dim1 = *lda;
+  aa_offset = 1 + aa_dim1;
+  aa -= aa_offset;
+
+  /* Function Body */
+  upper = *(unsigned char *)uplo == 'U';
+  if (s_cmp(type__, "ge", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      i__2 = *lda;
+      for (i__ = *m + 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + j * aa_dim1;
+        i__4 = i__ + j * as_dim1;
+        if (aa[i__3].r != as[i__4].r || aa[i__3].i != as[i__4].i) {
+          goto L70;
+        }
+        /* L10: */
+      }
+      /* L20: */
+    }
+  } else if (s_cmp(type__, "he", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      if (upper) {
+        ibeg = 1;
+        iend = j;
+      } else {
+        ibeg = j;
+        iend = *n;
+      }
+      i__2 = ibeg - 1;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + j * aa_dim1;
+        i__4 = i__ + j * as_dim1;
+        if (aa[i__3].r != as[i__4].r || aa[i__3].i != as[i__4].i) {
+          goto L70;
+        }
+        /* L30: */
+      }
+      i__2 = *lda;
+      for (i__ = iend + 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + j * aa_dim1;
+        i__4 = i__ + j * as_dim1;
+        if (aa[i__3].r != as[i__4].r || aa[i__3].i != as[i__4].i) {
+          goto L70;
+        }
+        /* L40: */
+      }
+      /* L50: */
+    }
+  }
+
+  /* L60: */
+  ret_val = TRUE_;
+  goto L80;
+L70:
+  ret_val = FALSE_;
+L80:
+  return ret_val;
+
+  /*     End of LZERES. */
+
+} /* lzeres_ */
+
+/* Double Complex */ VOID zbeg_(doublecomplex *ret_val, logical *reset) {
+  /* System generated locals */
+  doublereal d__1, d__2;
+  doublecomplex z__1;
+
+  /* Local variables */
+  static integer i__, j, ic, mi, mj;
+
+  /*  Generates complex numbers as pairs of random numbers uniformly */
+  /*  distributed between -0.5 and 0.5. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Save statement .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Executable Statements .. */
+  if (*reset) {
+    /*        Initialize local variables. */
+    mi = 891;
+    mj = 457;
+    i__ = 7;
+    j = 7;
+    ic = 0;
+    *reset = FALSE_;
+  }
+
+  /*     The sequence of values of I or J is bounded between 1 and 999. */
+  /*     If initial I or J = 1,2,3,6,7 or 9, the period will be 50. */
+  /*     If initial I or J = 4 or 8, the period will be 25. */
+  /*     If initial I or J = 5, the period will be 10. */
+  /*     IC is used to break up the period by skipping 1 value of I or J */
+  /*     in 6. */
+
+  ++ic;
+L10:
+  i__ *= mi;
+  j *= mj;
+  i__ -= i__ / 1000 * 1000;
+  j -= j / 1000 * 1000;
+  if (ic >= 5) {
+    ic = 0;
+    goto L10;
+  }
+  d__1 = (doublereal)((i__ - 500) / 1001.f);
+  d__2 = (doublereal)((j - 500) / 1001.f);
+  z__1.r = d__1, z__1.i = d__2;
+  ret_val->r = z__1.r, ret_val->i = z__1.i;
+  return;
+
+  /*     End of ZBEG. */
+
+} /* zbeg_ */
+
+doublereal ddiff_(doublereal *x, doublereal *y) {
+  /* System generated locals */
+  doublereal ret_val;
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Executable Statements .. */
+  ret_val = *x - *y;
+  return ret_val;
+
+  /*     End of DDIFF. */
+
+} /* ddiff_ */
+
+/* Subroutine */ int zmake_(char *type__, char *uplo, char *diag, integer *m,
+                            integer *n, doublecomplex *a, integer *nmax,
+                            doublecomplex *aa, integer *lda, integer *kl,
+                            integer *ku, logical *reset, doublecomplex *transl,
+                            ftnlen type_len, ftnlen uplo_len, ftnlen diag_len) {
+  /* System generated locals */
+  integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
+  doublereal d__1;
+  doublecomplex z__1, z__2;
+
+  /* Builtin functions */
+  void d_cnjg(doublecomplex *, doublecomplex *);
+  integer s_cmp(char *, char *, ftnlen, ftnlen);
+
+  /* Local variables */
+  integer i__, j, i1, i2, i3, jj, kk;
+  logical gen, tri, sym;
+  integer ibeg, iend, ioff;
+  extern /* Double Complex */ VOID zbeg_(doublecomplex *, logical *);
+  logical unit, lower, upper;
+
+  /*  Generates values for an M by N matrix A within the bandwidth */
+  /*  defined by KL and KU. */
+  /*  Stores the values in the array AA in the data structure required */
+  /*  by the routine, with unwanted elements set to rogue value. */
+
+  /*  TYPE is 'ge', 'gb', 'he', 'hb', 'hp', 'tr', 'tb' OR 'tp'. */
+
+  /*  Auxiliary routine for test program for Level 2 Blas. */
+
+  /*  -- Written on 10-August-1987. */
+  /*     Richard Hanson, Sandia National Labs. */
+  /*     Jeremy Du Croz, NAG Central Office. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. External Functions .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --aa;
+
+  /* Function Body */
+  gen = *(unsigned char *)type__ == 'g';
+  sym = *(unsigned char *)type__ == 'h';
+  tri = *(unsigned char *)type__ == 't';
+  upper = (sym || tri) && *(unsigned char *)uplo == 'U';
+  lower = (sym || tri) && *(unsigned char *)uplo == 'L';
+  unit = tri && *(unsigned char *)diag == 'U';
+
+  /*     Generate data in array A. */
+
+  i__1 = *n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = *m;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      if (gen || upper && i__ <= j || lower && i__ >= j) {
+        if (i__ <= j && j - i__ <= *ku || i__ >= j && i__ - j <= *kl) {
+          i__3 = i__ + j * a_dim1;
+          zbeg_(&z__2, reset);
+          z__1.r = z__2.r + transl->r, z__1.i = z__2.i + transl->i;
+          a[i__3].r = z__1.r, a[i__3].i = z__1.i;
+        } else {
+          i__3 = i__ + j * a_dim1;
+          a[i__3].r = 0., a[i__3].i = 0.;
+        }
+        if (i__ != j) {
+          if (sym) {
+            i__3 = j + i__ * a_dim1;
+            d_cnjg(&z__1, &a[i__ + j * a_dim1]);
+            a[i__3].r = z__1.r, a[i__3].i = z__1.i;
+          } else if (tri) {
+            i__3 = j + i__ * a_dim1;
+            a[i__3].r = 0., a[i__3].i = 0.;
+          }
+        }
+      }
+      /* L10: */
+    }
+    if (sym) {
+      i__2 = j + j * a_dim1;
+      i__3 = j + j * a_dim1;
+      d__1 = a[i__3].r;
+      z__1.r = d__1, z__1.i = 0.;
+      a[i__2].r = z__1.r, a[i__2].i = z__1.i;
+    }
+    if (tri) {
+      i__2 = j + j * a_dim1;
+      i__3 = j + j * a_dim1;
+      z__1.r = a[i__3].r + 1., z__1.i = a[i__3].i + 0.;
+      a[i__2].r = z__1.r, a[i__2].i = z__1.i;
+    }
+    if (unit) {
+      i__2 = j + j * a_dim1;
+      a[i__2].r = 1., a[i__2].i = 0.;
+    }
+    /* L20: */
+  }
+
+  /*     Store elements in array AS in data structure required by routine. */
+
+  if (s_cmp(type__, "ge", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      i__2 = *m;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        i__4 = i__ + j * a_dim1;
+        aa[i__3].r = a[i__4].r, aa[i__3].i = a[i__4].i;
+        /* L30: */
+      }
+      i__2 = *lda;
+      for (i__ = *m + 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        aa[i__3].r = -1e10, aa[i__3].i = 1e10;
+        /* L40: */
+      }
+      /* L50: */
+    }
+  } else if (s_cmp(type__, "gb", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      i__2 = *ku + 1 - j;
+      for (i1 = 1; i1 <= i__2; ++i1) {
+        i__3 = i1 + (j - 1) * *lda;
+        aa[i__3].r = -1e10, aa[i__3].i = 1e10;
+        /* L60: */
+      }
+      /* Computing MIN */
+      i__3 = *kl + *ku + 1, i__4 = *ku + 1 + *m - j;
+      i__2 = min(i__3, i__4);
+      for (i2 = i1; i2 <= i__2; ++i2) {
+        i__3 = i2 + (j - 1) * *lda;
+        i__4 = i2 + j - *ku - 1 + j * a_dim1;
+        aa[i__3].r = a[i__4].r, aa[i__3].i = a[i__4].i;
+        /* L70: */
+      }
+      i__2 = *lda;
+      for (i3 = i2; i3 <= i__2; ++i3) {
+        i__3 = i3 + (j - 1) * *lda;
+        aa[i__3].r = -1e10, aa[i__3].i = 1e10;
+        /* L80: */
+      }
+      /* L90: */
+    }
+  } else if (s_cmp(type__, "he", (ftnlen)2, (ftnlen)2) == 0 ||
+             s_cmp(type__, "tr", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      if (upper) {
+        ibeg = 1;
+        if (unit) {
+          iend = j - 1;
+        } else {
+          iend = j;
+        }
+      } else {
+        if (unit) {
+          ibeg = j + 1;
+        } else {
+          ibeg = j;
+        }
+        iend = *n;
+      }
+      i__2 = ibeg - 1;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        aa[i__3].r = -1e10, aa[i__3].i = 1e10;
+        /* L100: */
+      }
+      i__2 = iend;
+      for (i__ = ibeg; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        i__4 = i__ + j * a_dim1;
+        aa[i__3].r = a[i__4].r, aa[i__3].i = a[i__4].i;
+        /* L110: */
+      }
+      i__2 = *lda;
+      for (i__ = iend + 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        aa[i__3].r = -1e10, aa[i__3].i = 1e10;
+        /* L120: */
+      }
+      if (sym) {
+        jj = j + (j - 1) * *lda;
+        i__2 = jj;
+        i__3 = jj;
+        d__1 = aa[i__3].r;
+        z__1.r = d__1, z__1.i = -1e10;
+        aa[i__2].r = z__1.r, aa[i__2].i = z__1.i;
+      }
+      /* L130: */
+    }
+  } else if (s_cmp(type__, "hb", (ftnlen)2, (ftnlen)2) == 0 ||
+             s_cmp(type__, "tb", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      if (upper) {
+        kk = *kl + 1;
+        /* Computing MAX */
+        i__2 = 1, i__3 = *kl + 2 - j;
+        ibeg = max(i__2, i__3);
+        if (unit) {
+          iend = *kl;
+        } else {
+          iend = *kl + 1;
+        }
+      } else {
+        kk = 1;
+        if (unit) {
+          ibeg = 2;
+        } else {
+          ibeg = 1;
+        }
+        /* Computing MIN */
+        i__2 = *kl + 1, i__3 = *m + 1 - j;
+        iend = min(i__2, i__3);
+      }
+      i__2 = ibeg - 1;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        aa[i__3].r = -1e10, aa[i__3].i = 1e10;
+        /* L140: */
+      }
+      i__2 = iend;
+      for (i__ = ibeg; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        i__4 = i__ + j - kk + j * a_dim1;
+        aa[i__3].r = a[i__4].r, aa[i__3].i = a[i__4].i;
+        /* L150: */
+      }
+      i__2 = *lda;
+      for (i__ = iend + 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        aa[i__3].r = -1e10, aa[i__3].i = 1e10;
+        /* L160: */
+      }
+      if (sym) {
+        jj = kk + (j - 1) * *lda;
+        i__2 = jj;
+        i__3 = jj;
+        d__1 = aa[i__3].r;
+        z__1.r = d__1, z__1.i = -1e10;
+        aa[i__2].r = z__1.r, aa[i__2].i = z__1.i;
+      }
+      /* L170: */
+    }
+  } else if (s_cmp(type__, "hp", (ftnlen)2, (ftnlen)2) == 0 ||
+             s_cmp(type__, "tp", (ftnlen)2, (ftnlen)2) == 0) {
+    ioff = 0;
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      if (upper) {
+        ibeg = 1;
+        iend = j;
+      } else {
+        ibeg = j;
+        iend = *n;
+      }
+      i__2 = iend;
+      for (i__ = ibeg; i__ <= i__2; ++i__) {
+        ++ioff;
+        i__3 = ioff;
+        i__4 = i__ + j * a_dim1;
+        aa[i__3].r = a[i__4].r, aa[i__3].i = a[i__4].i;
+        if (i__ == j) {
+          if (unit) {
+            i__3 = ioff;
+            aa[i__3].r = -1e10, aa[i__3].i = 1e10;
+          }
+          if (sym) {
+            i__3 = ioff;
+            i__4 = ioff;
+            d__1 = aa[i__4].r;
+            z__1.r = d__1, z__1.i = -1e10;
+            aa[i__3].r = z__1.r, aa[i__3].i = z__1.i;
+          }
+        }
+        /* L180: */
+      }
+      /* L190: */
+    }
+  }
+  return 0;
+
+  /*     End of ZMAKE. */
+
+} /* zmake_ */
+
+/* Main program alias */ int zblat2_() {
+  MAIN__();
+  return 0;
+}
diff --git a/CBLAS/testing/c_zblat3.c b/CBLAS/testing/c_zblat3.c
new file mode 100644
index 0000000..715dc8a
--- /dev/null
+++ b/CBLAS/testing/c_zblat3.c
@@ -0,0 +1,4458 @@
+/* testing/c_zblat3.f -- translated by f2c (version 20191129).
+   You must link the resulting object file with libf2c:
+        on Microsoft Windows system, link with libf2c.lib;
+        on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+        or, if you install libf2c.a in a standard place, with -lf2c -lm
+        -- in that order, at the end of the command line, as in
+                cc *.o -lf2c -lm
+        Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+                http://www.netlib.org/f2c/libf2c.zip
+*/
+
+#include "f2c.h"
+
+/* Common Block Declarations */
+
+struct {
+  integer infot, noutc;
+  logical ok, lerr;
+} infoc_;
+
+#define infoc_1 infoc_
+
+struct {
+  char srnamt[12];
+} srnamc_;
+
+#define srnamc_1 srnamc_
+
+/* Table of constant values */
+
+static doublecomplex c_b1 = {0., 0.};
+static doublecomplex c_b2 = {1., 0.};
+static integer c__9 = 9;
+static integer c__1 = 1;
+static integer c__3 = 3;
+static integer c__8 = 8;
+static integer c__5 = 5;
+static integer c__65 = 65;
+static integer c__7 = 7;
+static integer c__2 = 2;
+static doublereal c_b92 = 1.;
+static integer c__6 = 6;
+static logical c_true = TRUE_;
+static integer c__0 = 0;
+static logical c_false = FALSE_;
+
+/* Main program */ int MAIN__(void) {
+  /* Initialized data */
+
+  static char snames[12 * 9] = "cblas_zgemm "
+                               "cblas_zhemm "
+                               "cblas_zsymm "
+                               "cblas_ztrmm "
+                               "cblas_ztrsm "
+                               "cblas_zherk "
+                               "cblas_zsyrk "
+                               "cbl"
+                               "as_zher2k"
+                               "cblas_zsyr2k";
+
+  /* Format strings */
+  static char fmt_9997[] = "(\002 NUMBER OF VALUES OF \002,a,\002 IS LESS "
+                           "THAN 1 OR GREATER \002,\002THAN \002,i2)";
+  static char fmt_9996[] = "(\002 VALUE OF N IS LESS THAN 0 OR GREATER THA"
+                           "N \002,i2)";
+  static char fmt_9995[] =
+      "(\002TESTS OF THE COMPLEX*16        LEVEL 3 BL"
+      "AS\002,//\002 THE F\002,\002OLLOWING PARAMETER VALUES WILL BE US"
+      "ED:\002)";
+  static char fmt_9994[] = "(\002   FOR N              \002,9i6)";
+  static char fmt_9993[] = "(\002   FOR ALPHA          \002,7(\002(\002,f4"
+                           ".1,\002,\002,f4.1,\002)  \002,:))";
+  static char fmt_9992[] = "(\002   FOR BETA           \002,7(\002(\002,f4"
+                           ".1,\002,\002,f4.1,\002)  \002,:))";
+  static char fmt_9984[] = "(\002 ERROR-EXITS WILL NOT BE TESTED\002)";
+  static char fmt_9999[] = "(\002 ROUTINES PASS COMPUTATIONAL TESTS IF TES"
+                           "T RATIO IS LES\002,\002S THAN\002,f8.2)";
+  static char fmt_10002[] = "(\002 COLUMN-MAJOR AND ROW-MAJOR DATA LAYOUTS"
+                            " ARE TESTED\002)";
+  static char fmt_10001[] = "(\002 ROW-MAJOR DATA LAYOUT IS TESTED\002)";
+  static char fmt_10000[] = "(\002 COLUMN-MAJOR DATA LAYOUT IS TESTED\002)";
+  static char fmt_9988[] = "(a12,l2)";
+  static char fmt_9990[] =
+      "(\002 SUBPROGRAM NAME \002,a12,\002 NOT RECOGN"
+      "IZED\002,/\002 ******* T\002,\002ESTS ABANDONED *******\002)";
+  static char fmt_9998[] = "(\002 RELATIVE MACHINE PRECISION IS TAKEN TO"
+                           " BE\002,1p,e9.1)";
+  static char fmt_9989[] =
+      "(\002 ERROR IN ZMMCH -  IN-LINE DOT PRODUCTS A"
+      "RE BEING EVALU\002,\002ATED WRONGLY.\002,/\002 ZMMCH WAS CALLED "
+      "WITH TRANSA = \002,a1,\002AND TRANSB = \002,a1,/\002 AND RETURNE"
+      "D SAME = \002,l1,\002 AND \002,\002 ERR = \002,f12.3,\002.\002,"
+      "/\002 THIS MAY BE DUE TO FAULTS IN THE \002,\002ARITHMETIC OR TH"
+      "E COMPILER.\002,/\002 ******* TESTS ABANDONED \002,\002******"
+      "*\002)";
+  static char fmt_9987[] = "(1x,a12,\002 WAS NOT TESTED\002)";
+  static char fmt_9986[] = "(/\002 END OF TESTS\002)";
+  static char fmt_9985[] = "(/\002 ******* FATAL ERROR - TESTS ABANDONED *"
+                           "******\002)";
+  static char fmt_9991[] =
+      "(\002 AMEND DATA FILE OR INCREASE ARRAY SIZES "
+      "IN PROGRAM\002,/\002 ******* TESTS ABANDONED *******\002)";
+
+  /* System generated locals */
+  integer i__1, i__2, i__3, i__4, i__5;
+  doublereal d__1;
+  olist o__1;
+  cllist cl__1;
+
+  /* Builtin functions */
+  integer s_rsle(cilist *), do_lio(integer *, integer *, char *, ftnlen),
+      e_rsle(void), f_open(olist *), s_wsfe(cilist *),
+      do_fio(integer *, char *, ftnlen), e_wsfe(void), s_wsle(cilist *),
+      e_wsle(void), s_rsfe(cilist *), e_rsfe(void),
+      s_cmp(char *, char *, ftnlen, ftnlen);
+  /* Subroutine */ int s_stop(char *, ftnlen);
+  integer f_clos(cllist *);
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+
+  /* Local variables */
+  doublecomplex c__[4225] /* was [65][65] */;
+  doublereal g[65];
+  integer i__, j, n;
+  doublecomplex w[130], aa[4225], ab[8450] /* was [65][130] */, bb[4225],
+      cc[4225], as[4225], bs[4225], cs[4225], ct[65], alf[7], bet[7];
+  doublereal eps, err;
+  extern logical lze_(doublecomplex *, doublecomplex *, integer *);
+  integer nalf, idim[9];
+  logical same;
+  integer nbet, ntra;
+  logical rewi;
+  extern /* Subroutine */ int zchk1_(
+      char *, doublereal *, doublereal *, integer *, integer *, logical *,
+      logical *, logical *, integer *, integer *, integer *, doublecomplex *,
+      integer *, doublecomplex *, integer *, doublecomplex *, doublecomplex *,
+      doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+      doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+      doublereal *, integer *, ftnlen),
+      zchk2_(char *, doublereal *, doublereal *, integer *, integer *,
+             logical *, logical *, logical *, integer *, integer *, integer *,
+             doublecomplex *, integer *, doublecomplex *, integer *,
+             doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+             doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+             doublecomplex *, doublecomplex *, doublereal *, integer *, ftnlen),
+      zchk3_(char *, doublereal *, doublereal *, integer *, integer *,
+             logical *, logical *, logical *, integer *, integer *, integer *,
+             doublecomplex *, integer *, doublecomplex *, doublecomplex *,
+             doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+             doublecomplex *, doublereal *, doublecomplex *, integer *, ftnlen),
+      zchk4_(char *, doublereal *, doublereal *, integer *, integer *,
+             logical *, logical *, logical *, integer *, integer *, integer *,
+             doublecomplex *, integer *, doublecomplex *, integer *,
+             doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+             doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+             doublecomplex *, doublecomplex *, doublereal *, integer *, ftnlen),
+      zchk5_(char *, doublereal *, doublereal *, integer *, integer *,
+             logical *, logical *, logical *, integer *, integer *, integer *,
+             doublecomplex *, integer *, doublecomplex *, integer *,
+             doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+             doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *,
+             doublecomplex *, doublereal *, doublecomplex *, integer *, ftnlen);
+  extern doublereal ddiff_(doublereal *, doublereal *);
+  logical fatal, trace;
+  integer nidim;
+  extern /* Subroutine */ int zmmch_(
+      char *, char *, integer *, integer *, integer *, doublecomplex *,
+      doublecomplex *, integer *, doublecomplex *, integer *, doublecomplex *,
+      doublecomplex *, integer *, doublecomplex *, doublereal *,
+      doublecomplex *, integer *, doublereal *, doublereal *, logical *,
+      integer *, logical *, ftnlen, ftnlen);
+  char snaps[32];
+  integer isnum;
+  logical ltest[9], sfatal, corder;
+  char snamet[12], transa[1], transb[1];
+  doublereal thresh;
+  logical rorder;
+  integer layout;
+  logical ltestt, tsterr;
+  extern /* Subroutine */ void cz3chke_(char *);
+
+  /* Fortran I/O blocks */
+  static cilist io___2 = {0, 5, 0, 0, 0};
+  static cilist io___4 = {0, 5, 0, 0, 0};
+  static cilist io___7 = {0, 5, 0, 0, 0};
+  static cilist io___9 = {0, 5, 0, 0, 0};
+  static cilist io___11 = {0, 5, 0, 0, 0};
+  static cilist io___13 = {0, 5, 0, 0, 0};
+  static cilist io___15 = {0, 5, 0, 0, 0};
+  static cilist io___17 = {0, 5, 0, 0, 0};
+  static cilist io___19 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___20 = {0, 5, 0, 0, 0};
+  static cilist io___23 = {0, 6, 0, fmt_9996, 0};
+  static cilist io___24 = {0, 5, 0, 0, 0};
+  static cilist io___26 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___27 = {0, 5, 0, 0, 0};
+  static cilist io___29 = {0, 5, 0, 0, 0};
+  static cilist io___31 = {0, 6, 0, fmt_9997, 0};
+  static cilist io___32 = {0, 5, 0, 0, 0};
+  static cilist io___34 = {0, 6, 0, fmt_9995, 0};
+  static cilist io___35 = {0, 6, 0, fmt_9994, 0};
+  static cilist io___36 = {0, 6, 0, fmt_9993, 0};
+  static cilist io___37 = {0, 6, 0, fmt_9992, 0};
+  static cilist io___38 = {0, 6, 0, 0, 0};
+  static cilist io___39 = {0, 6, 0, fmt_9984, 0};
+  static cilist io___40 = {0, 6, 0, 0, 0};
+  static cilist io___41 = {0, 6, 0, fmt_9999, 0};
+  static cilist io___42 = {0, 6, 0, 0, 0};
+  static cilist io___45 = {0, 6, 0, fmt_10002, 0};
+  static cilist io___46 = {0, 6, 0, fmt_10001, 0};
+  static cilist io___47 = {0, 6, 0, fmt_10000, 0};
+  static cilist io___48 = {0, 6, 0, 0, 0};
+  static cilist io___50 = {0, 5, 1, fmt_9988, 0};
+  static cilist io___53 = {0, 6, 0, fmt_9990, 0};
+  static cilist io___55 = {0, 6, 0, fmt_9998, 0};
+  static cilist io___68 = {0, 6, 0, fmt_9989, 0};
+  static cilist io___69 = {0, 6, 0, fmt_9989, 0};
+  static cilist io___70 = {0, 6, 0, fmt_9989, 0};
+  static cilist io___71 = {0, 6, 0, fmt_9989, 0};
+  static cilist io___73 = {0, 6, 0, 0, 0};
+  static cilist io___74 = {0, 6, 0, fmt_9987, 0};
+  static cilist io___75 = {0, 6, 0, 0, 0};
+  static cilist io___82 = {0, 6, 0, fmt_9986, 0};
+  static cilist io___83 = {0, 6, 0, fmt_9985, 0};
+  static cilist io___84 = {0, 6, 0, fmt_9991, 0};
+
+  /*  Test program for the COMPLEX*16          Level 3 Blas. */
+
+  /*  The program must be driven by a short data file. The first 13 records */
+  /*  of the file are read using list-directed input, the last 9 records */
+  /*  are read using the format ( A12,L2 ). An annotated example of a data */
+  /*  file can be obtained by deleting the first 3 characters from the */
+  /*  following 22 lines: */
+  /*  'CBLAT3.SNAP'     NAME OF SNAPSHOT OUTPUT FILE */
+  /*  -1                UNIT NUMBER OF SNAPSHOT FILE (NOT USED IF .LT. 0) */
+  /*  F        LOGICAL FLAG, T TO REWIND SNAPSHOT FILE AFTER EACH RECORD. */
+  /*  F        LOGICAL FLAG, T TO STOP ON FAILURES. */
+  /*  T        LOGICAL FLAG, T TO TEST ERROR EXITS. */
+  /*  2        0 TO TEST COLUMN-MAJOR, 1 TO TEST ROW-MAJOR, 2 TO TEST BOTH */
+  /*  16.0     THRESHOLD VALUE OF TEST RATIO */
+  /*  6                 NUMBER OF VALUES OF N */
+  /*  0 1 2 3 5 9       VALUES OF N */
+  /*  3                 NUMBER OF VALUES OF ALPHA */
+  /*  (0.0,0.0) (1.0,0.0) (0.7,-0.9)       VALUES OF ALPHA */
+  /*  3                 NUMBER OF VALUES OF BETA */
+  /*  (0.0,0.0) (1.0,0.0) (1.3,-1.1)       VALUES OF BETA */
+  /*  ZGEMM  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  ZHEMM  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  ZSYMM  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  ZTRMM  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  ZTRSM  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  ZHERK  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  ZSYRK  T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  ZHER2K T PUT F FOR NO TEST. SAME COLUMNS. */
+  /*  ZSYR2K T PUT F FOR NO TEST. SAME COLUMNS. */
+
+  /*  See: */
+
+  /*     Dongarra J. J., Du Croz J. J., Duff I. S. and Hammarling S. */
+  /*     A Set of Level 3 Basic Linear Algebra Subprograms. */
+
+  /*     Technical Memorandum No.88 (Revision 1), Mathematics and */
+  /*     Computer Science Division, Argonne National Laboratory, 9700 */
+  /*     South Cass Avenue, Argonne, Illinois 60439, US. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /*     .. Executable Statements .. */
+
+  infoc_1.noutc = 6;
+
+  /*     Read name and unit number for snapshot output file and open file. */
+
+  s_rsle(&io___2);
+  do_lio(&c__9, &c__1, snaps, (ftnlen)32);
+  e_rsle();
+  s_rsle(&io___4);
+  do_lio(&c__3, &c__1, (char *)&ntra, (ftnlen)sizeof(integer));
+  e_rsle();
+  trace = ntra >= 0;
+  if (trace) {
+    o__1.oerr = 0;
+    o__1.ounit = ntra;
+    o__1.ofnmlen = 32;
+    o__1.ofnm = snaps;
+    o__1.orl = 0;
+    o__1.osta = "NEW";
+    o__1.oacc = 0;
+    o__1.ofm = 0;
+    o__1.oblnk = 0;
+    f_open(&o__1);
+  }
+  /*     Read the flag that directs rewinding of the snapshot file. */
+  s_rsle(&io___7);
+  do_lio(&c__8, &c__1, (char *)&rewi, (ftnlen)sizeof(logical));
+  e_rsle();
+  rewi = rewi && trace;
+  /*     Read the flag that directs stopping on any failure. */
+  s_rsle(&io___9);
+  do_lio(&c__8, &c__1, (char *)&sfatal, (ftnlen)sizeof(logical));
+  e_rsle();
+  /*     Read the flag that indicates whether error exits are to be tested. */
+  s_rsle(&io___11);
+  do_lio(&c__8, &c__1, (char *)&tsterr, (ftnlen)sizeof(logical));
+  e_rsle();
+  /*     Read the flag that indicates whether row-major data layout to be
+   * tested. */
+  s_rsle(&io___13);
+  do_lio(&c__3, &c__1, (char *)&layout, (ftnlen)sizeof(integer));
+  e_rsle();
+  /*     Read the threshold value of the test ratio */
+  s_rsle(&io___15);
+  do_lio(&c__5, &c__1, (char *)&thresh, (ftnlen)sizeof(doublereal));
+  e_rsle();
+
+  /*     Read and check the parameter values for the tests. */
+
+  /*     Values of N */
+  s_rsle(&io___17);
+  do_lio(&c__3, &c__1, (char *)&nidim, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nidim < 1 || nidim > 9) {
+    s_wsfe(&io___19);
+    do_fio(&c__1, "N", (ftnlen)1);
+    do_fio(&c__1, (char *)&c__9, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L220;
+  }
+  s_rsle(&io___20);
+  i__1 = nidim;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__3, &c__1, (char *)&idim[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_rsle();
+  i__1 = nidim;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    if (idim[i__ - 1] < 0 || idim[i__ - 1] > 65) {
+      s_wsfe(&io___23);
+      do_fio(&c__1, (char *)&c__65, (ftnlen)sizeof(integer));
+      e_wsfe();
+      goto L220;
+    }
+    /* L10: */
+  }
+  /*     Values of ALPHA */
+  s_rsle(&io___24);
+  do_lio(&c__3, &c__1, (char *)&nalf, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nalf < 1 || nalf > 7) {
+    s_wsfe(&io___26);
+    do_fio(&c__1, "ALPHA", (ftnlen)5);
+    do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L220;
+  }
+  s_rsle(&io___27);
+  i__1 = nalf;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__7, &c__1, (char *)&alf[i__ - 1], (ftnlen)sizeof(doublecomplex));
+  }
+  e_rsle();
+  /*     Values of BETA */
+  s_rsle(&io___29);
+  do_lio(&c__3, &c__1, (char *)&nbet, (ftnlen)sizeof(integer));
+  e_rsle();
+  if (nbet < 1 || nbet > 7) {
+    s_wsfe(&io___31);
+    do_fio(&c__1, "BETA", (ftnlen)4);
+    do_fio(&c__1, (char *)&c__7, (ftnlen)sizeof(integer));
+    e_wsfe();
+    goto L220;
+  }
+  s_rsle(&io___32);
+  i__1 = nbet;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_lio(&c__7, &c__1, (char *)&bet[i__ - 1], (ftnlen)sizeof(doublecomplex));
+  }
+  e_rsle();
+
+  /*     Report values of parameters. */
+
+  s_wsfe(&io___34);
+  e_wsfe();
+  s_wsfe(&io___35);
+  i__1 = nidim;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__1, (char *)&idim[i__ - 1], (ftnlen)sizeof(integer));
+  }
+  e_wsfe();
+  s_wsfe(&io___36);
+  i__1 = nalf;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__2, (char *)&alf[i__ - 1], (ftnlen)sizeof(doublereal));
+  }
+  e_wsfe();
+  s_wsfe(&io___37);
+  i__1 = nbet;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    do_fio(&c__2, (char *)&bet[i__ - 1], (ftnlen)sizeof(doublereal));
+  }
+  e_wsfe();
+  if (!tsterr) {
+    s_wsle(&io___38);
+    e_wsle();
+    s_wsfe(&io___39);
+    e_wsfe();
+  }
+  s_wsle(&io___40);
+  e_wsle();
+  s_wsfe(&io___41);
+  do_fio(&c__1, (char *)&thresh, (ftnlen)sizeof(doublereal));
+  e_wsfe();
+  s_wsle(&io___42);
+  e_wsle();
+  rorder = FALSE_;
+  corder = FALSE_;
+  if (layout == 2) {
+    rorder = TRUE_;
+    corder = TRUE_;
+    s_wsfe(&io___45);
+    e_wsfe();
+  } else if (layout == 1) {
+    rorder = TRUE_;
+    s_wsfe(&io___46);
+    e_wsfe();
+  } else if (layout == 0) {
+    corder = TRUE_;
+    s_wsfe(&io___47);
+    e_wsfe();
+  }
+  s_wsle(&io___48);
+  e_wsle();
+
+  /*     Read names of subroutines and flags which indicate */
+  /*     whether they are to be tested. */
+
+  for (i__ = 1; i__ <= 9; ++i__) {
+    ltest[i__ - 1] = FALSE_;
+    /* L20: */
+  }
+L30:
+  i__1 = s_rsfe(&io___50);
+  if (i__1 != 0) {
+    goto L60;
+  }
+  i__1 = do_fio(&c__1, snamet, (ftnlen)12);
+  if (i__1 != 0) {
+    goto L60;
+  }
+  i__1 = do_fio(&c__1, (char *)&ltestt, (ftnlen)sizeof(logical));
+  if (i__1 != 0) {
+    goto L60;
+  }
+  i__1 = e_rsfe();
+  if (i__1 != 0) {
+    goto L60;
+  }
+  for (i__ = 1; i__ <= 9; ++i__) {
+    if (s_cmp(snamet, snames + (i__ - 1) * 12, (ftnlen)12, (ftnlen)12) == 0) {
+      goto L50;
+    }
+    /* L40: */
+  }
+  s_wsfe(&io___53);
+  do_fio(&c__1, snamet, (ftnlen)12);
+  e_wsfe();
+  s_stop("", (ftnlen)0);
+L50:
+  ltest[i__ - 1] = ltestt;
+  goto L30;
+
+L60:
+  cl__1.cerr = 0;
+  cl__1.cunit = 5;
+  cl__1.csta = 0;
+  f_clos(&cl__1);
+
+  /*     Compute EPS (the machine precision). */
+
+  eps = 1.;
+L70:
+  d__1 = eps + 1.;
+  if (ddiff_(&d__1, &c_b92) == 0.) {
+    goto L80;
+  }
+  eps *= .5;
+  goto L70;
+L80:
+  eps += eps;
+  s_wsfe(&io___55);
+  do_fio(&c__1, (char *)&eps, (ftnlen)sizeof(doublereal));
+  e_wsfe();
+
+  /*     Check the reliability of ZMMCH using exact data. */
+
+  n = 32;
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = n;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      i__3 = i__ + j * 65 - 66;
+      /* Computing MAX */
+      i__5 = i__ - j + 1;
+      i__4 = max(i__5, 0);
+      ab[i__3].r = (doublereal)i__4, ab[i__3].i = 0.;
+      /* L90: */
+    }
+    i__2 = j + 4224;
+    ab[i__2].r = (doublereal)j, ab[i__2].i = 0.;
+    i__2 = (j + 65) * 65 - 65;
+    ab[i__2].r = (doublereal)j, ab[i__2].i = 0.;
+    i__2 = j - 1;
+    c__[i__2].r = 0., c__[i__2].i = 0.;
+    /* L100: */
+  }
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = j - 1;
+    i__3 = j * ((j + 1) * j) / 2 - (j + 1) * j * (j - 1) / 3;
+    cc[i__2].r = (doublereal)i__3, cc[i__2].i = 0.;
+    /* L110: */
+  }
+  /*     CC holds the exact result. On exit from ZMMCH CT holds */
+  /*     the result computed by ZMMCH. */
+  *(unsigned char *)transa = 'N';
+  *(unsigned char *)transb = 'N';
+  zmmch_(transa, transb, &n, &c__1, &n, &c_b2, ab, &c__65, &ab[4225], &c__65,
+         &c_b1, c__, &c__65, ct, g, cc, &c__65, &eps, &err, &fatal, &c__6,
+         &c_true, (ftnlen)1, (ftnlen)1);
+  same = lze_(cc, ct, &n);
+  if (!same || err != 0.) {
+    s_wsfe(&io___68);
+    do_fio(&c__1, transa, (ftnlen)1);
+    do_fio(&c__1, transb, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(doublereal));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+  *(unsigned char *)transb = 'C';
+  zmmch_(transa, transb, &n, &c__1, &n, &c_b2, ab, &c__65, &ab[4225], &c__65,
+         &c_b1, c__, &c__65, ct, g, cc, &c__65, &eps, &err, &fatal, &c__6,
+         &c_true, (ftnlen)1, (ftnlen)1);
+  same = lze_(cc, ct, &n);
+  if (!same || err != 0.) {
+    s_wsfe(&io___69);
+    do_fio(&c__1, transa, (ftnlen)1);
+    do_fio(&c__1, transb, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(doublereal));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = j + 4224;
+    i__3 = n - j + 1;
+    ab[i__2].r = (doublereal)i__3, ab[i__2].i = 0.;
+    i__2 = (j + 65) * 65 - 65;
+    i__3 = n - j + 1;
+    ab[i__2].r = (doublereal)i__3, ab[i__2].i = 0.;
+    /* L120: */
+  }
+  i__1 = n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = n - j;
+    i__3 = j * ((j + 1) * j) / 2 - (j + 1) * j * (j - 1) / 3;
+    cc[i__2].r = (doublereal)i__3, cc[i__2].i = 0.;
+    /* L130: */
+  }
+  *(unsigned char *)transa = 'C';
+  *(unsigned char *)transb = 'N';
+  zmmch_(transa, transb, &n, &c__1, &n, &c_b2, ab, &c__65, &ab[4225], &c__65,
+         &c_b1, c__, &c__65, ct, g, cc, &c__65, &eps, &err, &fatal, &c__6,
+         &c_true, (ftnlen)1, (ftnlen)1);
+  same = lze_(cc, ct, &n);
+  if (!same || err != 0.) {
+    s_wsfe(&io___70);
+    do_fio(&c__1, transa, (ftnlen)1);
+    do_fio(&c__1, transb, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(doublereal));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+  *(unsigned char *)transb = 'C';
+  zmmch_(transa, transb, &n, &c__1, &n, &c_b2, ab, &c__65, &ab[4225], &c__65,
+         &c_b1, c__, &c__65, ct, g, cc, &c__65, &eps, &err, &fatal, &c__6,
+         &c_true, (ftnlen)1, (ftnlen)1);
+  same = lze_(cc, ct, &n);
+  if (!same || err != 0.) {
+    s_wsfe(&io___71);
+    do_fio(&c__1, transa, (ftnlen)1);
+    do_fio(&c__1, transb, (ftnlen)1);
+    do_fio(&c__1, (char *)&same, (ftnlen)sizeof(logical));
+    do_fio(&c__1, (char *)&err, (ftnlen)sizeof(doublereal));
+    e_wsfe();
+    s_stop("", (ftnlen)0);
+  }
+
+  /*     Test each subroutine in turn. */
+
+  for (isnum = 1; isnum <= 9; ++isnum) {
+    s_wsle(&io___73);
+    e_wsle();
+    if (!ltest[isnum - 1]) {
+      /*           Subprogram is not to be tested. */
+      s_wsfe(&io___74);
+      do_fio(&c__1, snames + (isnum - 1) * 12, (ftnlen)12);
+      e_wsfe();
+    } else {
+      s_copy(srnamc_1.srnamt, snames + (isnum - 1) * 12, (ftnlen)12,
+             (ftnlen)12);
+      /*           Test error exits. */
+      if (tsterr) {
+        cz3chke_(snames + (isnum - 1) * 12);
+        s_wsle(&io___75);
+        e_wsle();
+      }
+      /*           Test computations. */
+      infoc_1.infot = 0;
+      infoc_1.ok = TRUE_;
+      fatal = FALSE_;
+      switch (isnum) {
+      case 1:
+        goto L140;
+      case 2:
+        goto L150;
+      case 3:
+        goto L150;
+      case 4:
+        goto L160;
+      case 5:
+        goto L160;
+      case 6:
+        goto L170;
+      case 7:
+        goto L170;
+      case 8:
+        goto L180;
+      case 9:
+        goto L180;
+      }
+    /*           Test ZGEMM, 01. */
+    L140:
+      if (corder) {
+        zchk1_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__0,
+               (ftnlen)12);
+      }
+      if (rorder) {
+        zchk1_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__1,
+               (ftnlen)12);
+      }
+      goto L190;
+    /*           Test ZHEMM, 02, ZSYMM, 03. */
+    L150:
+      if (corder) {
+        zchk2_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__0,
+               (ftnlen)12);
+      }
+      if (rorder) {
+        zchk2_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__1,
+               (ftnlen)12);
+      }
+      goto L190;
+    /*           Test ZTRMM, 04, ZTRSM, 05. */
+    L160:
+      if (corder) {
+        zchk3_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &c__65, ab, aa, as,
+               &ab[4225], bb, bs, ct, g, c__, &c__0, (ftnlen)12);
+      }
+      if (rorder) {
+        zchk3_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &c__65, ab, aa, as,
+               &ab[4225], bb, bs, ct, g, c__, &c__1, (ftnlen)12);
+      }
+      goto L190;
+    /*           Test ZHERK, 06, ZSYRK, 07. */
+    L170:
+      if (corder) {
+        zchk4_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__0,
+               (ftnlen)12);
+      }
+      if (rorder) {
+        zchk4_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, &ab[4225], bb, bs, c__, cc, cs, ct, g, &c__1,
+               (ftnlen)12);
+      }
+      goto L190;
+    /*           Test ZHER2K, 08, ZSYR2K, 09. */
+    L180:
+      if (corder) {
+        zchk5_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, bb, bs, c__, cc, cs, ct, g, w, &c__0, (ftnlen)12);
+      }
+      if (rorder) {
+        zchk5_(snames + (isnum - 1) * 12, &eps, &thresh, &c__6, &ntra, &trace,
+               &rewi, &fatal, &nidim, idim, &nalf, alf, &nbet, bet, &c__65, ab,
+               aa, as, bb, bs, c__, cc, cs, ct, g, w, &c__1, (ftnlen)12);
+      }
+      goto L190;
+
+    L190:
+      if (fatal && sfatal) {
+        goto L210;
+      }
+    }
+    /* L200: */
+  }
+  s_wsfe(&io___82);
+  e_wsfe();
+  goto L230;
+
+L210:
+  s_wsfe(&io___83);
+  e_wsfe();
+  goto L230;
+
+L220:
+  s_wsfe(&io___84);
+  e_wsfe();
+
+L230:
+  if (trace) {
+    cl__1.cerr = 0;
+    cl__1.cunit = ntra;
+    cl__1.csta = 0;
+    f_clos(&cl__1);
+  }
+  cl__1.cerr = 0;
+  cl__1.cunit = 6;
+  cl__1.csta = 0;
+  f_clos(&cl__1);
+  s_stop("", (ftnlen)0);
+
+  /*     End of ZBLAT3. */
+
+  return 0;
+} /* MAIN__ */
+
+/* Subroutine */ int
+zchk1_(char *sname, doublereal *eps, doublereal *thresh, integer *nout,
+       integer *ntra, logical *trace, logical *rewi, logical *fatal,
+       integer *nidim, integer *idim, integer *nalf, doublecomplex *alf,
+       integer *nbet, doublecomplex *bet, integer *nmax, doublecomplex *a,
+       doublecomplex *aa, doublecomplex *as, doublecomplex *b,
+       doublecomplex *bb, doublecomplex *bs, doublecomplex *c__,
+       doublecomplex *cc, doublecomplex *cs, doublecomplex *ct, doublereal *g,
+       integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ich[3] = "NTC";
+
+  /* Format strings */
+  static char fmt_9994[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
+      i__3, i__4, i__5, i__6, i__7, i__8;
+  alist al__1;
+
+  /* Builtin functions */
+  integer f_rew(alist *), s_wsfe(cilist *), e_wsfe(void),
+      do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, k, m, n, ia, ib, ma, mb, na, nb, nc, ik, im, in, ks, ms, ns, ica,
+      icb, laa, lbb, lda, lcc, ldb, ldc;
+  doublecomplex als, bls;
+  doublereal err;
+  extern logical lze_(doublecomplex *, doublecomplex *, integer *);
+  doublecomplex beta;
+  integer ldas, ldbs, ldcs;
+  logical same, null;
+  doublecomplex alpha;
+  logical isame[13], trana, tranb;
+  extern /* Subroutine */ int zmake_(char *, char *, char *, integer *,
+                                     integer *, doublecomplex *, integer *,
+                                     doublecomplex *, integer *, logical *,
+                                     doublecomplex *, ftnlen, ftnlen, ftnlen);
+  integer nargs;
+  extern /* Subroutine */ int zmmch_(
+      char *, char *, integer *, integer *, integer *, doublecomplex *,
+      doublecomplex *, integer *, doublecomplex *, integer *, doublecomplex *,
+      doublecomplex *, integer *, doublecomplex *, doublereal *,
+      doublecomplex *, integer *, doublereal *, doublereal *, logical *,
+      integer *, logical *, ftnlen, ftnlen);
+  logical reset;
+  extern /* Subroutine */ int zprcn1_(
+      integer *, integer *, char *, integer *, char *, char *, integer *,
+      integer *, integer *, doublecomplex *, integer *, integer *,
+      doublecomplex *, integer *, ftnlen, ftnlen, ftnlen);
+  extern void czgemm_(integer *, char *, char *, integer *, integer *, integer *,
+              doublecomplex *, doublecomplex *, integer *, doublecomplex *,
+              integer *, doublecomplex *, doublecomplex *, integer *);
+  char tranas[1], tranbs[1], transa[1], transb[1];
+  doublereal errmax;
+  extern logical lzeres_(char *, char *, integer *, integer *, doublecomplex *,
+                         doublecomplex *, integer *, ftnlen, ftnlen);
+
+  /* Fortran I/O blocks */
+  static cilist io___128 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___131 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___133 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___134 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___135 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___136 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___137 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests ZGEMM. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --bet;
+  --g;
+  --ct;
+  --cs;
+  --cc;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --bs;
+  --bb;
+  b_dim1 = *nmax;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+
+  nargs = 13;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.;
+
+  i__1 = *nidim;
+  for (im = 1; im <= i__1; ++im) {
+    m = idim[im];
+
+    i__2 = *nidim;
+    for (in = 1; in <= i__2; ++in) {
+      n = idim[in];
+      /*           Set LDC to 1 more than minimum value if room. */
+      ldc = m;
+      if (ldc < *nmax) {
+        ++ldc;
+      }
+      /*           Skip tests if not enough room. */
+      if (ldc > *nmax) {
+        goto L100;
+      }
+      lcc = ldc * n;
+      null = n <= 0 || m <= 0;
+
+      i__3 = *nidim;
+      for (ik = 1; ik <= i__3; ++ik) {
+        k = idim[ik];
+
+        for (ica = 1; ica <= 3; ++ica) {
+          *(unsigned char *)transa = *(unsigned char *)&ich[ica - 1];
+          trana = *(unsigned char *)transa == 'T' ||
+                  *(unsigned char *)transa == 'C';
+
+          if (trana) {
+            ma = k;
+            na = m;
+          } else {
+            ma = m;
+            na = k;
+          }
+          /*                 Set LDA to 1 more than minimum value if room. */
+          lda = ma;
+          if (lda < *nmax) {
+            ++lda;
+          }
+          /*                 Skip tests if not enough room. */
+          if (lda > *nmax) {
+            goto L80;
+          }
+          laa = lda * na;
+
+          /*                 Generate the matrix A. */
+
+          zmake_("ge", " ", " ", &ma, &na, &a[a_offset], nmax, &aa[1], &lda,
+                 &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+          for (icb = 1; icb <= 3; ++icb) {
+            *(unsigned char *)transb = *(unsigned char *)&ich[icb - 1];
+            tranb = *(unsigned char *)transb == 'T' ||
+                    *(unsigned char *)transb == 'C';
+
+            if (tranb) {
+              mb = n;
+              nb = k;
+            } else {
+              mb = k;
+              nb = n;
+            }
+            /*                    Set LDB to 1 more than minimum value if room.
+             */
+            ldb = mb;
+            if (ldb < *nmax) {
+              ++ldb;
+            }
+            /*                    Skip tests if not enough room. */
+            if (ldb > *nmax) {
+              goto L70;
+            }
+            lbb = ldb * nb;
+
+            /*                    Generate the matrix B. */
+
+            zmake_("ge", " ", " ", &mb, &nb, &b[b_offset], nmax, &bb[1], &ldb,
+                   &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+            i__4 = *nalf;
+            for (ia = 1; ia <= i__4; ++ia) {
+              i__5 = ia;
+              alpha.r = alf[i__5].r, alpha.i = alf[i__5].i;
+
+              i__5 = *nbet;
+              for (ib = 1; ib <= i__5; ++ib) {
+                i__6 = ib;
+                beta.r = bet[i__6].r, beta.i = bet[i__6].i;
+
+                /*                          Generate the matrix C. */
+
+                zmake_("ge", " ", " ", &m, &n, &c__[c_offset], nmax, &cc[1],
+                       &ldc, &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+                ++nc;
+
+                /*                          Save every datum before calling the
+                 */
+                /*                          subroutine. */
+
+                *(unsigned char *)tranas = *(unsigned char *)transa;
+                *(unsigned char *)tranbs = *(unsigned char *)transb;
+                ms = m;
+                ns = n;
+                ks = k;
+                als.r = alpha.r, als.i = alpha.i;
+                i__6 = laa;
+                for (i__ = 1; i__ <= i__6; ++i__) {
+                  i__7 = i__;
+                  i__8 = i__;
+                  as[i__7].r = aa[i__8].r, as[i__7].i = aa[i__8].i;
+                  /* L10: */
+                }
+                ldas = lda;
+                i__6 = lbb;
+                for (i__ = 1; i__ <= i__6; ++i__) {
+                  i__7 = i__;
+                  i__8 = i__;
+                  bs[i__7].r = bb[i__8].r, bs[i__7].i = bb[i__8].i;
+                  /* L20: */
+                }
+                ldbs = ldb;
+                bls.r = beta.r, bls.i = beta.i;
+                i__6 = lcc;
+                for (i__ = 1; i__ <= i__6; ++i__) {
+                  i__7 = i__;
+                  i__8 = i__;
+                  cs[i__7].r = cc[i__8].r, cs[i__7].i = cc[i__8].i;
+                  /* L30: */
+                }
+                ldcs = ldc;
+
+                /*                          Call the subroutine. */
+
+                if (*trace) {
+                  zprcn1_(ntra, &nc, sname, iorder, transa, transb, &m, &n, &k,
+                          &alpha, &lda, &ldb, &beta, &ldc, (ftnlen)12,
+                          (ftnlen)1, (ftnlen)1);
+                }
+                if (*rewi) {
+                  al__1.aerr = 0;
+                  al__1.aunit = *ntra;
+                  f_rew(&al__1);
+                }
+                czgemm_(iorder, transa, transb, &m, &n, &k, &alpha, &aa[1],
+                        &lda, &bb[1], &ldb, &beta, &cc[1], &ldc);
+
+                /*                          Check if error-exit was taken
+                 * incorrectly. */
+
+                if (!infoc_1.ok) {
+                  io___128.ciunit = *nout;
+                  s_wsfe(&io___128);
+                  e_wsfe();
+                  *fatal = TRUE_;
+                  goto L120;
+                }
+
+                /*                          See what data changed inside
+                 * subroutines. */
+
+                isame[0] = *(unsigned char *)transa == *(unsigned char *)tranas;
+                isame[1] = *(unsigned char *)transb == *(unsigned char *)tranbs;
+                isame[2] = ms == m;
+                isame[3] = ns == n;
+                isame[4] = ks == k;
+                isame[5] = als.r == alpha.r && als.i == alpha.i;
+                isame[6] = lze_(&as[1], &aa[1], &laa);
+                isame[7] = ldas == lda;
+                isame[8] = lze_(&bs[1], &bb[1], &lbb);
+                isame[9] = ldbs == ldb;
+                isame[10] = bls.r == beta.r && bls.i == beta.i;
+                if (null) {
+                  isame[11] = lze_(&cs[1], &cc[1], &lcc);
+                } else {
+                  isame[11] = lzeres_("ge", " ", &m, &n, &cs[1], &cc[1], &ldc,
+                                      (ftnlen)2, (ftnlen)1);
+                }
+                isame[12] = ldcs == ldc;
+
+                /*                          If data was incorrectly changed,
+                 * report */
+                /*                          and return. */
+
+                same = TRUE_;
+                i__6 = nargs;
+                for (i__ = 1; i__ <= i__6; ++i__) {
+                  same = same && isame[i__ - 1];
+                  if (!isame[i__ - 1]) {
+                    io___131.ciunit = *nout;
+                    s_wsfe(&io___131);
+                    do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  /* L40: */
+                }
+                if (!same) {
+                  *fatal = TRUE_;
+                  goto L120;
+                }
+
+                if (!null) {
+
+                  /*                             Check the result. */
+
+                  zmmch_(transa, transb, &m, &n, &k, &alpha, &a[a_offset], nmax,
+                         &b[b_offset], nmax, &beta, &c__[c_offset], nmax,
+                         &ct[1], &g[1], &cc[1], &ldc, eps, &err, fatal, nout,
+                         &c_true, (ftnlen)1, (ftnlen)1);
+                  errmax = max(errmax, err);
+                  /*                             If got really bad answer,
+                   * report and */
+                  /*                             return. */
+                  if (*fatal) {
+                    goto L120;
+                  }
+                }
+
+                /* L50: */
+              }
+
+              /* L60: */
+            }
+
+          L70:;
+          }
+
+        L80:;
+        }
+
+        /* L90: */
+      }
+
+    L100:;
+    }
+
+    /* L110: */
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___133.ciunit = *nout;
+      s_wsfe(&io___133);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___134.ciunit = *nout;
+      s_wsfe(&io___134);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___135.ciunit = *nout;
+      s_wsfe(&io___135);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___136.ciunit = *nout;
+      s_wsfe(&io___136);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+  }
+  goto L130;
+
+L120:
+  io___137.ciunit = *nout;
+  s_wsfe(&io___137);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  zprcn1_(nout, &nc, sname, iorder, transa, transb, &m, &n, &k, &alpha, &lda,
+          &ldb, &beta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+
+L130:
+  return 0;
+
+  /* L9995: */
+
+  /*     End of ZCHK1. */
+
+} /* zchk1_ */
+
+/* Subroutine */ int
+zprcn1_(integer *nout, integer *nc, char *sname, integer *iorder, char *transa,
+        char *transb, integer *m, integer *n, integer *k, doublecomplex *alpha,
+        integer *lda, integer *ldb, doublecomplex *beta, integer *ldc,
+        ftnlen sname_len, ftnlen transa_len, ftnlen transb_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+                           "a14,\002,\002,a14,\002,\002)";
+  static char fmt_9994[] =
+      "(10x,3(i3,\002,\002),\002 (\002,f4.1,\002,\002"
+      ",f4.1,\002) , A,\002,i3,\002, B,\002,i3,\002, (\002,f4.1,\002"
+      ",\002,f4.1,\002) , C,\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char crc[14], cta[14], ctb[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___141 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___142 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(cta, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(cta, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cta, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transb == 'N') {
+    s_copy(ctb, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transb == 'T') {
+    s_copy(ctb, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ctb, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___141.ciunit = *nout;
+  s_wsfe(&io___141);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cta, (ftnlen)14);
+  do_fio(&c__1, ctb, (ftnlen)14);
+  e_wsfe();
+  io___142.ciunit = *nout;
+  s_wsfe(&io___142);
+  do_fio(&c__1, (char *)&(*m), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*k), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*alpha), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*ldb), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*beta), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* zprcn1_ */
+
+/* Subroutine */ int
+zchk2_(char *sname, doublereal *eps, doublereal *thresh, integer *nout,
+       integer *ntra, logical *trace, logical *rewi, logical *fatal,
+       integer *nidim, integer *idim, integer *nalf, doublecomplex *alf,
+       integer *nbet, doublecomplex *bet, integer *nmax, doublecomplex *a,
+       doublecomplex *aa, doublecomplex *as, doublecomplex *b,
+       doublecomplex *bb, doublecomplex *bs, doublecomplex *c__,
+       doublecomplex *cc, doublecomplex *cs, doublecomplex *ct, doublereal *g,
+       integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ichs[2] = "LR";
+  static char ichu[2] = "UL";
+
+  /* Format strings */
+  static char fmt_9994[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
+      i__3, i__4, i__5, i__6, i__7;
+  alist al__1;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen), f_rew(alist *),
+      s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, m, n, ia, ib, na, nc, im, in, ms, ns, laa, lbb, lda, lcc, ldb,
+      ldc, ics;
+  doublecomplex als, bls;
+  integer icu;
+  doublereal err;
+  extern logical lze_(doublecomplex *, doublecomplex *, integer *);
+  doublecomplex beta;
+  integer ldas, ldbs, ldcs;
+  logical same;
+  char side[1];
+  logical conj, left, null;
+  char uplo[1];
+  doublecomplex alpha;
+  logical isame[13];
+  char sides[1];
+  extern /* Subroutine */ int zmake_(char *, char *, char *, integer *,
+                                     integer *, doublecomplex *, integer *,
+                                     doublecomplex *, integer *, logical *,
+                                     doublecomplex *, ftnlen, ftnlen, ftnlen);
+  integer nargs;
+  extern /* Subroutine */ int zmmch_(
+      char *, char *, integer *, integer *, integer *, doublecomplex *,
+      doublecomplex *, integer *, doublecomplex *, integer *, doublecomplex *,
+      doublecomplex *, integer *, doublecomplex *, doublereal *,
+      doublecomplex *, integer *, doublereal *, doublereal *, logical *,
+      integer *, logical *, ftnlen, ftnlen);
+  logical reset;
+  char uplos[1];
+  extern /* Subroutine */ int zprcn2_(
+      integer *, integer *, char *, integer *, char *, char *, integer *,
+      integer *, doublecomplex *, integer *, integer *, doublecomplex *,
+      integer *, ftnlen, ftnlen, ftnlen);
+  extern void czhemm_(integer *, char *, char *, integer *, integer *, doublecomplex *,
+                      doublecomplex *, integer *, doublecomplex *, integer *,
+                      doublecomplex *, doublecomplex *, integer *);
+  doublereal errmax;
+  extern logical lzeres_(char *, char *, integer *, integer *, doublecomplex *,
+                         doublecomplex *, integer *, ftnlen, ftnlen);
+  extern /* Subroutine */ void czsymm_(
+      integer *, char *, char *, integer *, integer *, doublecomplex *,
+      doublecomplex *, integer *, doublecomplex *, integer *, doublecomplex *,
+      doublecomplex *, integer *);
+
+  /* Fortran I/O blocks */
+  static cilist io___181 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___184 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___186 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___187 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___188 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___189 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___190 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests ZHEMM and ZSYMM. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --bet;
+  --g;
+  --ct;
+  --cs;
+  --cc;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --bs;
+  --bb;
+  b_dim1 = *nmax;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+  conj = s_cmp(sname + 7, "he", (ftnlen)2, (ftnlen)2) == 0;
+
+  nargs = 12;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.;
+
+  i__1 = *nidim;
+  for (im = 1; im <= i__1; ++im) {
+    m = idim[im];
+
+    i__2 = *nidim;
+    for (in = 1; in <= i__2; ++in) {
+      n = idim[in];
+      /*           Set LDC to 1 more than minimum value if room. */
+      ldc = m;
+      if (ldc < *nmax) {
+        ++ldc;
+      }
+      /*           Skip tests if not enough room. */
+      if (ldc > *nmax) {
+        goto L90;
+      }
+      lcc = ldc * n;
+      null = n <= 0 || m <= 0;
+      /*           Set LDB to 1 more than minimum value if room. */
+      ldb = m;
+      if (ldb < *nmax) {
+        ++ldb;
+      }
+      /*           Skip tests if not enough room. */
+      if (ldb > *nmax) {
+        goto L90;
+      }
+      lbb = ldb * n;
+
+      /*           Generate the matrix B. */
+
+      zmake_("ge", " ", " ", &m, &n, &b[b_offset], nmax, &bb[1], &ldb, &reset,
+             &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+      for (ics = 1; ics <= 2; ++ics) {
+        *(unsigned char *)side = *(unsigned char *)&ichs[ics - 1];
+        left = *(unsigned char *)side == 'L';
+
+        if (left) {
+          na = m;
+        } else {
+          na = n;
+        }
+        /*              Set LDA to 1 more than minimum value if room. */
+        lda = na;
+        if (lda < *nmax) {
+          ++lda;
+        }
+        /*              Skip tests if not enough room. */
+        if (lda > *nmax) {
+          goto L80;
+        }
+        laa = lda * na;
+
+        for (icu = 1; icu <= 2; ++icu) {
+          *(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+
+          /*                 Generate the hermitian or symmetric matrix A. */
+
+          zmake_(sname + 7, uplo, " ", &na, &na, &a[a_offset], nmax, &aa[1],
+                 &lda, &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+          i__3 = *nalf;
+          for (ia = 1; ia <= i__3; ++ia) {
+            i__4 = ia;
+            alpha.r = alf[i__4].r, alpha.i = alf[i__4].i;
+
+            i__4 = *nbet;
+            for (ib = 1; ib <= i__4; ++ib) {
+              i__5 = ib;
+              beta.r = bet[i__5].r, beta.i = bet[i__5].i;
+
+              /*                       Generate the matrix C. */
+
+              zmake_("ge", " ", " ", &m, &n, &c__[c_offset], nmax, &cc[1], &ldc,
+                     &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+              ++nc;
+
+              /*                       Save every datum before calling the */
+              /*                       subroutine. */
+
+              *(unsigned char *)sides = *(unsigned char *)side;
+              *(unsigned char *)uplos = *(unsigned char *)uplo;
+              ms = m;
+              ns = n;
+              als.r = alpha.r, als.i = alpha.i;
+              i__5 = laa;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                i__6 = i__;
+                i__7 = i__;
+                as[i__6].r = aa[i__7].r, as[i__6].i = aa[i__7].i;
+                /* L10: */
+              }
+              ldas = lda;
+              i__5 = lbb;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                i__6 = i__;
+                i__7 = i__;
+                bs[i__6].r = bb[i__7].r, bs[i__6].i = bb[i__7].i;
+                /* L20: */
+              }
+              ldbs = ldb;
+              bls.r = beta.r, bls.i = beta.i;
+              i__5 = lcc;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                i__6 = i__;
+                i__7 = i__;
+                cs[i__6].r = cc[i__7].r, cs[i__6].i = cc[i__7].i;
+                /* L30: */
+              }
+              ldcs = ldc;
+
+              /*                       Call the subroutine. */
+
+              if (*trace) {
+                zprcn2_(ntra, &nc, sname, iorder, side, uplo, &m, &n, &alpha,
+                        &lda, &ldb, &beta, &ldc, (ftnlen)12, (ftnlen)1,
+                        (ftnlen)1);
+              }
+              if (*rewi) {
+                al__1.aerr = 0;
+                al__1.aunit = *ntra;
+                f_rew(&al__1);
+              }
+              if (conj) {
+                czhemm_(iorder, side, uplo, &m, &n, &alpha, &aa[1], &lda,
+                        &bb[1], &ldb, &beta, &cc[1], &ldc);
+              } else {
+                czsymm_(iorder, side, uplo, &m, &n, &alpha, &aa[1], &lda,
+                        &bb[1], &ldb, &beta, &cc[1], &ldc);
+              }
+
+              /*                       Check if error-exit was taken
+               * incorrectly. */
+
+              if (!infoc_1.ok) {
+                io___181.ciunit = *nout;
+                s_wsfe(&io___181);
+                e_wsfe();
+                *fatal = TRUE_;
+                goto L110;
+              }
+
+              /*                       See what data changed inside subroutines.
+               */
+
+              isame[0] = *(unsigned char *)sides == *(unsigned char *)side;
+              isame[1] = *(unsigned char *)uplos == *(unsigned char *)uplo;
+              isame[2] = ms == m;
+              isame[3] = ns == n;
+              isame[4] = als.r == alpha.r && als.i == alpha.i;
+              isame[5] = lze_(&as[1], &aa[1], &laa);
+              isame[6] = ldas == lda;
+              isame[7] = lze_(&bs[1], &bb[1], &lbb);
+              isame[8] = ldbs == ldb;
+              isame[9] = bls.r == beta.r && bls.i == beta.i;
+              if (null) {
+                isame[10] = lze_(&cs[1], &cc[1], &lcc);
+              } else {
+                isame[10] = lzeres_("ge", " ", &m, &n, &cs[1], &cc[1], &ldc,
+                                    (ftnlen)2, (ftnlen)1);
+              }
+              isame[11] = ldcs == ldc;
+
+              /*                       If data was incorrectly changed, report
+               * and */
+              /*                       return. */
+
+              same = TRUE_;
+              i__5 = nargs;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                same = same && isame[i__ - 1];
+                if (!isame[i__ - 1]) {
+                  io___184.ciunit = *nout;
+                  s_wsfe(&io___184);
+                  do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                  e_wsfe();
+                }
+                /* L40: */
+              }
+              if (!same) {
+                *fatal = TRUE_;
+                goto L110;
+              }
+
+              if (!null) {
+
+                /*                          Check the result. */
+
+                if (left) {
+                  zmmch_("N", "N", &m, &n, &m, &alpha, &a[a_offset], nmax,
+                         &b[b_offset], nmax, &beta, &c__[c_offset], nmax,
+                         &ct[1], &g[1], &cc[1], &ldc, eps, &err, fatal, nout,
+                         &c_true, (ftnlen)1, (ftnlen)1);
+                } else {
+                  zmmch_("N", "N", &m, &n, &n, &alpha, &b[b_offset], nmax,
+                         &a[a_offset], nmax, &beta, &c__[c_offset], nmax,
+                         &ct[1], &g[1], &cc[1], &ldc, eps, &err, fatal, nout,
+                         &c_true, (ftnlen)1, (ftnlen)1);
+                }
+                errmax = max(errmax, err);
+                /*                          If got really bad answer, report and
+                 */
+                /*                          return. */
+                if (*fatal) {
+                  goto L110;
+                }
+              }
+
+              /* L50: */
+            }
+
+            /* L60: */
+          }
+
+          /* L70: */
+        }
+
+      L80:;
+      }
+
+    L90:;
+    }
+
+    /* L100: */
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___186.ciunit = *nout;
+      s_wsfe(&io___186);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___187.ciunit = *nout;
+      s_wsfe(&io___187);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___188.ciunit = *nout;
+      s_wsfe(&io___188);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___189.ciunit = *nout;
+      s_wsfe(&io___189);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+  }
+  goto L120;
+
+L110:
+  io___190.ciunit = *nout;
+  s_wsfe(&io___190);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  zprcn2_(nout, &nc, sname, iorder, side, uplo, &m, &n, &alpha, &lda, &ldb,
+          &beta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+
+L120:
+  return 0;
+
+  /* L9995: */
+
+  /*     End of ZCHK2. */
+
+} /* zchk2_ */
+
+/* Subroutine */ int zprcn2_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *side, char *uplo,
+                             integer *m, integer *n, doublecomplex *alpha,
+                             integer *lda, integer *ldb, doublecomplex *beta,
+                             integer *ldc, ftnlen sname_len, ftnlen side_len,
+                             ftnlen uplo_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+                           "a14,\002,\002,a14,\002,\002)";
+  static char fmt_9994[] =
+      "(10x,2(i3,\002,\002),\002 (\002,f4.1,\002,\002"
+      ",f4.1,\002), A,\002,i3,\002, B,\002,i3,\002, (\002,f4.1,\002,"
+      "\002,f4.1,\002), \002,\002C,\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char cs[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___194 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___195 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)side == 'L') {
+    s_copy(cs, "     CblasLeft", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cs, "    CblasRight", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___194.ciunit = *nout;
+  s_wsfe(&io___194);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cs, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  e_wsfe();
+  io___195.ciunit = *nout;
+  s_wsfe(&io___195);
+  do_fio(&c__1, (char *)&(*m), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*alpha), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*ldb), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*beta), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* zprcn2_ */
+
+/* Subroutine */ int
+zchk3_(char *sname, doublereal *eps, doublereal *thresh, integer *nout,
+       integer *ntra, logical *trace, logical *rewi, logical *fatal,
+       integer *nidim, integer *idim, integer *nalf, doublecomplex *alf,
+       integer *nmax, doublecomplex *a, doublecomplex *aa, doublecomplex *as,
+       doublecomplex *b, doublecomplex *bb, doublecomplex *bs,
+       doublecomplex *ct, doublereal *g, doublecomplex *c__, integer *iorder,
+       ftnlen sname_len) {
+  /* Initialized data */
+
+  static char ichu[2] = "UL";
+  static char icht[3] = "NTC";
+  static char ichd[2] = "UN";
+  static char ichs[2] = "LR";
+
+  /* Format strings */
+  static char fmt_9994[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
+      i__3, i__4, i__5, i__6, i__7;
+  doublecomplex z__1;
+  alist al__1;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen), f_rew(alist *),
+      s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, j, m, n, ia, na, nc, im, in, ms, ns, laa, icd, lbb, lda, ldb,
+      ics;
+  doublecomplex als;
+  integer ict, icu;
+  doublereal err;
+  extern logical lze_(doublecomplex *, doublecomplex *, integer *);
+  char diag[1];
+  integer ldas, ldbs;
+  logical same;
+  char side[1];
+  logical left, null;
+  char uplo[1];
+  doublecomplex alpha;
+  char diags[1];
+  logical isame[13];
+  char sides[1];
+  extern /* Subroutine */ int zmake_(char *, char *, char *, integer *,
+                                     integer *, doublecomplex *, integer *,
+                                     doublecomplex *, integer *, logical *,
+                                     doublecomplex *, ftnlen, ftnlen, ftnlen);
+  integer nargs;
+  extern /* Subroutine */ int zmmch_(
+      char *, char *, integer *, integer *, integer *, doublecomplex *,
+      doublecomplex *, integer *, doublecomplex *, integer *, doublecomplex *,
+      doublecomplex *, integer *, doublecomplex *, doublereal *,
+      doublecomplex *, integer *, doublereal *, doublereal *, logical *,
+      integer *, logical *, ftnlen, ftnlen);
+  logical reset;
+  char uplos[1];
+  extern /* Subroutine */ int zprcn3_(
+      integer *, integer *, char *, integer *, char *, char *, char *, char *,
+      integer *, integer *, doublecomplex *, integer *, integer *, ftnlen,
+      ftnlen, ftnlen, ftnlen, ftnlen);
+  char tranas[1], transa[1];
+  doublereal errmax;
+  extern logical lzeres_(char *, char *, integer *, integer *, doublecomplex *,
+                         doublecomplex *, integer *, ftnlen, ftnlen);
+  extern /* Subroutine */ void cztrmm_(
+      integer *, char *, char *, char *, char *, integer *, integer *,
+      doublecomplex *, doublecomplex *, integer *, doublecomplex *, integer *),
+      cztrsm_(integer *, char *, char *, char *, char *, integer *, integer *,
+              doublecomplex *, doublecomplex *, integer *, doublecomplex *,
+              integer *);
+
+  /* Fortran I/O blocks */
+  static cilist io___236 = {0, 0, 0, fmt_9994, 0};
+  static cilist io___239 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___241 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___242 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___243 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___244 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___245 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests ZTRMM and ZTRSM. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --g;
+  --ct;
+  --bs;
+  --bb;
+  b_dim1 = *nmax;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+
+  nargs = 11;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.;
+  /*     Set up zero matrix for ZMMCH. */
+  i__1 = *nmax;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = *nmax;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      i__3 = i__ + j * c_dim1;
+      c__[i__3].r = 0., c__[i__3].i = 0.;
+      /* L10: */
+    }
+    /* L20: */
+  }
+
+  i__1 = *nidim;
+  for (im = 1; im <= i__1; ++im) {
+    m = idim[im];
+
+    i__2 = *nidim;
+    for (in = 1; in <= i__2; ++in) {
+      n = idim[in];
+      /*           Set LDB to 1 more than minimum value if room. */
+      ldb = m;
+      if (ldb < *nmax) {
+        ++ldb;
+      }
+      /*           Skip tests if not enough room. */
+      if (ldb > *nmax) {
+        goto L130;
+      }
+      lbb = ldb * n;
+      null = m <= 0 || n <= 0;
+
+      for (ics = 1; ics <= 2; ++ics) {
+        *(unsigned char *)side = *(unsigned char *)&ichs[ics - 1];
+        left = *(unsigned char *)side == 'L';
+        if (left) {
+          na = m;
+        } else {
+          na = n;
+        }
+        /*              Set LDA to 1 more than minimum value if room. */
+        lda = na;
+        if (lda < *nmax) {
+          ++lda;
+        }
+        /*              Skip tests if not enough room. */
+        if (lda > *nmax) {
+          goto L130;
+        }
+        laa = lda * na;
+
+        for (icu = 1; icu <= 2; ++icu) {
+          *(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+
+          for (ict = 1; ict <= 3; ++ict) {
+            *(unsigned char *)transa = *(unsigned char *)&icht[ict - 1];
+
+            for (icd = 1; icd <= 2; ++icd) {
+              *(unsigned char *)diag = *(unsigned char *)&ichd[icd - 1];
+
+              i__3 = *nalf;
+              for (ia = 1; ia <= i__3; ++ia) {
+                i__4 = ia;
+                alpha.r = alf[i__4].r, alpha.i = alf[i__4].i;
+
+                /*                          Generate the matrix A. */
+
+                zmake_("tr", uplo, diag, &na, &na, &a[a_offset], nmax, &aa[1],
+                       &lda, &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+                /*                          Generate the matrix B. */
+
+                zmake_("ge", " ", " ", &m, &n, &b[b_offset], nmax, &bb[1], &ldb,
+                       &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+                ++nc;
+
+                /*                          Save every datum before calling the
+                 */
+                /*                          subroutine. */
+
+                *(unsigned char *)sides = *(unsigned char *)side;
+                *(unsigned char *)uplos = *(unsigned char *)uplo;
+                *(unsigned char *)tranas = *(unsigned char *)transa;
+                *(unsigned char *)diags = *(unsigned char *)diag;
+                ms = m;
+                ns = n;
+                als.r = alpha.r, als.i = alpha.i;
+                i__4 = laa;
+                for (i__ = 1; i__ <= i__4; ++i__) {
+                  i__5 = i__;
+                  i__6 = i__;
+                  as[i__5].r = aa[i__6].r, as[i__5].i = aa[i__6].i;
+                  /* L30: */
+                }
+                ldas = lda;
+                i__4 = lbb;
+                for (i__ = 1; i__ <= i__4; ++i__) {
+                  i__5 = i__;
+                  i__6 = i__;
+                  bs[i__5].r = bb[i__6].r, bs[i__5].i = bb[i__6].i;
+                  /* L40: */
+                }
+                ldbs = ldb;
+
+                /*                          Call the subroutine. */
+
+                if (s_cmp(sname + 9, "mm", (ftnlen)2, (ftnlen)2) == 0) {
+                  if (*trace) {
+                    zprcn3_(ntra, &nc, sname, iorder, side, uplo, transa, diag,
+                            &m, &n, &alpha, &lda, &ldb, (ftnlen)12, (ftnlen)1,
+                            (ftnlen)1, (ftnlen)1, (ftnlen)1);
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cztrmm_(iorder, side, uplo, transa, diag, &m, &n, &alpha,
+                          &aa[1], &lda, &bb[1], &ldb);
+                } else if (s_cmp(sname + 9, "sm", (ftnlen)2, (ftnlen)2) == 0) {
+                  if (*trace) {
+                    zprcn3_(ntra, &nc, sname, iorder, side, uplo, transa, diag,
+                            &m, &n, &alpha, &lda, &ldb, (ftnlen)12, (ftnlen)1,
+                            (ftnlen)1, (ftnlen)1, (ftnlen)1);
+                  }
+                  if (*rewi) {
+                    al__1.aerr = 0;
+                    al__1.aunit = *ntra;
+                    f_rew(&al__1);
+                  }
+                  cztrsm_(iorder, side, uplo, transa, diag, &m, &n, &alpha,
+                          &aa[1], &lda, &bb[1], &ldb);
+                }
+
+                /*                          Check if error-exit was taken
+                 * incorrectly. */
+
+                if (!infoc_1.ok) {
+                  io___236.ciunit = *nout;
+                  s_wsfe(&io___236);
+                  e_wsfe();
+                  *fatal = TRUE_;
+                  goto L150;
+                }
+
+                /*                          See what data changed inside
+                 * subroutines. */
+
+                isame[0] = *(unsigned char *)sides == *(unsigned char *)side;
+                isame[1] = *(unsigned char *)uplos == *(unsigned char *)uplo;
+                isame[2] = *(unsigned char *)tranas == *(unsigned char *)transa;
+                isame[3] = *(unsigned char *)diags == *(unsigned char *)diag;
+                isame[4] = ms == m;
+                isame[5] = ns == n;
+                isame[6] = als.r == alpha.r && als.i == alpha.i;
+                isame[7] = lze_(&as[1], &aa[1], &laa);
+                isame[8] = ldas == lda;
+                if (null) {
+                  isame[9] = lze_(&bs[1], &bb[1], &lbb);
+                } else {
+                  isame[9] = lzeres_("ge", " ", &m, &n, &bs[1], &bb[1], &ldb,
+                                     (ftnlen)2, (ftnlen)1);
+                }
+                isame[10] = ldbs == ldb;
+
+                /*                          If data was incorrectly changed,
+                 * report and */
+                /*                          return. */
+
+                same = TRUE_;
+                i__4 = nargs;
+                for (i__ = 1; i__ <= i__4; ++i__) {
+                  same = same && isame[i__ - 1];
+                  if (!isame[i__ - 1]) {
+                    io___239.ciunit = *nout;
+                    s_wsfe(&io___239);
+                    do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                    e_wsfe();
+                  }
+                  /* L50: */
+                }
+                if (!same) {
+                  *fatal = TRUE_;
+                  goto L150;
+                }
+
+                if (!null) {
+                  if (s_cmp(sname + 9, "mm", (ftnlen)2, (ftnlen)2) == 0) {
+
+                    /*                                Check the result. */
+
+                    if (left) {
+                      zmmch_(transa, "N", &m, &n, &m, &alpha, &a[a_offset],
+                             nmax, &b[b_offset], nmax, &c_b1, &c__[c_offset],
+                             nmax, &ct[1], &g[1], &bb[1], &ldb, eps, &err,
+                             fatal, nout, &c_true, (ftnlen)1, (ftnlen)1);
+                    } else {
+                      zmmch_("N", transa, &m, &n, &n, &alpha, &b[b_offset],
+                             nmax, &a[a_offset], nmax, &c_b1, &c__[c_offset],
+                             nmax, &ct[1], &g[1], &bb[1], &ldb, eps, &err,
+                             fatal, nout, &c_true, (ftnlen)1, (ftnlen)1);
+                    }
+                  } else if (s_cmp(sname + 9, "sm", (ftnlen)2, (ftnlen)2) ==
+                             0) {
+
+                    /*                                Compute approximation to
+                     * original */
+                    /*                                matrix. */
+
+                    i__4 = n;
+                    for (j = 1; j <= i__4; ++j) {
+                      i__5 = m;
+                      for (i__ = 1; i__ <= i__5; ++i__) {
+                        i__6 = i__ + j * c_dim1;
+                        i__7 = i__ + (j - 1) * ldb;
+                        c__[i__6].r = bb[i__7].r, c__[i__6].i = bb[i__7].i;
+                        i__6 = i__ + (j - 1) * ldb;
+                        i__7 = i__ + j * b_dim1;
+                        z__1.r = alpha.r * b[i__7].r - alpha.i * b[i__7].i,
+                        z__1.i = alpha.r * b[i__7].i + alpha.i * b[i__7].r;
+                        bb[i__6].r = z__1.r, bb[i__6].i = z__1.i;
+                        /* L60: */
+                      }
+                      /* L70: */
+                    }
+
+                    if (left) {
+                      zmmch_(transa, "N", &m, &n, &m, &c_b2, &a[a_offset], nmax,
+                             &c__[c_offset], nmax, &c_b1, &b[b_offset], nmax,
+                             &ct[1], &g[1], &bb[1], &ldb, eps, &err, fatal,
+                             nout, &c_false, (ftnlen)1, (ftnlen)1);
+                    } else {
+                      zmmch_("N", transa, &m, &n, &n, &c_b2, &c__[c_offset],
+                             nmax, &a[a_offset], nmax, &c_b1, &b[b_offset],
+                             nmax, &ct[1], &g[1], &bb[1], &ldb, eps, &err,
+                             fatal, nout, &c_false, (ftnlen)1, (ftnlen)1);
+                    }
+                  }
+                  errmax = max(errmax, err);
+                  /*                             If got really bad answer,
+                   * report and */
+                  /*                             return. */
+                  if (*fatal) {
+                    goto L150;
+                  }
+                }
+
+                /* L80: */
+              }
+
+              /* L90: */
+            }
+
+            /* L100: */
+          }
+
+          /* L110: */
+        }
+
+        /* L120: */
+      }
+
+    L130:;
+    }
+
+    /* L140: */
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___241.ciunit = *nout;
+      s_wsfe(&io___241);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___242.ciunit = *nout;
+      s_wsfe(&io___242);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___243.ciunit = *nout;
+      s_wsfe(&io___243);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___244.ciunit = *nout;
+      s_wsfe(&io___244);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+  }
+  goto L160;
+
+L150:
+  io___245.ciunit = *nout;
+  s_wsfe(&io___245);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  zprcn3_(ntra, &nc, sname, iorder, side, uplo, transa, diag, &m, &n, &alpha,
+          &lda, &ldb, (ftnlen)12, (ftnlen)1, (ftnlen)1, (ftnlen)1, (ftnlen)1);
+
+L160:
+  return 0;
+
+  /* L9995: */
+
+  /*     End of ZCHK3. */
+
+} /* zchk3_ */
+
+/* Subroutine */ int zprcn3_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *side, char *uplo,
+                             char *transa, char *diag, integer *m, integer *n,
+                             doublecomplex *alpha, integer *lda, integer *ldb,
+                             ftnlen sname_len, ftnlen side_len, ftnlen uplo_len,
+                             ftnlen transa_len, ftnlen diag_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,a14,\002,\002,"
+                           "a14,\002,\002,a14,\002,\002)";
+  static char fmt_9994[] =
+      "(10x,2(a14,\002,\002),2(i3,\002,\002),\002 "
+      "(\002,f4.1,\002,\002,f4.1,\002), A,\002,i3,\002, B,\002,i3,\002)."
+      "\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char ca[14], cd[14], cs[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___251 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___252 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)side == 'L') {
+    s_copy(cs, "     CblasLeft", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cs, "    CblasRight", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(ca, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(ca, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ca, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)diag == 'N') {
+    s_copy(cd, "  CblasNonUnit", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cd, "     CblasUnit", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___251.ciunit = *nout;
+  s_wsfe(&io___251);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cs, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  e_wsfe();
+  io___252.ciunit = *nout;
+  s_wsfe(&io___252);
+  do_fio(&c__1, ca, (ftnlen)14);
+  do_fio(&c__1, cd, (ftnlen)14);
+  do_fio(&c__1, (char *)&(*m), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*alpha), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*ldb), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* zprcn3_ */
+
+/* Subroutine */ int
+zchk4_(char *sname, doublereal *eps, doublereal *thresh, integer *nout,
+       integer *ntra, logical *trace, logical *rewi, logical *fatal,
+       integer *nidim, integer *idim, integer *nalf, doublecomplex *alf,
+       integer *nbet, doublecomplex *bet, integer *nmax, doublecomplex *a,
+       doublecomplex *aa, doublecomplex *as, doublecomplex *b,
+       doublecomplex *bb, doublecomplex *bs, doublecomplex *c__,
+       doublecomplex *cc, doublecomplex *cs, doublecomplex *ct, doublereal *g,
+       integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char icht[2] = "NC";
+  static char ichu[2] = "UL";
+
+  /* Format strings */
+  static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+                           " \002,i3)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
+      i__3, i__4, i__5, i__6, i__7;
+  doublecomplex z__1;
+  alist al__1;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen), f_rew(alist *),
+      s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, j, k, n, ia, ib, jc, ma, na, nc, ik, in, jj, lj, ks, ns, laa,
+      lda, lcc, ldc;
+  doublecomplex als;
+  integer ict, icu;
+  doublereal err;
+  extern logical lze_(doublecomplex *, doublecomplex *, integer *);
+  doublecomplex beta;
+  integer ldas, ldcs;
+  logical same, conj;
+  doublecomplex bets;
+  doublereal rals;
+  logical tran, null;
+  char uplo[1];
+  doublecomplex alpha;
+  doublereal rbeta;
+  logical isame[13];
+  extern /* Subroutine */ int zmake_(char *, char *, char *, integer *,
+                                     integer *, doublecomplex *, integer *,
+                                     doublecomplex *, integer *, logical *,
+                                     doublecomplex *, ftnlen, ftnlen, ftnlen);
+  integer nargs;
+  extern /* Subroutine */ int zmmch_(
+      char *, char *, integer *, integer *, integer *, doublecomplex *,
+      doublecomplex *, integer *, doublecomplex *, integer *, doublecomplex *,
+      doublecomplex *, integer *, doublecomplex *, doublereal *,
+      doublecomplex *, integer *, doublereal *, doublereal *, logical *,
+      integer *, logical *, ftnlen, ftnlen);
+  doublereal rbets;
+  logical reset;
+  char trans[1];
+  logical upper;
+  char uplos[1];
+  extern /* Subroutine */ int zprcn4_(
+      integer *, integer *, char *, integer *, char *, char *, integer *,
+      integer *, doublecomplex *, integer *, doublecomplex *, integer *, ftnlen,
+      ftnlen, ftnlen),
+      zprcn6_(integer *, integer *, char *, integer *, char *, char *,
+              integer *, integer *, doublereal *, integer *, doublereal *,
+              integer *, ftnlen, ftnlen, ftnlen);
+  doublereal ralpha;
+  extern /* Subroutine */ void czherk_(integer *, char *, char *, integer *,
+                                       integer *, doublereal *, doublecomplex *,
+                                       integer *, doublereal *, doublecomplex *,
+                                       integer *);
+  doublereal errmax;
+  extern logical lzeres_(char *, char *, integer *, integer *, doublecomplex *,
+                         doublecomplex *, integer *, ftnlen, ftnlen);
+  char transs[1], transt[1];
+  extern /* Subroutine */ void czsyrk_(
+      integer *, char *, char *, integer *, integer *, doublecomplex *,
+      doublecomplex *, integer *, doublecomplex *, doublecomplex *, integer *);
+
+  /* Fortran I/O blocks */
+  static cilist io___294 = {0, 0, 0, fmt_9992, 0};
+  static cilist io___297 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___304 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___305 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___306 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___307 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___308 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___309 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests ZHERK and ZSYRK. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --bet;
+  --g;
+  --ct;
+  --cs;
+  --cc;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --bs;
+  --bb;
+  b_dim1 = *nmax;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  --as;
+  --aa;
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+  conj = s_cmp(sname + 7, "he", (ftnlen)2, (ftnlen)2) == 0;
+
+  nargs = 10;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.;
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+    /*        Set LDC to 1 more than minimum value if room. */
+    ldc = n;
+    if (ldc < *nmax) {
+      ++ldc;
+    }
+    /*        Skip tests if not enough room. */
+    if (ldc > *nmax) {
+      goto L100;
+    }
+    lcc = ldc * n;
+
+    i__2 = *nidim;
+    for (ik = 1; ik <= i__2; ++ik) {
+      k = idim[ik];
+
+      for (ict = 1; ict <= 2; ++ict) {
+        *(unsigned char *)trans = *(unsigned char *)&icht[ict - 1];
+        tran = *(unsigned char *)trans == 'C';
+        if (tran && !conj) {
+          *(unsigned char *)trans = 'T';
+        }
+        if (tran) {
+          ma = k;
+          na = n;
+        } else {
+          ma = n;
+          na = k;
+        }
+        /*              Set LDA to 1 more than minimum value if room. */
+        lda = ma;
+        if (lda < *nmax) {
+          ++lda;
+        }
+        /*              Skip tests if not enough room. */
+        if (lda > *nmax) {
+          goto L80;
+        }
+        laa = lda * na;
+
+        /*              Generate the matrix A. */
+
+        zmake_("ge", " ", " ", &ma, &na, &a[a_offset], nmax, &aa[1], &lda,
+               &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+        for (icu = 1; icu <= 2; ++icu) {
+          *(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+          upper = *(unsigned char *)uplo == 'U';
+
+          i__3 = *nalf;
+          for (ia = 1; ia <= i__3; ++ia) {
+            i__4 = ia;
+            alpha.r = alf[i__4].r, alpha.i = alf[i__4].i;
+            if (conj) {
+              ralpha = alpha.r;
+              z__1.r = ralpha, z__1.i = 0.;
+              alpha.r = z__1.r, alpha.i = z__1.i;
+            }
+
+            i__4 = *nbet;
+            for (ib = 1; ib <= i__4; ++ib) {
+              i__5 = ib;
+              beta.r = bet[i__5].r, beta.i = bet[i__5].i;
+              if (conj) {
+                rbeta = beta.r;
+                z__1.r = rbeta, z__1.i = 0.;
+                beta.r = z__1.r, beta.i = z__1.i;
+              }
+              null = n <= 0;
+              if (conj) {
+                null = null || (k <= 0 || ralpha == 0.) && rbeta == 1.;
+              }
+
+              /*                       Generate the matrix C. */
+
+              zmake_(sname + 7, uplo, " ", &n, &n, &c__[c_offset], nmax, &cc[1],
+                     &ldc, &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+              ++nc;
+
+              /*                       Save every datum before calling the
+               * subroutine. */
+
+              *(unsigned char *)uplos = *(unsigned char *)uplo;
+              *(unsigned char *)transs = *(unsigned char *)trans;
+              ns = n;
+              ks = k;
+              if (conj) {
+                rals = ralpha;
+              } else {
+                als.r = alpha.r, als.i = alpha.i;
+              }
+              i__5 = laa;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                i__6 = i__;
+                i__7 = i__;
+                as[i__6].r = aa[i__7].r, as[i__6].i = aa[i__7].i;
+                /* L10: */
+              }
+              ldas = lda;
+              if (conj) {
+                rbets = rbeta;
+              } else {
+                bets.r = beta.r, bets.i = beta.i;
+              }
+              i__5 = lcc;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                i__6 = i__;
+                i__7 = i__;
+                cs[i__6].r = cc[i__7].r, cs[i__6].i = cc[i__7].i;
+                /* L20: */
+              }
+              ldcs = ldc;
+
+              /*                       Call the subroutine. */
+
+              if (conj) {
+                if (*trace) {
+                  zprcn6_(ntra, &nc, sname, iorder, uplo, trans, &n, &k,
+                          &ralpha, &lda, &rbeta, &ldc, (ftnlen)12, (ftnlen)1,
+                          (ftnlen)1);
+                }
+                if (*rewi) {
+                  al__1.aerr = 0;
+                  al__1.aunit = *ntra;
+                  f_rew(&al__1);
+                }
+                czherk_(iorder, uplo, trans, &n, &k, &ralpha, &aa[1], &lda,
+                        &rbeta, &cc[1], &ldc);
+              } else {
+                if (*trace) {
+                  zprcn4_(ntra, &nc, sname, iorder, uplo, trans, &n, &k, &alpha,
+                          &lda, &beta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+                }
+                if (*rewi) {
+                  al__1.aerr = 0;
+                  al__1.aunit = *ntra;
+                  f_rew(&al__1);
+                }
+                czsyrk_(iorder, uplo, trans, &n, &k, &alpha, &aa[1], &lda,
+                        &beta, &cc[1], &ldc);
+              }
+
+              /*                       Check if error-exit was taken
+               * incorrectly. */
+
+              if (!infoc_1.ok) {
+                io___294.ciunit = *nout;
+                s_wsfe(&io___294);
+                e_wsfe();
+                *fatal = TRUE_;
+                goto L120;
+              }
+
+              /*                       See what data changed inside subroutines.
+               */
+
+              isame[0] = *(unsigned char *)uplos == *(unsigned char *)uplo;
+              isame[1] = *(unsigned char *)transs == *(unsigned char *)trans;
+              isame[2] = ns == n;
+              isame[3] = ks == k;
+              if (conj) {
+                isame[4] = rals == ralpha;
+              } else {
+                isame[4] = als.r == alpha.r && als.i == alpha.i;
+              }
+              isame[5] = lze_(&as[1], &aa[1], &laa);
+              isame[6] = ldas == lda;
+              if (conj) {
+                isame[7] = rbets == rbeta;
+              } else {
+                isame[7] = bets.r == beta.r && bets.i == beta.i;
+              }
+              if (null) {
+                isame[8] = lze_(&cs[1], &cc[1], &lcc);
+              } else {
+                isame[8] = lzeres_(sname + 7, uplo, &n, &n, &cs[1], &cc[1],
+                                   &ldc, (ftnlen)2, (ftnlen)1);
+              }
+              isame[9] = ldcs == ldc;
+
+              /*                       If data was incorrectly changed, report
+               * and */
+              /*                       return. */
+
+              same = TRUE_;
+              i__5 = nargs;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                same = same && isame[i__ - 1];
+                if (!isame[i__ - 1]) {
+                  io___297.ciunit = *nout;
+                  s_wsfe(&io___297);
+                  do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                  e_wsfe();
+                }
+                /* L30: */
+              }
+              if (!same) {
+                *fatal = TRUE_;
+                goto L120;
+              }
+
+              if (!null) {
+
+                /*                          Check the result column by column.
+                 */
+
+                if (conj) {
+                  *(unsigned char *)transt = 'C';
+                } else {
+                  *(unsigned char *)transt = 'T';
+                }
+                jc = 1;
+                i__5 = n;
+                for (j = 1; j <= i__5; ++j) {
+                  if (upper) {
+                    jj = 1;
+                    lj = j;
+                  } else {
+                    jj = j;
+                    lj = n - j + 1;
+                  }
+                  if (tran) {
+                    zmmch_(transt, "N", &lj, &c__1, &k, &alpha,
+                           &a[jj * a_dim1 + 1], nmax, &a[j * a_dim1 + 1], nmax,
+                           &beta, &c__[jj + j * c_dim1], nmax, &ct[1], &g[1],
+                           &cc[jc], &ldc, eps, &err, fatal, nout, &c_true,
+                           (ftnlen)1, (ftnlen)1);
+                  } else {
+                    zmmch_("N", transt, &lj, &c__1, &k, &alpha, &a[jj + a_dim1],
+                           nmax, &a[j + a_dim1], nmax, &beta,
+                           &c__[jj + j * c_dim1], nmax, &ct[1], &g[1], &cc[jc],
+                           &ldc, eps, &err, fatal, nout, &c_true, (ftnlen)1,
+                           (ftnlen)1);
+                  }
+                  if (upper) {
+                    jc += ldc;
+                  } else {
+                    jc = jc + ldc + 1;
+                  }
+                  errmax = max(errmax, err);
+                  /*                             If got really bad answer,
+                   * report and */
+                  /*                             return. */
+                  if (*fatal) {
+                    goto L110;
+                  }
+                  /* L40: */
+                }
+              }
+
+              /* L50: */
+            }
+
+            /* L60: */
+          }
+
+          /* L70: */
+        }
+
+      L80:;
+      }
+
+      /* L90: */
+    }
+
+  L100:;
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___304.ciunit = *nout;
+      s_wsfe(&io___304);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___305.ciunit = *nout;
+      s_wsfe(&io___305);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___306.ciunit = *nout;
+      s_wsfe(&io___306);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___307.ciunit = *nout;
+      s_wsfe(&io___307);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+  }
+  goto L130;
+
+L110:
+  if (n > 1) {
+    io___308.ciunit = *nout;
+    s_wsfe(&io___308);
+    do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L120:
+  io___309.ciunit = *nout;
+  s_wsfe(&io___309);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  if (conj) {
+    zprcn6_(nout, &nc, sname, iorder, uplo, trans, &n, &k, &ralpha, &lda,
+            &rbeta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+  } else {
+    zprcn4_(nout, &nc, sname, iorder, uplo, trans, &n, &k, &alpha, &lda, &beta,
+            &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+  }
+
+L130:
+  return 0;
+
+  /* L9994: */
+  /* L9993: */
+
+  /*     End of CCHK4. */
+
+} /* zchk4_ */
+
+/* Subroutine */ int zprcn4_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *uplo, char *transa,
+                             integer *n, integer *k, doublecomplex *alpha,
+                             integer *lda, doublecomplex *beta, integer *ldc,
+                             ftnlen sname_len, ftnlen uplo_len,
+                             ftnlen transa_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+                           "\002))";
+  static char fmt_9994[] =
+      "(10x,2(i3,\002,\002),\002 (\002,f4.1,\002,\002"
+      ",f4.1,\002), A,\002,i3,\002, (\002,f4.1,\002,\002,f4.1,\002), C"
+      ",\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char ca[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___313 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___314 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(ca, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(ca, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ca, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___313.ciunit = *nout;
+  s_wsfe(&io___313);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  do_fio(&c__1, ca, (ftnlen)14);
+  e_wsfe();
+  io___314.ciunit = *nout;
+  s_wsfe(&io___314);
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*k), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*alpha), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*beta), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* zprcn4_ */
+
+/* Subroutine */ int zprcn6_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *uplo, char *transa,
+                             integer *n, integer *k, doublereal *alpha,
+                             integer *lda, doublereal *beta, integer *ldc,
+                             ftnlen sname_len, ftnlen uplo_len,
+                             ftnlen transa_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+                           "\002))";
+  static char fmt_9994[] = "(10x,2(i3,\002,\002),f4.1,\002, A,\002,i3"
+                           ",\002,\002,f4.1,\002, C,\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char ca[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___318 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___319 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(ca, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(ca, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ca, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___318.ciunit = *nout;
+  s_wsfe(&io___318);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  do_fio(&c__1, ca, (ftnlen)14);
+  e_wsfe();
+  io___319.ciunit = *nout;
+  s_wsfe(&io___319);
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*k), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*alpha), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*beta), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* zprcn6_ */
+
+/* Subroutine */ int
+zchk5_(char *sname, doublereal *eps, doublereal *thresh, integer *nout,
+       integer *ntra, logical *trace, logical *rewi, logical *fatal,
+       integer *nidim, integer *idim, integer *nalf, doublecomplex *alf,
+       integer *nbet, doublecomplex *bet, integer *nmax, doublecomplex *ab,
+       doublecomplex *aa, doublecomplex *as, doublecomplex *bb,
+       doublecomplex *bs, doublecomplex *c__, doublecomplex *cc,
+       doublecomplex *cs, doublecomplex *ct, doublereal *g, doublecomplex *w,
+       integer *iorder, ftnlen sname_len) {
+  /* Initialized data */
+
+  static char icht[2] = "NC";
+  static char ichu[2] = "UL";
+
+  /* Format strings */
+  static char fmt_9992[] = "(\002 ******* FATAL ERROR - ERROR-EXIT TAKEN O"
+                           "N VALID CALL *\002,\002******\002)";
+  static char fmt_9998[] =
+      "(\002 ******* FATAL ERROR - PARAMETER NUMBER"
+      " \002,i2,\002 WAS CH\002,\002ANGED INCORRECTLY *******\002)";
+  static char fmt_10000[] =
+      "(\002 \002,a12,\002 PASSED THE COLUMN-MAJOR C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10001[] =
+      "(\002 \002,a12,\002 PASSED THE ROW-MAJOR    C"
+      "OMPUTATIONAL TESTS\002,\002 (\002,i6,\002 CALL\002,\002S)\002)";
+  static char fmt_10002[] =
+      "(\002 \002,a12,\002 COMPLETED THE COLUMN-MAJO"
+      "R COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_10003[] =
+      "(\002 \002,a12,\002 COMPLETED THE ROW-MAJOR  "
+      "  COMPUTATIONAL \002,\002TESTS (\002,i6,\002 CALLS)\002,/\002 **"
+      "***** BUT WITH MAXIMUM TEST \002,\002RATIO \002,f8.2,\002 - SUSP"
+      "ECT *******\002)";
+  static char fmt_9995[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+                           " \002,i3)";
+  static char fmt_9996[] = "(\002 ******* \002,a12,\002 FAILED ON CALL NUM"
+                           "BER:\002)";
+
+  /* System generated locals */
+  integer c_dim1, c_offset, i__1, i__2, i__3, i__4, i__5, i__6, i__7, i__8;
+  doublecomplex z__1, z__2;
+  alist al__1;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen), f_rew(alist *),
+      s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+  void d_cnjg(doublecomplex *, doublecomplex *);
+
+  /* Local variables */
+  integer i__, j, k, n, ia, ib, jc, ma, na, nc, ik, in, jj, lj, ks, ns, laa,
+      lbb, lda, lcc, ldb, ldc;
+  doublecomplex als;
+  integer ict, icu;
+  doublereal err;
+  extern logical lze_(doublecomplex *, doublecomplex *, integer *);
+  integer jjab;
+  doublecomplex beta;
+  integer ldas, ldbs, ldcs;
+  logical same, conj;
+  doublecomplex bets;
+  logical tran, null;
+  char uplo[1];
+  doublecomplex alpha;
+  doublereal rbeta;
+  logical isame[13];
+  extern /* Subroutine */ int zmake_(char *, char *, char *, integer *,
+                                     integer *, doublecomplex *, integer *,
+                                     doublecomplex *, integer *, logical *,
+                                     doublecomplex *, ftnlen, ftnlen, ftnlen);
+  integer nargs;
+  extern /* Subroutine */ int zmmch_(
+      char *, char *, integer *, integer *, integer *, doublecomplex *,
+      doublecomplex *, integer *, doublecomplex *, integer *, doublecomplex *,
+      doublecomplex *, integer *, doublecomplex *, doublereal *,
+      doublecomplex *, integer *, doublereal *, doublereal *, logical *,
+      integer *, logical *, ftnlen, ftnlen);
+  doublereal rbets;
+  logical reset;
+  char trans[1];
+  logical upper;
+  char uplos[1];
+  extern /* Subroutine */ int zprcn5_(
+      integer *, integer *, char *, integer *, char *, char *, integer *,
+      integer *, doublecomplex *, integer *, integer *, doublecomplex *,
+      integer *, ftnlen, ftnlen, ftnlen),
+      zprcn7_(integer *, integer *, char *, integer *, char *, char *,
+              integer *, integer *, doublecomplex *, integer *, integer *,
+              doublereal *, integer *, ftnlen, ftnlen, ftnlen);
+  doublereal errmax;
+  extern logical lzeres_(char *, char *, integer *, integer *, doublecomplex *,
+                         doublecomplex *, integer *, ftnlen, ftnlen);
+  char transs[1], transt[1];
+  extern /* Subroutine */ void czher2k_(
+      integer *, char *, char *, integer *, integer *, doublecomplex *,
+      doublecomplex *, integer *, doublecomplex *, integer *, doublereal *,
+      doublecomplex *, integer *),
+      czsyr2k_(integer *, char *, char *, integer *, integer *, doublecomplex *,
+               doublecomplex *, integer *, doublecomplex *, integer *,
+               doublecomplex *, doublecomplex *, integer *);
+
+  /* Fortran I/O blocks */
+  static cilist io___362 = {0, 0, 0, fmt_9992, 0};
+  static cilist io___365 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___373 = {0, 0, 0, fmt_10000, 0};
+  static cilist io___374 = {0, 0, 0, fmt_10001, 0};
+  static cilist io___375 = {0, 0, 0, fmt_10002, 0};
+  static cilist io___376 = {0, 0, 0, fmt_10003, 0};
+  static cilist io___377 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___378 = {0, 0, 0, fmt_9996, 0};
+
+  /*  Tests ZHER2K and ZSYR2K. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Local Arrays .. */
+  /*     .. External Functions .. */
+  /*     .. External Subroutines .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Scalars in Common .. */
+  /*     .. Common blocks .. */
+  /*     .. Data statements .. */
+  /* Parameter adjustments */
+  --idim;
+  --alf;
+  --bet;
+  --w;
+  --g;
+  --ct;
+  --cs;
+  --cc;
+  c_dim1 = *nmax;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --bs;
+  --bb;
+  --as;
+  --aa;
+  --ab;
+
+  /* Function Body */
+  /*     .. Executable Statements .. */
+  conj = s_cmp(sname + 7, "he", (ftnlen)2, (ftnlen)2) == 0;
+
+  nargs = 12;
+  nc = 0;
+  reset = TRUE_;
+  errmax = 0.;
+
+  i__1 = *nidim;
+  for (in = 1; in <= i__1; ++in) {
+    n = idim[in];
+    /*        Set LDC to 1 more than minimum value if room. */
+    ldc = n;
+    if (ldc < *nmax) {
+      ++ldc;
+    }
+    /*        Skip tests if not enough room. */
+    if (ldc > *nmax) {
+      goto L130;
+    }
+    lcc = ldc * n;
+
+    i__2 = *nidim;
+    for (ik = 1; ik <= i__2; ++ik) {
+      k = idim[ik];
+
+      for (ict = 1; ict <= 2; ++ict) {
+        *(unsigned char *)trans = *(unsigned char *)&icht[ict - 1];
+        tran = *(unsigned char *)trans == 'C';
+        if (tran && !conj) {
+          *(unsigned char *)trans = 'T';
+        }
+        if (tran) {
+          ma = k;
+          na = n;
+        } else {
+          ma = n;
+          na = k;
+        }
+        /*              Set LDA to 1 more than minimum value if room. */
+        lda = ma;
+        if (lda < *nmax) {
+          ++lda;
+        }
+        /*              Skip tests if not enough room. */
+        if (lda > *nmax) {
+          goto L110;
+        }
+        laa = lda * na;
+
+        /*              Generate the matrix A. */
+
+        if (tran) {
+          i__3 = *nmax << 1;
+          zmake_("ge", " ", " ", &ma, &na, &ab[1], &i__3, &aa[1], &lda, &reset,
+                 &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        } else {
+          zmake_("ge", " ", " ", &ma, &na, &ab[1], nmax, &aa[1], &lda, &reset,
+                 &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        }
+
+        /*              Generate the matrix B. */
+
+        ldb = lda;
+        lbb = laa;
+        if (tran) {
+          i__3 = *nmax << 1;
+          zmake_("ge", " ", " ", &ma, &na, &ab[k + 1], &i__3, &bb[1], &ldb,
+                 &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        } else {
+          zmake_("ge", " ", " ", &ma, &na, &ab[k * *nmax + 1], nmax, &bb[1],
+                 &ldb, &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+        }
+
+        for (icu = 1; icu <= 2; ++icu) {
+          *(unsigned char *)uplo = *(unsigned char *)&ichu[icu - 1];
+          upper = *(unsigned char *)uplo == 'U';
+
+          i__3 = *nalf;
+          for (ia = 1; ia <= i__3; ++ia) {
+            i__4 = ia;
+            alpha.r = alf[i__4].r, alpha.i = alf[i__4].i;
+
+            i__4 = *nbet;
+            for (ib = 1; ib <= i__4; ++ib) {
+              i__5 = ib;
+              beta.r = bet[i__5].r, beta.i = bet[i__5].i;
+              if (conj) {
+                rbeta = beta.r;
+                z__1.r = rbeta, z__1.i = 0.;
+                beta.r = z__1.r, beta.i = z__1.i;
+              }
+              null = n <= 0;
+              if (conj) {
+                null = null || (k <= 0 || alpha.r == 0. && alpha.i == 0.) &&
+                                   rbeta == 1.;
+              }
+
+              /*                       Generate the matrix C. */
+
+              zmake_(sname + 7, uplo, " ", &n, &n, &c__[c_offset], nmax, &cc[1],
+                     &ldc, &reset, &c_b1, (ftnlen)2, (ftnlen)1, (ftnlen)1);
+
+              ++nc;
+
+              /*                       Save every datum before calling the
+               * subroutine. */
+
+              *(unsigned char *)uplos = *(unsigned char *)uplo;
+              *(unsigned char *)transs = *(unsigned char *)trans;
+              ns = n;
+              ks = k;
+              als.r = alpha.r, als.i = alpha.i;
+              i__5 = laa;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                i__6 = i__;
+                i__7 = i__;
+                as[i__6].r = aa[i__7].r, as[i__6].i = aa[i__7].i;
+                /* L10: */
+              }
+              ldas = lda;
+              i__5 = lbb;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                i__6 = i__;
+                i__7 = i__;
+                bs[i__6].r = bb[i__7].r, bs[i__6].i = bb[i__7].i;
+                /* L20: */
+              }
+              ldbs = ldb;
+              if (conj) {
+                rbets = rbeta;
+              } else {
+                bets.r = beta.r, bets.i = beta.i;
+              }
+              i__5 = lcc;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                i__6 = i__;
+                i__7 = i__;
+                cs[i__6].r = cc[i__7].r, cs[i__6].i = cc[i__7].i;
+                /* L30: */
+              }
+              ldcs = ldc;
+
+              /*                       Call the subroutine. */
+
+              if (conj) {
+                if (*trace) {
+                  zprcn7_(ntra, &nc, sname, iorder, uplo, trans, &n, &k, &alpha,
+                          &lda, &ldb, &rbeta, &ldc, (ftnlen)12, (ftnlen)1,
+                          (ftnlen)1);
+                }
+                if (*rewi) {
+                  al__1.aerr = 0;
+                  al__1.aunit = *ntra;
+                  f_rew(&al__1);
+                }
+                czher2k_(iorder, uplo, trans, &n, &k, &alpha, &aa[1], &lda,
+                         &bb[1], &ldb, &rbeta, &cc[1], &ldc);
+              } else {
+                if (*trace) {
+                  zprcn5_(ntra, &nc, sname, iorder, uplo, trans, &n, &k, &alpha,
+                          &lda, &ldb, &beta, &ldc, (ftnlen)12, (ftnlen)1,
+                          (ftnlen)1);
+                }
+                if (*rewi) {
+                  al__1.aerr = 0;
+                  al__1.aunit = *ntra;
+                  f_rew(&al__1);
+                }
+                czsyr2k_(iorder, uplo, trans, &n, &k, &alpha, &aa[1], &lda,
+                         &bb[1], &ldb, &beta, &cc[1], &ldc);
+              }
+
+              /*                       Check if error-exit was taken
+               * incorrectly. */
+
+              if (!infoc_1.ok) {
+                io___362.ciunit = *nout;
+                s_wsfe(&io___362);
+                e_wsfe();
+                *fatal = TRUE_;
+                goto L150;
+              }
+
+              /*                       See what data changed inside subroutines.
+               */
+
+              isame[0] = *(unsigned char *)uplos == *(unsigned char *)uplo;
+              isame[1] = *(unsigned char *)transs == *(unsigned char *)trans;
+              isame[2] = ns == n;
+              isame[3] = ks == k;
+              isame[4] = als.r == alpha.r && als.i == alpha.i;
+              isame[5] = lze_(&as[1], &aa[1], &laa);
+              isame[6] = ldas == lda;
+              isame[7] = lze_(&bs[1], &bb[1], &lbb);
+              isame[8] = ldbs == ldb;
+              if (conj) {
+                isame[9] = rbets == rbeta;
+              } else {
+                isame[9] = bets.r == beta.r && bets.i == beta.i;
+              }
+              if (null) {
+                isame[10] = lze_(&cs[1], &cc[1], &lcc);
+              } else {
+                isame[10] = lzeres_("he", uplo, &n, &n, &cs[1], &cc[1], &ldc,
+                                    (ftnlen)2, (ftnlen)1);
+              }
+              isame[11] = ldcs == ldc;
+
+              /*                       If data was incorrectly changed, report
+               * and */
+              /*                       return. */
+
+              same = TRUE_;
+              i__5 = nargs;
+              for (i__ = 1; i__ <= i__5; ++i__) {
+                same = same && isame[i__ - 1];
+                if (!isame[i__ - 1]) {
+                  io___365.ciunit = *nout;
+                  s_wsfe(&io___365);
+                  do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+                  e_wsfe();
+                }
+                /* L40: */
+              }
+              if (!same) {
+                *fatal = TRUE_;
+                goto L150;
+              }
+
+              if (!null) {
+
+                /*                          Check the result column by column.
+                 */
+
+                if (conj) {
+                  *(unsigned char *)transt = 'C';
+                } else {
+                  *(unsigned char *)transt = 'T';
+                }
+                jjab = 1;
+                jc = 1;
+                i__5 = n;
+                for (j = 1; j <= i__5; ++j) {
+                  if (upper) {
+                    jj = 1;
+                    lj = j;
+                  } else {
+                    jj = j;
+                    lj = n - j + 1;
+                  }
+                  if (tran) {
+                    i__6 = k;
+                    for (i__ = 1; i__ <= i__6; ++i__) {
+                      i__7 = i__;
+                      i__8 = (j - 1 << 1) * *nmax + k + i__;
+                      z__1.r = alpha.r * ab[i__8].r - alpha.i * ab[i__8].i,
+                      z__1.i = alpha.r * ab[i__8].i + alpha.i * ab[i__8].r;
+                      w[i__7].r = z__1.r, w[i__7].i = z__1.i;
+                      if (conj) {
+                        i__7 = k + i__;
+                        d_cnjg(&z__2, &alpha);
+                        i__8 = (j - 1 << 1) * *nmax + i__;
+                        z__1.r = z__2.r * ab[i__8].r - z__2.i * ab[i__8].i,
+                        z__1.i = z__2.r * ab[i__8].i + z__2.i * ab[i__8].r;
+                        w[i__7].r = z__1.r, w[i__7].i = z__1.i;
+                      } else {
+                        i__7 = k + i__;
+                        i__8 = (j - 1 << 1) * *nmax + i__;
+                        z__1.r = alpha.r * ab[i__8].r - alpha.i * ab[i__8].i,
+                        z__1.i = alpha.r * ab[i__8].i + alpha.i * ab[i__8].r;
+                        w[i__7].r = z__1.r, w[i__7].i = z__1.i;
+                      }
+                      /* L50: */
+                    }
+                    i__6 = k << 1;
+                    i__7 = *nmax << 1;
+                    i__8 = *nmax << 1;
+                    zmmch_(transt, "N", &lj, &c__1, &i__6, &c_b2, &ab[jjab],
+                           &i__7, &w[1], &i__8, &beta, &c__[jj + j * c_dim1],
+                           nmax, &ct[1], &g[1], &cc[jc], &ldc, eps, &err, fatal,
+                           nout, &c_true, (ftnlen)1, (ftnlen)1);
+                  } else {
+                    i__6 = k;
+                    for (i__ = 1; i__ <= i__6; ++i__) {
+                      if (conj) {
+                        i__7 = i__;
+                        d_cnjg(&z__2, &ab[(k + i__ - 1) * *nmax + j]);
+                        z__1.r = alpha.r * z__2.r - alpha.i * z__2.i,
+                        z__1.i = alpha.r * z__2.i + alpha.i * z__2.r;
+                        w[i__7].r = z__1.r, w[i__7].i = z__1.i;
+                        i__7 = k + i__;
+                        i__8 = (i__ - 1) * *nmax + j;
+                        z__2.r = alpha.r * ab[i__8].r - alpha.i * ab[i__8].i,
+                        z__2.i = alpha.r * ab[i__8].i + alpha.i * ab[i__8].r;
+                        d_cnjg(&z__1, &z__2);
+                        w[i__7].r = z__1.r, w[i__7].i = z__1.i;
+                      } else {
+                        i__7 = i__;
+                        i__8 = (k + i__ - 1) * *nmax + j;
+                        z__1.r = alpha.r * ab[i__8].r - alpha.i * ab[i__8].i,
+                        z__1.i = alpha.r * ab[i__8].i + alpha.i * ab[i__8].r;
+                        w[i__7].r = z__1.r, w[i__7].i = z__1.i;
+                        i__7 = k + i__;
+                        i__8 = (i__ - 1) * *nmax + j;
+                        z__1.r = alpha.r * ab[i__8].r - alpha.i * ab[i__8].i,
+                        z__1.i = alpha.r * ab[i__8].i + alpha.i * ab[i__8].r;
+                        w[i__7].r = z__1.r, w[i__7].i = z__1.i;
+                      }
+                      /* L60: */
+                    }
+                    i__6 = k << 1;
+                    i__7 = *nmax << 1;
+                    zmmch_("N", "N", &lj, &c__1, &i__6, &c_b2, &ab[jj], nmax,
+                           &w[1], &i__7, &beta, &c__[jj + j * c_dim1], nmax,
+                           &ct[1], &g[1], &cc[jc], &ldc, eps, &err, fatal, nout,
+                           &c_true, (ftnlen)1, (ftnlen)1);
+                  }
+                  if (upper) {
+                    jc += ldc;
+                  } else {
+                    jc = jc + ldc + 1;
+                    if (tran) {
+                      jjab += *nmax << 1;
+                    }
+                  }
+                  errmax = max(errmax, err);
+                  /*                             If got really bad answer,
+                   * report and */
+                  /*                             return. */
+                  if (*fatal) {
+                    goto L140;
+                  }
+                  /* L70: */
+                }
+              }
+
+              /* L80: */
+            }
+
+            /* L90: */
+          }
+
+          /* L100: */
+        }
+
+      L110:;
+      }
+
+      /* L120: */
+    }
+
+  L130:;
+  }
+
+  /*     Report result. */
+
+  if (errmax < *thresh) {
+    if (*iorder == 0) {
+      io___373.ciunit = *nout;
+      s_wsfe(&io___373);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___374.ciunit = *nout;
+      s_wsfe(&io___374);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      e_wsfe();
+    }
+  } else {
+    if (*iorder == 0) {
+      io___375.ciunit = *nout;
+      s_wsfe(&io___375);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+    if (*iorder == 1) {
+      io___376.ciunit = *nout;
+      s_wsfe(&io___376);
+      do_fio(&c__1, sname, (ftnlen)12);
+      do_fio(&c__1, (char *)&nc, (ftnlen)sizeof(integer));
+      do_fio(&c__1, (char *)&errmax, (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+  }
+  goto L160;
+
+L140:
+  if (n > 1) {
+    io___377.ciunit = *nout;
+    s_wsfe(&io___377);
+    do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L150:
+  io___378.ciunit = *nout;
+  s_wsfe(&io___378);
+  do_fio(&c__1, sname, (ftnlen)12);
+  e_wsfe();
+  if (conj) {
+    zprcn7_(nout, &nc, sname, iorder, uplo, trans, &n, &k, &alpha, &lda, &ldb,
+            &rbeta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+  } else {
+    zprcn5_(nout, &nc, sname, iorder, uplo, trans, &n, &k, &alpha, &lda, &ldb,
+            &beta, &ldc, (ftnlen)12, (ftnlen)1, (ftnlen)1);
+  }
+
+L160:
+  return 0;
+
+  /* L9994: */
+  /* L9993: */
+
+  /*     End of ZCHK5. */
+
+} /* zchk5_ */
+
+/* Subroutine */ int zprcn5_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *uplo, char *transa,
+                             integer *n, integer *k, doublecomplex *alpha,
+                             integer *lda, integer *ldb, doublecomplex *beta,
+                             integer *ldc, ftnlen sname_len, ftnlen uplo_len,
+                             ftnlen transa_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+                           "\002))";
+  static char fmt_9994[] =
+      "(10x,2(i3,\002,\002),\002 (\002,f4.1,\002,\002"
+      ",f4.1,\002), A,\002,i3,\002, B\002,i3,\002, (\002,f4.1,\002,\002"
+      ",f4.1,\002), C,\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char ca[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___382 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___383 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(ca, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(ca, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ca, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___382.ciunit = *nout;
+  s_wsfe(&io___382);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  do_fio(&c__1, ca, (ftnlen)14);
+  e_wsfe();
+  io___383.ciunit = *nout;
+  s_wsfe(&io___383);
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*k), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*alpha), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*ldb), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*beta), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* zprcn5_ */
+
+/* Subroutine */ int zprcn7_(integer *nout, integer *nc, char *sname,
+                             integer *iorder, char *uplo, char *transa,
+                             integer *n, integer *k, doublecomplex *alpha,
+                             integer *lda, integer *ldb, doublereal *beta,
+                             integer *ldc, ftnlen sname_len, ftnlen uplo_len,
+                             ftnlen transa_len) {
+  /* Format strings */
+  static char fmt_9995[] = "(1x,i6,\002: \002,a12,\002(\002,3(a14,\002,"
+                           "\002))";
+  static char fmt_9994[] =
+      "(10x,2(i3,\002,\002),\002 (\002,f4.1,\002,\002"
+      ",f4.1,\002), A,\002,i3,\002, B\002,i3,\002,\002,f4.1,\002, C,"
+      "\002,i3,\002).\002)";
+
+  /* Builtin functions */
+  /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
+  integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
+
+  /* Local variables */
+  char ca[14], cu[14], crc[14];
+
+  /* Fortran I/O blocks */
+  static cilist io___387 = {0, 0, 0, fmt_9995, 0};
+  static cilist io___388 = {0, 0, 0, fmt_9994, 0};
+
+  if (*(unsigned char *)uplo == 'U') {
+    s_copy(cu, "    CblasUpper", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(cu, "    CblasLower", (ftnlen)14, (ftnlen)14);
+  }
+  if (*(unsigned char *)transa == 'N') {
+    s_copy(ca, "  CblasNoTrans", (ftnlen)14, (ftnlen)14);
+  } else if (*(unsigned char *)transa == 'T') {
+    s_copy(ca, "    CblasTrans", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(ca, "CblasConjTrans", (ftnlen)14, (ftnlen)14);
+  }
+  if (*iorder == 1) {
+    s_copy(crc, " CblasRowMajor", (ftnlen)14, (ftnlen)14);
+  } else {
+    s_copy(crc, " CblasColMajor", (ftnlen)14, (ftnlen)14);
+  }
+  io___387.ciunit = *nout;
+  s_wsfe(&io___387);
+  do_fio(&c__1, (char *)&(*nc), (ftnlen)sizeof(integer));
+  do_fio(&c__1, sname, (ftnlen)12);
+  do_fio(&c__1, crc, (ftnlen)14);
+  do_fio(&c__1, cu, (ftnlen)14);
+  do_fio(&c__1, ca, (ftnlen)14);
+  e_wsfe();
+  io___388.ciunit = *nout;
+  s_wsfe(&io___388);
+  do_fio(&c__1, (char *)&(*n), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*k), (ftnlen)sizeof(integer));
+  do_fio(&c__2, (char *)&(*alpha), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*lda), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*ldb), (ftnlen)sizeof(integer));
+  do_fio(&c__1, (char *)&(*beta), (ftnlen)sizeof(doublereal));
+  do_fio(&c__1, (char *)&(*ldc), (ftnlen)sizeof(integer));
+  e_wsfe();
+  return 0;
+} /* zprcn7_ */
+
+/* Subroutine */ int zmake_(char *type__, char *uplo, char *diag, integer *m,
+                            integer *n, doublecomplex *a, integer *nmax,
+                            doublecomplex *aa, integer *lda, logical *reset,
+                            doublecomplex *transl, ftnlen type_len,
+                            ftnlen uplo_len, ftnlen diag_len) {
+  /* System generated locals */
+  integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
+  doublereal d__1;
+  doublecomplex z__1, z__2;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen);
+  void d_cnjg(doublecomplex *, doublecomplex *);
+
+  /* Local variables */
+  integer i__, j, jj;
+  logical gen, her, tri, sym;
+  integer ibeg, iend;
+  extern /* Double Complex */ VOID zbeg_(doublecomplex *, logical *);
+  logical unit, lower, upper;
+
+  /*  Generates values for an M by N matrix A. */
+  /*  Stores the values in the array AA in the data structure required */
+  /*  by the routine, with unwanted elements set to rogue value. */
+
+  /*  TYPE is 'ge', 'he', 'sy' or 'tr'. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. External Functions .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  a_dim1 = *nmax;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  --aa;
+
+  /* Function Body */
+  gen = s_cmp(type__, "ge", (ftnlen)2, (ftnlen)2) == 0;
+  her = s_cmp(type__, "he", (ftnlen)2, (ftnlen)2) == 0;
+  sym = s_cmp(type__, "sy", (ftnlen)2, (ftnlen)2) == 0;
+  tri = s_cmp(type__, "tr", (ftnlen)2, (ftnlen)2) == 0;
+  upper = (her || sym || tri) && *(unsigned char *)uplo == 'U';
+  lower = (her || sym || tri) && *(unsigned char *)uplo == 'L';
+  unit = tri && *(unsigned char *)diag == 'U';
+
+  /*     Generate data in array A. */
+
+  i__1 = *n;
+  for (j = 1; j <= i__1; ++j) {
+    i__2 = *m;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      if (gen || upper && i__ <= j || lower && i__ >= j) {
+        i__3 = i__ + j * a_dim1;
+        zbeg_(&z__2, reset);
+        z__1.r = z__2.r + transl->r, z__1.i = z__2.i + transl->i;
+        a[i__3].r = z__1.r, a[i__3].i = z__1.i;
+        if (i__ != j) {
+          /*                 Set some elements to zero */
+          if (*n > 3 && j == *n / 2) {
+            i__3 = i__ + j * a_dim1;
+            a[i__3].r = 0., a[i__3].i = 0.;
+          }
+          if (her) {
+            i__3 = j + i__ * a_dim1;
+            d_cnjg(&z__1, &a[i__ + j * a_dim1]);
+            a[i__3].r = z__1.r, a[i__3].i = z__1.i;
+          } else if (sym) {
+            i__3 = j + i__ * a_dim1;
+            i__4 = i__ + j * a_dim1;
+            a[i__3].r = a[i__4].r, a[i__3].i = a[i__4].i;
+          } else if (tri) {
+            i__3 = j + i__ * a_dim1;
+            a[i__3].r = 0., a[i__3].i = 0.;
+          }
+        }
+      }
+      /* L10: */
+    }
+    if (her) {
+      i__2 = j + j * a_dim1;
+      i__3 = j + j * a_dim1;
+      d__1 = a[i__3].r;
+      z__1.r = d__1, z__1.i = 0.;
+      a[i__2].r = z__1.r, a[i__2].i = z__1.i;
+    }
+    if (tri) {
+      i__2 = j + j * a_dim1;
+      i__3 = j + j * a_dim1;
+      z__1.r = a[i__3].r + 1., z__1.i = a[i__3].i + 0.;
+      a[i__2].r = z__1.r, a[i__2].i = z__1.i;
+    }
+    if (unit) {
+      i__2 = j + j * a_dim1;
+      a[i__2].r = 1., a[i__2].i = 0.;
+    }
+    /* L20: */
+  }
+
+  /*     Store elements in array AS in data structure required by routine. */
+
+  if (s_cmp(type__, "ge", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      i__2 = *m;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        i__4 = i__ + j * a_dim1;
+        aa[i__3].r = a[i__4].r, aa[i__3].i = a[i__4].i;
+        /* L30: */
+      }
+      i__2 = *lda;
+      for (i__ = *m + 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        aa[i__3].r = -1e10, aa[i__3].i = 1e10;
+        /* L40: */
+      }
+      /* L50: */
+    }
+  } else if (s_cmp(type__, "he", (ftnlen)2, (ftnlen)2) == 0 ||
+             s_cmp(type__, "sy", (ftnlen)2, (ftnlen)2) == 0 ||
+             s_cmp(type__, "tr", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      if (upper) {
+        ibeg = 1;
+        if (unit) {
+          iend = j - 1;
+        } else {
+          iend = j;
+        }
+      } else {
+        if (unit) {
+          ibeg = j + 1;
+        } else {
+          ibeg = j;
+        }
+        iend = *n;
+      }
+      i__2 = ibeg - 1;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        aa[i__3].r = -1e10, aa[i__3].i = 1e10;
+        /* L60: */
+      }
+      i__2 = iend;
+      for (i__ = ibeg; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        i__4 = i__ + j * a_dim1;
+        aa[i__3].r = a[i__4].r, aa[i__3].i = a[i__4].i;
+        /* L70: */
+      }
+      i__2 = *lda;
+      for (i__ = iend + 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + (j - 1) * *lda;
+        aa[i__3].r = -1e10, aa[i__3].i = 1e10;
+        /* L80: */
+      }
+      if (her) {
+        jj = j + (j - 1) * *lda;
+        i__2 = jj;
+        i__3 = jj;
+        d__1 = aa[i__3].r;
+        z__1.r = d__1, z__1.i = -1e10;
+        aa[i__2].r = z__1.r, aa[i__2].i = z__1.i;
+      }
+      /* L90: */
+    }
+  }
+  return 0;
+
+  /*     End of ZMAKE. */
+
+} /* zmake_ */
+
+/* Subroutine */ int zmmch_(char *transa, char *transb, integer *m, integer *n,
+                            integer *kk, doublecomplex *alpha, doublecomplex *a,
+                            integer *lda, doublecomplex *b, integer *ldb,
+                            doublecomplex *beta, doublecomplex *c__,
+                            integer *ldc, doublecomplex *ct, doublereal *g,
+                            doublecomplex *cc, integer *ldcc, doublereal *eps,
+                            doublereal *err, logical *fatal, integer *nout,
+                            logical *mv, ftnlen transa_len, ftnlen transb_len) {
+  /* Format strings */
+  static char fmt_9999[] =
+      "(\002 ******* FATAL ERROR - COMPUTED RESULT IS"
+      " LESS THAN HAL\002,\002F ACCURATE *******\002,/\002             "
+      "          EXPECTED RE\002,\002SULT                    COMPUTED R"
+      "ESULT\002)";
+  static char fmt_9998[] = "(1x,i7,2(\002  (\002,g15.6,\002,\002,g15.6,"
+                           "\002)\002))";
+  static char fmt_9997[] = "(\002      THESE ARE THE RESULTS FOR COLUMN"
+                           " \002,i3)";
+
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, cc_dim1,
+      cc_offset, i__1, i__2, i__3, i__4, i__5, i__6, i__7;
+  doublereal d__1, d__2, d__3, d__4, d__5, d__6;
+  doublecomplex z__1, z__2, z__3, z__4;
+
+  /* Builtin functions */
+  double d_imag(doublecomplex *);
+  void d_cnjg(doublecomplex *, doublecomplex *);
+  double sqrt(doublereal);
+  integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);
+
+  /* Local variables */
+  integer i__, j, k;
+  doublereal erri;
+  logical trana, tranb, ctrana, ctranb;
+
+  /* Fortran I/O blocks */
+  static cilist io___409 = {0, 0, 0, fmt_9999, 0};
+  static cilist io___410 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___411 = {0, 0, 0, fmt_9998, 0};
+  static cilist io___412 = {0, 0, 0, fmt_9997, 0};
+
+  /*  Checks the results of the computational tests. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Parameters .. */
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Statement Functions .. */
+  /*     .. Statement Function definitions .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  a_dim1 = *lda;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  b_dim1 = *ldb;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  c_dim1 = *ldc;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+  --ct;
+  --g;
+  cc_dim1 = *ldcc;
+  cc_offset = 1 + cc_dim1;
+  cc -= cc_offset;
+
+  /* Function Body */
+  trana = *(unsigned char *)transa == 'T' || *(unsigned char *)transa == 'C';
+  tranb = *(unsigned char *)transb == 'T' || *(unsigned char *)transb == 'C';
+  ctrana = *(unsigned char *)transa == 'C';
+  ctranb = *(unsigned char *)transb == 'C';
+
+  /*     Compute expected result, one column at a time, in CT using data */
+  /*     in A, B and C. */
+  /*     Compute gauges in G. */
+
+  i__1 = *n;
+  for (j = 1; j <= i__1; ++j) {
+
+    i__2 = *m;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      i__3 = i__;
+      ct[i__3].r = 0., ct[i__3].i = 0.;
+      g[i__] = 0.;
+      /* L10: */
+    }
+    if (!trana && !tranb) {
+      i__2 = *kk;
+      for (k = 1; k <= i__2; ++k) {
+        i__3 = *m;
+        for (i__ = 1; i__ <= i__3; ++i__) {
+          i__4 = i__;
+          i__5 = i__;
+          i__6 = i__ + k * a_dim1;
+          i__7 = k + j * b_dim1;
+          z__2.r = a[i__6].r * b[i__7].r - a[i__6].i * b[i__7].i,
+          z__2.i = a[i__6].r * b[i__7].i + a[i__6].i * b[i__7].r;
+          z__1.r = ct[i__5].r + z__2.r, z__1.i = ct[i__5].i + z__2.i;
+          ct[i__4].r = z__1.r, ct[i__4].i = z__1.i;
+          i__4 = i__ + k * a_dim1;
+          i__5 = k + j * b_dim1;
+          g[i__] += ((d__1 = a[i__4].r, abs(d__1)) +
+                     (d__2 = d_imag(&a[i__ + k * a_dim1]), abs(d__2))) *
+                    ((d__3 = b[i__5].r, abs(d__3)) +
+                     (d__4 = d_imag(&b[k + j * b_dim1]), abs(d__4)));
+          /* L20: */
+        }
+        /* L30: */
+      }
+    } else if (trana && !tranb) {
+      if (ctrana) {
+        i__2 = *kk;
+        for (k = 1; k <= i__2; ++k) {
+          i__3 = *m;
+          for (i__ = 1; i__ <= i__3; ++i__) {
+            i__4 = i__;
+            i__5 = i__;
+            d_cnjg(&z__3, &a[k + i__ * a_dim1]);
+            i__6 = k + j * b_dim1;
+            z__2.r = z__3.r * b[i__6].r - z__3.i * b[i__6].i,
+            z__2.i = z__3.r * b[i__6].i + z__3.i * b[i__6].r;
+            z__1.r = ct[i__5].r + z__2.r, z__1.i = ct[i__5].i + z__2.i;
+            ct[i__4].r = z__1.r, ct[i__4].i = z__1.i;
+            i__4 = k + i__ * a_dim1;
+            i__5 = k + j * b_dim1;
+            g[i__] += ((d__1 = a[i__4].r, abs(d__1)) +
+                       (d__2 = d_imag(&a[k + i__ * a_dim1]), abs(d__2))) *
+                      ((d__3 = b[i__5].r, abs(d__3)) +
+                       (d__4 = d_imag(&b[k + j * b_dim1]), abs(d__4)));
+            /* L40: */
+          }
+          /* L50: */
+        }
+      } else {
+        i__2 = *kk;
+        for (k = 1; k <= i__2; ++k) {
+          i__3 = *m;
+          for (i__ = 1; i__ <= i__3; ++i__) {
+            i__4 = i__;
+            i__5 = i__;
+            i__6 = k + i__ * a_dim1;
+            i__7 = k + j * b_dim1;
+            z__2.r = a[i__6].r * b[i__7].r - a[i__6].i * b[i__7].i,
+            z__2.i = a[i__6].r * b[i__7].i + a[i__6].i * b[i__7].r;
+            z__1.r = ct[i__5].r + z__2.r, z__1.i = ct[i__5].i + z__2.i;
+            ct[i__4].r = z__1.r, ct[i__4].i = z__1.i;
+            i__4 = k + i__ * a_dim1;
+            i__5 = k + j * b_dim1;
+            g[i__] += ((d__1 = a[i__4].r, abs(d__1)) +
+                       (d__2 = d_imag(&a[k + i__ * a_dim1]), abs(d__2))) *
+                      ((d__3 = b[i__5].r, abs(d__3)) +
+                       (d__4 = d_imag(&b[k + j * b_dim1]), abs(d__4)));
+            /* L60: */
+          }
+          /* L70: */
+        }
+      }
+    } else if (!trana && tranb) {
+      if (ctranb) {
+        i__2 = *kk;
+        for (k = 1; k <= i__2; ++k) {
+          i__3 = *m;
+          for (i__ = 1; i__ <= i__3; ++i__) {
+            i__4 = i__;
+            i__5 = i__;
+            i__6 = i__ + k * a_dim1;
+            d_cnjg(&z__3, &b[j + k * b_dim1]);
+            z__2.r = a[i__6].r * z__3.r - a[i__6].i * z__3.i,
+            z__2.i = a[i__6].r * z__3.i + a[i__6].i * z__3.r;
+            z__1.r = ct[i__5].r + z__2.r, z__1.i = ct[i__5].i + z__2.i;
+            ct[i__4].r = z__1.r, ct[i__4].i = z__1.i;
+            i__4 = i__ + k * a_dim1;
+            i__5 = j + k * b_dim1;
+            g[i__] += ((d__1 = a[i__4].r, abs(d__1)) +
+                       (d__2 = d_imag(&a[i__ + k * a_dim1]), abs(d__2))) *
+                      ((d__3 = b[i__5].r, abs(d__3)) +
+                       (d__4 = d_imag(&b[j + k * b_dim1]), abs(d__4)));
+            /* L80: */
+          }
+          /* L90: */
+        }
+      } else {
+        i__2 = *kk;
+        for (k = 1; k <= i__2; ++k) {
+          i__3 = *m;
+          for (i__ = 1; i__ <= i__3; ++i__) {
+            i__4 = i__;
+            i__5 = i__;
+            i__6 = i__ + k * a_dim1;
+            i__7 = j + k * b_dim1;
+            z__2.r = a[i__6].r * b[i__7].r - a[i__6].i * b[i__7].i,
+            z__2.i = a[i__6].r * b[i__7].i + a[i__6].i * b[i__7].r;
+            z__1.r = ct[i__5].r + z__2.r, z__1.i = ct[i__5].i + z__2.i;
+            ct[i__4].r = z__1.r, ct[i__4].i = z__1.i;
+            i__4 = i__ + k * a_dim1;
+            i__5 = j + k * b_dim1;
+            g[i__] += ((d__1 = a[i__4].r, abs(d__1)) +
+                       (d__2 = d_imag(&a[i__ + k * a_dim1]), abs(d__2))) *
+                      ((d__3 = b[i__5].r, abs(d__3)) +
+                       (d__4 = d_imag(&b[j + k * b_dim1]), abs(d__4)));
+            /* L100: */
+          }
+          /* L110: */
+        }
+      }
+    } else if (trana && tranb) {
+      if (ctrana) {
+        if (ctranb) {
+          i__2 = *kk;
+          for (k = 1; k <= i__2; ++k) {
+            i__3 = *m;
+            for (i__ = 1; i__ <= i__3; ++i__) {
+              i__4 = i__;
+              i__5 = i__;
+              d_cnjg(&z__3, &a[k + i__ * a_dim1]);
+              d_cnjg(&z__4, &b[j + k * b_dim1]);
+              z__2.r = z__3.r * z__4.r - z__3.i * z__4.i,
+              z__2.i = z__3.r * z__4.i + z__3.i * z__4.r;
+              z__1.r = ct[i__5].r + z__2.r, z__1.i = ct[i__5].i + z__2.i;
+              ct[i__4].r = z__1.r, ct[i__4].i = z__1.i;
+              i__4 = k + i__ * a_dim1;
+              i__5 = j + k * b_dim1;
+              g[i__] += ((d__1 = a[i__4].r, abs(d__1)) +
+                         (d__2 = d_imag(&a[k + i__ * a_dim1]), abs(d__2))) *
+                        ((d__3 = b[i__5].r, abs(d__3)) +
+                         (d__4 = d_imag(&b[j + k * b_dim1]), abs(d__4)));
+              /* L120: */
+            }
+            /* L130: */
+          }
+        } else {
+          i__2 = *kk;
+          for (k = 1; k <= i__2; ++k) {
+            i__3 = *m;
+            for (i__ = 1; i__ <= i__3; ++i__) {
+              i__4 = i__;
+              i__5 = i__;
+              d_cnjg(&z__3, &a[k + i__ * a_dim1]);
+              i__6 = j + k * b_dim1;
+              z__2.r = z__3.r * b[i__6].r - z__3.i * b[i__6].i,
+              z__2.i = z__3.r * b[i__6].i + z__3.i * b[i__6].r;
+              z__1.r = ct[i__5].r + z__2.r, z__1.i = ct[i__5].i + z__2.i;
+              ct[i__4].r = z__1.r, ct[i__4].i = z__1.i;
+              i__4 = k + i__ * a_dim1;
+              i__5 = j + k * b_dim1;
+              g[i__] += ((d__1 = a[i__4].r, abs(d__1)) +
+                         (d__2 = d_imag(&a[k + i__ * a_dim1]), abs(d__2))) *
+                        ((d__3 = b[i__5].r, abs(d__3)) +
+                         (d__4 = d_imag(&b[j + k * b_dim1]), abs(d__4)));
+              /* L140: */
+            }
+            /* L150: */
+          }
+        }
+      } else {
+        if (ctranb) {
+          i__2 = *kk;
+          for (k = 1; k <= i__2; ++k) {
+            i__3 = *m;
+            for (i__ = 1; i__ <= i__3; ++i__) {
+              i__4 = i__;
+              i__5 = i__;
+              i__6 = k + i__ * a_dim1;
+              d_cnjg(&z__3, &b[j + k * b_dim1]);
+              z__2.r = a[i__6].r * z__3.r - a[i__6].i * z__3.i,
+              z__2.i = a[i__6].r * z__3.i + a[i__6].i * z__3.r;
+              z__1.r = ct[i__5].r + z__2.r, z__1.i = ct[i__5].i + z__2.i;
+              ct[i__4].r = z__1.r, ct[i__4].i = z__1.i;
+              i__4 = k + i__ * a_dim1;
+              i__5 = j + k * b_dim1;
+              g[i__] += ((d__1 = a[i__4].r, abs(d__1)) +
+                         (d__2 = d_imag(&a[k + i__ * a_dim1]), abs(d__2))) *
+                        ((d__3 = b[i__5].r, abs(d__3)) +
+                         (d__4 = d_imag(&b[j + k * b_dim1]), abs(d__4)));
+              /* L160: */
+            }
+            /* L170: */
+          }
+        } else {
+          i__2 = *kk;
+          for (k = 1; k <= i__2; ++k) {
+            i__3 = *m;
+            for (i__ = 1; i__ <= i__3; ++i__) {
+              i__4 = i__;
+              i__5 = i__;
+              i__6 = k + i__ * a_dim1;
+              i__7 = j + k * b_dim1;
+              z__2.r = a[i__6].r * b[i__7].r - a[i__6].i * b[i__7].i,
+              z__2.i = a[i__6].r * b[i__7].i + a[i__6].i * b[i__7].r;
+              z__1.r = ct[i__5].r + z__2.r, z__1.i = ct[i__5].i + z__2.i;
+              ct[i__4].r = z__1.r, ct[i__4].i = z__1.i;
+              i__4 = k + i__ * a_dim1;
+              i__5 = j + k * b_dim1;
+              g[i__] += ((d__1 = a[i__4].r, abs(d__1)) +
+                         (d__2 = d_imag(&a[k + i__ * a_dim1]), abs(d__2))) *
+                        ((d__3 = b[i__5].r, abs(d__3)) +
+                         (d__4 = d_imag(&b[j + k * b_dim1]), abs(d__4)));
+              /* L180: */
+            }
+            /* L190: */
+          }
+        }
+      }
+    }
+    i__2 = *m;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      i__3 = i__;
+      i__4 = i__;
+      z__2.r = alpha->r * ct[i__4].r - alpha->i * ct[i__4].i,
+      z__2.i = alpha->r * ct[i__4].i + alpha->i * ct[i__4].r;
+      i__5 = i__ + j * c_dim1;
+      z__3.r = beta->r * c__[i__5].r - beta->i * c__[i__5].i,
+      z__3.i = beta->r * c__[i__5].i + beta->i * c__[i__5].r;
+      z__1.r = z__2.r + z__3.r, z__1.i = z__2.i + z__3.i;
+      ct[i__3].r = z__1.r, ct[i__3].i = z__1.i;
+      i__3 = i__ + j * c_dim1;
+      g[i__] =
+          ((d__1 = alpha->r, abs(d__1)) + (d__2 = d_imag(alpha), abs(d__2))) *
+              g[i__] +
+          ((d__3 = beta->r, abs(d__3)) + (d__4 = d_imag(beta), abs(d__4))) *
+              ((d__5 = c__[i__3].r, abs(d__5)) +
+               (d__6 = d_imag(&c__[i__ + j * c_dim1]), abs(d__6)));
+      /* L200: */
+    }
+
+    /*        Compute the error ratio for this result. */
+
+    *err = 0.;
+    i__2 = *m;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+      i__3 = i__;
+      i__4 = i__ + j * cc_dim1;
+      z__2.r = ct[i__3].r - cc[i__4].r, z__2.i = ct[i__3].i - cc[i__4].i;
+      z__1.r = z__2.r, z__1.i = z__2.i;
+      erri = ((d__1 = z__1.r, abs(d__1)) + (d__2 = d_imag(&z__1), abs(d__2))) /
+             *eps;
+      if (g[i__] != 0.) {
+        erri /= g[i__];
+      }
+      *err = max(*err, erri);
+      if (*err * sqrt(*eps) >= 1.) {
+        goto L230;
+      }
+      /* L210: */
+    }
+
+    /* L220: */
+  }
+
+  /*     If the loop completes, all results are at least half accurate. */
+  goto L250;
+
+  /*     Report fatal error. */
+
+L230:
+  *fatal = TRUE_;
+  io___409.ciunit = *nout;
+  s_wsfe(&io___409);
+  e_wsfe();
+  i__1 = *m;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    if (*mv) {
+      io___410.ciunit = *nout;
+      s_wsfe(&io___410);
+      do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+      do_fio(&c__2, (char *)&ct[i__], (ftnlen)sizeof(doublereal));
+      do_fio(&c__2, (char *)&cc[i__ + j * cc_dim1], (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    } else {
+      io___411.ciunit = *nout;
+      s_wsfe(&io___411);
+      do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
+      do_fio(&c__2, (char *)&cc[i__ + j * cc_dim1], (ftnlen)sizeof(doublereal));
+      do_fio(&c__2, (char *)&ct[i__], (ftnlen)sizeof(doublereal));
+      e_wsfe();
+    }
+    /* L240: */
+  }
+  if (*n > 1) {
+    io___412.ciunit = *nout;
+    s_wsfe(&io___412);
+    do_fio(&c__1, (char *)&j, (ftnlen)sizeof(integer));
+    e_wsfe();
+  }
+
+L250:
+  return 0;
+
+  /*     End of ZMMCH. */
+
+} /* zmmch_ */
+
+logical lze_(doublecomplex *ri, doublecomplex *rj, integer *lr) {
+  /* System generated locals */
+  integer i__1, i__2, i__3;
+  logical ret_val;
+
+  /* Local variables */
+  integer i__;
+
+  /*  Tests if two arrays are identical. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  --rj;
+  --ri;
+
+  /* Function Body */
+  i__1 = *lr;
+  for (i__ = 1; i__ <= i__1; ++i__) {
+    i__2 = i__;
+    i__3 = i__;
+    if (ri[i__2].r != rj[i__3].r || ri[i__2].i != rj[i__3].i) {
+      goto L20;
+    }
+    /* L10: */
+  }
+  ret_val = TRUE_;
+  goto L30;
+L20:
+  ret_val = FALSE_;
+L30:
+  return ret_val;
+
+  /*     End of LZE. */
+
+} /* lze_ */
+
+logical lzeres_(char *type__, char *uplo, integer *m, integer *n,
+                doublecomplex *aa, doublecomplex *as, integer *lda,
+                ftnlen type_len, ftnlen uplo_len) {
+  /* System generated locals */
+  integer aa_dim1, aa_offset, as_dim1, as_offset, i__1, i__2, i__3, i__4;
+  logical ret_val;
+
+  /* Builtin functions */
+  integer s_cmp(char *, char *, ftnlen, ftnlen);
+
+  /* Local variables */
+  integer i__, j, ibeg, iend;
+  logical upper;
+
+  /*  Tests if selected elements in two arrays are equal. */
+
+  /*  TYPE is 'ge' or 'he' or 'sy'. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Array Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Executable Statements .. */
+  /* Parameter adjustments */
+  as_dim1 = *lda;
+  as_offset = 1 + as_dim1;
+  as -= as_offset;
+  aa_dim1 = *lda;
+  aa_offset = 1 + aa_dim1;
+  aa -= aa_offset;
+
+  /* Function Body */
+  upper = *(unsigned char *)uplo == 'U';
+  if (s_cmp(type__, "ge", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      i__2 = *lda;
+      for (i__ = *m + 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + j * aa_dim1;
+        i__4 = i__ + j * as_dim1;
+        if (aa[i__3].r != as[i__4].r || aa[i__3].i != as[i__4].i) {
+          goto L70;
+        }
+        /* L10: */
+      }
+      /* L20: */
+    }
+  } else if (s_cmp(type__, "he", (ftnlen)2, (ftnlen)2) == 0 ||
+             s_cmp(type__, "sy", (ftnlen)2, (ftnlen)2) == 0) {
+    i__1 = *n;
+    for (j = 1; j <= i__1; ++j) {
+      if (upper) {
+        ibeg = 1;
+        iend = j;
+      } else {
+        ibeg = j;
+        iend = *n;
+      }
+      i__2 = ibeg - 1;
+      for (i__ = 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + j * aa_dim1;
+        i__4 = i__ + j * as_dim1;
+        if (aa[i__3].r != as[i__4].r || aa[i__3].i != as[i__4].i) {
+          goto L70;
+        }
+        /* L30: */
+      }
+      i__2 = *lda;
+      for (i__ = iend + 1; i__ <= i__2; ++i__) {
+        i__3 = i__ + j * aa_dim1;
+        i__4 = i__ + j * as_dim1;
+        if (aa[i__3].r != as[i__4].r || aa[i__3].i != as[i__4].i) {
+          goto L70;
+        }
+        /* L40: */
+      }
+      /* L50: */
+    }
+  }
+
+  /* L60: */
+  ret_val = TRUE_;
+  goto L80;
+L70:
+  ret_val = FALSE_;
+L80:
+  return ret_val;
+
+  /*     End of LZERES. */
+
+} /* lzeres_ */
+
+/* Double Complex */ VOID zbeg_(doublecomplex *ret_val, logical *reset) {
+  /* System generated locals */
+  doublereal d__1, d__2;
+  doublecomplex z__1;
+
+  /* Local variables */
+  static integer i__, j, ic, mi, mj;
+
+  /*  Generates complex numbers as pairs of random numbers uniformly */
+  /*  distributed between -0.5 and 0.5. */
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Local Scalars .. */
+  /*     .. Save statement .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. Executable Statements .. */
+  if (*reset) {
+    /*        Initialize local variables. */
+    mi = 891;
+    mj = 457;
+    i__ = 7;
+    j = 7;
+    ic = 0;
+    *reset = FALSE_;
+  }
+
+  /*     The sequence of values of I or J is bounded between 1 and 999. */
+  /*     If initial I or J = 1,2,3,6,7 or 9, the period will be 50. */
+  /*     If initial I or J = 4 or 8, the period will be 25. */
+  /*     If initial I or J = 5, the period will be 10. */
+  /*     IC is used to break up the period by skipping 1 value of I or J */
+  /*     in 6. */
+
+  ++ic;
+L10:
+  i__ *= mi;
+  j *= mj;
+  i__ -= i__ / 1000 * 1000;
+  j -= j / 1000 * 1000;
+  if (ic >= 5) {
+    ic = 0;
+    goto L10;
+  }
+  d__1 = (i__ - 500) / 1001.;
+  d__2 = (j - 500) / 1001.;
+  z__1.r = d__1, z__1.i = d__2;
+  ret_val->r = z__1.r, ret_val->i = z__1.i;
+  return;
+
+  /*     End of ZBEG. */
+
+} /* zbeg_ */
+
+doublereal ddiff_(doublereal *x, doublereal *y) {
+  /* System generated locals */
+  doublereal ret_val;
+
+  /*  Auxiliary routine for test program for Level 3 Blas. */
+
+  /*  -- Written on 8-February-1989. */
+  /*     Jack Dongarra, Argonne National Laboratory. */
+  /*     Iain Duff, AERE Harwell. */
+  /*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+  /*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. Executable Statements .. */
+  ret_val = *x - *y;
+  return ret_val;
+
+  /*     End of DDIFF. */
+
+} /* ddiff_ */
+
+/* Main program alias */ int zblat3_() {
+  MAIN__();
+  return 0;
+}
diff --git a/CLAPACK-3.2.1/BLAS/WRAP/cblas.h b/CLAPACK-3.2.1/BLAS/WRAP/cblas.h
index ff09e18..80385c1 100644
--- a/CLAPACK-3.2.1/BLAS/WRAP/cblas.h
+++ b/CLAPACK-3.2.1/BLAS/WRAP/cblas.h
@@ -1,17 +1,21 @@
 #ifndef CBLAS_H
 #define CBLAS_H
-
 #include <stddef.h>
 
-#define CBLAS_INDEX size_t 
+/*
+ * Enumerated and derived types
+ */
+#define CBLAS_INDEX size_t  /* this may vary between platforms */
 
-enum CBLAS_ORDER 	{CblasRowMajor=101, CblasColMajor=102};
-enum CBLAS_TRANSPOSE 	{CblasNoTrans=111, CblasTrans=112, CblasConjTrans=113};
-enum CBLAS_UPLO		{CblasUpper=121, CblasLower=122};
-enum CBLAS_DIAG		{CblasNonUnit=131, CblasUnit=132};
-enum CBLAS_SIDE		{CblasLeft=141, CblasRight=142};
+enum CBLAS_ORDER {CblasRowMajor=101, CblasColMajor=102};
+enum CBLAS_TRANSPOSE {CblasNoTrans=111, CblasTrans=112, CblasConjTrans=113};
+enum CBLAS_UPLO {CblasUpper=121, CblasLower=122};
+enum CBLAS_DIAG {CblasNonUnit=131, CblasUnit=132};
+enum CBLAS_SIDE {CblasLeft=141, CblasRight=142};
 
-int cblas_errprn(int ierr, int info, char *form, ...);
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 /*
  * ===========================================================================
@@ -26,6 +30,7 @@ float  cblas_sdot(const int N, const float  *X, const int incX,
                   const float  *Y, const int incY);
 double cblas_ddot(const int N, const double *X, const int incX,
                   const double *Y, const int incY);
+
 /*
  * Functions having prefixes Z and C only
  */
@@ -33,12 +38,13 @@ void   cblas_cdotu_sub(const int N, const void *X, const int incX,
                        const void *Y, const int incY, void *dotu);
 void   cblas_cdotc_sub(const int N, const void *X, const int incX,
                        const void *Y, const int incY, void *dotc);
+void   cblas_crotg(void *a, void *b, void *c, void *s);
 
 void   cblas_zdotu_sub(const int N, const void *X, const int incX,
                        const void *Y, const int incY, void *dotu);
 void   cblas_zdotc_sub(const int N, const void *X, const int incX,
                        const void *Y, const int incY, void *dotc);
-
+void   cblas_zrotg(void *a, void *b, void *c, void *s);
 
 /*
  * Functions having prefixes S D SC DZ
@@ -64,73 +70,63 @@ CBLAS_INDEX cblas_idamax(const int N, const double *X, const int incX);
 CBLAS_INDEX cblas_icamax(const int N, const void   *X, const int incX);
 CBLAS_INDEX cblas_izamax(const int N, const void   *X, const int incX);
 
-
-/*
- * ===========================================================================
- * Prototypes for level 0 BLAS routines
- * ===========================================================================
- */
-void cblas_srotg(float a, float b, float c, float s);
-void cblas_crotg(complex a, complex b, complex c, float s);
-void cblas_drotg(double a, double b, double c, double s);
-void cblas_zrotg(doublecomplex a, doublecomplex b, doublecomplex c, double s);
-
-
 /*
  * ===========================================================================
  * Prototypes for level 1 BLAS routines
  * ===========================================================================
  */
 
-/*
+/* 
  * Routines with standard 4 prefixes (s, d, c, z)
  */
-void cblas_sswap(const int N, float *X, const int incX,
+void cblas_sswap(const int N, float *X, const int incX, 
                  float *Y, const int incY);
-void cblas_scopy(const int N, const float *X, const int incX,
+void cblas_scopy(const int N, const float *X, const int incX, 
                  float *Y, const int incY);
 void cblas_saxpy(const int N, const float alpha, const float *X,
                  const int incX, float *Y, const int incY);
 
-void cblas_dswap(const int N, double *X, const int incX,
+void cblas_dswap(const int N, double *X, const int incX, 
                  double *Y, const int incY);
-void cblas_dcopy(const int N, const double *X, const int incX,
+void cblas_dcopy(const int N, const double *X, const int incX, 
                  double *Y, const int incY);
 void cblas_daxpy(const int N, const double alpha, const double *X,
                  const int incX, double *Y, const int incY);
 
-void cblas_cswap(const int N, void *X, const int incX,
+void cblas_cswap(const int N, void *X, const int incX, 
                  void *Y, const int incY);
-void cblas_ccopy(const int N, const void *X, const int incX,
+void cblas_ccopy(const int N, const void *X, const int incX, 
                  void *Y, const int incY);
 void cblas_caxpy(const int N, const void *alpha, const void *X,
                  const int incX, void *Y, const int incY);
 
-void cblas_zswap(const int N, void *X, const int incX,
+void cblas_zswap(const int N, void *X, const int incX, 
                  void *Y, const int incY);
-void cblas_zcopy(const int N, const void *X, const int incX,
+void cblas_zcopy(const int N, const void *X, const int incX, 
                  void *Y, const int incY);
 void cblas_zaxpy(const int N, const void *alpha, const void *X,
                  const int incX, void *Y, const int incY);
 
 
-/*
+/* 
  * Routines with S and D prefix only
  */
+void cblas_srotg(float *a, float *b, float *c, float *s);
 void cblas_srotmg(float *d1, float *d2, float *b1, const float b2, float *P);
 void cblas_srot(const int N, float *X, const int incX,
                 float *Y, const int incY, const float c, const float s);
 void cblas_srotm(const int N, float *X, const int incX,
                 float *Y, const int incY, const float *P);
 
+void cblas_drotg(double *a, double *b, double *c, double *s);
 void cblas_drotmg(double *d1, double *d2, double *b1, const double b2, double *P);
 void cblas_drot(const int N, double *X, const int incX,
-                double *Y, const int incY, const double c, const double s);
+                double *Y, const int incY, const double c, const double  s);
 void cblas_drotm(const int N, double *X, const int incX,
                 double *Y, const int incY, const double *P);
 
 
-/*
+/* 
  * Routines with S D C Z CS and ZD prefixes
  */
 void cblas_sscal(const int N, const float alpha, float *X, const int incX);
@@ -146,266 +142,266 @@ void cblas_zdscal(const int N, const double alpha, void *X, const int incX);
  * ===========================================================================
  */
 
-/*
+/* 
  * Routines with standard 4 prefixes (S, D, C, Z)
  */
-void cblas_sgemv(const enum CBLAS_ORDER Order,
+void cblas_sgemv(const enum CBLAS_ORDER order,
                  const enum CBLAS_TRANSPOSE TransA, const int M, const int N,
                  const float alpha, const float *A, const int lda,
                  const float *X, const int incX, const float beta,
                  float *Y, const int incY);
-void cblas_sgbmv(const enum CBLAS_ORDER Order,
+void cblas_sgbmv(const enum CBLAS_ORDER order,
                  const enum CBLAS_TRANSPOSE TransA, const int M, const int N,
                  const int KL, const int KU, const float alpha,
                  const float *A, const int lda, const float *X,
                  const int incX, const float beta, float *Y, const int incY);
-void cblas_strmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_strmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
-                 const int N, const float *A, const int lda,
+                 const int N, const float *A, const int lda, 
                  float *X, const int incX);
-void cblas_stbmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_stbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
-                 const int N, const int K, const float *A, const int lda,
+                 const int N, const int K, const float *A, const int lda, 
                  float *X, const int incX);
-void cblas_stpmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_stpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                  const int N, const float *Ap, float *X, const int incX);
-void cblas_strsv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_strsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                  const int N, const float *A, const int lda, float *X,
                  const int incX);
-void cblas_stbsv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_stbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                  const int N, const int K, const float *A, const int lda,
                  float *X, const int incX);
-void cblas_stpsv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_stpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                  const int N, const float *Ap, float *X, const int incX);
 
-void cblas_dgemv(const enum CBLAS_ORDER Order,
+void cblas_dgemv(const enum CBLAS_ORDER order,
                  const enum CBLAS_TRANSPOSE TransA, const int M, const int N,
                  const double alpha, const double *A, const int lda,
                  const double *X, const int incX, const double beta,
                  double *Y, const int incY);
-void cblas_dgbmv(const enum CBLAS_ORDER Order,
+void cblas_dgbmv(const enum CBLAS_ORDER order,
                  const enum CBLAS_TRANSPOSE TransA, const int M, const int N,
                  const int KL, const int KU, const double alpha,
                  const double *A, const int lda, const double *X,
                  const int incX, const double beta, double *Y, const int incY);
-void cblas_dtrmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_dtrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
-                 const int N, const double *A, const int lda,
+                 const int N, const double *A, const int lda, 
                  double *X, const int incX);
-void cblas_dtbmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_dtbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
-                 const int N, const int K, const double *A, const int lda,
+                 const int N, const int K, const double *A, const int lda, 
                  double *X, const int incX);
-void cblas_dtpmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_dtpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                  const int N, const double *Ap, double *X, const int incX);
-void cblas_dtrsv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_dtrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                  const int N, const double *A, const int lda, double *X,
                  const int incX);
-void cblas_dtbsv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_dtbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                  const int N, const int K, const double *A, const int lda,
                  double *X, const int incX);
-void cblas_dtpsv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_dtpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                  const int N, const double *Ap, double *X, const int incX);
 
-void cblas_cgemv(const enum CBLAS_ORDER Order,
+void cblas_cgemv(const enum CBLAS_ORDER order,
                  const enum CBLAS_TRANSPOSE TransA, const int M, const int N,
                  const void *alpha, const void *A, const int lda,
                  const void *X, const int incX, const void *beta,
                  void *Y, const int incY);
-void cblas_cgbmv(const enum CBLAS_ORDER Order,
+void cblas_cgbmv(const enum CBLAS_ORDER order,
                  const enum CBLAS_TRANSPOSE TransA, const int M, const int N,
                  const int KL, const int KU, const void *alpha,
                  const void *A, const int lda, const void *X,
                  const int incX, const void *beta, void *Y, const int incY);
-void cblas_ctrmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_ctrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
-                 const int N, const void *A, const int lda,
+                 const int N, const void *A, const int lda, 
                  void *X, const int incX);
-void cblas_ctbmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_ctbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
-                 const int N, const int K, const void *A, const int lda,
+                 const int N, const int K, const void *A, const int lda, 
                  void *X, const int incX);
-void cblas_ctpmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_ctpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                  const int N, const void *Ap, void *X, const int incX);
-void cblas_ctrsv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_ctrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                  const int N, const void *A, const int lda, void *X,
                  const int incX);
-void cblas_ctbsv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_ctbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                  const int N, const int K, const void *A, const int lda,
                  void *X, const int incX);
-void cblas_ctpsv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_ctpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                  const int N, const void *Ap, void *X, const int incX);
 
-void cblas_zgemv(const enum CBLAS_ORDER Order,
+void cblas_zgemv(const enum CBLAS_ORDER order,
                  const enum CBLAS_TRANSPOSE TransA, const int M, const int N,
                  const void *alpha, const void *A, const int lda,
                  const void *X, const int incX, const void *beta,
                  void *Y, const int incY);
-void cblas_zgbmv(const enum CBLAS_ORDER Order,
+void cblas_zgbmv(const enum CBLAS_ORDER order,
                  const enum CBLAS_TRANSPOSE TransA, const int M, const int N,
                  const int KL, const int KU, const void *alpha,
                  const void *A, const int lda, const void *X,
                  const int incX, const void *beta, void *Y, const int incY);
-void cblas_ztrmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_ztrmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
-                 const int N, const void *A, const int lda,
+                 const int N, const void *A, const int lda, 
                  void *X, const int incX);
-void cblas_ztbmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_ztbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
-                 const int N, const int K, const void *A, const int lda,
+                 const int N, const int K, const void *A, const int lda, 
                  void *X, const int incX);
-void cblas_ztpmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_ztpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                  const int N, const void *Ap, void *X, const int incX);
-void cblas_ztrsv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_ztrsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                  const int N, const void *A, const int lda, void *X,
                  const int incX);
-void cblas_ztbsv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_ztbsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                  const int N, const int K, const void *A, const int lda,
                  void *X, const int incX);
-void cblas_ztpsv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_ztpsv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
                  const int N, const void *Ap, void *X, const int incX);
 
 
-/*
+/* 
  * Routines with S and D prefixes only
  */
-void cblas_ssymv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_ssymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const int N, const float alpha, const float *A,
                  const int lda, const float *X, const int incX,
                  const float beta, float *Y, const int incY);
-void cblas_ssbmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_ssbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const int N, const int K, const float alpha, const float *A,
                  const int lda, const float *X, const int incX,
                  const float beta, float *Y, const int incY);
-void cblas_sspmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_sspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const int N, const float alpha, const float *Ap,
                  const float *X, const int incX,
                  const float beta, float *Y, const int incY);
-void cblas_sger(const enum CBLAS_ORDER Order, const int M, const int N,
+void cblas_sger(const enum CBLAS_ORDER order, const int M, const int N,
                 const float alpha, const float *X, const int incX,
                 const float *Y, const int incY, float *A, const int lda);
-void cblas_ssyr(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_ssyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                 const int N, const float alpha, const float *X,
                 const int incX, float *A, const int lda);
-void cblas_sspr(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_sspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                 const int N, const float alpha, const float *X,
                 const int incX, float *Ap);
-void cblas_ssyr2(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_ssyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                 const int N, const float alpha, const float *X,
                 const int incX, const float *Y, const int incY, float *A,
                 const int lda);
-void cblas_sspr2(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_sspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                 const int N, const float alpha, const float *X,
                 const int incX, const float *Y, const int incY, float *A);
 
-void cblas_dsymv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_dsymv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const int N, const double alpha, const double *A,
                  const int lda, const double *X, const int incX,
                  const double beta, double *Y, const int incY);
-void cblas_dsbmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_dsbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const int N, const int K, const double alpha, const double *A,
                  const int lda, const double *X, const int incX,
                  const double beta, double *Y, const int incY);
-void cblas_dspmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_dspmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const int N, const double alpha, const double *Ap,
                  const double *X, const int incX,
                  const double beta, double *Y, const int incY);
-void cblas_dger(const enum CBLAS_ORDER Order, const int M, const int N,
+void cblas_dger(const enum CBLAS_ORDER order, const int M, const int N,
                 const double alpha, const double *X, const int incX,
                 const double *Y, const int incY, double *A, const int lda);
-void cblas_dsyr(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_dsyr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                 const int N, const double alpha, const double *X,
                 const int incX, double *A, const int lda);
-void cblas_dspr(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_dspr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                 const int N, const double alpha, const double *X,
                 const int incX, double *Ap);
-void cblas_dsyr2(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_dsyr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                 const int N, const double alpha, const double *X,
                 const int incX, const double *Y, const int incY, double *A,
                 const int lda);
-void cblas_dspr2(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_dspr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                 const int N, const double alpha, const double *X,
                 const int incX, const double *Y, const int incY, double *A);
 
 
-/*
+/* 
  * Routines with C and Z prefixes only
  */
-void cblas_chemv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_chemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const int N, const void *alpha, const void *A,
                  const int lda, const void *X, const int incX,
                  const void *beta, void *Y, const int incY);
-void cblas_chbmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_chbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const int N, const int K, const void *alpha, const void *A,
                  const int lda, const void *X, const int incX,
                  const void *beta, void *Y, const int incY);
-void cblas_chpmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_chpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const int N, const void *alpha, const void *Ap,
                  const void *X, const int incX,
                  const void *beta, void *Y, const int incY);
-void cblas_cgeru(const enum CBLAS_ORDER Order, const int M, const int N,
+void cblas_cgeru(const enum CBLAS_ORDER order, const int M, const int N,
                  const void *alpha, const void *X, const int incX,
                  const void *Y, const int incY, void *A, const int lda);
-void cblas_cgerc(const enum CBLAS_ORDER Order, const int M, const int N,
+void cblas_cgerc(const enum CBLAS_ORDER order, const int M, const int N,
                  const void *alpha, const void *X, const int incX,
                  const void *Y, const int incY, void *A, const int lda);
-void cblas_cher(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_cher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                 const int N, const float alpha, const void *X, const int incX,
                 void *A, const int lda);
-void cblas_chpr(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_chpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                 const int N, const float alpha, const void *X,
                 const int incX, void *A);
-void cblas_cher2(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const int N,
+void cblas_cher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N,
                 const void *alpha, const void *X, const int incX,
                 const void *Y, const int incY, void *A, const int lda);
-void cblas_chpr2(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const int N,
+void cblas_chpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N,
                 const void *alpha, const void *X, const int incX,
                 const void *Y, const int incY, void *Ap);
 
-void cblas_zhemv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_zhemv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const int N, const void *alpha, const void *A,
                  const int lda, const void *X, const int incX,
                  const void *beta, void *Y, const int incY);
-void cblas_zhbmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_zhbmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const int N, const int K, const void *alpha, const void *A,
                  const int lda, const void *X, const int incX,
                  const void *beta, void *Y, const int incY);
-void cblas_zhpmv(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_zhpmv(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                  const int N, const void *alpha, const void *Ap,
                  const void *X, const int incX,
                  const void *beta, void *Y, const int incY);
-void cblas_zgeru(const enum CBLAS_ORDER Order, const int M, const int N,
+void cblas_zgeru(const enum CBLAS_ORDER order, const int M, const int N,
                  const void *alpha, const void *X, const int incX,
                  const void *Y, const int incY, void *A, const int lda);
-void cblas_zgerc(const enum CBLAS_ORDER Order, const int M, const int N,
+void cblas_zgerc(const enum CBLAS_ORDER order, const int M, const int N,
                  const void *alpha, const void *X, const int incX,
                  const void *Y, const int incY, void *A, const int lda);
-void cblas_zher(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_zher(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                 const int N, const double alpha, const void *X, const int incX,
                 void *A, const int lda);
-void cblas_zhpr(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
+void cblas_zhpr(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
                 const int N, const double alpha, const void *X,
                 const int incX, void *A);
-void cblas_zher2(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const int N,
+void cblas_zher2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N,
                 const void *alpha, const void *X, const int incX,
                 const void *Y, const int incY, void *A, const int lda);
-void cblas_zhpr2(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const int N,
+void cblas_zhpr2(const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo, const int N,
                 const void *alpha, const void *X, const int incX,
                 const void *Y, const int incY, void *Ap);
 
@@ -415,7 +411,7 @@ void cblas_zhpr2(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo, const
  * ===========================================================================
  */
 
-/*
+/* 
  * Routines with standard 4 prefixes (S, D, C, Z)
  */
 void cblas_sgemm(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA,
@@ -539,7 +535,7 @@ void cblas_ztrsm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
                  void *B, const int ldb);
 
 
-/*
+/* 
  * Routines with prefixes C and Z only
  */
 void cblas_chemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
@@ -556,6 +552,7 @@ void cblas_cher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                   const void *alpha, const void *A, const int lda,
                   const void *B, const int ldb, const float beta,
                   void *C, const int ldc);
+
 void cblas_zhemm(const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
                  const enum CBLAS_UPLO Uplo, const int M, const int N,
                  const void *alpha, const void *A, const int lda,
@@ -571,7 +568,9 @@ void cblas_zher2k(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
                   const void *B, const int ldb, const double beta,
                   void *C, const int ldc);
 
-int cblas_errprn(int ierr, int info, char *form, ...);
-
+void cblas_xerbla(int p, const char *rout, const char *form, ...);
 
+#ifdef __cplusplus
+}
+#endif
 #endif
diff --git a/CLAPACK-3.2.1/BLAS/WRAP/cblaswr.c b/CLAPACK-3.2.1/BLAS/WRAP/cblaswr.c
index d1fb3b0..3f88e62 100644
--- a/CLAPACK-3.2.1/BLAS/WRAP/cblaswr.c
+++ b/CLAPACK-3.2.1/BLAS/WRAP/cblaswr.c
@@ -209,7 +209,7 @@ f2c_srotg(real* a,
 		  real* c,
 		  real* s)
 {
-    cblas_srotg(*a, *b, *c, *s);
+    cblas_srotg(a, b, c, s);
     return 0;
 }
 
@@ -219,7 +219,7 @@ f2c_crotg(complex* CA,
           complex* C,
           real* S)
 {
-    cblas_crotg(*CA, *CB, *C, *S);
+    cblas_crotg(CA, CB, C, S);
     return 0;
 }
 
@@ -229,7 +229,7 @@ f2c_drotg(doublereal* a,
           doublereal* c,
           doublereal* s)
 {
-    cblas_drotg(*a, *b, *c, *s);
+    cblas_drotg(a, b, c, s);
     return 0;
 }
 int
@@ -238,7 +238,7 @@ f2c_zrotg(doublecomplex* CA,
           doublecomplex* C,
           doublereal* S)
 {
-    cblas_zrotg(*CA, *CB, *C, *S);
+    cblas_zrotg(CA, CB, C, S);
     return 0;
 }
 /*
diff --git a/CLAPACK-3.2.1/INSTALL/tstiee.c b/CLAPACK-3.2.1/INSTALL/tstiee.c
index eb823d4..ac20c30 100644
--- a/CLAPACK-3.2.1/INSTALL/tstiee.c
+++ b/CLAPACK-3.2.1/INSTALL/tstiee.c
@@ -9,6 +9,7 @@
 
 		http://www.netlib.org/f2c/libf2c.zip
 */
+#include <string.h>
 
 #include "f2c.h"
 #include "blaswrap.h"
@@ -159,7 +160,7 @@ integer ilaenv_(integer *ispec, char *name__, char *opts, integer *n1,
     integer ret_val;
 
     /* Builtin functions */
-    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
+    /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
     integer s_cmp(char *, char *, ftnlen, ftnlen);
 
     /* Local variables */
diff --git a/CLAPACK-3.2.1/SRC/VARIANTS/LIB/.empty b/CLAPACK-3.2.1/SRC/VARIANTS/LIB/.empty
new file mode 100644
index 0000000..e69de29
diff --git a/CLAPACK-3.2.1/SRC/cbdsqr.c b/CLAPACK-3.2.1/SRC/cbdsqr.c
index 97c02ec..6634f9f 100644
--- a/CLAPACK-3.2.1/SRC/cbdsqr.c
+++ b/CLAPACK-3.2.1/SRC/cbdsqr.c
@@ -68,7 +68,8 @@ static real c_b72 = -1.f;
 , real *, real *, real *, real *, real *);
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
-	    *), xerbla_(char *, integer *);
+	    *);
+    void xerbla_(char *, integer *);
     real sminoa;
     extern /* Subroutine */ int slartg_(real *, real *, real *, real *, real *
 );
diff --git a/CLAPACK-3.2.1/SRC/cgbbrd.c b/CLAPACK-3.2.1/SRC/cgbbrd.c
index 113b54a..4af3467 100644
--- a/CLAPACK-3.2.1/SRC/cgbbrd.c
+++ b/CLAPACK-3.2.1/SRC/cgbbrd.c
@@ -52,8 +52,9 @@ static integer c__1 = 1;
     logical wantq;
     extern /* Subroutine */ int claset_(char *, integer *, integer *, complex 
 	    *, complex *, complex *, integer *), clartg_(complex *, 
-	    complex *, real *, complex *, complex *), xerbla_(char *, integer 
-	    *), clargv_(integer *, complex *, integer *, complex *, 
+	    complex *, real *, complex *, complex *);
+    void xerbla_(char *, integer *);
+    int clargv_(integer *, complex *, integer *, complex *, 
 	    integer *, real *, integer *), clartv_(integer *, complex *, 
 	    integer *, complex *, integer *, real *, complex *, integer *);
     logical wantpt;
diff --git a/CLAPACK-3.2.1/SRC/cgbcon.c b/CLAPACK-3.2.1/SRC/cgbcon.c
index 3e75842..5b83300 100644
--- a/CLAPACK-3.2.1/SRC/cgbcon.c
+++ b/CLAPACK-3.2.1/SRC/cgbcon.c
@@ -47,8 +47,8 @@ static integer c__1 = 1;
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int clatbs_(char *, char *, char *, char *, 
 	    integer *, integer *, complex *, integer *, complex *, real *, 
-	    real *, integer *), xerbla_(char *
-, integer *);
+	    real *, integer *);
+    void xerbla_(char *, integer *);
     real ainvnm;
     extern /* Subroutine */ int csrscl_(integer *, real *, complex *, integer 
 	    *);
diff --git a/CLAPACK-3.2.1/SRC/cgbequ.c b/CLAPACK-3.2.1/SRC/cgbequ.c
index 1469460..df41b29 100644
--- a/CLAPACK-3.2.1/SRC/cgbequ.c
+++ b/CLAPACK-3.2.1/SRC/cgbequ.c
@@ -28,7 +28,7 @@
     integer i__, j, kd;
     real rcmin, rcmax;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum, smlnum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/cgbequb.c b/CLAPACK-3.2.1/SRC/cgbequb.c
index 76cfdf9..d84953e 100644
--- a/CLAPACK-3.2.1/SRC/cgbequb.c
+++ b/CLAPACK-3.2.1/SRC/cgbequb.c
@@ -28,7 +28,7 @@
     integer i__, j, kd;
     real radix, rcmin, rcmax;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum, logrdx, smlnum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/cgbrfs.c b/CLAPACK-3.2.1/SRC/cgbrfs.c
index e2a720d..bd81297 100644
--- a/CLAPACK-3.2.1/SRC/cgbrfs.c
+++ b/CLAPACK-3.2.1/SRC/cgbrfs.c
@@ -55,7 +55,8 @@ static integer c__1 = 1;
 	    *, integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), cgbtrs_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  cgbtrs_(
 	    char *, integer *, integer *, integer *, integer *, complex *, 
 	    integer *, integer *, complex *, integer *, integer *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/cgbrfsx.c b/CLAPACK-3.2.1/SRC/cgbrfsx.c
index 4d24a80..e5280cb 100644
--- a/CLAPACK-3.2.1/SRC/cgbrfsx.c
+++ b/CLAPACK-3.2.1/SRC/cgbrfsx.c
@@ -64,7 +64,7 @@ static logical c_false = FALSE_;
 	    *, complex *, integer *, integer *, real *, real *, complex *, 
 	    real *, integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical colequ, notran, rowequ;
     extern integer ilaprec_(char *);
     integer ithresh, n_norms__;
diff --git a/CLAPACK-3.2.1/SRC/cgbsv.c b/CLAPACK-3.2.1/SRC/cgbsv.c
index fbbdc81..c242965 100644
--- a/CLAPACK-3.2.1/SRC/cgbsv.c
+++ b/CLAPACK-3.2.1/SRC/cgbsv.c
@@ -22,8 +22,9 @@
 
     /* Local variables */
     extern /* Subroutine */ int cgbtrf_(integer *, integer *, integer *, 
-	    integer *, complex *, integer *, integer *, integer *), xerbla_(
-	    char *, integer *), cgbtrs_(char *, integer *, integer *, 
+	    integer *, complex *, integer *, integer *, integer *);
+    void xerbla_(char *, integer *);
+    int cgbtrs_(char *, integer *, integer *, 
 	    integer *, integer *, complex *, integer *, integer *, complex *, 
 	    integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/cgbsvx.c b/CLAPACK-3.2.1/SRC/cgbsvx.c
index ed72200..dab0e6d 100644
--- a/CLAPACK-3.2.1/SRC/cgbsvx.c
+++ b/CLAPACK-3.2.1/SRC/cgbsvx.c
@@ -63,8 +63,8 @@ static integer c__1 = 1;
 	    *);
     logical nofact;
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
-	    *, integer *, complex *, integer *), xerbla_(char *, 
-	    integer *);
+	    *, integer *, complex *, integer *);
+    void xerbla_(char *, integer *);
     real bignum;
     extern /* Subroutine */ int cgbtrs_(char *, integer *, integer *, integer 
 	    *, integer *, complex *, integer *, integer *, complex *, integer 
diff --git a/CLAPACK-3.2.1/SRC/cgbsvxx.c b/CLAPACK-3.2.1/SRC/cgbsvxx.c
index ace9940..9a53982 100644
--- a/CLAPACK-3.2.1/SRC/cgbsvxx.c
+++ b/CLAPACK-3.2.1/SRC/cgbsvxx.c
@@ -44,8 +44,8 @@
 	    integer *, complex *, integer *, integer *, integer *);
     logical nofact;
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
-	    *, integer *, complex *, integer *), xerbla_(char *, 
-	    integer *);
+	    *, integer *, complex *, integer *);
+    void xerbla_(char *, integer *);
     real bignum;
     extern /* Subroutine */ int cgbtrs_(char *, integer *, integer *, integer 
 	    *, integer *, complex *, integer *, integer *, complex *, integer 
diff --git a/CLAPACK-3.2.1/SRC/cgbtf2.c b/CLAPACK-3.2.1/SRC/cgbtf2.c
index ddf5cf5..16b706f 100644
--- a/CLAPACK-3.2.1/SRC/cgbtf2.c
+++ b/CLAPACK-3.2.1/SRC/cgbtf2.c
@@ -35,7 +35,7 @@ static integer c__1 = 1;
 	    integer *, complex *, integer *, complex *, integer *), cswap_(
 	    integer *, complex *, integer *, complex *, integer *);
     extern integer icamax_(integer *, complex *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cgbtrf.c b/CLAPACK-3.2.1/SRC/cgbtrf.c
index 491eb8d..4117c55 100644
--- a/CLAPACK-3.2.1/SRC/cgbtrf.c
+++ b/CLAPACK-3.2.1/SRC/cgbtrf.c
@@ -49,7 +49,7 @@ static integer c__65 = 65;
 	    integer *, integer *, integer *, complex *, integer *, integer *, 
 	    integer *);
     extern integer icamax_(integer *, complex *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int claswp_(integer *, complex *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/cgbtrs.c b/CLAPACK-3.2.1/SRC/cgbtrs.c
index 358ed1a..d857658 100644
--- a/CLAPACK-3.2.1/SRC/cgbtrs.c
+++ b/CLAPACK-3.2.1/SRC/cgbtrs.c
@@ -37,8 +37,8 @@ static integer c__1 = 1;
 	    ctbsv_(char *, char *, char *, integer *, integer *, complex *, 
 	    integer *, complex *, integer *);
     logical lnoti;
-    extern /* Subroutine */ int clacgv_(integer *, complex *, integer *), 
-	    xerbla_(char *, integer *);
+    extern /* Subroutine */ int clacgv_(integer *, complex *, integer *);
+	void xerbla_(char *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/cgebak.c b/CLAPACK-3.2.1/SRC/cgebak.c
index d84eacb..9ddcfd5 100644
--- a/CLAPACK-3.2.1/SRC/cgebak.c
+++ b/CLAPACK-3.2.1/SRC/cgebak.c
@@ -29,7 +29,8 @@
 	    complex *, integer *);
     logical leftv;
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
-	    *), xerbla_(char *, integer *);
+	    *);
+    void xerbla_(char *, integer *);
     logical rightv;
 
 
diff --git a/CLAPACK-3.2.1/SRC/cgebal.c b/CLAPACK-3.2.1/SRC/cgebal.c
index 435e9a7..1112314 100644
--- a/CLAPACK-3.2.1/SRC/cgebal.c
+++ b/CLAPACK-3.2.1/SRC/cgebal.c
@@ -39,7 +39,8 @@ static integer c__1 = 1;
     extern integer icamax_(integer *, complex *, integer *);
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
-	    *), xerbla_(char *, integer *);
+	    *);
+    void xerbla_(char *, integer *);
     logical noconv;
 
 
diff --git a/CLAPACK-3.2.1/SRC/cgebd2.c b/CLAPACK-3.2.1/SRC/cgebd2.c
index 0b30141..905cf7a 100644
--- a/CLAPACK-3.2.1/SRC/cgebd2.c
+++ b/CLAPACK-3.2.1/SRC/cgebd2.c
@@ -34,8 +34,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int clarf_(char *, integer *, integer *, complex *
 , integer *, complex *, complex *, integer *, complex *), 
 	    clarfg_(integer *, complex *, complex *, integer *, complex *), 
-	    clacgv_(integer *, complex *, integer *), xerbla_(char *, integer 
-	    *);
+	    clacgv_(integer *, complex *, integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cgebrd.c b/CLAPACK-3.2.1/SRC/cgebrd.c
index 8e8e753..cfac63f 100644
--- a/CLAPACK-3.2.1/SRC/cgebrd.c
+++ b/CLAPACK-3.2.1/SRC/cgebrd.c
@@ -41,7 +41,8 @@ static integer c__2 = 2;
 	    integer *, real *, real *, complex *, complex *, complex *, 
 	    integer *), clabrd_(integer *, integer *, integer *, complex *, 
 	    integer *, real *, real *, complex *, complex *, complex *, 
-	    integer *, complex *, integer *), xerbla_(char *, integer *);
+	    integer *, complex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwrkx, ldwrky, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/cgecon.c b/CLAPACK-3.2.1/SRC/cgecon.c
index fe9d614..9eca229 100644
--- a/CLAPACK-3.2.1/SRC/cgecon.c
+++ b/CLAPACK-3.2.1/SRC/cgecon.c
@@ -39,7 +39,7 @@ static integer c__1 = 1;
 	    *, integer *, integer *);
     extern integer icamax_(integer *, complex *, integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real ainvnm;
     extern /* Subroutine */ int clatrs_(char *, char *, char *, char *, 
 	    integer *, complex *, integer *, complex *, real *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/cgeequ.c b/CLAPACK-3.2.1/SRC/cgeequ.c
index 84cf694..3c2520c 100644
--- a/CLAPACK-3.2.1/SRC/cgeequ.c
+++ b/CLAPACK-3.2.1/SRC/cgeequ.c
@@ -28,7 +28,7 @@
     integer i__, j;
     real rcmin, rcmax;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum, smlnum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/cgeequb.c b/CLAPACK-3.2.1/SRC/cgeequb.c
index 93318d0..002fc8d 100644
--- a/CLAPACK-3.2.1/SRC/cgeequb.c
+++ b/CLAPACK-3.2.1/SRC/cgeequb.c
@@ -28,7 +28,7 @@
     integer i__, j;
     real radix, rcmin, rcmax;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum, logrdx, smlnum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/cgees.c b/CLAPACK-3.2.1/SRC/cgees.c
index d113eb3..bb1bded 100644
--- a/CLAPACK-3.2.1/SRC/cgees.c
+++ b/CLAPACK-3.2.1/SRC/cgees.c
@@ -54,8 +54,8 @@ static integer c_n1 = -1;
 	    integer *, complex *, integer *, integer *);
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
-	    *, integer *, complex *, integer *), xerbla_(char *, 
-	    integer *);
+	    *, integer *, complex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     real bignum;
diff --git a/CLAPACK-3.2.1/SRC/cgeesx.c b/CLAPACK-3.2.1/SRC/cgeesx.c
index ea9c236..df761c6 100644
--- a/CLAPACK-3.2.1/SRC/cgeesx.c
+++ b/CLAPACK-3.2.1/SRC/cgeesx.c
@@ -52,8 +52,8 @@ static integer c_n1 = -1;
 	    integer *, complex *, integer *, integer *);
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
-	    *, integer *, complex *, integer *), xerbla_(char *, 
-	    integer *);
+	    *, integer *, complex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     real bignum;
diff --git a/CLAPACK-3.2.1/SRC/cgeev.c b/CLAPACK-3.2.1/SRC/cgeev.c
index 81a7b98..36ab747 100644
--- a/CLAPACK-3.2.1/SRC/cgeev.c
+++ b/CLAPACK-3.2.1/SRC/cgeev.c
@@ -63,7 +63,8 @@ static integer c_n1 = -1;
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
 	    *), clacpy_(char *, integer *, integer *, complex *, integer *, 
-	    complex *, integer *), xerbla_(char *, integer *);
+	    complex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical select[1];
diff --git a/CLAPACK-3.2.1/SRC/cgeevx.c b/CLAPACK-3.2.1/SRC/cgeevx.c
index 589c88d..9ff3c5d 100644
--- a/CLAPACK-3.2.1/SRC/cgeevx.c
+++ b/CLAPACK-3.2.1/SRC/cgeevx.c
@@ -63,7 +63,8 @@ static integer c_n1 = -1;
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
 	    *), clacpy_(char *, integer *, integer *, complex *, integer *, 
-	    complex *, integer *), xerbla_(char *, integer *);
+	    complex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical select[1];
diff --git a/CLAPACK-3.2.1/SRC/cgegs.c b/CLAPACK-3.2.1/SRC/cgegs.c
index f4d2a8e..8ce88f2 100644
--- a/CLAPACK-3.2.1/SRC/cgegs.c
+++ b/CLAPACK-3.2.1/SRC/cgegs.c
@@ -59,7 +59,7 @@ static integer c_n1 = -1;
 	    *, integer *, complex *, integer *), claset_(char *, 
 	    integer *, integer *, complex *, complex *, complex *, integer *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     real bignum;
diff --git a/CLAPACK-3.2.1/SRC/cgegv.c b/CLAPACK-3.2.1/SRC/cgegv.c
index 4841b04..e0c0dfe 100644
--- a/CLAPACK-3.2.1/SRC/cgegv.c
+++ b/CLAPACK-3.2.1/SRC/cgegv.c
@@ -77,8 +77,8 @@ static real c_b29 = 1.f;
     extern /* Subroutine */ int chgeqz_(char *, char *, char *, integer *, 
 	    integer *, integer *, complex *, integer *, complex *, integer *, 
 	    complex *, complex *, complex *, integer *, complex *, integer *, 
-	    complex *, integer *, real *, integer *), 
-	    xerbla_(char *, integer *);
+	    complex *, integer *, real *, integer *);
+	void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ijobvl, iright;
diff --git a/CLAPACK-3.2.1/SRC/cgehd2.c b/CLAPACK-3.2.1/SRC/cgehd2.c
index 8cbc13f..c47723c 100644
--- a/CLAPACK-3.2.1/SRC/cgehd2.c
+++ b/CLAPACK-3.2.1/SRC/cgehd2.c
@@ -32,8 +32,8 @@ static integer c__1 = 1;
     complex alpha;
     extern /* Subroutine */ int clarf_(char *, integer *, integer *, complex *
 , integer *, complex *, complex *, integer *, complex *), 
-	    clarfg_(integer *, complex *, complex *, integer *, complex *), 
-	    xerbla_(char *, integer *);
+	    clarfg_(integer *, complex *, complex *, integer *, complex *);
+	void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cgehrd.c b/CLAPACK-3.2.1/SRC/cgehrd.c
index 0cf4b2d..0ca3f99 100644
--- a/CLAPACK-3.2.1/SRC/cgehrd.c
+++ b/CLAPACK-3.2.1/SRC/cgehrd.c
@@ -49,7 +49,8 @@ static integer c__65 = 65;
 	    complex *, integer *, complex *, complex *, integer *, complex *, 
 	    integer *), clarfb_(char *, char *, char *, char *, integer *, 
 	    integer *, integer *, complex *, integer *, complex *, integer *, 
-	    complex *, integer *, complex *, integer *), xerbla_(char *, integer *);
+	    complex *, integer *, complex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwork, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/cgelq2.c b/CLAPACK-3.2.1/SRC/cgelq2.c
index 04a23f8..9445bc5 100644
--- a/CLAPACK-3.2.1/SRC/cgelq2.c
+++ b/CLAPACK-3.2.1/SRC/cgelq2.c
@@ -25,8 +25,8 @@
     extern /* Subroutine */ int clarf_(char *, integer *, integer *, complex *
 , integer *, complex *, complex *, integer *, complex *), 
 	    clacgv_(integer *, complex *, integer *), clarfp_(integer *, 
-	    complex *, complex *, integer *, complex *), xerbla_(char *, 
-	    integer *);
+	    complex *, complex *, integer *, complex *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cgelqf.c b/CLAPACK-3.2.1/SRC/cgelqf.c
index 9c62f96..d7d0e2b 100644
--- a/CLAPACK-3.2.1/SRC/cgelqf.c
+++ b/CLAPACK-3.2.1/SRC/cgelqf.c
@@ -34,7 +34,8 @@ static integer c__2 = 2;
 	    integer *, complex *, integer *, complex *, integer *, complex *, 
 	    integer *), clarft_(char *, char *
 , integer *, integer *, complex *, integer *, complex *, complex *
-, integer *), xerbla_(char *, integer *);
+, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwork, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/cgels.c b/CLAPACK-3.2.1/SRC/cgels.c
index 3385ab8..2f4dbff 100644
--- a/CLAPACK-3.2.1/SRC/cgels.c
+++ b/CLAPACK-3.2.1/SRC/cgels.c
@@ -48,7 +48,8 @@ static integer c__0 = 0;
     extern /* Subroutine */ int cgeqrf_(integer *, integer *, complex *, 
 	    integer *, complex *, complex *, integer *, integer *), claset_(
 	    char *, integer *, integer *, complex *, complex *, complex *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer scllen;
diff --git a/CLAPACK-3.2.1/SRC/cgelsd.c b/CLAPACK-3.2.1/SRC/cgelsd.c
index c949a93..b8db1b8 100644
--- a/CLAPACK-3.2.1/SRC/cgelsd.c
+++ b/CLAPACK-3.2.1/SRC/cgelsd.c
@@ -55,7 +55,8 @@ static real c_b80 = 0.f;
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
 	    *, integer *, complex *, integer *), claset_(char *, 
-	    integer *, integer *, complex *, complex *, complex *, integer *), xerbla_(char *, integer *);
+	    integer *, integer *, complex *, complex *, complex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     real bignum;
diff --git a/CLAPACK-3.2.1/SRC/cgelss.c b/CLAPACK-3.2.1/SRC/cgelss.c
index 24729a7..4baed73 100644
--- a/CLAPACK-3.2.1/SRC/cgelss.c
+++ b/CLAPACK-3.2.1/SRC/cgelss.c
@@ -63,7 +63,9 @@ static real c_b78 = 0.f;
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
 	    *, integer *, complex *, integer *), claset_(char *, 
-	    integer *, integer *, complex *, complex *, complex *, integer *), xerbla_(char *, integer *), cbdsqr_(char *, 
+	    integer *, integer *, complex *, complex *, complex *, integer *);
+    void xerbla_(char *, integer *);
+    int cbdsqr_(char *, 
 	    integer *, integer *, integer *, integer *, real *, real *, 
 	    complex *, integer *, complex *, integer *, complex *, integer *, 
 	    real *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/cgelsx.c b/CLAPACK-3.2.1/SRC/cgelsx.c
index d75a178..c160a7e 100644
--- a/CLAPACK-3.2.1/SRC/cgelsx.c
+++ b/CLAPACK-3.2.1/SRC/cgelsx.c
@@ -53,8 +53,8 @@ static integer c__1 = 1;
 	    integer *, complex *, complex *, real *, integer *);
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int claset_(char *, integer *, integer *, complex 
-	    *, complex *, complex *, integer *), xerbla_(char *, 
-	    integer *);
+	    *, complex *, complex *, integer *);
+    void xerbla_(char *, integer *);
     real bignum;
     extern /* Subroutine */ int clatzm_(char *, integer *, integer *, complex 
 	    *, integer *, complex *, complex *, complex *, integer *, complex 
diff --git a/CLAPACK-3.2.1/SRC/cgelsy.c b/CLAPACK-3.2.1/SRC/cgelsy.c
index 836bfd0..54f45f8 100644
--- a/CLAPACK-3.2.1/SRC/cgelsy.c
+++ b/CLAPACK-3.2.1/SRC/cgelsy.c
@@ -59,8 +59,8 @@ static integer c__2 = 2;
 	    real *, integer *, integer *, complex *, integer *, integer *);
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int claset_(char *, integer *, integer *, complex 
-	    *, complex *, complex *, integer *), xerbla_(char *, 
-	    integer *);
+	    *, complex *, complex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     real bignum;
diff --git a/CLAPACK-3.2.1/SRC/cgeql2.c b/CLAPACK-3.2.1/SRC/cgeql2.c
index e261411..fe52886 100644
--- a/CLAPACK-3.2.1/SRC/cgeql2.c
+++ b/CLAPACK-3.2.1/SRC/cgeql2.c
@@ -32,8 +32,8 @@ static integer c__1 = 1;
     complex alpha;
     extern /* Subroutine */ int clarf_(char *, integer *, integer *, complex *
 , integer *, complex *, complex *, integer *, complex *), 
-	    clarfp_(integer *, complex *, complex *, integer *, complex *), 
-	    xerbla_(char *, integer *);
+	    clarfp_(integer *, complex *, complex *, integer *, complex *);
+	void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cgeqlf.c b/CLAPACK-3.2.1/SRC/cgeqlf.c
index 9437d05..b9af7e2 100644
--- a/CLAPACK-3.2.1/SRC/cgeqlf.c
+++ b/CLAPACK-3.2.1/SRC/cgeqlf.c
@@ -34,7 +34,8 @@ static integer c__2 = 2;
 	    integer *, complex *, integer *, complex *, integer *, complex *, 
 	    integer *), clarft_(char *, char *
 , integer *, integer *, complex *, integer *, complex *, complex *
-, integer *), xerbla_(char *, integer *);
+, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwork, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/cgeqp3.c b/CLAPACK-3.2.1/SRC/cgeqp3.c
index f07fa2d..66d2cdb 100644
--- a/CLAPACK-3.2.1/SRC/cgeqp3.c
+++ b/CLAPACK-3.2.1/SRC/cgeqp3.c
@@ -37,8 +37,8 @@ static integer c__2 = 2;
 	    complex *);
     extern doublereal scnrm2_(integer *, complex *, integer *);
     extern /* Subroutine */ int cgeqrf_(integer *, integer *, complex *, 
-	    integer *, complex *, complex *, integer *, integer *), xerbla_(
-	    char *, integer *);
+	    integer *, complex *, complex *, integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int claqps_(integer *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/cgeqpf.c b/CLAPACK-3.2.1/SRC/cgeqpf.c
index b341824..a99643a 100644
--- a/CLAPACK-3.2.1/SRC/cgeqpf.c
+++ b/CLAPACK-3.2.1/SRC/cgeqpf.c
@@ -48,7 +48,7 @@ static integer c__1 = 1;
 	    complex *, integer *), clarfp_(integer *, complex 
 	    *, complex *, integer *, complex *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/cgeqr2.c b/CLAPACK-3.2.1/SRC/cgeqr2.c
index 8c46a05..3cc48fd 100644
--- a/CLAPACK-3.2.1/SRC/cgeqr2.c
+++ b/CLAPACK-3.2.1/SRC/cgeqr2.c
@@ -32,8 +32,8 @@ static integer c__1 = 1;
     complex alpha;
     extern /* Subroutine */ int clarf_(char *, integer *, integer *, complex *
 , integer *, complex *, complex *, integer *, complex *), 
-	    clarfp_(integer *, complex *, complex *, integer *, complex *), 
-	    xerbla_(char *, integer *);
+	    clarfp_(integer *, complex *, complex *, integer *, complex *);
+	void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cgeqrf.c b/CLAPACK-3.2.1/SRC/cgeqrf.c
index c473abe..a241f38 100644
--- a/CLAPACK-3.2.1/SRC/cgeqrf.c
+++ b/CLAPACK-3.2.1/SRC/cgeqrf.c
@@ -34,7 +34,8 @@ static integer c__2 = 2;
 	    integer *, complex *, integer *, complex *, integer *, complex *, 
 	    integer *), clarft_(char *, char *
 , integer *, integer *, complex *, integer *, complex *, complex *
-, integer *), xerbla_(char *, integer *);
+, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwork, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/cgerfs.c b/CLAPACK-3.2.1/SRC/cgerfs.c
index c9f854c..9922545 100644
--- a/CLAPACK-3.2.1/SRC/cgerfs.c
+++ b/CLAPACK-3.2.1/SRC/cgerfs.c
@@ -52,7 +52,8 @@ static integer c__1 = 1;
 	    *, integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), cgetrs_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  cgetrs_(
 	    char *, integer *, integer *, complex *, integer *, integer *, 
 	    complex *, integer *, integer *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/cgerfsx.c b/CLAPACK-3.2.1/SRC/cgerfsx.c
index ffc7073..8d1e5e6 100644
--- a/CLAPACK-3.2.1/SRC/cgerfsx.c
+++ b/CLAPACK-3.2.1/SRC/cgerfsx.c
@@ -62,7 +62,7 @@ static logical c_false = FALSE_;
     extern /* Subroutine */ int cgecon_(char *, integer *, complex *, integer 
 	    *, real *, real *, complex *, real *, integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical colequ, notran, rowequ;
     extern integer ilaprec_(char *);
     integer ithresh, n_norms__;
diff --git a/CLAPACK-3.2.1/SRC/cgerq2.c b/CLAPACK-3.2.1/SRC/cgerq2.c
index 885c716..0a50d48 100644
--- a/CLAPACK-3.2.1/SRC/cgerq2.c
+++ b/CLAPACK-3.2.1/SRC/cgerq2.c
@@ -25,8 +25,8 @@
     extern /* Subroutine */ int clarf_(char *, integer *, integer *, complex *
 , integer *, complex *, complex *, integer *, complex *), 
 	    clacgv_(integer *, complex *, integer *), clarfp_(integer *, 
-	    complex *, complex *, integer *, complex *), xerbla_(char *, 
-	    integer *);
+	    complex *, complex *, integer *, complex *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cgerqf.c b/CLAPACK-3.2.1/SRC/cgerqf.c
index 204b487..2ebfc2f 100644
--- a/CLAPACK-3.2.1/SRC/cgerqf.c
+++ b/CLAPACK-3.2.1/SRC/cgerqf.c
@@ -34,7 +34,8 @@ static integer c__2 = 2;
 	    integer *, complex *, integer *, complex *, integer *, complex *, 
 	    integer *), clarft_(char *, char *
 , integer *, integer *, complex *, integer *, complex *, complex *
-, integer *), xerbla_(char *, integer *);
+, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwork, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/cgesdd.c b/CLAPACK-3.2.1/SRC/cgesdd.c
index 6149ae7..4c32e32 100644
--- a/CLAPACK-3.2.1/SRC/cgesdd.c
+++ b/CLAPACK-3.2.1/SRC/cgesdd.c
@@ -68,7 +68,8 @@ static integer c__0 = 0;
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
 	    *, integer *, complex *, integer *), claset_(char *, 
-	    integer *, integer *, complex *, complex *, complex *, integer *), xerbla_(char *, integer *);
+	    integer *, integer *, complex *, complex *, complex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int cungbr_(char *, integer *, integer *, integer 
diff --git a/CLAPACK-3.2.1/SRC/cgesv.c b/CLAPACK-3.2.1/SRC/cgesv.c
index 1d3ea37..1f293ac 100644
--- a/CLAPACK-3.2.1/SRC/cgesv.c
+++ b/CLAPACK-3.2.1/SRC/cgesv.c
@@ -21,7 +21,9 @@
 
     /* Local variables */
     extern /* Subroutine */ int cgetrf_(integer *, integer *, complex *, 
-	    integer *, integer *, integer *), xerbla_(char *, integer *), cgetrs_(char *, integer *, integer *, complex *, integer 
+	    integer *, integer *, integer *);
+    void xerbla_(char *, integer *);
+    int cgetrs_(char *, integer *, integer *, complex *, integer 
 	    *, integer *, complex *, integer *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/cgesvd.c b/CLAPACK-3.2.1/SRC/cgesvd.c
index f6b5b7c..85465cf 100644
--- a/CLAPACK-3.2.1/SRC/cgesvd.c
+++ b/CLAPACK-3.2.1/SRC/cgesvd.c
@@ -35,7 +35,7 @@ static integer c_n1 = -1;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
     double sqrt(doublereal);
 
     /* Local variables */
@@ -68,8 +68,10 @@ static integer c_n1 = -1;
 	    *, integer *, complex *, integer *), claset_(char *, 
 	    integer *, integer *, complex *, complex *, complex *, integer *), cbdsqr_(char *, integer *, integer *, integer *, integer 
 	    *, real *, real *, complex *, integer *, complex *, integer *, 
-	    complex *, integer *, real *, integer *), xerbla_(char *, 
-	    integer *), cungbr_(char *, integer *, integer *, integer 
+	    complex *, integer *, real *, integer *);
+    void xerbla_(char *, 
+	    integer *);
+    int cungbr_(char *, integer *, integer *, integer 
 	    *, complex *, integer *, complex *, complex *, integer *, integer 
 	    *);
     real bignum;
diff --git a/CLAPACK-3.2.1/SRC/cgesvx.c b/CLAPACK-3.2.1/SRC/cgesvx.c
index 3dffd52..700afeb 100644
--- a/CLAPACK-3.2.1/SRC/cgesvx.c
+++ b/CLAPACK-3.2.1/SRC/cgesvx.c
@@ -48,8 +48,8 @@
 	    *, complex *, integer *, real *, real *, complex *, real *, 
 	    integer *), cgetrf_(integer *, integer *, complex *, 
 	    integer *, integer *, integer *), clacpy_(char *, integer *, 
-	    integer *, complex *, integer *, complex *, integer *), 
-	    xerbla_(char *, integer *);
+	    integer *, complex *, integer *, complex *, integer *);
+	void xerbla_(char *, integer *);
     real bignum;
     extern doublereal clantr_(char *, char *, char *, integer *, integer *, 
 	    complex *, integer *, real *);
diff --git a/CLAPACK-3.2.1/SRC/cgesvxx.c b/CLAPACK-3.2.1/SRC/cgesvxx.c
index 3fc32de..52027cc 100644
--- a/CLAPACK-3.2.1/SRC/cgesvxx.c
+++ b/CLAPACK-3.2.1/SRC/cgesvxx.c
@@ -43,8 +43,8 @@
     logical nofact;
     extern /* Subroutine */ int cgetrf_(integer *, integer *, complex *, 
 	    integer *, integer *, integer *), clacpy_(char *, integer *, 
-	    integer *, complex *, integer *, complex *, integer *), 
-	    xerbla_(char *, integer *);
+	    integer *, complex *, integer *, complex *, integer *);
+	void xerbla_(char *, integer *);
     real bignum;
     integer infequ;
     logical colequ;
diff --git a/CLAPACK-3.2.1/SRC/cgetf2.c b/CLAPACK-3.2.1/SRC/cgetf2.c
index e41b695..9e67cda 100644
--- a/CLAPACK-3.2.1/SRC/cgetf2.c
+++ b/CLAPACK-3.2.1/SRC/cgetf2.c
@@ -39,7 +39,7 @@ static integer c__1 = 1;
 	    complex *, integer *);
     extern integer icamax_(integer *, complex *, integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cgetrf.c b/CLAPACK-3.2.1/SRC/cgetrf.c
index 0798e8f..b8a1201 100644
--- a/CLAPACK-3.2.1/SRC/cgetrf.c
+++ b/CLAPACK-3.2.1/SRC/cgetrf.c
@@ -35,8 +35,8 @@ static integer c_n1 = -1;
     extern /* Subroutine */ int ctrsm_(char *, char *, char *, char *, 
 	    integer *, integer *, complex *, complex *, integer *, complex *, 
 	    integer *), cgetf2_(integer *, 
-	    integer *, complex *, integer *, integer *, integer *), xerbla_(
-	    char *, integer *);
+	    integer *, complex *, integer *, integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int claswp_(integer *, complex *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/cgetri.c b/CLAPACK-3.2.1/SRC/cgetri.c
index e849bfd..c61fb46 100644
--- a/CLAPACK-3.2.1/SRC/cgetri.c
+++ b/CLAPACK-3.2.1/SRC/cgetri.c
@@ -41,7 +41,7 @@ static integer c__2 = 2;
 	    integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer ldwork;
     extern /* Subroutine */ int ctrtri_(char *, char *, integer *, complex *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/cgetrs.c b/CLAPACK-3.2.1/SRC/cgetrs.c
index e0bcf1f..29055a2 100644
--- a/CLAPACK-3.2.1/SRC/cgetrs.c
+++ b/CLAPACK-3.2.1/SRC/cgetrs.c
@@ -30,8 +30,9 @@ static integer c_n1 = -1;
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int ctrsm_(char *, char *, char *, char *, 
 	    integer *, integer *, complex *, complex *, integer *, complex *, 
-	    integer *), xerbla_(char *, 
-	    integer *), claswp_(integer *, complex *, integer *, 
+	    integer *);
+    void xerbla_(char *, integer *);
+    int claswp_(integer *, complex *, integer *, 
 	    integer *, integer *, integer *, integer *);
     logical notran;
 
diff --git a/CLAPACK-3.2.1/SRC/cggbak.c b/CLAPACK-3.2.1/SRC/cggbak.c
index 643170b..5ec6153 100644
--- a/CLAPACK-3.2.1/SRC/cggbak.c
+++ b/CLAPACK-3.2.1/SRC/cggbak.c
@@ -27,7 +27,8 @@
 	    complex *, integer *);
     logical leftv;
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
-	    *), xerbla_(char *, integer *);
+	    *);
+    void xerbla_(char *, integer *);
     logical rightv;
 
 
diff --git a/CLAPACK-3.2.1/SRC/cggbal.c b/CLAPACK-3.2.1/SRC/cggbal.c
index c12f5ea..33775be 100644
--- a/CLAPACK-3.2.1/SRC/cggbal.c
+++ b/CLAPACK-3.2.1/SRC/cggbal.c
@@ -59,7 +59,8 @@ static real c_b72 = .5f;
     extern integer icamax_(integer *, complex *, integer *);
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
-	    *), xerbla_(char *, integer *);
+	    *);
+    void xerbla_(char *, integer *);
     integer lsfmin, lsfmax;
 
 
diff --git a/CLAPACK-3.2.1/SRC/cgges.c b/CLAPACK-3.2.1/SRC/cgges.c
index b19048d..7b05400 100644
--- a/CLAPACK-3.2.1/SRC/cgges.c
+++ b/CLAPACK-3.2.1/SRC/cgges.c
@@ -63,7 +63,8 @@ static integer c_n1 = -1;
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
 	    *, integer *, complex *, integer *), claset_(char *, 
-	    integer *, integer *, complex *, complex *, complex *, integer *), xerbla_(char *, integer *);
+	    integer *, integer *, complex *, complex *, complex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     real bignum;
diff --git a/CLAPACK-3.2.1/SRC/cggesx.c b/CLAPACK-3.2.1/SRC/cggesx.c
index 57667e1..83e2e00 100644
--- a/CLAPACK-3.2.1/SRC/cggesx.c
+++ b/CLAPACK-3.2.1/SRC/cggesx.c
@@ -64,7 +64,8 @@ static integer c_n1 = -1;
 	    integer *, complex *, complex *, integer *, integer *), clacpy_(
 	    char *, integer *, integer *, complex *, integer *, complex *, 
 	    integer *), claset_(char *, integer *, integer *, complex 
-	    *, complex *, complex *, integer *), xerbla_(char *, 
+	    *, complex *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/cggev.c b/CLAPACK-3.2.1/SRC/cggev.c
index 615ac57..104c885 100644
--- a/CLAPACK-3.2.1/SRC/cggev.c
+++ b/CLAPACK-3.2.1/SRC/cggev.c
@@ -66,7 +66,8 @@ static integer c_n1 = -1;
 	    *, integer *, complex *, integer *), claset_(char *, 
 	    integer *, integer *, complex *, complex *, complex *, integer *), ctgevc_(char *, char *, logical *, integer *, complex *, 
 	    integer *, complex *, integer *, complex *, integer *, complex *, 
-	    integer *, integer *, integer *, complex *, real *, integer *), xerbla_(char *, integer *);
+	    integer *, integer *, integer *, complex *, real *, integer *);
+    void xerbla_(char *, integer *);
     logical ldumma[1];
     char chtemp[1];
     real bignum;
diff --git a/CLAPACK-3.2.1/SRC/cggevx.c b/CLAPACK-3.2.1/SRC/cggevx.c
index 5c1a1b3..f56014a 100644
--- a/CLAPACK-3.2.1/SRC/cggevx.c
+++ b/CLAPACK-3.2.1/SRC/cggevx.c
@@ -84,7 +84,8 @@ static integer c__0 = 0;
 	    integer *, integer *);
     integer ijobvl;
     extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *, 
-	    real *, integer *, integer *, real *, integer *, integer *), xerbla_(char *, integer *);
+	    real *, integer *, integer *, real *, integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern doublereal slamch_(char *);
diff --git a/CLAPACK-3.2.1/SRC/cggglm.c b/CLAPACK-3.2.1/SRC/cggglm.c
index a8ec88d..1f003c4 100644
--- a/CLAPACK-3.2.1/SRC/cggglm.c
+++ b/CLAPACK-3.2.1/SRC/cggglm.c
@@ -34,7 +34,8 @@ static integer c_n1 = -1;
 , integer *), ccopy_(integer *, complex *, integer *, 
 	    complex *, integer *), cggqrf_(integer *, integer *, integer *, 
 	    complex *, integer *, complex *, complex *, integer *, complex *, 
-	    complex *, integer *, integer *), xerbla_(char *, integer *);
+	    complex *, integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer lwkmin;
diff --git a/CLAPACK-3.2.1/SRC/cgghrd.c b/CLAPACK-3.2.1/SRC/cgghrd.c
index 18bc120..f11f9c4 100644
--- a/CLAPACK-3.2.1/SRC/cgghrd.c
+++ b/CLAPACK-3.2.1/SRC/cgghrd.c
@@ -43,7 +43,8 @@ static integer c__1 = 1;
     complex ctemp;
     extern /* Subroutine */ int claset_(char *, integer *, integer *, complex 
 	    *, complex *, complex *, integer *), clartg_(complex *, 
-	    complex *, real *, complex *, complex *), xerbla_(char *, integer 
+	    complex *, real *, complex *, complex *);
+    void xerbla_(char *, integer 
 	    *);
     integer icompq, icompz;
 
diff --git a/CLAPACK-3.2.1/SRC/cgglse.c b/CLAPACK-3.2.1/SRC/cgglse.c
index a57f3d4..ee6dcc1 100644
--- a/CLAPACK-3.2.1/SRC/cgglse.c
+++ b/CLAPACK-3.2.1/SRC/cgglse.c
@@ -36,7 +36,8 @@ static integer c_n1 = -1;
 	    integer *, complex *, integer *), ctrmv_(char *, char *, char *, 
 	    integer *, complex *, integer *, complex *, integer *), cggrqf_(integer *, integer *, integer *, complex 
 	    *, integer *, complex *, complex *, integer *, complex *, complex 
-	    *, integer *, integer *), xerbla_(char *, integer *);
+	    *, integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer lwkmin;
diff --git a/CLAPACK-3.2.1/SRC/cggqrf.c b/CLAPACK-3.2.1/SRC/cggqrf.c
index 41c861a..c69f169 100644
--- a/CLAPACK-3.2.1/SRC/cggqrf.c
+++ b/CLAPACK-3.2.1/SRC/cggqrf.c
@@ -30,7 +30,8 @@ static integer c_n1 = -1;
     extern /* Subroutine */ int cgeqrf_(integer *, integer *, complex *, 
 	    integer *, complex *, complex *, integer *, integer *), cgerqf_(
 	    integer *, integer *, complex *, integer *, complex *, complex *, 
-	    integer *, integer *), xerbla_(char *, integer *);
+	    integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int cunmqr_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/cggrqf.c b/CLAPACK-3.2.1/SRC/cggrqf.c
index 2653aea..48fbcc7 100644
--- a/CLAPACK-3.2.1/SRC/cggrqf.c
+++ b/CLAPACK-3.2.1/SRC/cggrqf.c
@@ -30,7 +30,8 @@ static integer c_n1 = -1;
     extern /* Subroutine */ int cgeqrf_(integer *, integer *, complex *, 
 	    integer *, complex *, complex *, integer *, integer *), cgerqf_(
 	    integer *, integer *, complex *, integer *, complex *, complex *, 
-	    integer *, integer *), xerbla_(char *, integer *);
+	    integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int cunmrq_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/cggsvd.c b/CLAPACK-3.2.1/SRC/cggsvd.c
index 9415098..7b3176f 100644
--- a/CLAPACK-3.2.1/SRC/cggsvd.c
+++ b/CLAPACK-3.2.1/SRC/cggsvd.c
@@ -48,7 +48,8 @@ static integer c__1 = 1;
 	    integer *, complex *, integer *, complex *, integer *, complex *, 
 	    integer *, integer *);
     integer ncycle;
-    extern /* Subroutine */ int xerbla_(char *, integer *), cggsvp_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  cggsvp_(
 	    char *, char *, char *, integer *, integer *, integer *, complex *
 , integer *, complex *, integer *, real *, real *, integer *, 
 	    integer *, complex *, integer *, complex *, integer *, complex *, 
diff --git a/CLAPACK-3.2.1/SRC/cggsvp.c b/CLAPACK-3.2.1/SRC/cggsvp.c
index 6f21946..dd58dcf 100644
--- a/CLAPACK-3.2.1/SRC/cggsvp.c
+++ b/CLAPACK-3.2.1/SRC/cggsvp.c
@@ -49,8 +49,10 @@ static complex c_b2 = {1.f,0.f};
 	    integer *, complex *, complex *, real *, integer *), clacpy_(char 
 	    *, integer *, integer *, complex *, integer *, complex *, integer 
 	    *), claset_(char *, integer *, integer *, complex *, 
-	    complex *, complex *, integer *), xerbla_(char *, integer 
-	    *), clapmt_(logical *, integer *, integer *, complex *, 
+	    complex *, complex *, integer *);
+    void xerbla_(char *, integer 
+	    *);
+    int clapmt_(logical *, integer *, integer *, complex *, 
 	    integer *, integer *);
     logical forwrd;
 
diff --git a/CLAPACK-3.2.1/SRC/cgtcon.c b/CLAPACK-3.2.1/SRC/cgtcon.c
index 462a36a..14ee105 100644
--- a/CLAPACK-3.2.1/SRC/cgtcon.c
+++ b/CLAPACK-3.2.1/SRC/cgtcon.c
@@ -29,7 +29,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     integer isave[3];
     extern /* Subroutine */ int clacn2_(integer *, complex *, complex *, real 
-	    *, integer *, integer *), xerbla_(char *, integer *);
+	    *, integer *, integer *);
+    void xerbla_(char *, integer *);
     real ainvnm;
     logical onenrm;
     extern /* Subroutine */ int cgttrs_(char *, integer *, integer *, complex 
diff --git a/CLAPACK-3.2.1/SRC/cgtrfs.c b/CLAPACK-3.2.1/SRC/cgtrfs.c
index 8589822..feaaf7e 100644
--- a/CLAPACK-3.2.1/SRC/cgtrfs.c
+++ b/CLAPACK-3.2.1/SRC/cgtrfs.c
@@ -55,7 +55,7 @@ static complex c_b26 = {1.f,0.f};
 	    real *, complex *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
     char transn[1];
     extern /* Subroutine */ int cgttrs_(char *, integer *, integer *, complex 
diff --git a/CLAPACK-3.2.1/SRC/cgtsv.c b/CLAPACK-3.2.1/SRC/cgtsv.c
index 57a1e32..e1b7b46 100644
--- a/CLAPACK-3.2.1/SRC/cgtsv.c
+++ b/CLAPACK-3.2.1/SRC/cgtsv.c
@@ -28,7 +28,7 @@
     /* Local variables */
     integer j, k;
     complex temp, mult;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cgtsvx.c b/CLAPACK-3.2.1/SRC/cgtsvx.c
index 9e99fb0..91ad860 100644
--- a/CLAPACK-3.2.1/SRC/cgtsvx.c
+++ b/CLAPACK-3.2.1/SRC/cgtsvx.c
@@ -38,8 +38,10 @@ static integer c__1 = 1;
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
 	    *, integer *, complex *, integer *), cgtcon_(char *, 
 	    integer *, complex *, complex *, complex *, complex *, integer *, 
-	    real *, real *, complex *, integer *), xerbla_(char *, 
-	    integer *), cgtrfs_(char *, integer *, integer *, complex 
+	    real *, real *, complex *, integer *);
+    void xerbla_(char *, 
+	    integer *);
+    int cgtrfs_(char *, integer *, integer *, complex 
 	    *, complex *, complex *, complex *, complex *, complex *, complex 
 	    *, integer *, complex *, integer *, complex *, integer *, real *, 
 	    real *, complex *, real *, integer *), cgttrf_(integer *, 
diff --git a/CLAPACK-3.2.1/SRC/cgttrf.c b/CLAPACK-3.2.1/SRC/cgttrf.c
index b6a012b..1fa10b7 100644
--- a/CLAPACK-3.2.1/SRC/cgttrf.c
+++ b/CLAPACK-3.2.1/SRC/cgttrf.c
@@ -28,7 +28,7 @@
     /* Local variables */
     integer i__;
     complex fact, temp;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cgttrs.c b/CLAPACK-3.2.1/SRC/cgttrs.c
index 8bd8c7a..e19e4ae 100644
--- a/CLAPACK-3.2.1/SRC/cgttrs.c
+++ b/CLAPACK-3.2.1/SRC/cgttrs.c
@@ -29,7 +29,8 @@ static integer c_n1 = -1;
     integer j, jb, nb;
     extern /* Subroutine */ int cgtts2_(integer *, integer *, integer *, 
 	    complex *, complex *, complex *, complex *, integer *, complex *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer itrans;
diff --git a/CLAPACK-3.2.1/SRC/chbev.c b/CLAPACK-3.2.1/SRC/chbev.c
index 45c3ef8..8dd7b18 100644
--- a/CLAPACK-3.2.1/SRC/chbev.c
+++ b/CLAPACK-3.2.1/SRC/chbev.c
@@ -48,7 +48,7 @@ static integer c__1 = 1;
 	    integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     integer indrwk;
     extern /* Subroutine */ int csteqr_(char *, integer *, real *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/chbevd.c b/CLAPACK-3.2.1/SRC/chbevd.c
index 148aafd..c763cdb 100644
--- a/CLAPACK-3.2.1/SRC/chbevd.c
+++ b/CLAPACK-3.2.1/SRC/chbevd.c
@@ -64,7 +64,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
 	    *, integer *, complex *, integer *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     integer indwrk, liwmin;
     extern /* Subroutine */ int ssterf_(integer *, real *, real *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/chbevx.c b/CLAPACK-3.2.1/SRC/chbevx.c
index 0a395a2..2b544f6 100644
--- a/CLAPACK-3.2.1/SRC/chbevx.c
+++ b/CLAPACK-3.2.1/SRC/chbevx.c
@@ -72,7 +72,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
 	    *, integer *, complex *, integer *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real abstll, bignum;
     integer indiwk, indisp;
     extern /* Subroutine */ int cstein_(integer *, real *, real *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/chbgst.c b/CLAPACK-3.2.1/SRC/chbgst.c
index a4d1581..157c3f8 100644
--- a/CLAPACK-3.2.1/SRC/chbgst.c
+++ b/CLAPACK-3.2.1/SRC/chbgst.c
@@ -55,8 +55,10 @@ static integer c__1 = 1;
 	    integer *, complex *, integer *), csscal_(integer *, real *, 
 	    complex *, integer *), claset_(char *, integer *, integer *, 
 	    complex *, complex *, complex *, integer *), clartg_(
-	    complex *, complex *, real *, complex *, complex *), xerbla_(char 
-	    *, integer *), clargv_(integer *, complex *, integer *, 
+	    complex *, complex *, real *, complex *, complex *);
+    void xerbla_(char 
+	    *, integer *);
+    int clargv_(integer *, complex *, integer *, 
 	    complex *, integer *, real *, integer *);
     logical update;
     extern /* Subroutine */ int clartv_(integer *, complex *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/chbgv.c b/CLAPACK-3.2.1/SRC/chbgv.c
index b4e70a4..466ac14 100644
--- a/CLAPACK-3.2.1/SRC/chbgv.c
+++ b/CLAPACK-3.2.1/SRC/chbgv.c
@@ -31,7 +31,9 @@
 	    complex *, integer *, real *, real *, complex *, integer *, 
 	    complex *, integer *), chbgst_(char *, char *, 
 	    integer *, integer *, integer *, complex *, integer *, complex *, 
-	    integer *, complex *, integer *, complex *, real *, integer *), xerbla_(char *, integer *), cpbstf_(char 
+	    integer *, complex *, integer *, complex *, real *, integer *);
+    void xerbla_(char *, integer *);
+    int cpbstf_(char 
 	    *, integer *, integer *, complex *, integer *, integer *);
     integer indwrk;
     extern /* Subroutine */ int csteqr_(char *, integer *, real *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/chbgvd.c b/CLAPACK-3.2.1/SRC/chbgvd.c
index 780f128..c076c6a 100644
--- a/CLAPACK-3.2.1/SRC/chbgvd.c
+++ b/CLAPACK-3.2.1/SRC/chbgvd.c
@@ -48,8 +48,9 @@ static complex c_b2 = {0.f,0.f};
 	    chbgst_(char *, char *, integer *, integer *, integer *, complex *
 , integer *, complex *, integer *, complex *, integer *, complex *
 , real *, integer *), clacpy_(char *, integer *, 
-	    integer *, complex *, integer *, complex *, integer *), 
-	    xerbla_(char *, integer *), cpbstf_(char *, integer *, 
+	    integer *, complex *, integer *, complex *, integer *);
+	void xerbla_(char *, integer *);
+    void cpbstf_(char *, integer *,
 	    integer *, complex *, integer *, integer *);
     integer indwrk, liwmin;
     extern /* Subroutine */ int ssterf_(integer *, real *, real *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/chbgvx.c b/CLAPACK-3.2.1/SRC/chbgvx.c
index 295bc86..e05aecd 100644
--- a/CLAPACK-3.2.1/SRC/chbgvx.c
+++ b/CLAPACK-3.2.1/SRC/chbgvx.c
@@ -59,7 +59,9 @@ static integer c__1 = 1;
 	    integer *, complex *, integer *, complex *, integer *, complex *, 
 	    integer *, complex *, real *, integer *), clacpy_(
 	    char *, integer *, integer *, complex *, integer *, complex *, 
-	    integer *), xerbla_(char *, integer *), cpbstf_(
+	    integer *);
+    void xerbla_(char *, integer *);
+    int cpbstf_(
 	    char *, integer *, integer *, complex *, integer *, integer *);
     integer indiwk, indisp;
     extern /* Subroutine */ int cstein_(integer *, real *, real *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/chbtrd.c b/CLAPACK-3.2.1/SRC/chbtrd.c
index a62bd64..1c544e3 100644
--- a/CLAPACK-3.2.1/SRC/chbtrd.c
+++ b/CLAPACK-3.2.1/SRC/chbtrd.c
@@ -55,8 +55,10 @@ static integer c__1 = 1;
     integer iqaend;
     extern /* Subroutine */ int claset_(char *, integer *, integer *, complex 
 	    *, complex *, complex *, integer *), clartg_(complex *, 
-	    complex *, real *, complex *, complex *), xerbla_(char *, integer 
-	    *), clargv_(integer *, complex *, integer *, complex *, 
+	    complex *, real *, complex *, complex *);
+    void xerbla_(char *, integer 
+	    *);
+    int clargv_(integer *, complex *, integer *, complex *, 
 	    integer *, real *, integer *), clartv_(integer *, complex *, 
 	    integer *, complex *, integer *, real *, complex *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/checon.c b/CLAPACK-3.2.1/SRC/checon.c
index af7eeed..edf9677 100644
--- a/CLAPACK-3.2.1/SRC/checon.c
+++ b/CLAPACK-3.2.1/SRC/checon.c
@@ -30,7 +30,8 @@ static integer c__1 = 1;
     integer isave[3];
     logical upper;
     extern /* Subroutine */ int clacn2_(integer *, complex *, complex *, real 
-	    *, integer *, integer *), xerbla_(char *, integer *);
+	    *, integer *, integer *);
+    void xerbla_(char *, integer *);
     real ainvnm;
     extern /* Subroutine */ int chetrs_(char *, integer *, integer *, complex 
 	    *, integer *, integer *, complex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/cheequb.c b/CLAPACK-3.2.1/SRC/cheequb.c
index dd51a2b..38a0fe3 100644
--- a/CLAPACK-3.2.1/SRC/cheequb.c
+++ b/CLAPACK-3.2.1/SRC/cheequb.c
@@ -41,7 +41,7 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     real sumsq;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     extern /* Subroutine */ int classq_(integer *, complex *, integer *, real 
 	    *, real *);
diff --git a/CLAPACK-3.2.1/SRC/cheev.c b/CLAPACK-3.2.1/SRC/cheev.c
index 58e2c93..5034dfa 100644
--- a/CLAPACK-3.2.1/SRC/cheev.c
+++ b/CLAPACK-3.2.1/SRC/cheev.c
@@ -53,7 +53,7 @@ static real c_b18 = 1.f;
     real safmin;
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     integer indtau, indwrk;
     extern /* Subroutine */ int csteqr_(char *, integer *, real *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/cheevd.c b/CLAPACK-3.2.1/SRC/cheevd.c
index 0cade89..8ac5f18 100644
--- a/CLAPACK-3.2.1/SRC/cheevd.c
+++ b/CLAPACK-3.2.1/SRC/cheevd.c
@@ -61,7 +61,7 @@ static real c_b18 = 1.f;
     real safmin;
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     integer indtau, indrwk, indwrk, liwmin;
     extern /* Subroutine */ int ssterf_(integer *, real *, real *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/cheevr.c b/CLAPACK-3.2.1/SRC/cheevr.c
index 20e21ba..204c847 100644
--- a/CLAPACK-3.2.1/SRC/cheevr.c
+++ b/CLAPACK-3.2.1/SRC/cheevr.c
@@ -63,7 +63,7 @@ static integer c_n1 = -1;
     real safmin;
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real abstll, bignum;
     integer indtau, indisp;
     extern /* Subroutine */ int cstein_(integer *, real *, real *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/cheevx.c b/CLAPACK-3.2.1/SRC/cheevx.c
index 3381e87..013142b 100644
--- a/CLAPACK-3.2.1/SRC/cheevx.c
+++ b/CLAPACK-3.2.1/SRC/cheevx.c
@@ -64,7 +64,7 @@ static integer c_n1 = -1;
     real safmin;
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real abstll, bignum;
     integer indiwk, indisp, indtau;
     extern /* Subroutine */ int cstein_(integer *, real *, real *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/chegs2.c b/CLAPACK-3.2.1/SRC/chegs2.c
index 1988418..4b90631 100644
--- a/CLAPACK-3.2.1/SRC/chegs2.c
+++ b/CLAPACK-3.2.1/SRC/chegs2.c
@@ -40,7 +40,8 @@ static integer c__1 = 1;
 	    complex *, integer *, complex *, integer *), ctrsv_(char *, char *, char *, integer *, complex *, 
 	    integer *, complex *, integer *), clacgv_(
 	    integer *, complex *, integer *), csscal_(integer *, real *, 
-	    complex *, integer *), xerbla_(char *, integer *);
+	    complex *, integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/chegst.c b/CLAPACK-3.2.1/SRC/chegst.c
index 783d0ac..4e02961 100644
--- a/CLAPACK-3.2.1/SRC/chegst.c
+++ b/CLAPACK-3.2.1/SRC/chegst.c
@@ -43,7 +43,8 @@ static real c_b18 = 1.f;
     extern /* Subroutine */ int chegs2_(integer *, char *, integer *, complex 
 	    *, integer *, complex *, integer *, integer *), cher2k_(
 	    char *, char *, integer *, integer *, complex *, complex *, 
-	    integer *, complex *, integer *, real *, complex *, integer *), xerbla_(char *, integer *);
+	    integer *, complex *, integer *, real *, complex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/chegv.c b/CLAPACK-3.2.1/SRC/chegv.c
index 0888e89..545d386 100644
--- a/CLAPACK-3.2.1/SRC/chegv.c
+++ b/CLAPACK-3.2.1/SRC/chegv.c
@@ -43,7 +43,8 @@ static integer c_n1 = -1;
 	    *, integer *, complex *, integer *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), cpotrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  cpotrf_(
 	    char *, integer *, complex *, integer *, integer *);
     integer lwkopt;
     logical lquery;
diff --git a/CLAPACK-3.2.1/SRC/chegvd.c b/CLAPACK-3.2.1/SRC/chegvd.c
index 5f19c37..84aa4a5 100644
--- a/CLAPACK-3.2.1/SRC/chegvd.c
+++ b/CLAPACK-3.2.1/SRC/chegvd.c
@@ -45,7 +45,9 @@ static complex c_b1 = {1.f,0.f};
 	    integer *, real *, complex *, integer *, real *, integer *, 
 	    integer *, integer *, integer *), chegst_(integer 
 	    *, char *, integer *, complex *, integer *, complex *, integer *, 
-	    integer *), xerbla_(char *, integer *), cpotrf_(
+	    integer *);
+    void xerbla_(char *, integer *);
+    int cpotrf_(
 	    char *, integer *, complex *, integer *, integer *);
     integer liwmin, lrwmin;
     logical lquery;
diff --git a/CLAPACK-3.2.1/SRC/chegvx.c b/CLAPACK-3.2.1/SRC/chegvx.c
index 89d91de..4e8a4e1 100644
--- a/CLAPACK-3.2.1/SRC/chegvx.c
+++ b/CLAPACK-3.2.1/SRC/chegvx.c
@@ -43,7 +43,8 @@ static integer c_n1 = -1;
 	    *, integer *, complex *, integer *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), cheevx_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  cheevx_(
 	    char *, char *, char *, integer *, complex *, integer *, real *, 
 	    real *, integer *, integer *, real *, integer *, real *, complex *
 , integer *, complex *, integer *, real *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/cherfs.c b/CLAPACK-3.2.1/SRC/cherfs.c
index 4811c60..43b7944 100644
--- a/CLAPACK-3.2.1/SRC/cherfs.c
+++ b/CLAPACK-3.2.1/SRC/cherfs.c
@@ -53,7 +53,8 @@ static integer c__1 = 1;
 	    *, integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), chetrs_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  chetrs_(
 	    char *, integer *, integer *, complex *, integer *, integer *, 
 	    complex *, integer *, integer *);
     real lstres;
diff --git a/CLAPACK-3.2.1/SRC/cherfsx.c b/CLAPACK-3.2.1/SRC/cherfsx.c
index a1776eb..93e4d68 100644
--- a/CLAPACK-3.2.1/SRC/cherfsx.c
+++ b/CLAPACK-3.2.1/SRC/cherfsx.c
@@ -62,7 +62,7 @@ static logical c_false = FALSE_;
     extern /* Subroutine */ int checon_(char *, integer *, complex *, integer 
 	    *, integer *, real *, real *, complex *, integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaprec_(char *);
     integer ithresh, n_norms__;
     real rthresh;
diff --git a/CLAPACK-3.2.1/SRC/chesv.c b/CLAPACK-3.2.1/SRC/chesv.c
index a0e4d1f..7116192 100644
--- a/CLAPACK-3.2.1/SRC/chesv.c
+++ b/CLAPACK-3.2.1/SRC/chesv.c
@@ -29,7 +29,8 @@ static integer c_n1 = -1;
     integer nb;
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int chetrf_(char *, integer *, complex *, integer 
-	    *, integer *, complex *, integer *, integer *), xerbla_(
+	    *, integer *, complex *, integer *, integer *);
+    void xerbla_(
 	    char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/chesvx.c b/CLAPACK-3.2.1/SRC/chesvx.c
index f025237..e3478fe 100644
--- a/CLAPACK-3.2.1/SRC/chesvx.c
+++ b/CLAPACK-3.2.1/SRC/chesvx.c
@@ -47,7 +47,8 @@ static integer c_n1 = -1;
 	    integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), chetrs_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  chetrs_(
 	    char *, integer *, integer *, complex *, integer *, integer *, 
 	    complex *, integer *, integer *);
     integer lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/chesvxx.c b/CLAPACK-3.2.1/SRC/chesvxx.c
index 7d9c5d1..b6d1ae7 100644
--- a/CLAPACK-3.2.1/SRC/chesvxx.c
+++ b/CLAPACK-3.2.1/SRC/chesvxx.c
@@ -41,7 +41,8 @@
     extern /* Subroutine */ int chetrf_(char *, integer *, complex *, integer 
 	    *, integer *, complex *, integer *, integer *), clacpy_(
 	    char *, integer *, integer *, complex *, integer *, complex *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     real bignum;
     integer infequ;
     extern /* Subroutine */ int chetrs_(char *, integer *, integer *, complex 
diff --git a/CLAPACK-3.2.1/SRC/chetd2.c b/CLAPACK-3.2.1/SRC/chetd2.c
index a18ee71..92cab0c 100644
--- a/CLAPACK-3.2.1/SRC/chetd2.c
+++ b/CLAPACK-3.2.1/SRC/chetd2.c
@@ -41,7 +41,8 @@ static integer c__1 = 1;
 	    complex *, integer *);
     logical upper;
     extern /* Subroutine */ int clarfg_(integer *, complex *, complex *, 
-	    integer *, complex *), xerbla_(char *, integer *);
+	    integer *, complex *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/chetf2.c b/CLAPACK-3.2.1/SRC/chetf2.c
index 8e98051..fa6cb02 100644
--- a/CLAPACK-3.2.1/SRC/chetf2.c
+++ b/CLAPACK-3.2.1/SRC/chetf2.c
@@ -54,7 +54,8 @@ static integer c__1 = 1;
     real absakk;
     extern integer icamax_(integer *, complex *, integer *);
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
-	    *), xerbla_(char *, integer *);
+	    *);
+    void xerbla_(char *, integer *);
     real colmax;
     extern logical sisnan_(real *);
     real rowmax;
diff --git a/CLAPACK-3.2.1/SRC/chetrd.c b/CLAPACK-3.2.1/SRC/chetrd.c
index 38df87a..66159ca 100644
--- a/CLAPACK-3.2.1/SRC/chetrd.c
+++ b/CLAPACK-3.2.1/SRC/chetrd.c
@@ -38,7 +38,8 @@ static real c_b23 = 1.f;
 	    *, real *, real *, complex *, integer *), cher2k_(char *, 
 	    char *, integer *, integer *, complex *, complex *, integer *, 
 	    complex *, integer *, real *, complex *, integer *), clatrd_(char *, integer *, integer *, complex *, integer 
-	    *, real *, complex *, complex *, integer *), xerbla_(char 
+	    *, real *, complex *, complex *, integer *);
+    void xerbla_(char 
 	    *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/chetrf.c b/CLAPACK-3.2.1/SRC/chetrf.c
index 75c17bb..75a6bbc 100644
--- a/CLAPACK-3.2.1/SRC/chetrf.c
+++ b/CLAPACK-3.2.1/SRC/chetrf.c
@@ -33,7 +33,8 @@ static integer c__2 = 2;
     extern /* Subroutine */ int chetf2_(char *, integer *, complex *, integer 
 	    *, integer *, integer *), clahef_(char *, integer *, 
 	    integer *, integer *, complex *, integer *, integer *, complex *, 
-	    integer *, integer *), xerbla_(char *, integer *);
+	    integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwork, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/chetri.c b/CLAPACK-3.2.1/SRC/chetri.c
index ac9c6bf..e01e298 100644
--- a/CLAPACK-3.2.1/SRC/chetri.c
+++ b/CLAPACK-3.2.1/SRC/chetri.c
@@ -47,7 +47,7 @@ static integer c__1 = 1;
 	    integer *);
     integer kstep;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/chetrs.c b/CLAPACK-3.2.1/SRC/chetrs.c
index fcb0eef..7d4346c 100644
--- a/CLAPACK-3.2.1/SRC/chetrs.c
+++ b/CLAPACK-3.2.1/SRC/chetrs.c
@@ -44,7 +44,8 @@ static integer c__1 = 1;
 	     cswap_(integer *, complex *, integer *, complex *, integer *);
     logical upper;
     extern /* Subroutine */ int clacgv_(integer *, complex *, integer *), 
-	    csscal_(integer *, real *, complex *, integer *), xerbla_(char *, 
+	    csscal_(integer *, real *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/chfrk.c b/CLAPACK-3.2.1/SRC/chfrk.c
index d980a7e..6bc4529 100644
--- a/CLAPACK-3.2.1/SRC/chfrk.c
+++ b/CLAPACK-3.2.1/SRC/chfrk.c
@@ -34,7 +34,7 @@
     integer nrowa;
     logical lower;
     complex calpha;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd, notrans;
 
 
diff --git a/CLAPACK-3.2.1/SRC/chgeqz.c b/CLAPACK-3.2.1/SRC/chgeqz.c
index a728058..9466b2d 100644
--- a/CLAPACK-3.2.1/SRC/chgeqz.c
+++ b/CLAPACK-3.2.1/SRC/chgeqz.c
@@ -74,7 +74,7 @@ static integer c__2 = 2;
 	    *, complex *, complex *, integer *), clartg_(complex *, 
 	    complex *, real *, complex *, complex *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     complex eshift;
     logical ilschr;
     integer icompq, ilastm;
diff --git a/CLAPACK-3.2.1/SRC/chpcon.c b/CLAPACK-3.2.1/SRC/chpcon.c
index 8fdf9f3..fa74b22 100644
--- a/CLAPACK-3.2.1/SRC/chpcon.c
+++ b/CLAPACK-3.2.1/SRC/chpcon.c
@@ -29,7 +29,8 @@ static integer c__1 = 1;
     integer isave[3];
     logical upper;
     extern /* Subroutine */ int clacn2_(integer *, complex *, complex *, real 
-	    *, integer *, integer *), xerbla_(char *, integer *);
+	    *, integer *, integer *);
+    void xerbla_(char *, integer *);
     real ainvnm;
     extern /* Subroutine */ int chptrs_(char *, integer *, integer *, complex 
 	    *, integer *, complex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/chpev.c b/CLAPACK-3.2.1/SRC/chpev.c
index 12442c0..c7262ca 100644
--- a/CLAPACK-3.2.1/SRC/chpev.c
+++ b/CLAPACK-3.2.1/SRC/chpev.c
@@ -43,7 +43,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
 	    *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     integer indtau;
     extern /* Subroutine */ int chptrd_(char *, integer *, complex *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/chpevd.c b/CLAPACK-3.2.1/SRC/chpevd.c
index e69b3f0..09f1c46 100644
--- a/CLAPACK-3.2.1/SRC/chpevd.c
+++ b/CLAPACK-3.2.1/SRC/chpevd.c
@@ -49,7 +49,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
 	    *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     integer indtau;
     extern /* Subroutine */ int chptrd_(char *, integer *, complex *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/chpevx.c b/CLAPACK-3.2.1/SRC/chpevx.c
index 77334b2..c643616 100644
--- a/CLAPACK-3.2.1/SRC/chpevx.c
+++ b/CLAPACK-3.2.1/SRC/chpevx.c
@@ -54,7 +54,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
 	    *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real abstll, bignum;
     integer indiwk, indisp, indtau;
     extern /* Subroutine */ int chptrd_(char *, integer *, complex *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/chpgst.c b/CLAPACK-3.2.1/SRC/chpgst.c
index b830930..a32d873 100644
--- a/CLAPACK-3.2.1/SRC/chpgst.c
+++ b/CLAPACK-3.2.1/SRC/chpgst.c
@@ -47,7 +47,8 @@ static integer c__1 = 1;
     logical upper;
     extern /* Subroutine */ int ctpsv_(char *, char *, char *, integer *, 
 	    complex *, complex *, integer *), csscal_(
-	    integer *, real *, complex *, integer *), xerbla_(char *, integer 
+	    integer *, real *, complex *, integer *);
+    void xerbla_(char *, integer 
 	    *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/chpgv.c b/CLAPACK-3.2.1/SRC/chpgv.c
index bf69356..dbac1f1 100644
--- a/CLAPACK-3.2.1/SRC/chpgv.c
+++ b/CLAPACK-3.2.1/SRC/chpgv.c
@@ -36,7 +36,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int ctpsv_(char *, char *, char *, integer *, 
 	    complex *, complex *, integer *);
     logical wantz;
-    extern /* Subroutine */ int xerbla_(char *, integer *), chpgst_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  chpgst_(
 	    integer *, char *, integer *, complex *, complex *, integer *), cpptrf_(char *, integer *, complex *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/chpgvd.c b/CLAPACK-3.2.1/SRC/chpgvd.c
index 58fe02a..0353953 100644
--- a/CLAPACK-3.2.1/SRC/chpgvd.c
+++ b/CLAPACK-3.2.1/SRC/chpgvd.c
@@ -39,8 +39,9 @@ static integer c__1 = 1;
     logical wantz;
     extern /* Subroutine */ int chpevd_(char *, char *, integer *, complex *, 
 	    real *, complex *, integer *, complex *, integer *, real *, 
-	    integer *, integer *, integer *, integer *), 
-	    xerbla_(char *, integer *), chpgst_(integer *, char *, 
+	    integer *, integer *, integer *, integer *);
+	void xerbla_(char *, integer *);
+    int chpgst_(integer *, char *, 
 	    integer *, complex *, complex *, integer *), cpptrf_(char 
 	    *, integer *, complex *, integer *);
     integer liwmin, lrwmin;
diff --git a/CLAPACK-3.2.1/SRC/chpgvx.c b/CLAPACK-3.2.1/SRC/chpgvx.c
index 838b558..9fa3246 100644
--- a/CLAPACK-3.2.1/SRC/chpgvx.c
+++ b/CLAPACK-3.2.1/SRC/chpgvx.c
@@ -36,7 +36,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int ctpsv_(char *, char *, char *, integer *, 
 	    complex *, complex *, integer *);
     logical wantz, alleig, indeig, valeig;
-    extern /* Subroutine */ int xerbla_(char *, integer *), chpgst_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  chpgst_(
 	    integer *, char *, integer *, complex *, complex *, integer *), chpevx_(char *, char *, char *, integer *, complex *, 
 	    real *, real *, integer *, integer *, real *, integer *, real *, 
 	    complex *, integer *, complex *, real *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/chprfs.c b/CLAPACK-3.2.1/SRC/chprfs.c
index 6f73ec3..85a9f6b 100644
--- a/CLAPACK-3.2.1/SRC/chprfs.c
+++ b/CLAPACK-3.2.1/SRC/chprfs.c
@@ -52,7 +52,8 @@ static integer c__1 = 1;
 	    *, integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), chptrs_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  chptrs_(
 	    char *, integer *, integer *, complex *, integer *, complex *, 
 	    integer *, integer *);
     real lstres;
diff --git a/CLAPACK-3.2.1/SRC/chpsv.c b/CLAPACK-3.2.1/SRC/chpsv.c
index 977b0cf..70ba309 100644
--- a/CLAPACK-3.2.1/SRC/chpsv.c
+++ b/CLAPACK-3.2.1/SRC/chpsv.c
@@ -21,7 +21,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), chptrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  chptrf_(
 	    char *, integer *, complex *, integer *, integer *), 
 	    chptrs_(char *, integer *, integer *, complex *, integer *, 
 	    complex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/chpsvx.c b/CLAPACK-3.2.1/SRC/chpsvx.c
index d75ccae..8241651 100644
--- a/CLAPACK-3.2.1/SRC/chpsvx.c
+++ b/CLAPACK-3.2.1/SRC/chpsvx.c
@@ -34,7 +34,9 @@ static integer c__1 = 1;
     logical nofact;
     extern /* Subroutine */ int chpcon_(char *, integer *, complex *, integer 
 	    *, real *, real *, complex *, integer *), clacpy_(char *, 
-	    integer *, integer *, complex *, integer *, complex *, integer *), xerbla_(char *, integer *), chprfs_(char *, 
+	    integer *, integer *, complex *, integer *, complex *, integer *);
+    void xerbla_(char *, integer *);
+    int chprfs_(char *, 
 	    integer *, integer *, complex *, complex *, integer *, complex *, 
 	    integer *, complex *, integer *, real *, real *, complex *, real *
 , integer *), chptrf_(char *, integer *, complex *, 
diff --git a/CLAPACK-3.2.1/SRC/chptrd.c b/CLAPACK-3.2.1/SRC/chptrd.c
index b08a545..b15c139 100644
--- a/CLAPACK-3.2.1/SRC/chptrd.c
+++ b/CLAPACK-3.2.1/SRC/chptrd.c
@@ -41,7 +41,8 @@ static integer c__1 = 1;
 	    integer *);
     logical upper;
     extern /* Subroutine */ int clarfg_(integer *, complex *, complex *, 
-	    integer *, complex *), xerbla_(char *, integer *);
+	    integer *, complex *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/chptrf.c b/CLAPACK-3.2.1/SRC/chptrf.c
index 47d9337..73c0dc6 100644
--- a/CLAPACK-3.2.1/SRC/chptrf.c
+++ b/CLAPACK-3.2.1/SRC/chptrf.c
@@ -56,7 +56,8 @@ static integer c__1 = 1;
     real absakk;
     extern integer icamax_(integer *, complex *, integer *);
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
-	    *), xerbla_(char *, integer *);
+	    *);
+    void xerbla_(char *, integer *);
     real colmax, rowmax;
 
 
diff --git a/CLAPACK-3.2.1/SRC/chptri.c b/CLAPACK-3.2.1/SRC/chptri.c
index 069bb2a..1ea65ae 100644
--- a/CLAPACK-3.2.1/SRC/chptri.c
+++ b/CLAPACK-3.2.1/SRC/chptri.c
@@ -46,7 +46,7 @@ static integer c__1 = 1;
 	    integer *);
     integer kstep;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer kcnext;
 
 
diff --git a/CLAPACK-3.2.1/SRC/chptrs.c b/CLAPACK-3.2.1/SRC/chptrs.c
index e5c7536..43eb5ef 100644
--- a/CLAPACK-3.2.1/SRC/chptrs.c
+++ b/CLAPACK-3.2.1/SRC/chptrs.c
@@ -43,7 +43,8 @@ static integer c__1 = 1;
 	     cswap_(integer *, complex *, integer *, complex *, integer *);
     logical upper;
     extern /* Subroutine */ int clacgv_(integer *, complex *, integer *), 
-	    csscal_(integer *, real *, complex *, integer *), xerbla_(char *, 
+	    csscal_(integer *, real *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/chsein.c b/CLAPACK-3.2.1/SRC/chsein.c
index bc49ab1..217a685 100644
--- a/CLAPACK-3.2.1/SRC/chsein.c
+++ b/CLAPACK-3.2.1/SRC/chsein.c
@@ -47,7 +47,7 @@ static logical c_true = TRUE_;
 	    real *, real *, real *, integer *);
     extern doublereal slamch_(char *), clanhs_(char *, integer *, 
 	    complex *, integer *, real *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noinit;
     integer ldwork;
     logical rightv, fromqr;
diff --git a/CLAPACK-3.2.1/SRC/chseqr.c b/CLAPACK-3.2.1/SRC/chseqr.c
index 0a02ec5..95f9af2 100644
--- a/CLAPACK-3.2.1/SRC/chseqr.c
+++ b/CLAPACK-3.2.1/SRC/chseqr.c
@@ -34,7 +34,7 @@ static integer c__49 = 49;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     complex hl[2401]	/* was [49][49] */;
@@ -53,7 +53,8 @@ static integer c__49 = 49;
 	    integer *, integer *), clacpy_(char *, integer *, integer *, 
 	    complex *, integer *, complex *, integer *), claset_(char 
 	    *, integer *, integer *, complex *, complex *, complex *, integer 
-	    *), xerbla_(char *, integer *);
+	    *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical lquery;
diff --git a/CLAPACK-3.2.1/SRC/cla_gbamv.c b/CLAPACK-3.2.1/SRC/cla_gbamv.c
index 8e271d8..f183c27 100644
--- a/CLAPACK-3.2.1/SRC/cla_gbamv.c
+++ b/CLAPACK-3.2.1/SRC/cla_gbamv.c
@@ -33,7 +33,7 @@
     integer lenx, leny;
     real safe1;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*     -- LAPACK routine (version 3.2)                                 -- */
diff --git a/CLAPACK-3.2.1/SRC/cla_gbrcond_c.c b/CLAPACK-3.2.1/SRC/cla_gbrcond_c.c
index 172784a..2bb1679 100644
--- a/CLAPACK-3.2.1/SRC/cla_gbrcond_c.c
+++ b/CLAPACK-3.2.1/SRC/cla_gbrcond_c.c
@@ -38,8 +38,9 @@ doublereal cla_gbrcond_c__(char *trans, integer *n, integer *kl, integer *ku,
     integer isave[3];
     real anorm;
     extern /* Subroutine */ int clacn2_(integer *, complex *, complex *, real 
-	    *, integer *, integer *), xerbla_(char *, integer *), 
-	    cgbtrs_(char *, integer *, integer *, integer *, integer *, 
+	    *, integer *, integer *);
+    void xerbla_(char *, integer *);
+	int cgbtrs_(char *, integer *, integer *, integer *, integer *, 
 	    complex *, integer *, integer *, complex *, integer *, integer *);
     real ainvnm;
     logical notrans;
diff --git a/CLAPACK-3.2.1/SRC/cla_gbrcond_x.c b/CLAPACK-3.2.1/SRC/cla_gbrcond_x.c
index 5f82d1c..5a57525 100644
--- a/CLAPACK-3.2.1/SRC/cla_gbrcond_x.c
+++ b/CLAPACK-3.2.1/SRC/cla_gbrcond_x.c
@@ -39,8 +39,9 @@ doublereal cla_gbrcond_x__(char *trans, integer *n, integer *kl, integer *ku,
     integer isave[3];
     real anorm;
     extern /* Subroutine */ int clacn2_(integer *, complex *, complex *, real 
-	    *, integer *, integer *), xerbla_(char *, integer *), 
-	    cgbtrs_(char *, integer *, integer *, integer *, integer *, 
+	    *, integer *, integer *);
+    void xerbla_(char *, integer *);
+	int cgbtrs_(char *, integer *, integer *, integer *, integer *, 
 	    complex *, integer *, integer *, complex *, integer *, integer *);
     real ainvnm;
     logical notrans;
diff --git a/CLAPACK-3.2.1/SRC/cla_geamv.c b/CLAPACK-3.2.1/SRC/cla_geamv.c
index 11b1fff..e4633c2 100644
--- a/CLAPACK-3.2.1/SRC/cla_geamv.c
+++ b/CLAPACK-3.2.1/SRC/cla_geamv.c
@@ -33,7 +33,7 @@
     integer lenx, leny;
     real safe1;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*     -- LAPACK routine (version 3.2)                                 -- */
diff --git a/CLAPACK-3.2.1/SRC/cla_gercond_c.c b/CLAPACK-3.2.1/SRC/cla_gercond_c.c
index 0d6476c..5c050d4 100644
--- a/CLAPACK-3.2.1/SRC/cla_gercond_c.c
+++ b/CLAPACK-3.2.1/SRC/cla_gercond_c.c
@@ -37,8 +37,9 @@ doublereal cla_gercond_c__(char *trans, integer *n, complex *a, integer *lda,
     integer isave[3];
     real anorm;
     extern /* Subroutine */ int clacn2_(integer *, complex *, complex *, real 
-	    *, integer *, integer *), xerbla_(char *, integer *), 
-	    cgetrs_(char *, integer *, integer *, complex *, integer *, 
+	    *, integer *, integer *);
+    void xerbla_(char *, integer *);
+	int cgetrs_(char *, integer *, integer *, complex *, integer *, 
 	    integer *, complex *, integer *, integer *);
     real ainvnm;
     logical notrans;
diff --git a/CLAPACK-3.2.1/SRC/cla_gercond_x.c b/CLAPACK-3.2.1/SRC/cla_gercond_x.c
index 11f440b..1ac80f2 100644
--- a/CLAPACK-3.2.1/SRC/cla_gercond_x.c
+++ b/CLAPACK-3.2.1/SRC/cla_gercond_x.c
@@ -38,8 +38,9 @@ doublereal cla_gercond_x__(char *trans, integer *n, complex *a, integer *lda,
     integer isave[3];
     real anorm;
     extern /* Subroutine */ int clacn2_(integer *, complex *, complex *, real 
-	    *, integer *, integer *), xerbla_(char *, integer *), 
-	    cgetrs_(char *, integer *, integer *, complex *, integer *, 
+	    *, integer *, integer *);
+    void xerbla_(char *, integer *);
+    int cgetrs_(char *, integer *, integer *, complex *, integer *, 
 	    integer *, complex *, integer *, integer *);
     real ainvnm;
     logical notrans;
diff --git a/CLAPACK-3.2.1/SRC/cla_heamv.c b/CLAPACK-3.2.1/SRC/cla_heamv.c
index 8a7be1c..6229e9d 100644
--- a/CLAPACK-3.2.1/SRC/cla_heamv.c
+++ b/CLAPACK-3.2.1/SRC/cla_heamv.c
@@ -30,7 +30,7 @@
     integer iy, jx, kx, ky, info;
     real temp, safe1;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilauplo_(char *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/cla_hercond_c.c b/CLAPACK-3.2.1/SRC/cla_hercond_c.c
index 71c7262..d2deddf 100644
--- a/CLAPACK-3.2.1/SRC/cla_hercond_c.c
+++ b/CLAPACK-3.2.1/SRC/cla_hercond_c.c
@@ -38,7 +38,8 @@ doublereal cla_hercond_c__(char *uplo, integer *n, complex *a, integer *lda,
     integer isave[3];
     real anorm;
     extern /* Subroutine */ int clacn2_(integer *, complex *, complex *, real 
-	    *, integer *, integer *), xerbla_(char *, integer *);
+	    *, integer *, integer *);
+    void xerbla_(char *, integer *);
     real ainvnm;
     extern /* Subroutine */ int chetrs_(char *, integer *, integer *, complex 
 	    *, integer *, integer *, complex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/cla_hercond_x.c b/CLAPACK-3.2.1/SRC/cla_hercond_x.c
index 4a2b643..f38b890 100644
--- a/CLAPACK-3.2.1/SRC/cla_hercond_x.c
+++ b/CLAPACK-3.2.1/SRC/cla_hercond_x.c
@@ -39,7 +39,8 @@ doublereal cla_hercond_x__(char *uplo, integer *n, complex *a, integer *lda,
     integer isave[3];
     real anorm;
     extern /* Subroutine */ int clacn2_(integer *, complex *, complex *, real 
-	    *, integer *, integer *), xerbla_(char *, integer *);
+	    *, integer *, integer *);
+    void xerbla_(char *, integer *);
     real ainvnm;
     extern /* Subroutine */ int chetrs_(char *, integer *, integer *, complex 
 	    *, integer *, integer *, complex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/cla_porcond_c.c b/CLAPACK-3.2.1/SRC/cla_porcond_c.c
index b5b853e..403d8f8 100644
--- a/CLAPACK-3.2.1/SRC/cla_porcond_c.c
+++ b/CLAPACK-3.2.1/SRC/cla_porcond_c.c
@@ -38,7 +38,8 @@ doublereal cla_porcond_c__(char *uplo, integer *n, complex *a, integer *lda,
     integer isave[3];
     real anorm;
     extern /* Subroutine */ int clacn2_(integer *, complex *, complex *, real 
-	    *, integer *, integer *), xerbla_(char *, integer *);
+	    *, integer *, integer *);
+    void xerbla_(char *, integer *);
     real ainvnm;
     extern /* Subroutine */ int cpotrs_(char *, integer *, integer *, complex 
 	    *, integer *, complex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/cla_porcond_x.c b/CLAPACK-3.2.1/SRC/cla_porcond_x.c
index ca274eb..f210468 100644
--- a/CLAPACK-3.2.1/SRC/cla_porcond_x.c
+++ b/CLAPACK-3.2.1/SRC/cla_porcond_x.c
@@ -39,7 +39,8 @@ doublereal cla_porcond_x__(char *uplo, integer *n, complex *a, integer *lda,
     integer isave[3];
     real anorm;
     extern /* Subroutine */ int clacn2_(integer *, complex *, complex *, real 
-	    *, integer *, integer *), xerbla_(char *, integer *);
+	    *, integer *, integer *);
+    void xerbla_(char *, integer *);
     real ainvnm;
     extern /* Subroutine */ int cpotrs_(char *, integer *, integer *, complex 
 	    *, integer *, complex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/cla_syamv.c b/CLAPACK-3.2.1/SRC/cla_syamv.c
index 2038542..ec3257f 100644
--- a/CLAPACK-3.2.1/SRC/cla_syamv.c
+++ b/CLAPACK-3.2.1/SRC/cla_syamv.c
@@ -30,7 +30,7 @@
     integer iy, jx, kx, ky, info;
     real temp, safe1;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilauplo_(char *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/cla_syrcond_c.c b/CLAPACK-3.2.1/SRC/cla_syrcond_c.c
index 4c52b17..1f27f7e 100644
--- a/CLAPACK-3.2.1/SRC/cla_syrcond_c.c
+++ b/CLAPACK-3.2.1/SRC/cla_syrcond_c.c
@@ -38,7 +38,8 @@ doublereal cla_syrcond_c__(char *uplo, integer *n, complex *a, integer *lda,
     integer isave[3];
     real anorm;
     extern /* Subroutine */ int clacn2_(integer *, complex *, complex *, real 
-	    *, integer *, integer *), xerbla_(char *, integer *);
+	    *, integer *, integer *);
+    void xerbla_(char *, integer *);
     real ainvnm;
     extern /* Subroutine */ int csytrs_(char *, integer *, integer *, complex 
 	    *, integer *, integer *, complex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/cla_syrcond_x.c b/CLAPACK-3.2.1/SRC/cla_syrcond_x.c
index f4c8cc1..fd76dc1 100644
--- a/CLAPACK-3.2.1/SRC/cla_syrcond_x.c
+++ b/CLAPACK-3.2.1/SRC/cla_syrcond_x.c
@@ -39,7 +39,8 @@ doublereal cla_syrcond_x__(char *uplo, integer *n, complex *a, integer *lda,
     integer isave[3];
     real anorm;
     extern /* Subroutine */ int clacn2_(integer *, complex *, complex *, real 
-	    *, integer *, integer *), xerbla_(char *, integer *);
+	    *, integer *, integer *);
+    void xerbla_(char *, integer *);
     real ainvnm;
     extern /* Subroutine */ int csytrs_(char *, integer *, integer *, complex 
 	    *, integer *, integer *, complex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/claed0.c b/CLAPACK-3.2.1/SRC/claed0.c
index a1f2a9b..7ba8912 100644
--- a/CLAPACK-3.2.1/SRC/claed0.c
+++ b/CLAPACK-3.2.1/SRC/claed0.c
@@ -51,7 +51,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int clacrm_(integer *, integer *, complex *, 
 	    integer *, real *, integer *, complex *, integer *, real *);
     integer igivcl;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer igivnm, submat, curprb, subpbs, igivpt, curlvl, matsiz, iprmpt, 
diff --git a/CLAPACK-3.2.1/SRC/claed7.c b/CLAPACK-3.2.1/SRC/claed7.c
index 14728f8..de27cec 100644
--- a/CLAPACK-3.2.1/SRC/claed7.c
+++ b/CLAPACK-3.2.1/SRC/claed7.c
@@ -45,8 +45,9 @@ static integer c_n1 = -1;
 , real *, integer *);
     integer idlmda;
     extern /* Subroutine */ int clacrm_(integer *, integer *, complex *, 
-	    integer *, real *, integer *, complex *, integer *, real *), 
-	    xerbla_(char *, integer *), slamrg_(integer *, integer *, 
+	    integer *, real *, integer *, complex *, integer *, real *);
+	void xerbla_(char *, integer *);
+    int slamrg_(integer *, integer *, 
 	    real *, integer *, integer *, integer *);
     integer coltyp;
 
diff --git a/CLAPACK-3.2.1/SRC/claed8.c b/CLAPACK-3.2.1/SRC/claed8.c
index 74e9416..ba18809 100644
--- a/CLAPACK-3.2.1/SRC/claed8.c
+++ b/CLAPACK-3.2.1/SRC/claed8.c
@@ -45,7 +45,8 @@ static integer c__1 = 1;
 	    integer *);
     extern doublereal slapy2_(real *, real *), slamch_(char *);
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
-	    *, integer *, complex *, integer *), xerbla_(char *, 
+	    *, integer *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     extern integer isamax_(integer *, real *, integer *);
     extern /* Subroutine */ int slamrg_(integer *, integer *, real *, integer 
diff --git a/CLAPACK-3.2.1/SRC/clals0.c b/CLAPACK-3.2.1/SRC/clals0.c
index 0e83601..ce591bc 100644
--- a/CLAPACK-3.2.1/SRC/clals0.c
+++ b/CLAPACK-3.2.1/SRC/clals0.c
@@ -54,7 +54,8 @@ static integer c__0 = 0;
     extern /* Subroutine */ int clascl_(char *, integer *, integer *, real *, 
 	    real *, integer *, integer *, complex *, integer *, integer *), csscal_(integer *, real *, complex *, integer *), 
 	    clacpy_(char *, integer *, integer *, complex *, integer *, 
-	    complex *, integer *), xerbla_(char *, integer *);
+	    complex *, integer *);
+    void xerbla_(char *, integer *);
     real dsigjp;
 
 
diff --git a/CLAPACK-3.2.1/SRC/clalsa.c b/CLAPACK-3.2.1/SRC/clalsa.c
index ca12b37..e472272 100644
--- a/CLAPACK-3.2.1/SRC/clalsa.c
+++ b/CLAPACK-3.2.1/SRC/clalsa.c
@@ -51,7 +51,9 @@ static integer c__2 = 2;
 	    integer *, integer *, complex *, integer *, complex *, integer *, 
 	    integer *, integer *, integer *, integer *, real *, integer *, 
 	    real *, real *, real *, real *, integer *, real *, real *, real *, 
-	     integer *), xerbla_(char *, integer *), slasdt_(integer *
+	     integer *);
+    void xerbla_(char *, integer *);
+    int slasdt_(integer *
 , integer *, integer *, integer *, integer *, integer *, integer *
 );
 
diff --git a/CLAPACK-3.2.1/SRC/clalsd.c b/CLAPACK-3.2.1/SRC/clalsd.c
index 0ae828f..8f2134c 100644
--- a/CLAPACK-3.2.1/SRC/clalsd.c
+++ b/CLAPACK-3.2.1/SRC/clalsd.c
@@ -73,8 +73,10 @@ static real c_b35 = 0.f;
 	    integer *, real *, real *, real *, real *, integer *, integer *), 
 	    clacpy_(char *, integer *, integer *, complex *, integer *, 
 	    complex *, integer *), claset_(char *, integer *, integer 
-	    *, complex *, complex *, complex *, integer *), xerbla_(
-	    char *, integer *), slascl_(char *, integer *, integer *, 
+	    *, complex *, complex *, complex *, integer *);
+    void xerbla_(
+	    char *, integer *);
+    int slascl_(char *, integer *, integer *, 
 	    real *, real *, integer *, integer *, real *, integer *, integer *
 );
     extern integer isamax_(integer *, real *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/clarzb.c b/CLAPACK-3.2.1/SRC/clarzb.c
index 8861dc6..808b5a1 100644
--- a/CLAPACK-3.2.1/SRC/clarzb.c
+++ b/CLAPACK-3.2.1/SRC/clarzb.c
@@ -38,7 +38,8 @@ static integer c__1 = 1;
 	    complex *, integer *), ctrmm_(char *, char *, char *, char *, 
 	    integer *, integer *, complex *, complex *, integer *, complex *, 
 	    integer *), clacgv_(integer *, 
-	    complex *, integer *), xerbla_(char *, integer *);
+	    complex *, integer *);
+    void xerbla_(char *, integer *);
     char transt[1];
 
 
diff --git a/CLAPACK-3.2.1/SRC/clarzt.c b/CLAPACK-3.2.1/SRC/clarzt.c
index 8287e70..eddfb21 100644
--- a/CLAPACK-3.2.1/SRC/clarzt.c
+++ b/CLAPACK-3.2.1/SRC/clarzt.c
@@ -32,7 +32,8 @@ static integer c__1 = 1;
 , integer *);
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int ctrmv_(char *, char *, char *, integer *, 
-	    complex *, integer *, complex *, integer *), clacgv_(integer *, complex *, integer *), xerbla_(char *, 
+	    complex *, integer *, complex *, integer *), clacgv_(integer *, complex *, integer *);
+    void xerbla_(char *, 
 	     integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/clascl.c b/CLAPACK-3.2.1/SRC/clascl.c
index ca01694..ccd8dcd 100644
--- a/CLAPACK-3.2.1/SRC/clascl.c
+++ b/CLAPACK-3.2.1/SRC/clascl.c
@@ -31,7 +31,7 @@
     real cfrom1;
     extern doublereal slamch_(char *);
     real cfromc;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     extern logical sisnan_(real *);
     real smlnum;
diff --git a/CLAPACK-3.2.1/SRC/clasr.c b/CLAPACK-3.2.1/SRC/clasr.c
index 4f12a7f..1c84bf5 100644
--- a/CLAPACK-3.2.1/SRC/clasr.c
+++ b/CLAPACK-3.2.1/SRC/clasr.c
@@ -25,7 +25,7 @@
     complex temp;
     extern logical lsame_(char *, char *);
     real ctemp, stemp;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK auxiliary routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/clatbs.c b/CLAPACK-3.2.1/SRC/clatbs.c
index 646e4f4..db29099 100644
--- a/CLAPACK-3.2.1/SRC/clatbs.c
+++ b/CLAPACK-3.2.1/SRC/clatbs.c
@@ -60,7 +60,8 @@ static real c_b36 = .5f;
     extern /* Complex */ VOID cladiv_(complex *, complex *, complex *);
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
-	    *), xerbla_(char *, integer *);
+	    *);
+    void xerbla_(char *, integer *);
     real bignum;
     extern integer isamax_(integer *, real *, integer *);
     extern doublereal scasum_(integer *, complex *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/clatps.c b/CLAPACK-3.2.1/SRC/clatps.c
index c30b6d4..a2927fb 100644
--- a/CLAPACK-3.2.1/SRC/clatps.c
+++ b/CLAPACK-3.2.1/SRC/clatps.c
@@ -60,7 +60,8 @@ static real c_b36 = .5f;
     extern /* Complex */ VOID cladiv_(complex *, complex *, complex *);
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
-	    *), xerbla_(char *, integer *);
+	    *);
+    void xerbla_(char *, integer *);
     real bignum;
     extern integer isamax_(integer *, real *, integer *);
     extern doublereal scasum_(integer *, complex *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/clatrs.c b/CLAPACK-3.2.1/SRC/clatrs.c
index 3bf8994..c2ea751 100644
--- a/CLAPACK-3.2.1/SRC/clatrs.c
+++ b/CLAPACK-3.2.1/SRC/clatrs.c
@@ -59,7 +59,8 @@ static real c_b36 = .5f;
     extern /* Complex */ VOID cladiv_(complex *, complex *, complex *);
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
-	    *), xerbla_(char *, integer *);
+	    *);
+    void xerbla_(char *, integer *);
     real bignum;
     extern integer isamax_(integer *, real *, integer *);
     extern doublereal scasum_(integer *, complex *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/clauu2.c b/CLAPACK-3.2.1/SRC/clauu2.c
index 34f67f6..61d5890 100644
--- a/CLAPACK-3.2.1/SRC/clauu2.c
+++ b/CLAPACK-3.2.1/SRC/clauu2.c
@@ -37,7 +37,8 @@ static integer c__1 = 1;
 , integer *);
     logical upper;
     extern /* Subroutine */ int clacgv_(integer *, complex *, integer *), 
-	    csscal_(integer *, real *, complex *, integer *), xerbla_(char *, 
+	    csscal_(integer *, real *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/clauum.c b/CLAPACK-3.2.1/SRC/clauum.c
index c6816a7..073223e 100644
--- a/CLAPACK-3.2.1/SRC/clauum.c
+++ b/CLAPACK-3.2.1/SRC/clauum.c
@@ -39,7 +39,8 @@ static real c_b21 = 1.f;
 	    integer *);
     logical upper;
     extern /* Subroutine */ int clauu2_(char *, integer *, complex *, integer 
-	    *, integer *), xerbla_(char *, integer *);
+	    *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/cpbcon.c b/CLAPACK-3.2.1/SRC/cpbcon.c
index 6c32104..78568b3 100644
--- a/CLAPACK-3.2.1/SRC/cpbcon.c
+++ b/CLAPACK-3.2.1/SRC/cpbcon.c
@@ -43,7 +43,7 @@ static integer c__1 = 1;
 	    integer *, integer *, complex *, integer *, complex *, real *, 
 	    real *, integer *);
     real scaleu;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real ainvnm;
     extern /* Subroutine */ int csrscl_(integer *, real *, complex *, integer 
 	    *);
diff --git a/CLAPACK-3.2.1/SRC/cpbequ.c b/CLAPACK-3.2.1/SRC/cpbequ.c
index d83df71..29a72d2 100644
--- a/CLAPACK-3.2.1/SRC/cpbequ.c
+++ b/CLAPACK-3.2.1/SRC/cpbequ.c
@@ -28,7 +28,7 @@
     real smin;
     extern logical lsame_(char *, char *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cpbrfs.c b/CLAPACK-3.2.1/SRC/cpbrfs.c
index 43625c6..61f937b 100644
--- a/CLAPACK-3.2.1/SRC/cpbrfs.c
+++ b/CLAPACK-3.2.1/SRC/cpbrfs.c
@@ -53,7 +53,8 @@ static integer c__1 = 1;
 	    *, integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), cpbtrs_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  cpbtrs_(
 	    char *, integer *, integer *, integer *, complex *, integer *, 
 	    complex *, integer *, integer *);
     real lstres;
diff --git a/CLAPACK-3.2.1/SRC/cpbstf.c b/CLAPACK-3.2.1/SRC/cpbstf.c
index 3770330..2335c9a 100644
--- a/CLAPACK-3.2.1/SRC/cpbstf.c
+++ b/CLAPACK-3.2.1/SRC/cpbstf.c
@@ -37,7 +37,8 @@ static real c_b9 = -1.f;
     extern logical lsame_(char *, char *);
     logical upper;
     extern /* Subroutine */ int clacgv_(integer *, complex *, integer *), 
-	    csscal_(integer *, real *, complex *, integer *), xerbla_(char *, 
+	    csscal_(integer *, real *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/cpbsv.c b/CLAPACK-3.2.1/SRC/cpbsv.c
index 4b59d79..b76c030 100644
--- a/CLAPACK-3.2.1/SRC/cpbsv.c
+++ b/CLAPACK-3.2.1/SRC/cpbsv.c
@@ -22,7 +22,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), cpbtrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  cpbtrf_(
 	    char *, integer *, integer *, complex *, integer *, integer *), cpbtrs_(char *, integer *, integer *, integer *, complex 
 	    *, integer *, complex *, integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/cpbsvx.c b/CLAPACK-3.2.1/SRC/cpbsvx.c
index f3ad88c..552fb7d 100644
--- a/CLAPACK-3.2.1/SRC/cpbsvx.c
+++ b/CLAPACK-3.2.1/SRC/cpbsvx.c
@@ -46,8 +46,10 @@ static integer c__1 = 1;
     extern doublereal slamch_(char *);
     logical nofact;
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
-	    *, integer *, complex *, integer *), xerbla_(char *, 
-	    integer *), cpbequ_(char *, integer *, integer *, complex 
+	    *, integer *, complex *, integer *);
+    void xerbla_(char *, 
+	    integer *);
+    int cpbequ_(char *, integer *, integer *, complex 
 	    *, integer *, real *, real *, real *, integer *), cpbrfs_(
 	    char *, integer *, integer *, integer *, complex *, integer *, 
 	    complex *, integer *, complex *, integer *, complex *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/cpbtf2.c b/CLAPACK-3.2.1/SRC/cpbtf2.c
index eab52ff..48afb15 100644
--- a/CLAPACK-3.2.1/SRC/cpbtf2.c
+++ b/CLAPACK-3.2.1/SRC/cpbtf2.c
@@ -37,7 +37,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     logical upper;
     extern /* Subroutine */ int clacgv_(integer *, complex *, integer *), 
-	    csscal_(integer *, real *, complex *, integer *), xerbla_(char *, 
+	    csscal_(integer *, real *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/cpbtrf.c b/CLAPACK-3.2.1/SRC/cpbtrf.c
index 7d08412..9f76a36 100644
--- a/CLAPACK-3.2.1/SRC/cpbtrf.c
+++ b/CLAPACK-3.2.1/SRC/cpbtrf.c
@@ -42,7 +42,8 @@ static integer c__33 = 33;
 	    integer *, integer *, complex *, complex *, integer *, complex *, 
 	    integer *), cpbtf2_(char *, 
 	    integer *, integer *, complex *, integer *, integer *), 
-	    cpotf2_(char *, integer *, complex *, integer *, integer *), xerbla_(char *, integer *);
+	    cpotf2_(char *, integer *, complex *, integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/cpbtrs.c b/CLAPACK-3.2.1/SRC/cpbtrs.c
index d325213..a980d02 100644
--- a/CLAPACK-3.2.1/SRC/cpbtrs.c
+++ b/CLAPACK-3.2.1/SRC/cpbtrs.c
@@ -30,7 +30,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int ctbsv_(char *, char *, char *, integer *, 
 	    integer *, complex *, integer *, complex *, integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cpftrf.c b/CLAPACK-3.2.1/SRC/cpftrf.c
index 85bdab7..c4417b9 100644
--- a/CLAPACK-3.2.1/SRC/cpftrf.c
+++ b/CLAPACK-3.2.1/SRC/cpftrf.c
@@ -34,7 +34,8 @@ static real c_b16 = 1.f;
     logical lower;
     extern /* Subroutine */ int ctrsm_(char *, char *, char *, char *, 
 	    integer *, integer *, complex *, complex *, integer *, complex *, 
-	    integer *), xerbla_(char *, 
+	    integer *);
+    void xerbla_(char *, 
 	    integer *);
     logical nisodd;
     extern /* Subroutine */ int cpotrf_(char *, integer *, complex *, integer 
diff --git a/CLAPACK-3.2.1/SRC/cpftri.c b/CLAPACK-3.2.1/SRC/cpftri.c
index da7e26d..7e5d2b3 100644
--- a/CLAPACK-3.2.1/SRC/cpftri.c
+++ b/CLAPACK-3.2.1/SRC/cpftri.c
@@ -34,7 +34,7 @@ static real c_b12 = 1.f;
 	    integer *, integer *, complex *, complex *, integer *, complex *, 
 	    integer *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd;
     extern /* Subroutine */ int clauum_(char *, integer *, complex *, integer 
 	    *, integer *), ctftri_(char *, char *, char *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/cpftrs.c b/CLAPACK-3.2.1/SRC/cpftrs.c
index 7c42d26..4abb9ef 100644
--- a/CLAPACK-3.2.1/SRC/cpftrs.c
+++ b/CLAPACK-3.2.1/SRC/cpftrs.c
@@ -29,7 +29,7 @@ static complex c_b1 = {1.f,0.f};
     extern /* Subroutine */ int ctfsm_(char *, char *, char *, char *, char *, 
 	     integer *, integer *, complex *, complex *, complex *, integer *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2)                                    -- */
diff --git a/CLAPACK-3.2.1/SRC/cpocon.c b/CLAPACK-3.2.1/SRC/cpocon.c
index b31555e..9779df6 100644
--- a/CLAPACK-3.2.1/SRC/cpocon.c
+++ b/CLAPACK-3.2.1/SRC/cpocon.c
@@ -39,7 +39,7 @@ static integer c__1 = 1;
     real scalel;
     extern doublereal slamch_(char *);
     real scaleu;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real ainvnm;
     extern /* Subroutine */ int clatrs_(char *, char *, char *, char *, 
 	    integer *, complex *, integer *, complex *, real *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/cpoequ.c b/CLAPACK-3.2.1/SRC/cpoequ.c
index a6c8498..ea080a1 100644
--- a/CLAPACK-3.2.1/SRC/cpoequ.c
+++ b/CLAPACK-3.2.1/SRC/cpoequ.c
@@ -26,7 +26,7 @@
     /* Local variables */
     integer i__;
     real smin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cpoequb.c b/CLAPACK-3.2.1/SRC/cpoequb.c
index 1c29632..340cff7 100644
--- a/CLAPACK-3.2.1/SRC/cpoequb.c
+++ b/CLAPACK-3.2.1/SRC/cpoequb.c
@@ -27,7 +27,7 @@
     integer i__;
     real tmp, base, smin;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*     -- LAPACK routine (version 3.2)                                 -- */
diff --git a/CLAPACK-3.2.1/SRC/cporfs.c b/CLAPACK-3.2.1/SRC/cporfs.c
index 401a877..b3ac4fa 100644
--- a/CLAPACK-3.2.1/SRC/cporfs.c
+++ b/CLAPACK-3.2.1/SRC/cporfs.c
@@ -53,7 +53,8 @@ static integer c__1 = 1;
 	    *, integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), cpotrs_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  cpotrs_(
 	    char *, integer *, integer *, complex *, integer *, complex *, 
 	    integer *, integer *);
     real lstres;
diff --git a/CLAPACK-3.2.1/SRC/cporfsx.c b/CLAPACK-3.2.1/SRC/cporfsx.c
index 5ce6195..cb2eb38 100644
--- a/CLAPACK-3.2.1/SRC/cporfsx.c
+++ b/CLAPACK-3.2.1/SRC/cporfsx.c
@@ -58,7 +58,8 @@ static logical c_false = FALSE_;
 	    integer *, complex *, integer *, complex *, integer *, complex *, 
 	    real *, ftnlen), clanhe_(char *, char *, integer *, complex *, 
 	    integer *, real *), slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), cpocon_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  cpocon_(
 	    char *, integer *, complex *, integer *, real *, real *, complex *
 , real *, integer *);
     extern integer ilaprec_(char *);
diff --git a/CLAPACK-3.2.1/SRC/cposv.c b/CLAPACK-3.2.1/SRC/cposv.c
index 8dbc051..ad2874e 100644
--- a/CLAPACK-3.2.1/SRC/cposv.c
+++ b/CLAPACK-3.2.1/SRC/cposv.c
@@ -21,7 +21,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), cpotrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  cpotrf_(
 	    char *, integer *, complex *, integer *, integer *), 
 	    cpotrs_(char *, integer *, integer *, complex *, integer *, 
 	    complex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/cposvx.c b/CLAPACK-3.2.1/SRC/cposvx.c
index bf2fc35..1b6863d 100644
--- a/CLAPACK-3.2.1/SRC/cposvx.c
+++ b/CLAPACK-3.2.1/SRC/cposvx.c
@@ -38,7 +38,8 @@
     extern doublereal slamch_(char *);
     logical nofact;
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
-	    *, integer *, complex *, integer *), xerbla_(char *, 
+	    *, integer *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     real bignum;
     extern /* Subroutine */ int cpocon_(char *, integer *, complex *, integer 
diff --git a/CLAPACK-3.2.1/SRC/cposvxx.c b/CLAPACK-3.2.1/SRC/cposvxx.c
index 067ff77..ed1eb77 100644
--- a/CLAPACK-3.2.1/SRC/cposvxx.c
+++ b/CLAPACK-3.2.1/SRC/cposvxx.c
@@ -39,7 +39,8 @@
     extern doublereal slamch_(char *);
     logical nofact;
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
-	    *, integer *, complex *, integer *), xerbla_(char *, 
+	    *, integer *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     real bignum;
     integer infequ;
diff --git a/CLAPACK-3.2.1/SRC/cpotf2.c b/CLAPACK-3.2.1/SRC/cpotf2.c
index 53ff862..3066bf5 100644
--- a/CLAPACK-3.2.1/SRC/cpotf2.c
+++ b/CLAPACK-3.2.1/SRC/cpotf2.c
@@ -40,7 +40,8 @@ static integer c__1 = 1;
 , integer *);
     logical upper;
     extern /* Subroutine */ int clacgv_(integer *, complex *, integer *), 
-	    csscal_(integer *, real *, complex *, integer *), xerbla_(char *, 
+	    csscal_(integer *, real *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     extern logical sisnan_(real *);
 
diff --git a/CLAPACK-3.2.1/SRC/cpotrf.c b/CLAPACK-3.2.1/SRC/cpotrf.c
index f71adee..7f8c53c 100644
--- a/CLAPACK-3.2.1/SRC/cpotrf.c
+++ b/CLAPACK-3.2.1/SRC/cpotrf.c
@@ -41,7 +41,8 @@ static real c_b15 = 1.f;
 	    integer *);
     logical upper;
     extern /* Subroutine */ int cpotf2_(char *, integer *, complex *, integer 
-	    *, integer *), xerbla_(char *, integer *);
+	    *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/cpotri.c b/CLAPACK-3.2.1/SRC/cpotri.c
index 27e88ce..cc4ecb3 100644
--- a/CLAPACK-3.2.1/SRC/cpotri.c
+++ b/CLAPACK-3.2.1/SRC/cpotri.c
@@ -21,7 +21,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), clauum_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  clauum_(
 	    char *, integer *, complex *, integer *, integer *), 
 	    ctrtri_(char *, char *, integer *, complex *, integer *, integer *
 );
diff --git a/CLAPACK-3.2.1/SRC/cpotrs.c b/CLAPACK-3.2.1/SRC/cpotrs.c
index d65ce4e..60a878c 100644
--- a/CLAPACK-3.2.1/SRC/cpotrs.c
+++ b/CLAPACK-3.2.1/SRC/cpotrs.c
@@ -29,7 +29,7 @@ static complex c_b1 = {1.f,0.f};
 	    integer *, integer *, complex *, complex *, integer *, complex *, 
 	    integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cppcon.c b/CLAPACK-3.2.1/SRC/cppcon.c
index 656f100..180db9b 100644
--- a/CLAPACK-3.2.1/SRC/cppcon.c
+++ b/CLAPACK-3.2.1/SRC/cppcon.c
@@ -39,7 +39,8 @@ static integer c__1 = 1;
     real scalel;
     extern doublereal slamch_(char *);
     real scaleu;
-    extern /* Subroutine */ int xerbla_(char *, integer *), clatps_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  clatps_(
 	    char *, char *, char *, char *, integer *, complex *, complex *, 
 	    real *, real *, integer *);
     real ainvnm;
diff --git a/CLAPACK-3.2.1/SRC/cppequ.c b/CLAPACK-3.2.1/SRC/cppequ.c
index 31877c8..7100ce8 100644
--- a/CLAPACK-3.2.1/SRC/cppequ.c
+++ b/CLAPACK-3.2.1/SRC/cppequ.c
@@ -28,7 +28,7 @@
     real smin;
     extern logical lsame_(char *, char *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cpprfs.c b/CLAPACK-3.2.1/SRC/cpprfs.c
index 2159485..c375ab2 100644
--- a/CLAPACK-3.2.1/SRC/cpprfs.c
+++ b/CLAPACK-3.2.1/SRC/cpprfs.c
@@ -51,7 +51,8 @@ static integer c__1 = 1;
 	    *, integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), cpptrs_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  cpptrs_(
 	    char *, integer *, integer *, complex *, complex *, integer *, 
 	    integer *);
     real lstres;
diff --git a/CLAPACK-3.2.1/SRC/cppsv.c b/CLAPACK-3.2.1/SRC/cppsv.c
index c13d7d3..4973da7 100644
--- a/CLAPACK-3.2.1/SRC/cppsv.c
+++ b/CLAPACK-3.2.1/SRC/cppsv.c
@@ -21,7 +21,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), cpptrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  cpptrf_(
 	    char *, integer *, complex *, integer *), cpptrs_(char *, 
 	    integer *, integer *, complex *, complex *, integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/cppsvx.c b/CLAPACK-3.2.1/SRC/cppsvx.c
index 3898b38..2a75715 100644
--- a/CLAPACK-3.2.1/SRC/cppsvx.c
+++ b/CLAPACK-3.2.1/SRC/cppsvx.c
@@ -40,7 +40,8 @@ static integer c__1 = 1;
 	    real *, real *, char *);
     logical nofact;
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
-	    *, integer *, complex *, integer *), xerbla_(char *, 
+	    *, integer *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     real bignum;
     extern /* Subroutine */ int cppcon_(char *, integer *, complex *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/cpptrf.c b/CLAPACK-3.2.1/SRC/cpptrf.c
index 39bf238..ad72eed 100644
--- a/CLAPACK-3.2.1/SRC/cpptrf.c
+++ b/CLAPACK-3.2.1/SRC/cpptrf.c
@@ -40,7 +40,8 @@ static real c_b16 = -1.f;
     logical upper;
     extern /* Subroutine */ int ctpsv_(char *, char *, char *, integer *, 
 	    complex *, complex *, integer *), csscal_(
-	    integer *, real *, complex *, integer *), xerbla_(char *, integer 
+	    integer *, real *, complex *, integer *);
+    void xerbla_(char *, integer 
 	    *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/cpptri.c b/CLAPACK-3.2.1/SRC/cpptri.c
index b3dcfd4..67b24a7 100644
--- a/CLAPACK-3.2.1/SRC/cpptri.c
+++ b/CLAPACK-3.2.1/SRC/cpptri.c
@@ -39,7 +39,9 @@ static integer c__1 = 1;
 	    complex *, complex *, integer *);
     logical upper;
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
-	    *), xerbla_(char *, integer *), ctptri_(char *, char *, 
+	    *);
+    void xerbla_(char *, integer *);
+    int ctptri_(char *, char *, 
 	    integer *, complex *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/cpptrs.c b/CLAPACK-3.2.1/SRC/cpptrs.c
index 631f870..176480d 100644
--- a/CLAPACK-3.2.1/SRC/cpptrs.c
+++ b/CLAPACK-3.2.1/SRC/cpptrs.c
@@ -28,7 +28,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     logical upper;
     extern /* Subroutine */ int ctpsv_(char *, char *, char *, integer *, 
-	    complex *, complex *, integer *), xerbla_(
+	    complex *, complex *, integer *);
+    void xerbla_(
 	    char *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/cpstf2.c b/CLAPACK-3.2.1/SRC/cpstf2.c
index 1811995..12027e7 100644
--- a/CLAPACK-3.2.1/SRC/cpstf2.c
+++ b/CLAPACK-3.2.1/SRC/cpstf2.c
@@ -48,7 +48,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int clacgv_(integer *, complex *, integer *);
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
-	    *), xerbla_(char *, integer *);
+	    *);
+    void xerbla_(char *, integer *);
     extern logical sisnan_(real *);
     extern integer smaxloc_(real *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/cpstrf.c b/CLAPACK-3.2.1/SRC/cpstrf.c
index aab54b9..e53dcec 100644
--- a/CLAPACK-3.2.1/SRC/cpstrf.c
+++ b/CLAPACK-3.2.1/SRC/cpstrf.c
@@ -55,7 +55,8 @@ static real c_b30 = 1.f;
 	    clacgv_(integer *, complex *, integer *);
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
-	    *), xerbla_(char *, integer *);
+	    *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern logical sisnan_(real *);
diff --git a/CLAPACK-3.2.1/SRC/cptcon.c b/CLAPACK-3.2.1/SRC/cptcon.c
index a09b17d..887b5ea 100644
--- a/CLAPACK-3.2.1/SRC/cptcon.c
+++ b/CLAPACK-3.2.1/SRC/cptcon.c
@@ -29,7 +29,7 @@ static integer c__1 = 1;
 
     /* Local variables */
     integer i__, ix;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
     real ainvnm;
 
diff --git a/CLAPACK-3.2.1/SRC/cpteqr.c b/CLAPACK-3.2.1/SRC/cpteqr.c
index 82c53c6..963f7d6 100644
--- a/CLAPACK-3.2.1/SRC/cpteqr.c
+++ b/CLAPACK-3.2.1/SRC/cpteqr.c
@@ -36,8 +36,10 @@ static integer c__1 = 1;
     integer nru;
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int claset_(char *, integer *, integer *, complex 
-	    *, complex *, complex *, integer *), xerbla_(char *, 
-	    integer *), cbdsqr_(char *, integer *, integer *, integer 
+	    *, complex *, complex *, integer *);
+    void xerbla_(char *, 
+	    integer *);
+    int cbdsqr_(char *, integer *, integer *, integer 
 	    *, integer *, real *, real *, complex *, integer *, complex *, 
 	    integer *, complex *, integer *, real *, integer *);
     integer icompz;
diff --git a/CLAPACK-3.2.1/SRC/cptrfs.c b/CLAPACK-3.2.1/SRC/cptrfs.c
index 66e9b3c..8d89b17 100644
--- a/CLAPACK-3.2.1/SRC/cptrfs.c
+++ b/CLAPACK-3.2.1/SRC/cptrfs.c
@@ -48,7 +48,7 @@ static complex c_b16 = {1.f,0.f};
     logical upper;
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
     real lstres;
     extern /* Subroutine */ int cpttrs_(char *, integer *, integer *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/cptsv.c b/CLAPACK-3.2.1/SRC/cptsv.c
index 5f9b31f..13709c6 100644
--- a/CLAPACK-3.2.1/SRC/cptsv.c
+++ b/CLAPACK-3.2.1/SRC/cptsv.c
@@ -20,7 +20,8 @@
     integer b_dim1, b_offset, i__1;
 
     /* Local variables */
-    extern /* Subroutine */ int xerbla_(char *, integer *), cpttrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  cpttrf_(
 	    integer *, real *, complex *, integer *), cpttrs_(char *, integer 
 	    *, integer *, real *, complex *, complex *, integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/cptsvx.c b/CLAPACK-3.2.1/SRC/cptsvx.c
index 2e31446..4faa4d3 100644
--- a/CLAPACK-3.2.1/SRC/cptsvx.c
+++ b/CLAPACK-3.2.1/SRC/cptsvx.c
@@ -35,8 +35,10 @@ static integer c__1 = 1;
 	    real *, complex *);
     logical nofact;
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
-	    *, integer *, complex *, integer *), xerbla_(char *, 
-	    integer *), cptcon_(integer *, real *, complex *, real *, 
+	    *, integer *, complex *, integer *);
+    void xerbla_(char *, 
+	    integer *);
+    int cptcon_(integer *, real *, complex *, real *, 
 	    real *, real *, integer *), cptrfs_(char *, integer *, integer *, 
 	    real *, complex *, real *, complex *, complex *, integer *, 
 	    complex *, integer *, real *, real *, complex *, real *, integer *
diff --git a/CLAPACK-3.2.1/SRC/cpttrf.c b/CLAPACK-3.2.1/SRC/cpttrf.c
index 29a877c..ee9fe7a 100644
--- a/CLAPACK-3.2.1/SRC/cpttrf.c
+++ b/CLAPACK-3.2.1/SRC/cpttrf.c
@@ -26,7 +26,7 @@
     real f, g;
     integer i__, i4;
     real eii, eir;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cpttrs.c b/CLAPACK-3.2.1/SRC/cpttrs.c
index fe730b7..ed0f9d4 100644
--- a/CLAPACK-3.2.1/SRC/cpttrs.c
+++ b/CLAPACK-3.2.1/SRC/cpttrs.c
@@ -28,7 +28,8 @@ static integer c_n1 = -1;
     integer j, jb, nb, iuplo;
     logical upper;
     extern /* Subroutine */ int cptts2_(integer *, integer *, integer *, real 
-	    *, complex *, complex *, integer *), xerbla_(char *, integer *);
+	    *, complex *, complex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/cspcon.c b/CLAPACK-3.2.1/SRC/cspcon.c
index fe65b69..2ebb3c0 100644
--- a/CLAPACK-3.2.1/SRC/cspcon.c
+++ b/CLAPACK-3.2.1/SRC/cspcon.c
@@ -29,7 +29,8 @@ static integer c__1 = 1;
     integer isave[3];
     logical upper;
     extern /* Subroutine */ int clacn2_(integer *, complex *, complex *, real 
-	    *, integer *, integer *), xerbla_(char *, integer *);
+	    *, integer *, integer *);
+    void xerbla_(char *, integer *);
     real ainvnm;
     extern /* Subroutine */ int csptrs_(char *, integer *, integer *, complex 
 	    *, integer *, complex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/cspmv.c b/CLAPACK-3.2.1/SRC/cspmv.c
index fc9a3d1..3743a80 100644
--- a/CLAPACK-3.2.1/SRC/cspmv.c
+++ b/CLAPACK-3.2.1/SRC/cspmv.c
@@ -25,7 +25,7 @@
     integer i__, j, k, kk, ix, iy, jx, jy, kx, ky, info;
     complex temp1, temp2;
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK auxiliary routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cspr.c b/CLAPACK-3.2.1/SRC/cspr.c
index 9b49f94..24f57a4 100644
--- a/CLAPACK-3.2.1/SRC/cspr.c
+++ b/CLAPACK-3.2.1/SRC/cspr.c
@@ -24,7 +24,7 @@
     integer i__, j, k, kk, ix, jx, kx, info;
     complex temp;
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK auxiliary routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/csprfs.c b/CLAPACK-3.2.1/SRC/csprfs.c
index 2f385f6..ec10bde 100644
--- a/CLAPACK-3.2.1/SRC/csprfs.c
+++ b/CLAPACK-3.2.1/SRC/csprfs.c
@@ -53,7 +53,7 @@ static integer c__1 = 1;
 	    *, integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real lstres;
     extern /* Subroutine */ int csptrs_(char *, integer *, integer *, complex 
 	    *, integer *, complex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/cspsv.c b/CLAPACK-3.2.1/SRC/cspsv.c
index fd24509..1e3d702 100644
--- a/CLAPACK-3.2.1/SRC/cspsv.c
+++ b/CLAPACK-3.2.1/SRC/cspsv.c
@@ -21,7 +21,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), csptrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  csptrf_(
 	    char *, integer *, complex *, integer *, integer *), 
 	    csptrs_(char *, integer *, integer *, complex *, integer *, 
 	    complex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/cspsvx.c b/CLAPACK-3.2.1/SRC/cspsvx.c
index 5a2d13a..78c1a2b 100644
--- a/CLAPACK-3.2.1/SRC/cspsvx.c
+++ b/CLAPACK-3.2.1/SRC/cspsvx.c
@@ -33,7 +33,8 @@ static integer c__1 = 1;
     extern doublereal slamch_(char *);
     logical nofact;
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
-	    *, integer *, complex *, integer *), xerbla_(char *, 
+	    *, integer *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     extern doublereal clansp_(char *, char *, integer *, complex *, real *);
     extern /* Subroutine */ int cspcon_(char *, integer *, complex *, integer 
diff --git a/CLAPACK-3.2.1/SRC/csptrf.c b/CLAPACK-3.2.1/SRC/csptrf.c
index 753039b..b4d4968 100644
--- a/CLAPACK-3.2.1/SRC/csptrf.c
+++ b/CLAPACK-3.2.1/SRC/csptrf.c
@@ -50,7 +50,7 @@ static integer c__1 = 1;
     logical upper;
     real absakk;
     extern integer icamax_(integer *, complex *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real colmax, rowmax;
 
 
diff --git a/CLAPACK-3.2.1/SRC/csptri.c b/CLAPACK-3.2.1/SRC/csptri.c
index 67dc455..67f5f34 100644
--- a/CLAPACK-3.2.1/SRC/csptri.c
+++ b/CLAPACK-3.2.1/SRC/csptri.c
@@ -46,7 +46,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int cspmv_(char *, integer *, complex *, complex *
 , complex *, integer *, complex *, complex *, integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer kcnext;
 
 
diff --git a/CLAPACK-3.2.1/SRC/csptrs.c b/CLAPACK-3.2.1/SRC/csptrs.c
index d976b8c..c6c9668 100644
--- a/CLAPACK-3.2.1/SRC/csptrs.c
+++ b/CLAPACK-3.2.1/SRC/csptrs.c
@@ -43,7 +43,7 @@ static integer c__1 = 1;
 	    complex *, integer *, complex *, integer *, complex *, integer *),
 	     cswap_(integer *, complex *, integer *, complex *, integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cstedc.c b/CLAPACK-3.2.1/SRC/cstedc.c
index 6c499a4..e57f058 100644
--- a/CLAPACK-3.2.1/SRC/cstedc.c
+++ b/CLAPACK-3.2.1/SRC/cstedc.c
@@ -53,7 +53,8 @@ static integer c__1 = 1;
 	    integer *, real *, integer *, complex *, integer *, real *);
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
-	    *, integer *, complex *, integer *), xerbla_(char *, 
+	    *, integer *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/cstein.c b/CLAPACK-3.2.1/SRC/cstein.c
index ad5a3fc..08b89ce 100644
--- a/CLAPACK-3.2.1/SRC/cstein.c
+++ b/CLAPACK-3.2.1/SRC/cstein.c
@@ -46,7 +46,8 @@ static integer c_n1 = -1;
     real ortol;
     integer indrv1, indrv2, indrv3, indrv4, indrv5;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), slagtf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slagtf_(
 	    integer *, real *, real *, real *, real *, real *, real *, 
 	    integer *, integer *);
     integer nrmchk;
diff --git a/CLAPACK-3.2.1/SRC/cstemr.c b/CLAPACK-3.2.1/SRC/cstemr.c
index 2726853..1cd7982 100644
--- a/CLAPACK-3.2.1/SRC/cstemr.c
+++ b/CLAPACK-3.2.1/SRC/cstemr.c
@@ -70,7 +70,7 @@ static real c_b18 = .003f;
     extern doublereal slamch_(char *);
     integer wbegin;
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     integer inderr, iindwk, indgrs, offset;
     extern /* Subroutine */ int slarrc_(char *, integer *, real *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/csteqr.c b/CLAPACK-3.2.1/SRC/csteqr.c
index 724bf45..cbaa78a 100644
--- a/CLAPACK-3.2.1/SRC/csteqr.c
+++ b/CLAPACK-3.2.1/SRC/csteqr.c
@@ -58,7 +58,7 @@ static real c_b41 = 1.f;
     extern /* Subroutine */ int claset_(char *, integer *, integer *, complex 
 	    *, complex *, complex *, integer *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real safmax;
     extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *, 
 	    real *, integer *, integer *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/csycon.c b/CLAPACK-3.2.1/SRC/csycon.c
index fe23ded..59c9490 100644
--- a/CLAPACK-3.2.1/SRC/csycon.c
+++ b/CLAPACK-3.2.1/SRC/csycon.c
@@ -30,7 +30,8 @@ static integer c__1 = 1;
     integer isave[3];
     logical upper;
     extern /* Subroutine */ int clacn2_(integer *, complex *, complex *, real 
-	    *, integer *, integer *), xerbla_(char *, integer *);
+	    *, integer *, integer *);
+    void xerbla_(char *, integer *);
     real ainvnm;
     extern /* Subroutine */ int csytrs_(char *, integer *, integer *, complex 
 	    *, integer *, integer *, complex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/csyequb.c b/CLAPACK-3.2.1/SRC/csyequb.c
index d2e20e3..e4d6268 100644
--- a/CLAPACK-3.2.1/SRC/csyequb.c
+++ b/CLAPACK-3.2.1/SRC/csyequb.c
@@ -41,7 +41,7 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     real sumsq;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     extern /* Subroutine */ int classq_(integer *, complex *, integer *, real 
 	    *, real *);
diff --git a/CLAPACK-3.2.1/SRC/csymv.c b/CLAPACK-3.2.1/SRC/csymv.c
index d6851ee..5f1ad5b 100644
--- a/CLAPACK-3.2.1/SRC/csymv.c
+++ b/CLAPACK-3.2.1/SRC/csymv.c
@@ -25,7 +25,7 @@
     integer i__, j, ix, iy, jx, jy, kx, ky, info;
     complex temp1, temp2;
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK auxiliary routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/csyr.c b/CLAPACK-3.2.1/SRC/csyr.c
index d09dcea..06c3e21 100644
--- a/CLAPACK-3.2.1/SRC/csyr.c
+++ b/CLAPACK-3.2.1/SRC/csyr.c
@@ -24,7 +24,7 @@
     integer i__, j, ix, jx, kx, info;
     complex temp;
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK auxiliary routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/csyrfs.c b/CLAPACK-3.2.1/SRC/csyrfs.c
index 730bd46..7cb660b 100644
--- a/CLAPACK-3.2.1/SRC/csyrfs.c
+++ b/CLAPACK-3.2.1/SRC/csyrfs.c
@@ -52,7 +52,7 @@ static integer c__1 = 1;
 	    integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real lstres;
     extern /* Subroutine */ int csytrs_(char *, integer *, integer *, complex 
 	    *, integer *, integer *, complex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/csyrfsx.c b/CLAPACK-3.2.1/SRC/csyrfsx.c
index 7331e39..47d50fd 100644
--- a/CLAPACK-3.2.1/SRC/csyrfsx.c
+++ b/CLAPACK-3.2.1/SRC/csyrfsx.c
@@ -57,7 +57,7 @@ static logical c_false = FALSE_;
 	    complex *, real *, ftnlen), cla_syrcond_x__(char *, integer *, 
 	    complex *, integer *, complex *, integer *, integer *, complex *, 
 	    integer *, complex *, real *, ftnlen), slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal clansy_(char *, char *, integer *, complex *, integer *, 
 	     real *);
     extern /* Subroutine */ int csycon_(char *, integer *, complex *, integer 
diff --git a/CLAPACK-3.2.1/SRC/csysv.c b/CLAPACK-3.2.1/SRC/csysv.c
index c5e682d..d2ef66a 100644
--- a/CLAPACK-3.2.1/SRC/csysv.c
+++ b/CLAPACK-3.2.1/SRC/csysv.c
@@ -28,7 +28,7 @@ static integer c_n1 = -1;
     /* Local variables */
     integer nb;
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int csytrf_(char *, integer *, complex *, integer 
diff --git a/CLAPACK-3.2.1/SRC/csysvx.c b/CLAPACK-3.2.1/SRC/csysvx.c
index 233fa11..74ba66c 100644
--- a/CLAPACK-3.2.1/SRC/csysvx.c
+++ b/CLAPACK-3.2.1/SRC/csysvx.c
@@ -35,7 +35,8 @@ static integer c_n1 = -1;
     extern doublereal slamch_(char *);
     logical nofact;
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
-	    *, integer *, complex *, integer *), xerbla_(char *, 
+	    *, integer *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/csysvxx.c b/CLAPACK-3.2.1/SRC/csysvxx.c
index 2863ad5..0be9187 100644
--- a/CLAPACK-3.2.1/SRC/csysvxx.c
+++ b/CLAPACK-3.2.1/SRC/csysvxx.c
@@ -37,7 +37,8 @@
     extern doublereal slamch_(char *);
     logical nofact;
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
-	    *, integer *, complex *, integer *), xerbla_(char *, 
+	    *, integer *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     real bignum;
     integer infequ;
diff --git a/CLAPACK-3.2.1/SRC/csytf2.c b/CLAPACK-3.2.1/SRC/csytf2.c
index 5d00495..5895eb8 100644
--- a/CLAPACK-3.2.1/SRC/csytf2.c
+++ b/CLAPACK-3.2.1/SRC/csytf2.c
@@ -48,7 +48,7 @@ static integer c__1 = 1;
     logical upper;
     real absakk;
     extern integer icamax_(integer *, complex *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real colmax;
     extern logical sisnan_(real *);
     real rowmax;
diff --git a/CLAPACK-3.2.1/SRC/csytrf.c b/CLAPACK-3.2.1/SRC/csytrf.c
index c8d2b53..542db01 100644
--- a/CLAPACK-3.2.1/SRC/csytrf.c
+++ b/CLAPACK-3.2.1/SRC/csytrf.c
@@ -31,7 +31,8 @@ static integer c__2 = 2;
     integer nbmin, iinfo;
     logical upper;
     extern /* Subroutine */ int csytf2_(char *, integer *, complex *, integer 
-	    *, integer *, integer *), xerbla_(char *, integer *);
+	    *, integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int clasyf_(char *, integer *, integer *, integer 
diff --git a/CLAPACK-3.2.1/SRC/csytri.c b/CLAPACK-3.2.1/SRC/csytri.c
index a35945d..cf120d7 100644
--- a/CLAPACK-3.2.1/SRC/csytri.c
+++ b/CLAPACK-3.2.1/SRC/csytri.c
@@ -46,7 +46,8 @@ static integer c__1 = 1;
     logical upper;
     extern /* Subroutine */ int csymv_(char *, integer *, complex *, complex *
 , integer *, complex *, integer *, complex *, complex *, integer *
-), xerbla_(char *, integer *);
+);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/csytrs.c b/CLAPACK-3.2.1/SRC/csytrs.c
index 50a2488..ebd2b90 100644
--- a/CLAPACK-3.2.1/SRC/csytrs.c
+++ b/CLAPACK-3.2.1/SRC/csytrs.c
@@ -44,7 +44,7 @@ static integer c__1 = 1;
 	    complex *, integer *, complex *, integer *, complex *, integer *),
 	     cswap_(integer *, complex *, integer *, complex *, integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/ctbcon.c b/CLAPACK-3.2.1/SRC/ctbcon.c
index 014bac5..82a8621 100644
--- a/CLAPACK-3.2.1/SRC/ctbcon.c
+++ b/CLAPACK-3.2.1/SRC/ctbcon.c
@@ -44,7 +44,8 @@ static integer c__1 = 1;
 	    char *);
     extern /* Subroutine */ int clatbs_(char *, char *, char *, char *, 
 	    integer *, integer *, complex *, integer *, complex *, real *, 
-	    real *, integer *), xerbla_(char *
+	    real *, integer *);
+    void xerbla_(char *
 , integer *);
     real ainvnm;
     extern /* Subroutine */ int csrscl_(integer *, real *, complex *, integer 
diff --git a/CLAPACK-3.2.1/SRC/ctbrfs.c b/CLAPACK-3.2.1/SRC/ctbrfs.c
index 883e532..6a66a98 100644
--- a/CLAPACK-3.2.1/SRC/ctbrfs.c
+++ b/CLAPACK-3.2.1/SRC/ctbrfs.c
@@ -50,7 +50,7 @@ static integer c__1 = 1;
 	    *, integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
     char transn[1], transt[1];
     logical nounit;
diff --git a/CLAPACK-3.2.1/SRC/ctbtrs.c b/CLAPACK-3.2.1/SRC/ctbtrs.c
index d19e3ea..1c8778e 100644
--- a/CLAPACK-3.2.1/SRC/ctbtrs.c
+++ b/CLAPACK-3.2.1/SRC/ctbtrs.c
@@ -30,7 +30,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int ctbsv_(char *, char *, char *, integer *, 
 	    integer *, complex *, integer *, complex *, integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nounit;
 
 
diff --git a/CLAPACK-3.2.1/SRC/ctfsm.c b/CLAPACK-3.2.1/SRC/ctfsm.c
index 2b07055..e693c61 100644
--- a/CLAPACK-3.2.1/SRC/ctfsm.c
+++ b/CLAPACK-3.2.1/SRC/ctfsm.c
@@ -36,7 +36,8 @@ static complex c_b1 = {1.f,0.f};
     logical lower;
     extern /* Subroutine */ int ctrsm_(char *, char *, char *, char *, 
 	    integer *, integer *, complex *, complex *, integer *, complex *, 
-	    integer *), xerbla_(char *, 
+	    integer *);
+    void xerbla_(char *, 
 	    integer *);
     logical misodd, nisodd, notrans;
 
diff --git a/CLAPACK-3.2.1/SRC/ctftri.c b/CLAPACK-3.2.1/SRC/ctftri.c
index 1453e33..dbc110e 100644
--- a/CLAPACK-3.2.1/SRC/ctftri.c
+++ b/CLAPACK-3.2.1/SRC/ctftri.c
@@ -32,7 +32,7 @@ static complex c_b1 = {1.f,0.f};
 	    integer *, integer *, complex *, complex *, integer *, complex *, 
 	    integer *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd;
     extern /* Subroutine */ int ctrtri_(char *, char *, integer *, complex *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/ctfttp.c b/CLAPACK-3.2.1/SRC/ctfttp.c
index c581937..01dcc25 100644
--- a/CLAPACK-3.2.1/SRC/ctfttp.c
+++ b/CLAPACK-3.2.1/SRC/ctfttp.c
@@ -28,7 +28,7 @@
     logical normaltransr;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd;
 
 
diff --git a/CLAPACK-3.2.1/SRC/ctfttr.c b/CLAPACK-3.2.1/SRC/ctfttr.c
index a927b2d..50bd55c 100644
--- a/CLAPACK-3.2.1/SRC/ctfttr.c
+++ b/CLAPACK-3.2.1/SRC/ctfttr.c
@@ -28,7 +28,7 @@
     logical normaltransr;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd;
 
 
diff --git a/CLAPACK-3.2.1/SRC/ctgevc.c b/CLAPACK-3.2.1/SRC/ctgevc.c
index 7aeae85..8d91a0c 100644
--- a/CLAPACK-3.2.1/SRC/ctgevc.c
+++ b/CLAPACK-3.2.1/SRC/ctgevc.c
@@ -69,7 +69,7 @@ static integer c__1 = 1;
     extern doublereal slamch_(char *);
     complex salpha;
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     logical ilcomp;
     integer ihwmny;
diff --git a/CLAPACK-3.2.1/SRC/ctgexc.c b/CLAPACK-3.2.1/SRC/ctgexc.c
index 2ef6ebc..ac490f0 100644
--- a/CLAPACK-3.2.1/SRC/ctgexc.c
+++ b/CLAPACK-3.2.1/SRC/ctgexc.c
@@ -26,7 +26,8 @@
     integer here;
     extern /* Subroutine */ int ctgex2_(logical *, logical *, integer *, 
 	    complex *, integer *, complex *, integer *, complex *, integer *, 
-	    complex *, integer *, integer *, integer *), xerbla_(char *, 
+	    complex *, integer *, integer *, integer *);
+    void xerbla_(char *, 
 	    integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/ctgsen.c b/CLAPACK-3.2.1/SRC/ctgsen.c
index c307f99..cbba400 100644
--- a/CLAPACK-3.2.1/SRC/ctgsen.c
+++ b/CLAPACK-3.2.1/SRC/ctgsen.c
@@ -55,8 +55,10 @@ static integer c__1 = 1;
     real safmin;
     extern /* Subroutine */ int ctgexc_(logical *, logical *, integer *, 
 	    complex *, integer *, complex *, integer *, complex *, integer *, 
-	    complex *, integer *, integer *, integer *, integer *), xerbla_(
-	    char *, integer *), classq_(integer *, complex *, integer 
+	    complex *, integer *, integer *, integer *, integer *);
+    void xerbla_(
+	    char *, integer *);
+    int classq_(integer *, complex *, integer 
 	    *, real *, real *);
     integer liwmin;
     extern /* Subroutine */ int ctgsyl_(char *, integer *, integer *, integer 
diff --git a/CLAPACK-3.2.1/SRC/ctgsja.c b/CLAPACK-3.2.1/SRC/ctgsja.c
index 04174e8..fba5e69 100644
--- a/CLAPACK-3.2.1/SRC/ctgsja.c
+++ b/CLAPACK-3.2.1/SRC/ctgsja.c
@@ -61,8 +61,10 @@ static real c_b42 = 1.f;
 	    *, integer *);
     integer kcycle;
     extern /* Subroutine */ int claset_(char *, integer *, integer *, complex 
-	    *, complex *, complex *, integer *), xerbla_(char *, 
-	    integer *), slartg_(real *, real *, real *, real *, real *
+	    *, complex *, complex *, integer *);
+    void xerbla_(char *, 
+	    integer *);
+    int slartg_(real *, real *, real *, real *, real *
 );
 
 
diff --git a/CLAPACK-3.2.1/SRC/ctgsna.c b/CLAPACK-3.2.1/SRC/ctgsna.c
index d235cdb..453c750 100644
--- a/CLAPACK-3.2.1/SRC/ctgsna.c
+++ b/CLAPACK-3.2.1/SRC/ctgsna.c
@@ -62,7 +62,8 @@ static integer c__3 = 3;
 	    *, integer *, complex *, integer *), ctgexc_(logical *, 
 	    logical *, integer *, complex *, integer *, complex *, integer *, 
 	    complex *, integer *, complex *, integer *, integer *, integer *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     real bignum;
     logical wantbh, wantdf, somcon;
     extern /* Subroutine */ int ctgsyl_(char *, integer *, integer *, integer 
diff --git a/CLAPACK-3.2.1/SRC/ctgsy2.c b/CLAPACK-3.2.1/SRC/ctgsy2.c
index 055e2ed..e835241 100644
--- a/CLAPACK-3.2.1/SRC/ctgsy2.c
+++ b/CLAPACK-3.2.1/SRC/ctgsy2.c
@@ -48,7 +48,7 @@ static integer c__1 = 1;
 	     clatdf_(integer *, integer *, complex *, integer *, complex *, 
 	    real *, real *, integer *, integer *);
     real scaloc;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/ctgsyl.c b/CLAPACK-3.2.1/SRC/ctgsyl.c
index 2e13f9b..0370f38 100644
--- a/CLAPACK-3.2.1/SRC/ctgsyl.c
+++ b/CLAPACK-3.2.1/SRC/ctgsyl.c
@@ -55,7 +55,8 @@ static complex c_b45 = {1.f,0.f};
     real dscale, scaloc;
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
 	    *, integer *, complex *, integer *), claset_(char *, 
-	    integer *, integer *, complex *, complex *, complex *, integer *), xerbla_(char *, integer *);
+	    integer *, integer *, complex *, complex *, complex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer iround;
diff --git a/CLAPACK-3.2.1/SRC/ctpcon.c b/CLAPACK-3.2.1/SRC/ctpcon.c
index fafeb8e..91ed952 100644
--- a/CLAPACK-3.2.1/SRC/ctpcon.c
+++ b/CLAPACK-3.2.1/SRC/ctpcon.c
@@ -39,7 +39,7 @@ static integer c__1 = 1;
     real xnorm;
     extern integer icamax_(integer *, complex *, integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal clantp_(char *, char *, char *, integer *, complex *, 
 	    real *);
     extern /* Subroutine */ int clatps_(char *, char *, char *, char *, 
diff --git a/CLAPACK-3.2.1/SRC/ctprfs.c b/CLAPACK-3.2.1/SRC/ctprfs.c
index cf3bd0e..c511fb7 100644
--- a/CLAPACK-3.2.1/SRC/ctprfs.c
+++ b/CLAPACK-3.2.1/SRC/ctprfs.c
@@ -51,7 +51,7 @@ static integer c__1 = 1;
 	    integer *, complex *, complex *, real *, integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
     char transn[1], transt[1];
     logical nounit;
diff --git a/CLAPACK-3.2.1/SRC/ctptri.c b/CLAPACK-3.2.1/SRC/ctptri.c
index f8161f2..80d8e62 100644
--- a/CLAPACK-3.2.1/SRC/ctptri.c
+++ b/CLAPACK-3.2.1/SRC/ctptri.c
@@ -37,7 +37,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int ctpmv_(char *, char *, char *, integer *, 
 	    complex *, complex *, integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer jclast;
     logical nounit;
 
diff --git a/CLAPACK-3.2.1/SRC/ctptrs.c b/CLAPACK-3.2.1/SRC/ctptrs.c
index ae5dbc7..acb7511 100644
--- a/CLAPACK-3.2.1/SRC/ctptrs.c
+++ b/CLAPACK-3.2.1/SRC/ctptrs.c
@@ -28,7 +28,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     logical upper;
     extern /* Subroutine */ int ctpsv_(char *, char *, char *, integer *, 
-	    complex *, complex *, integer *), xerbla_(
+	    complex *, complex *, integer *);
+    void xerbla_(
 	    char *, integer *);
     logical nounit;
 
diff --git a/CLAPACK-3.2.1/SRC/ctpttf.c b/CLAPACK-3.2.1/SRC/ctpttf.c
index ffd424c..b63d995 100644
--- a/CLAPACK-3.2.1/SRC/ctpttf.c
+++ b/CLAPACK-3.2.1/SRC/ctpttf.c
@@ -28,7 +28,7 @@
     logical normaltransr;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd;
 
 
diff --git a/CLAPACK-3.2.1/SRC/ctpttr.c b/CLAPACK-3.2.1/SRC/ctpttr.c
index 552c88e..1680f68 100644
--- a/CLAPACK-3.2.1/SRC/ctpttr.c
+++ b/CLAPACK-3.2.1/SRC/ctpttr.c
@@ -23,7 +23,7 @@
     integer i__, j, k;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2)                                    -- */
diff --git a/CLAPACK-3.2.1/SRC/ctrcon.c b/CLAPACK-3.2.1/SRC/ctrcon.c
index 05831a7..f4e817c 100644
--- a/CLAPACK-3.2.1/SRC/ctrcon.c
+++ b/CLAPACK-3.2.1/SRC/ctrcon.c
@@ -40,7 +40,7 @@ static integer c__1 = 1;
     real xnorm;
     extern integer icamax_(integer *, complex *, integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal clantr_(char *, char *, char *, integer *, integer *, 
 	    complex *, integer *, real *);
     real ainvnm;
diff --git a/CLAPACK-3.2.1/SRC/ctrevc.c b/CLAPACK-3.2.1/SRC/ctrevc.c
index 05c60f4..28c1b83 100644
--- a/CLAPACK-3.2.1/SRC/ctrevc.c
+++ b/CLAPACK-3.2.1/SRC/ctrevc.c
@@ -52,7 +52,9 @@ static integer c__1 = 1;
     extern integer icamax_(integer *, complex *, integer *);
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
-	    *), xerbla_(char *, integer *), clatrs_(char *, char *, 
+	    *);
+    void xerbla_(char *, integer *);
+    int clatrs_(char *, char *, 
 	    char *, char *, integer *, complex *, integer *, complex *, real *
 , real *, integer *);
     extern doublereal scasum_(integer *, complex *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/ctrexc.c b/CLAPACK-3.2.1/SRC/ctrexc.c
index 7f292e4..85fdaaf 100644
--- a/CLAPACK-3.2.1/SRC/ctrexc.c
+++ b/CLAPACK-3.2.1/SRC/ctrexc.c
@@ -37,7 +37,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     logical wantq;
     extern /* Subroutine */ int clartg_(complex *, complex *, real *, complex 
-	    *, complex *), xerbla_(char *, integer *);
+	    *, complex *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/ctrrfs.c b/CLAPACK-3.2.1/SRC/ctrrfs.c
index c7748a6..81ceec2 100644
--- a/CLAPACK-3.2.1/SRC/ctrrfs.c
+++ b/CLAPACK-3.2.1/SRC/ctrrfs.c
@@ -50,7 +50,7 @@ static integer c__1 = 1;
 	    integer *, complex *, complex *, real *, integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
     char transn[1], transt[1];
     logical nounit;
diff --git a/CLAPACK-3.2.1/SRC/ctrsen.c b/CLAPACK-3.2.1/SRC/ctrsen.c
index 7e45587..447b806 100644
--- a/CLAPACK-3.2.1/SRC/ctrsen.c
+++ b/CLAPACK-3.2.1/SRC/ctrsen.c
@@ -43,7 +43,8 @@ static integer c_n1 = -1;
     extern doublereal clange_(char *, integer *, integer *, complex *, 
 	    integer *, real *);
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
-	    *, integer *, complex *, integer *), xerbla_(char *, 
+	    *, integer *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     logical wantbh;
     extern /* Subroutine */ int ctrexc_(char *, integer *, complex *, integer 
diff --git a/CLAPACK-3.2.1/SRC/ctrsna.c b/CLAPACK-3.2.1/SRC/ctrsna.c
index 0ca9457..c1f3652 100644
--- a/CLAPACK-3.2.1/SRC/ctrsna.c
+++ b/CLAPACK-3.2.1/SRC/ctrsna.c
@@ -51,7 +51,8 @@ static integer c__1 = 1;
     extern integer icamax_(integer *, complex *, integer *);
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int clacpy_(char *, integer *, integer *, complex 
-	    *, integer *, complex *, integer *), xerbla_(char *, 
+	    *, integer *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     real bignum;
     logical wantbh;
diff --git a/CLAPACK-3.2.1/SRC/ctrsyl.c b/CLAPACK-3.2.1/SRC/ctrsyl.c
index 1d525ae..6cc1937 100644
--- a/CLAPACK-3.2.1/SRC/ctrsyl.c
+++ b/CLAPACK-3.2.1/SRC/ctrsyl.c
@@ -52,7 +52,8 @@ static integer c__1 = 1;
     real scaloc;
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int csscal_(integer *, real *, complex *, integer 
-	    *), xerbla_(char *, integer *);
+	    *);
+    void xerbla_(char *, integer *);
     real bignum;
     logical notrna, notrnb;
     real smlnum;
diff --git a/CLAPACK-3.2.1/SRC/ctrti2.c b/CLAPACK-3.2.1/SRC/ctrti2.c
index 36dee65..ed67ed4 100644
--- a/CLAPACK-3.2.1/SRC/ctrti2.c
+++ b/CLAPACK-3.2.1/SRC/ctrti2.c
@@ -36,7 +36,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     logical upper;
     extern /* Subroutine */ int ctrmv_(char *, char *, char *, integer *, 
-	    complex *, integer *, complex *, integer *), xerbla_(char *, integer *);
+	    complex *, integer *, complex *, integer *);
+    void xerbla_(char *, integer *);
     logical nounit;
 
 
diff --git a/CLAPACK-3.2.1/SRC/ctrtri.c b/CLAPACK-3.2.1/SRC/ctrtri.c
index 4647bbf..06188ab 100644
--- a/CLAPACK-3.2.1/SRC/ctrtri.c
+++ b/CLAPACK-3.2.1/SRC/ctrtri.c
@@ -30,7 +30,7 @@ static integer c__2 = 2;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer j, jb, nb, nn;
@@ -42,7 +42,8 @@ static integer c__2 = 2;
 	    integer *, complex *, integer *);
     logical upper;
     extern /* Subroutine */ int ctrti2_(char *, char *, integer *, complex *, 
-	    integer *, integer *), xerbla_(char *, integer *);
+	    integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical nounit;
diff --git a/CLAPACK-3.2.1/SRC/ctrtrs.c b/CLAPACK-3.2.1/SRC/ctrtrs.c
index 71692d1..5bb3f9f 100644
--- a/CLAPACK-3.2.1/SRC/ctrtrs.c
+++ b/CLAPACK-3.2.1/SRC/ctrtrs.c
@@ -28,7 +28,8 @@ static complex c_b2 = {1.f,0.f};
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int ctrsm_(char *, char *, char *, char *, 
 	    integer *, integer *, complex *, complex *, integer *, complex *, 
-	    integer *), xerbla_(char *, 
+	    integer *);
+    void xerbla_(char *, 
 	    integer *);
     logical nounit;
 
diff --git a/CLAPACK-3.2.1/SRC/ctrttf.c b/CLAPACK-3.2.1/SRC/ctrttf.c
index 406aaed..0e8c73a 100644
--- a/CLAPACK-3.2.1/SRC/ctrttf.c
+++ b/CLAPACK-3.2.1/SRC/ctrttf.c
@@ -28,7 +28,7 @@
     logical normaltransr;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd;
 
 
diff --git a/CLAPACK-3.2.1/SRC/ctrttp.c b/CLAPACK-3.2.1/SRC/ctrttp.c
index bdf7acb..f374b19 100644
--- a/CLAPACK-3.2.1/SRC/ctrttp.c
+++ b/CLAPACK-3.2.1/SRC/ctrttp.c
@@ -23,7 +23,7 @@
     integer i__, j, k;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/ctzrqf.c b/CLAPACK-3.2.1/SRC/ctzrqf.c
index 80987b9..3d217e3 100644
--- a/CLAPACK-3.2.1/SRC/ctzrqf.c
+++ b/CLAPACK-3.2.1/SRC/ctzrqf.c
@@ -39,7 +39,8 @@ static integer c__1 = 1;
 	    complex *, integer *), caxpy_(integer *, complex *, complex *, 
 	    integer *, complex *, integer *), clacgv_(integer *, complex *, 
 	    integer *), clarfp_(integer *, complex *, complex *, integer *, 
-	    complex *), xerbla_(char *, integer *);
+	    complex *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/ctzrzf.c b/CLAPACK-3.2.1/SRC/ctzrzf.c
index 759ccba..9a39323 100644
--- a/CLAPACK-3.2.1/SRC/ctzrzf.c
+++ b/CLAPACK-3.2.1/SRC/ctzrzf.c
@@ -30,7 +30,8 @@ static integer c__2 = 2;
     integer i__, m1, ib, nb, ki, kk, mu, nx, iws, nbmin;
     extern /* Subroutine */ int clarzb_(char *, char *, char *, char *, 
 	    integer *, integer *, integer *, integer *, complex *, integer *, 
-	    complex *, integer *, complex *, integer *, complex *, integer *), xerbla_(char *, integer *);
+	    complex *, integer *, complex *, integer *, complex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int clarzt_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/cung2l.c b/CLAPACK-3.2.1/SRC/cung2l.c
index 5af1652..93e697c 100644
--- a/CLAPACK-3.2.1/SRC/cung2l.c
+++ b/CLAPACK-3.2.1/SRC/cung2l.c
@@ -28,8 +28,8 @@ static integer c__1 = 1;
     integer i__, j, l, ii;
     extern /* Subroutine */ int cscal_(integer *, complex *, complex *, 
 	    integer *), clarf_(char *, integer *, integer *, complex *, 
-	    integer *, complex *, complex *, integer *, complex *), 
-	    xerbla_(char *, integer *);
+	    integer *, complex *, complex *, integer *, complex *);
+	void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cung2r.c b/CLAPACK-3.2.1/SRC/cung2r.c
index d02600f..a5c7eb8 100644
--- a/CLAPACK-3.2.1/SRC/cung2r.c
+++ b/CLAPACK-3.2.1/SRC/cung2r.c
@@ -28,8 +28,8 @@ static integer c__1 = 1;
     integer i__, j, l;
     extern /* Subroutine */ int cscal_(integer *, complex *, complex *, 
 	    integer *), clarf_(char *, integer *, integer *, complex *, 
-	    integer *, complex *, complex *, integer *, complex *), 
-	    xerbla_(char *, integer *);
+	    integer *, complex *, complex *, integer *, complex *);
+	void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cungbr.c b/CLAPACK-3.2.1/SRC/cungbr.c
index c8369b0..931ef4d 100644
--- a/CLAPACK-3.2.1/SRC/cungbr.c
+++ b/CLAPACK-3.2.1/SRC/cungbr.c
@@ -30,7 +30,7 @@ static integer c_n1 = -1;
     extern logical lsame_(char *, char *);
     integer iinfo;
     logical wantq;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int cunglq_(integer *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/cunghr.c b/CLAPACK-3.2.1/SRC/cunghr.c
index c52e4a4..bfda7cf 100644
--- a/CLAPACK-3.2.1/SRC/cunghr.c
+++ b/CLAPACK-3.2.1/SRC/cunghr.c
@@ -27,7 +27,7 @@ static integer c_n1 = -1;
 
     /* Local variables */
     integer i__, j, nb, nh, iinfo;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int cungqr_(integer *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/cungl2.c b/CLAPACK-3.2.1/SRC/cungl2.c
index 6a74939..985ec8b 100644
--- a/CLAPACK-3.2.1/SRC/cungl2.c
+++ b/CLAPACK-3.2.1/SRC/cungl2.c
@@ -28,7 +28,8 @@
     extern /* Subroutine */ int cscal_(integer *, complex *, complex *, 
 	    integer *), clarf_(char *, integer *, integer *, complex *, 
 	    integer *, complex *, complex *, integer *, complex *), 
-	    clacgv_(integer *, complex *, integer *), xerbla_(char *, integer 
+	    clacgv_(integer *, complex *, integer *);
+    void xerbla_(char *, integer 
 	    *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/cunglq.c b/CLAPACK-3.2.1/SRC/cunglq.c
index 9165a47..d27f731 100644
--- a/CLAPACK-3.2.1/SRC/cunglq.c
+++ b/CLAPACK-3.2.1/SRC/cunglq.c
@@ -35,7 +35,8 @@ static integer c__2 = 2;
 	    complex *, integer *, complex *, integer *, complex *, integer *, 
 	    complex *, integer *), clarft_(
 	    char *, char *, integer *, integer *, complex *, integer *, 
-	    complex *, complex *, integer *), xerbla_(char *, 
+	    complex *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/cungql.c b/CLAPACK-3.2.1/SRC/cungql.c
index fc7f77d..1792899 100644
--- a/CLAPACK-3.2.1/SRC/cungql.c
+++ b/CLAPACK-3.2.1/SRC/cungql.c
@@ -35,7 +35,8 @@ static integer c__2 = 2;
 	    complex *, integer *, complex *, integer *, complex *, integer *, 
 	    complex *, integer *), clarft_(
 	    char *, char *, integer *, integer *, complex *, integer *, 
-	    complex *, complex *, integer *), xerbla_(char *, 
+	    complex *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/cungqr.c b/CLAPACK-3.2.1/SRC/cungqr.c
index beb92b7..3c765df 100644
--- a/CLAPACK-3.2.1/SRC/cungqr.c
+++ b/CLAPACK-3.2.1/SRC/cungqr.c
@@ -35,7 +35,8 @@ static integer c__2 = 2;
 	    complex *, integer *, complex *, integer *, complex *, integer *, 
 	    complex *, integer *), clarft_(
 	    char *, char *, integer *, integer *, complex *, integer *, 
-	    complex *, complex *, integer *), xerbla_(char *, 
+	    complex *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/cungr2.c b/CLAPACK-3.2.1/SRC/cungr2.c
index 5a9c5f3..f629fa0 100644
--- a/CLAPACK-3.2.1/SRC/cungr2.c
+++ b/CLAPACK-3.2.1/SRC/cungr2.c
@@ -28,7 +28,8 @@
     extern /* Subroutine */ int cscal_(integer *, complex *, complex *, 
 	    integer *), clarf_(char *, integer *, integer *, complex *, 
 	    integer *, complex *, complex *, integer *, complex *), 
-	    clacgv_(integer *, complex *, integer *), xerbla_(char *, integer 
+	    clacgv_(integer *, complex *, integer *);
+    void xerbla_(char *, integer 
 	    *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/cungrq.c b/CLAPACK-3.2.1/SRC/cungrq.c
index 5eeb910..9bee6af 100644
--- a/CLAPACK-3.2.1/SRC/cungrq.c
+++ b/CLAPACK-3.2.1/SRC/cungrq.c
@@ -35,7 +35,8 @@ static integer c__2 = 2;
 	    complex *, integer *, complex *, integer *, complex *, integer *, 
 	    complex *, integer *), clarft_(
 	    char *, char *, integer *, integer *, complex *, integer *, 
-	    complex *, complex *, integer *), xerbla_(char *, 
+	    complex *, complex *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/cungtr.c b/CLAPACK-3.2.1/SRC/cungtr.c
index 58997f7..c242120 100644
--- a/CLAPACK-3.2.1/SRC/cungtr.c
+++ b/CLAPACK-3.2.1/SRC/cungtr.c
@@ -29,7 +29,7 @@ static integer c_n1 = -1;
     extern logical lsame_(char *, char *);
     integer iinfo;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int cungql_(integer *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/cunm2l.c b/CLAPACK-3.2.1/SRC/cunm2l.c
index c553f8f..fa5ec4e 100644
--- a/CLAPACK-3.2.1/SRC/cunm2l.c
+++ b/CLAPACK-3.2.1/SRC/cunm2l.c
@@ -36,7 +36,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int clarf_(char *, integer *, integer *, complex *
 , integer *, complex *, complex *, integer *, complex *);
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/cunm2r.c b/CLAPACK-3.2.1/SRC/cunm2r.c
index 58c69ad..7277f1c 100644
--- a/CLAPACK-3.2.1/SRC/cunm2r.c
+++ b/CLAPACK-3.2.1/SRC/cunm2r.c
@@ -36,7 +36,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int clarf_(char *, integer *, integer *, complex *
 , integer *, complex *, complex *, integer *, complex *);
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/cunmbr.c b/CLAPACK-3.2.1/SRC/cunmbr.c
index ccf73e4..e534657 100644
--- a/CLAPACK-3.2.1/SRC/cunmbr.c
+++ b/CLAPACK-3.2.1/SRC/cunmbr.c
@@ -30,14 +30,14 @@ static integer c__2 = 2;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i1, i2, nb, mi, ni, nq, nw;
     logical left;
     extern logical lsame_(char *, char *);
     integer iinfo;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int cunmlq_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/cunmhr.c b/CLAPACK-3.2.1/SRC/cunmhr.c
index 687085a..643827e 100644
--- a/CLAPACK-3.2.1/SRC/cunmhr.c
+++ b/CLAPACK-3.2.1/SRC/cunmhr.c
@@ -30,14 +30,14 @@ static integer c__2 = 2;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i1, i2, nb, mi, nh, ni, nq, nw;
     logical left;
     extern logical lsame_(char *, char *);
     integer iinfo;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int cunmqr_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/cunml2.c b/CLAPACK-3.2.1/SRC/cunml2.c
index 21b050e..846e5b1 100644
--- a/CLAPACK-3.2.1/SRC/cunml2.c
+++ b/CLAPACK-3.2.1/SRC/cunml2.c
@@ -32,8 +32,8 @@
     extern /* Subroutine */ int clarf_(char *, integer *, integer *, complex *
 , integer *, complex *, complex *, integer *, complex *);
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int clacgv_(integer *, complex *, integer *), 
-	    xerbla_(char *, integer *);
+    extern /* Subroutine */ int clacgv_(integer *, complex *, integer *);
+	void xerbla_(char *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/cunmlq.c b/CLAPACK-3.2.1/SRC/cunmlq.c
index d7aa7a4..077c9f5 100644
--- a/CLAPACK-3.2.1/SRC/cunmlq.c
+++ b/CLAPACK-3.2.1/SRC/cunmlq.c
@@ -31,7 +31,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -47,7 +47,8 @@ static integer c__65 = 65;
 	    integer *, complex *, integer *, complex *, integer *, complex *, 
 	    integer *), clarft_(char *, char *
 , integer *, integer *, complex *, integer *, complex *, complex *
-, integer *), xerbla_(char *, integer *);
+, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/cunmql.c b/CLAPACK-3.2.1/SRC/cunmql.c
index cdd02a3..6fd3ecd 100644
--- a/CLAPACK-3.2.1/SRC/cunmql.c
+++ b/CLAPACK-3.2.1/SRC/cunmql.c
@@ -31,7 +31,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -47,7 +47,8 @@ static integer c__65 = 65;
 	    integer *, complex *, integer *, complex *, integer *, complex *, 
 	    integer *), clarft_(char *, char *
 , integer *, integer *, complex *, integer *, complex *, complex *
-, integer *), xerbla_(char *, integer *);
+, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/cunmqr.c b/CLAPACK-3.2.1/SRC/cunmqr.c
index 846c9a5..bf0b2b9 100644
--- a/CLAPACK-3.2.1/SRC/cunmqr.c
+++ b/CLAPACK-3.2.1/SRC/cunmqr.c
@@ -31,7 +31,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -47,7 +47,8 @@ static integer c__65 = 65;
 	    integer *, complex *, integer *, complex *, integer *, complex *, 
 	    integer *), clarft_(char *, char *
 , integer *, integer *, complex *, integer *, complex *, complex *
-, integer *), xerbla_(char *, integer *);
+, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/cunmr2.c b/CLAPACK-3.2.1/SRC/cunmr2.c
index 2cfe39e..dd71b09 100644
--- a/CLAPACK-3.2.1/SRC/cunmr2.c
+++ b/CLAPACK-3.2.1/SRC/cunmr2.c
@@ -32,8 +32,8 @@
     extern /* Subroutine */ int clarf_(char *, integer *, integer *, complex *
 , integer *, complex *, complex *, integer *, complex *);
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int clacgv_(integer *, complex *, integer *), 
-	    xerbla_(char *, integer *);
+    extern /* Subroutine */ int clacgv_(integer *, complex *, integer *);
+	void xerbla_(char *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/cunmr3.c b/CLAPACK-3.2.1/SRC/cunmr3.c
index ba5e2bd..f67774a 100644
--- a/CLAPACK-3.2.1/SRC/cunmr3.c
+++ b/CLAPACK-3.2.1/SRC/cunmr3.c
@@ -31,7 +31,8 @@
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int clarz_(char *, integer *, integer *, integer *
 , complex *, integer *, complex *, complex *, integer *, complex *
-), xerbla_(char *, integer *);
+);
+    void xerbla_(char *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/cunmrq.c b/CLAPACK-3.2.1/SRC/cunmrq.c
index 020d684..d50480d 100644
--- a/CLAPACK-3.2.1/SRC/cunmrq.c
+++ b/CLAPACK-3.2.1/SRC/cunmrq.c
@@ -31,7 +31,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -47,7 +47,8 @@ static integer c__65 = 65;
 	    integer *, complex *, integer *, complex *, integer *, complex *, 
 	    integer *), clarft_(char *, char *
 , integer *, integer *, complex *, integer *, complex *, complex *
-, integer *), xerbla_(char *, integer *);
+, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/cunmrz.c b/CLAPACK-3.2.1/SRC/cunmrz.c
index e9d4d63..16da22e 100644
--- a/CLAPACK-3.2.1/SRC/cunmrz.c
+++ b/CLAPACK-3.2.1/SRC/cunmrz.c
@@ -32,7 +32,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -49,7 +49,8 @@ static integer c__65 = 65;
 , complex *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), clarzt_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  clarzt_(
 	    char *, char *, integer *, integer *, complex *, integer *, 
 	    complex *, complex *, integer *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/cunmtr.c b/CLAPACK-3.2.1/SRC/cunmtr.c
index c1d63f4..a16d276 100644
--- a/CLAPACK-3.2.1/SRC/cunmtr.c
+++ b/CLAPACK-3.2.1/SRC/cunmtr.c
@@ -29,7 +29,7 @@ static integer c__2 = 2;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i1, i2, nb, mi, ni, nq, nw;
@@ -37,7 +37,7 @@ static integer c__2 = 2;
     extern logical lsame_(char *, char *);
     integer iinfo;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int cunmql_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/cupgtr.c b/CLAPACK-3.2.1/SRC/cupgtr.c
index 135728b..3ffab81 100644
--- a/CLAPACK-3.2.1/SRC/cupgtr.c
+++ b/CLAPACK-3.2.1/SRC/cupgtr.c
@@ -27,7 +27,8 @@
     extern /* Subroutine */ int cung2l_(integer *, integer *, integer *, 
 	    complex *, integer *, complex *, complex *, integer *), cung2r_(
 	    integer *, integer *, integer *, complex *, integer *, complex *, 
-	    complex *, integer *), xerbla_(char *, integer *);
+	    complex *, integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/cupmtr.c b/CLAPACK-3.2.1/SRC/cupmtr.c
index 993d479..afe563f 100644
--- a/CLAPACK-3.2.1/SRC/cupmtr.c
+++ b/CLAPACK-3.2.1/SRC/cupmtr.c
@@ -37,7 +37,7 @@ static integer c__1 = 1;
 , integer *, complex *, complex *, integer *, complex *);
     extern logical lsame_(char *, char *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran, forwrd;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dbdsdc.c b/CLAPACK-3.2.1/SRC/dbdsdc.c
index 6096e4f..76143cc 100644
--- a/CLAPACK-3.2.1/SRC/dbdsdc.c
+++ b/CLAPACK-3.2.1/SRC/dbdsdc.c
@@ -68,7 +68,7 @@ static doublereal c_b29 = 0.;
 	    doublereal *, doublereal *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer givcol;
     extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
     integer icompq;
diff --git a/CLAPACK-3.2.1/SRC/dbdsqr.c b/CLAPACK-3.2.1/SRC/dbdsqr.c
index 08b04fc..0b2620d 100644
--- a/CLAPACK-3.2.1/SRC/dbdsqr.c
+++ b/CLAPACK-3.2.1/SRC/dbdsqr.c
@@ -70,7 +70,8 @@ static doublereal c_b72 = -1.;
 	    doublereal *, doublereal *, doublereal *);
     extern doublereal dlamch_(char *);
     extern /* Subroutine */ int dlartg_(doublereal *, doublereal *, 
-	    doublereal *, doublereal *, doublereal *), xerbla_(char *, 
+	    doublereal *, doublereal *, doublereal *);
+    void xerbla_(char *, 
 	    integer *);
     doublereal sminoa, thresh;
     logical rotate;
diff --git a/CLAPACK-3.2.1/SRC/ddisna.c b/CLAPACK-3.2.1/SRC/ddisna.c
index ad7c367..30746e2 100644
--- a/CLAPACK-3.2.1/SRC/ddisna.c
+++ b/CLAPACK-3.2.1/SRC/ddisna.c
@@ -29,7 +29,7 @@
     logical right;
     extern doublereal dlamch_(char *);
     doublereal oldgap, safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal newgap, thresh;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dgbbrd.c b/CLAPACK-3.2.1/SRC/dgbbrd.c
index 03e09a7..e966c04 100644
--- a/CLAPACK-3.2.1/SRC/dgbbrd.c
+++ b/CLAPACK-3.2.1/SRC/dgbbrd.c
@@ -44,7 +44,9 @@ static integer c__1 = 1;
     extern /* Subroutine */ int dlaset_(char *, integer *, integer *, 
 	    doublereal *, doublereal *, doublereal *, integer *), 
 	    dlartg_(doublereal *, doublereal *, doublereal *, doublereal *, 
-	    doublereal *), xerbla_(char *, integer *), dlargv_(
+	    doublereal *);
+    void xerbla_(char *, integer *);
+    int dlargv_(
 	    integer *, doublereal *, integer *, doublereal *, integer *, 
 	    doublereal *, integer *), dlartv_(integer *, doublereal *, 
 	    integer *, doublereal *, integer *, doublereal *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dgbcon.c b/CLAPACK-3.2.1/SRC/dgbcon.c
index 8b6144c..5773b28 100644
--- a/CLAPACK-3.2.1/SRC/dgbcon.c
+++ b/CLAPACK-3.2.1/SRC/dgbcon.c
@@ -46,7 +46,8 @@ static integer c__1 = 1;
     extern integer idamax_(integer *, doublereal *, integer *);
     extern /* Subroutine */ int dlatbs_(char *, char *, char *, char *, 
 	    integer *, integer *, doublereal *, integer *, doublereal *, 
-	    doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
+	    doublereal *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
     doublereal ainvnm;
     logical onenrm;
     char normin[1];
diff --git a/CLAPACK-3.2.1/SRC/dgbequ.c b/CLAPACK-3.2.1/SRC/dgbequ.c
index d104537..2ad0e60 100644
--- a/CLAPACK-3.2.1/SRC/dgbequ.c
+++ b/CLAPACK-3.2.1/SRC/dgbequ.c
@@ -26,7 +26,7 @@
     integer i__, j, kd;
     doublereal rcmin, rcmax;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum, smlnum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dgbequb.c b/CLAPACK-3.2.1/SRC/dgbequb.c
index 4a0f34b..c4d1614 100644
--- a/CLAPACK-3.2.1/SRC/dgbequb.c
+++ b/CLAPACK-3.2.1/SRC/dgbequb.c
@@ -29,7 +29,7 @@
     integer i__, j, kd;
     doublereal radix, rcmin, rcmax;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum, logrdx, smlnum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dgbrfs.c b/CLAPACK-3.2.1/SRC/dgbrfs.c
index e95b2dc..81a0ce1 100644
--- a/CLAPACK-3.2.1/SRC/dgbrfs.c
+++ b/CLAPACK-3.2.1/SRC/dgbrfs.c
@@ -52,7 +52,8 @@ static doublereal c_b17 = 1.;
 	     integer *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), dgbtrs_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dgbtrs_(
 	    char *, integer *, integer *, integer *, integer *, doublereal *, 
 	    integer *, integer *, doublereal *, integer *, integer *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/dgbrfsx.c b/CLAPACK-3.2.1/SRC/dgbrfsx.c
index 73ab53f..e389b22 100644
--- a/CLAPACK-3.2.1/SRC/dgbrfsx.c
+++ b/CLAPACK-3.2.1/SRC/dgbrfsx.c
@@ -64,7 +64,8 @@ static integer c__1 = 1;
 	    doublereal *, integer *, doublereal *), dlamch_(char *);
     extern /* Subroutine */ int dgbcon_(char *, integer *, integer *, integer 
 	    *, doublereal *, integer *, integer *, doublereal *, doublereal *, 
-	     doublereal *, integer *, integer *), xerbla_(char *, 
+	     doublereal *, integer *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     logical colequ, notran, rowequ;
     extern integer ilaprec_(char *);
diff --git a/CLAPACK-3.2.1/SRC/dgbsv.c b/CLAPACK-3.2.1/SRC/dgbsv.c
index 97c0538..5ba1fce 100644
--- a/CLAPACK-3.2.1/SRC/dgbsv.c
+++ b/CLAPACK-3.2.1/SRC/dgbsv.c
@@ -22,8 +22,9 @@
 
     /* Local variables */
     extern /* Subroutine */ int dgbtrf_(integer *, integer *, integer *, 
-	    integer *, doublereal *, integer *, integer *, integer *), 
-	    xerbla_(char *, integer *), dgbtrs_(char *, integer *, 
+	    integer *, doublereal *, integer *, integer *, integer *);
+	void xerbla_(char *, integer *);
+    int dgbtrs_(char *, integer *, 
 	    integer *, integer *, integer *, doublereal *, integer *, integer 
 	    *, doublereal *, integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/dgbsvx.c b/CLAPACK-3.2.1/SRC/dgbsvx.c
index 7e414cc..0d4c771 100644
--- a/CLAPACK-3.2.1/SRC/dgbsvx.c
+++ b/CLAPACK-3.2.1/SRC/dgbsvx.c
@@ -60,8 +60,8 @@ static integer c__1 = 1;
 	    *, integer *);
     logical nofact;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     doublereal bignum;
     extern /* Subroutine */ int dgbtrs_(char *, integer *, integer *, integer 
 	    *, integer *, doublereal *, integer *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dgbsvxx.c b/CLAPACK-3.2.1/SRC/dgbsvxx.c
index aeb294b..e4cec66 100644
--- a/CLAPACK-3.2.1/SRC/dgbsvxx.c
+++ b/CLAPACK-3.2.1/SRC/dgbsvxx.c
@@ -45,8 +45,8 @@
 	    integer *, doublereal *, integer *, integer *, integer *);
     logical nofact;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     doublereal bignum;
     extern /* Subroutine */ int dgbtrs_(char *, integer *, integer *, integer 
 	    *, integer *, doublereal *, integer *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dgbtf2.c b/CLAPACK-3.2.1/SRC/dgbtf2.c
index 400eafb..7c0e604 100644
--- a/CLAPACK-3.2.1/SRC/dgbtf2.c
+++ b/CLAPACK-3.2.1/SRC/dgbtf2.c
@@ -33,7 +33,7 @@ static doublereal c_b9 = -1.;
 	    *), dswap_(integer *, doublereal *, integer *, doublereal *, 
 	    integer *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dgbtrf.c b/CLAPACK-3.2.1/SRC/dgbtrf.c
index 7b90c9b..24d956b 100644
--- a/CLAPACK-3.2.1/SRC/dgbtrf.c
+++ b/CLAPACK-3.2.1/SRC/dgbtrf.c
@@ -49,7 +49,7 @@ static doublereal c_b31 = 1.;
 	    integer *, integer *, integer *, integer *, doublereal *, integer 
 	    *, integer *, integer *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int dlaswp_(integer *, doublereal *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dgbtrs.c b/CLAPACK-3.2.1/SRC/dgbtrs.c
index 83d8460..4888481 100644
--- a/CLAPACK-3.2.1/SRC/dgbtrs.c
+++ b/CLAPACK-3.2.1/SRC/dgbtrs.c
@@ -39,7 +39,7 @@ static doublereal c_b23 = 1.;
 	    char *, char *, integer *, integer *, doublereal *, integer *, 
 	    doublereal *, integer *);
     logical lnoti;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dgebak.c b/CLAPACK-3.2.1/SRC/dgebak.c
index db1af91..71aee30 100644
--- a/CLAPACK-3.2.1/SRC/dgebak.c
+++ b/CLAPACK-3.2.1/SRC/dgebak.c
@@ -30,7 +30,7 @@
     extern /* Subroutine */ int dswap_(integer *, doublereal *, integer *, 
 	    doublereal *, integer *);
     logical leftv;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical rightv;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dgebal.c b/CLAPACK-3.2.1/SRC/dgebal.c
index aef5ab8..e70d410 100644
--- a/CLAPACK-3.2.1/SRC/dgebal.c
+++ b/CLAPACK-3.2.1/SRC/dgebal.c
@@ -37,7 +37,7 @@ static integer c__1 = 1;
     doublereal sfmin1, sfmin2, sfmax1, sfmax2;
     extern doublereal dlamch_(char *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconv;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dgebd2.c b/CLAPACK-3.2.1/SRC/dgebd2.c
index e2e5472..77298c9 100644
--- a/CLAPACK-3.2.1/SRC/dgebd2.c
+++ b/CLAPACK-3.2.1/SRC/dgebd2.c
@@ -29,7 +29,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int dlarf_(char *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, doublereal *, integer *, 
 	    doublereal *), dlarfg_(integer *, doublereal *, 
-	    doublereal *, integer *, doublereal *), xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dgebrd.c b/CLAPACK-3.2.1/SRC/dgebrd.c
index d5202c8..7165b35 100644
--- a/CLAPACK-3.2.1/SRC/dgebrd.c
+++ b/CLAPACK-3.2.1/SRC/dgebrd.c
@@ -41,7 +41,8 @@ static doublereal c_b22 = 1.;
 	     doublereal *, integer *), dlabrd_(integer *, integer *, integer *
 , doublereal *, integer *, doublereal *, doublereal *, doublereal 
 	    *, doublereal *, doublereal *, integer *, doublereal *, integer *)
-	    , xerbla_(char *, integer *);
+	    ;
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwrkx, ldwrky, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/dgecon.c b/CLAPACK-3.2.1/SRC/dgecon.c
index ba86cf6..6ef70d6 100644
--- a/CLAPACK-3.2.1/SRC/dgecon.c
+++ b/CLAPACK-3.2.1/SRC/dgecon.c
@@ -38,7 +38,7 @@ static integer c__1 = 1;
 	    integer *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int dlatrs_(char *, char *, char *, char *, 
 	    integer *, doublereal *, integer *, doublereal *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dgeequ.c b/CLAPACK-3.2.1/SRC/dgeequ.c
index b0b1462..7040991 100644
--- a/CLAPACK-3.2.1/SRC/dgeequ.c
+++ b/CLAPACK-3.2.1/SRC/dgeequ.c
@@ -25,7 +25,7 @@
     integer i__, j;
     doublereal rcmin, rcmax;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum, smlnum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dgeequb.c b/CLAPACK-3.2.1/SRC/dgeequb.c
index fbaeb2f..042de8f 100644
--- a/CLAPACK-3.2.1/SRC/dgeequb.c
+++ b/CLAPACK-3.2.1/SRC/dgeequb.c
@@ -28,7 +28,7 @@
     integer i__, j;
     doublereal radix, rcmin, rcmax;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum, logrdx, smlnum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dgees.c b/CLAPACK-3.2.1/SRC/dgees.c
index 9de8ab0..bc9f444 100644
--- a/CLAPACK-3.2.1/SRC/dgees.c
+++ b/CLAPACK-3.2.1/SRC/dgees.c
@@ -58,8 +58,8 @@ static integer c_n1 = -1;
 	    integer *), dlascl_(char *, integer *, integer *, doublereal *, 
 	    doublereal *, integer *, integer *, doublereal *, integer *, 
 	    integer *), dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     doublereal bignum;
diff --git a/CLAPACK-3.2.1/SRC/dgeesx.c b/CLAPACK-3.2.1/SRC/dgeesx.c
index d404f4a..8b4f7b2 100644
--- a/CLAPACK-3.2.1/SRC/dgeesx.c
+++ b/CLAPACK-3.2.1/SRC/dgeesx.c
@@ -58,8 +58,8 @@ static integer c_n1 = -1;
 	    integer *), dlascl_(char *, integer *, integer *, doublereal *, 
 	    doublereal *, integer *, integer *, doublereal *, integer *, 
 	    integer *), dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     doublereal bignum;
diff --git a/CLAPACK-3.2.1/SRC/dgeev.c b/CLAPACK-3.2.1/SRC/dgeev.c
index d523306..8cc7890 100644
--- a/CLAPACK-3.2.1/SRC/dgeev.c
+++ b/CLAPACK-3.2.1/SRC/dgeev.c
@@ -70,7 +70,8 @@ static integer c_n1 = -1;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *), 
 	    dlartg_(doublereal *, doublereal *, doublereal *, doublereal *, 
-	    doublereal *), xerbla_(char *, integer *);
+	    doublereal *);
+    void xerbla_(char *, integer *);
     logical select[1];
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dgeevx.c b/CLAPACK-3.2.1/SRC/dgeevx.c
index 2907767..a2fedd6 100644
--- a/CLAPACK-3.2.1/SRC/dgeevx.c
+++ b/CLAPACK-3.2.1/SRC/dgeevx.c
@@ -70,7 +70,8 @@ static integer c_n1 = -1;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *), 
 	    dlartg_(doublereal *, doublereal *, doublereal *, doublereal *, 
-	    doublereal *), xerbla_(char *, integer *);
+	    doublereal *);
+    void xerbla_(char *, integer *);
     logical select[1];
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dgegs.c b/CLAPACK-3.2.1/SRC/dgegs.c
index cb409fb..25db237 100644
--- a/CLAPACK-3.2.1/SRC/dgegs.c
+++ b/CLAPACK-3.2.1/SRC/dgegs.c
@@ -59,8 +59,8 @@ static doublereal c_b37 = 1.;
 	    doublereal *, integer *);
     doublereal safmin;
     extern /* Subroutine */ int dlaset_(char *, integer *, integer *, 
-	    doublereal *, doublereal *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, doublereal *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     doublereal bignum;
diff --git a/CLAPACK-3.2.1/SRC/dgegv.c b/CLAPACK-3.2.1/SRC/dgegv.c
index 8551895..77da418 100644
--- a/CLAPACK-3.2.1/SRC/dgegv.c
+++ b/CLAPACK-3.2.1/SRC/dgegv.c
@@ -74,8 +74,8 @@ static doublereal c_b38 = 0.;
 	    integer *), dtgevc_(char *, char *, 
 	    logical *, integer *, doublereal *, integer *, doublereal *, 
 	    integer *, doublereal *, integer *, doublereal *, integer *, 
-	    integer *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    integer *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     integer ijobvl, iright;
     logical ilimit;
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dgehd2.c b/CLAPACK-3.2.1/SRC/dgehd2.c
index b9a4c75..d98749f 100644
--- a/CLAPACK-3.2.1/SRC/dgehd2.c
+++ b/CLAPACK-3.2.1/SRC/dgehd2.c
@@ -30,7 +30,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int dlarf_(char *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, doublereal *, integer *, 
 	    doublereal *), dlarfg_(integer *, doublereal *, 
-	    doublereal *, integer *, doublereal *), xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dgehrd.c b/CLAPACK-3.2.1/SRC/dgehrd.c
index 6e88e9d..245ced2 100644
--- a/CLAPACK-3.2.1/SRC/dgehrd.c
+++ b/CLAPACK-3.2.1/SRC/dgehrd.c
@@ -50,7 +50,8 @@ static doublereal c_b26 = 1.;
 	    doublereal *, doublereal *, integer *, doublereal *, integer *), 
 	    dlarfb_(char *, char *, char *, char *, integer *, integer *, 
 	    integer *, doublereal *, integer *, doublereal *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwork, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/dgejsv.c b/CLAPACK-3.2.1/SRC/dgejsv.c
index 0b0376b..668b5d7 100644
--- a/CLAPACK-3.2.1/SRC/dgejsv.c
+++ b/CLAPACK-3.2.1/SRC/dgejsv.c
@@ -83,7 +83,8 @@ static integer c_n1 = -1;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *), 
 	    dlaset_(char *, integer *, integer *, doublereal *, doublereal *, 
-	    doublereal *, integer *), xerbla_(char *, integer *);
+	    doublereal *, integer *);
+    void xerbla_(char *, integer *);
     logical noscal;
     extern /* Subroutine */ int dpocon_(char *, integer *, doublereal *, 
 	    integer *, doublereal *, doublereal *, doublereal *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dgelq2.c b/CLAPACK-3.2.1/SRC/dgelq2.c
index c77e5a8..a77e350 100644
--- a/CLAPACK-3.2.1/SRC/dgelq2.c
+++ b/CLAPACK-3.2.1/SRC/dgelq2.c
@@ -25,7 +25,8 @@
     extern /* Subroutine */ int dlarf_(char *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, doublereal *, integer *, 
 	    doublereal *), dlarfp_(integer *, doublereal *, 
-	    doublereal *, integer *, doublereal *), xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dgelqf.c b/CLAPACK-3.2.1/SRC/dgelqf.c
index 08bc818..7d3fbda 100644
--- a/CLAPACK-3.2.1/SRC/dgelqf.c
+++ b/CLAPACK-3.2.1/SRC/dgelqf.c
@@ -33,7 +33,8 @@ static integer c__2 = 2;
 	     char *, char *, char *, integer *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
 	    integer *, doublereal *, integer *), dlarft_(char *, char *, integer *, integer *, doublereal 
-	    *, integer *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
+	    *, integer *, doublereal *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwork, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/dgels.c b/CLAPACK-3.2.1/SRC/dgels.c
index 55b28c7..5092722 100644
--- a/CLAPACK-3.2.1/SRC/dgels.c
+++ b/CLAPACK-3.2.1/SRC/dgels.c
@@ -46,7 +46,8 @@ static integer c__0 = 0;
 	     dgeqrf_(integer *, integer *, doublereal *, integer *, 
 	    doublereal *, doublereal *, integer *, integer *), dlaset_(char *, 
 	     integer *, integer *, doublereal *, doublereal *, doublereal *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer scllen;
diff --git a/CLAPACK-3.2.1/SRC/dgelsd.c b/CLAPACK-3.2.1/SRC/dgelsd.c
index 01a638d..2701713 100644
--- a/CLAPACK-3.2.1/SRC/dgelsd.c
+++ b/CLAPACK-3.2.1/SRC/dgelsd.c
@@ -55,7 +55,8 @@ static doublereal c_b82 = 0.;
 	    integer *, integer *, doublereal *, integer *, doublereal *, 
 	    doublereal *, integer *, integer *), dlacpy_(char *, integer *, 
 	    integer *, doublereal *, integer *, doublereal *, integer *), dlaset_(char *, integer *, integer *, doublereal *, 
-	    doublereal *, doublereal *, integer *), xerbla_(char *, 
+	    doublereal *, doublereal *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dgelss.c b/CLAPACK-3.2.1/SRC/dgelss.c
index 82cf9a4..97272b3 100644
--- a/CLAPACK-3.2.1/SRC/dgelss.c
+++ b/CLAPACK-3.2.1/SRC/dgelss.c
@@ -65,8 +65,9 @@ static doublereal c_b108 = 1.;
 	    doublereal *, doublereal *, integer *, integer *), dlacpy_(char *, 
 	     integer *, integer *, doublereal *, integer *, doublereal *, 
 	    integer *), dlaset_(char *, integer *, integer *, 
-	    doublereal *, doublereal *, doublereal *, integer *), 
-	    xerbla_(char *, integer *), dbdsqr_(char *, integer *, 
+	    doublereal *, doublereal *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
+    int dbdsqr_(char *, integer *, 
 	    integer *, integer *, integer *, doublereal *, doublereal *, 
 	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
 	    integer *, doublereal *, integer *), dorgbr_(char *, 
diff --git a/CLAPACK-3.2.1/SRC/dgelsx.c b/CLAPACK-3.2.1/SRC/dgelsx.c
index 75217ae..3419eff 100644
--- a/CLAPACK-3.2.1/SRC/dgelsx.c
+++ b/CLAPACK-3.2.1/SRC/dgelsx.c
@@ -51,7 +51,8 @@ static doublereal c_b36 = 1.;
 	    integer *, integer *), dgeqpf_(integer *, integer *, 
 	    doublereal *, integer *, integer *, doublereal *, doublereal *, 
 	    integer *), dlaset_(char *, integer *, integer *, doublereal *, 
-	    doublereal *, doublereal *, integer *), xerbla_(char *, 
+	    doublereal *, doublereal *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     doublereal bignum;
     extern /* Subroutine */ int dlatzm_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dgelsy.c b/CLAPACK-3.2.1/SRC/dgelsy.c
index 0ae3452..ebabb5d 100644
--- a/CLAPACK-3.2.1/SRC/dgelsy.c
+++ b/CLAPACK-3.2.1/SRC/dgelsy.c
@@ -54,8 +54,8 @@ static doublereal c_b54 = 1.;
     extern /* Subroutine */ int dlascl_(char *, integer *, integer *, 
 	    doublereal *, doublereal *, integer *, integer *, doublereal *, 
 	    integer *, integer *), dlaset_(char *, integer *, integer 
-	    *, doublereal *, doublereal *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    *, doublereal *, doublereal *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     doublereal bignum;
diff --git a/CLAPACK-3.2.1/SRC/dgeql2.c b/CLAPACK-3.2.1/SRC/dgeql2.c
index 07cd966..c51a9be 100644
--- a/CLAPACK-3.2.1/SRC/dgeql2.c
+++ b/CLAPACK-3.2.1/SRC/dgeql2.c
@@ -29,7 +29,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int dlarf_(char *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, doublereal *, integer *, 
 	    doublereal *), dlarfp_(integer *, doublereal *, 
-	    doublereal *, integer *, doublereal *), xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dgeqlf.c b/CLAPACK-3.2.1/SRC/dgeqlf.c
index 0b97795..1263768 100644
--- a/CLAPACK-3.2.1/SRC/dgeqlf.c
+++ b/CLAPACK-3.2.1/SRC/dgeqlf.c
@@ -33,7 +33,8 @@ static integer c__2 = 2;
 	     char *, char *, char *, integer *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
 	    integer *, doublereal *, integer *), dlarft_(char *, char *, integer *, integer *, doublereal 
-	    *, integer *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
+	    *, integer *, doublereal *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwork, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/dgeqp3.c b/CLAPACK-3.2.1/SRC/dgeqp3.c
index e3fda57..556a632 100644
--- a/CLAPACK-3.2.1/SRC/dgeqp3.c
+++ b/CLAPACK-3.2.1/SRC/dgeqp3.c
@@ -38,7 +38,8 @@ static integer c__2 = 2;
 	    doublereal *, integer *, integer *, doublereal *, doublereal *, 
 	    doublereal *, doublereal *), dgeqrf_(integer *, integer *, 
 	    doublereal *, integer *, doublereal *, doublereal *, integer *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int dlaqps_(integer *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dgeqpf.c b/CLAPACK-3.2.1/SRC/dgeqpf.c
index 10743f5..0d33f55 100644
--- a/CLAPACK-3.2.1/SRC/dgeqpf.c
+++ b/CLAPACK-3.2.1/SRC/dgeqpf.c
@@ -47,7 +47,8 @@ static integer c__1 = 1;
     extern doublereal dlamch_(char *);
     extern integer idamax_(integer *, doublereal *, integer *);
     extern /* Subroutine */ int dlarfp_(integer *, doublereal *, doublereal *, 
-	     integer *, doublereal *), xerbla_(char *, integer *);
+	     integer *, doublereal *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK deprecated driver routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dgeqr2.c b/CLAPACK-3.2.1/SRC/dgeqr2.c
index 663388f..434c863 100644
--- a/CLAPACK-3.2.1/SRC/dgeqr2.c
+++ b/CLAPACK-3.2.1/SRC/dgeqr2.c
@@ -29,7 +29,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int dlarf_(char *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, doublereal *, integer *, 
 	    doublereal *), dlarfp_(integer *, doublereal *, 
-	    doublereal *, integer *, doublereal *), xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dgeqrf.c b/CLAPACK-3.2.1/SRC/dgeqrf.c
index 1062e27..924d140 100644
--- a/CLAPACK-3.2.1/SRC/dgeqrf.c
+++ b/CLAPACK-3.2.1/SRC/dgeqrf.c
@@ -33,7 +33,8 @@ static integer c__2 = 2;
 	     char *, char *, char *, integer *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
 	    integer *, doublereal *, integer *), dlarft_(char *, char *, integer *, integer *, doublereal 
-	    *, integer *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
+	    *, integer *, doublereal *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwork, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/dgerfs.c b/CLAPACK-3.2.1/SRC/dgerfs.c
index d8f941d..23eafb3 100644
--- a/CLAPACK-3.2.1/SRC/dgerfs.c
+++ b/CLAPACK-3.2.1/SRC/dgerfs.c
@@ -50,7 +50,8 @@ static doublereal c_b17 = 1.;
 	     integer *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), dgetrs_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dgetrs_(
 	    char *, integer *, integer *, doublereal *, integer *, integer *, 
 	    doublereal *, integer *, integer *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/dgerfsx.c b/CLAPACK-3.2.1/SRC/dgerfsx.c
index a9698eb..c7ef999 100644
--- a/CLAPACK-3.2.1/SRC/dgerfsx.c
+++ b/CLAPACK-3.2.1/SRC/dgerfsx.c
@@ -62,7 +62,8 @@ static integer c__1 = 1;
 	    integer *, doublereal *, integer *, doublereal *);
     extern /* Subroutine */ int dgecon_(char *, integer *, doublereal *, 
 	    integer *, doublereal *, doublereal *, doublereal *, integer *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     logical colequ, notran, rowequ;
     extern integer ilaprec_(char *);
     integer ithresh, n_norms__;
diff --git a/CLAPACK-3.2.1/SRC/dgerq2.c b/CLAPACK-3.2.1/SRC/dgerq2.c
index 13ccabf..2e0d307 100644
--- a/CLAPACK-3.2.1/SRC/dgerq2.c
+++ b/CLAPACK-3.2.1/SRC/dgerq2.c
@@ -25,7 +25,8 @@
     extern /* Subroutine */ int dlarf_(char *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, doublereal *, integer *, 
 	    doublereal *), dlarfp_(integer *, doublereal *, 
-	    doublereal *, integer *, doublereal *), xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dgerqf.c b/CLAPACK-3.2.1/SRC/dgerqf.c
index 1d78250..b4f080a 100644
--- a/CLAPACK-3.2.1/SRC/dgerqf.c
+++ b/CLAPACK-3.2.1/SRC/dgerqf.c
@@ -33,7 +33,8 @@ static integer c__2 = 2;
 	     char *, char *, char *, integer *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
 	    integer *, doublereal *, integer *), dlarft_(char *, char *, integer *, integer *, doublereal 
-	    *, integer *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
+	    *, integer *, doublereal *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwork, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/dgesdd.c b/CLAPACK-3.2.1/SRC/dgesdd.c
index 9a12830..fdbb4c9 100644
--- a/CLAPACK-3.2.1/SRC/dgesdd.c
+++ b/CLAPACK-3.2.1/SRC/dgesdd.c
@@ -63,8 +63,9 @@ static doublereal c_b248 = 1.;
 	    doublereal *, doublereal *, integer *, integer *), dlacpy_(char *, 
 	     integer *, integer *, doublereal *, integer *, doublereal *, 
 	    integer *), dlaset_(char *, integer *, integer *, 
-	    doublereal *, doublereal *, doublereal *, integer *), 
-	    xerbla_(char *, integer *), dorgbr_(char *, integer *, 
+	    doublereal *, doublereal *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
+    int dorgbr_(char *, integer *, 
 	    integer *, integer *, doublereal *, integer *, doublereal *, 
 	    doublereal *, integer *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dgesv.c b/CLAPACK-3.2.1/SRC/dgesv.c
index c44d06f..392e1c0 100644
--- a/CLAPACK-3.2.1/SRC/dgesv.c
+++ b/CLAPACK-3.2.1/SRC/dgesv.c
@@ -21,7 +21,9 @@
 
     /* Local variables */
     extern /* Subroutine */ int dgetrf_(integer *, integer *, doublereal *, 
-	    integer *, integer *, integer *), xerbla_(char *, integer *), dgetrs_(char *, integer *, integer *, doublereal *, 
+	    integer *, integer *, integer *);
+    void xerbla_(char *, integer *);
+    int dgetrs_(char *, integer *, integer *, doublereal *, 
 	    integer *, integer *, doublereal *, integer *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/dgesvd.c b/CLAPACK-3.2.1/SRC/dgesvd.c
index a667033..6d14d8a 100644
--- a/CLAPACK-3.2.1/SRC/dgesvd.c
+++ b/CLAPACK-3.2.1/SRC/dgesvd.c
@@ -35,7 +35,7 @@ static doublereal c_b443 = 1.;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
     double sqrt(doublereal);
 
     /* Local variables */
@@ -71,7 +71,7 @@ static doublereal c_b443 = 1.;
 	    doublereal *, integer *, doublereal *, doublereal *, integer *, 
 	    integer *);
     doublereal bignum;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int dormbr_(char *, char *, char *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dgesvj.c b/CLAPACK-3.2.1/SRC/dgesvj.c
index 2d36977..9691932 100644
--- a/CLAPACK-3.2.1/SRC/dgesvj.c
+++ b/CLAPACK-3.2.1/SRC/dgesvj.c
@@ -86,8 +86,8 @@ static integer c__2 = 2;
 	    integer *, integer *);
     extern integer idamax_(integer *, doublereal *, integer *);
     extern /* Subroutine */ int dlaset_(char *, integer *, integer *, 
-	    doublereal *, doublereal *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, doublereal *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     integer ijblsk, swband, blskip;
     doublereal mxaapq;
     extern /* Subroutine */ int dlassq_(integer *, doublereal *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dgesvx.c b/CLAPACK-3.2.1/SRC/dgesvx.c
index ab372d0..c3bf8ca 100644
--- a/CLAPACK-3.2.1/SRC/dgesvx.c
+++ b/CLAPACK-3.2.1/SRC/dgesvx.c
@@ -49,7 +49,8 @@
 	    doublereal *, doublereal *, integer *, integer *), 
 	    dgetrf_(integer *, integer *, doublereal *, integer *, integer *, 
 	    integer *), dlacpy_(char *, integer *, integer *, doublereal *, 
-	    integer *, doublereal *, integer *), xerbla_(char *, 
+	    integer *, doublereal *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     doublereal bignum;
     extern doublereal dlantr_(char *, char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dgesvxx.c b/CLAPACK-3.2.1/SRC/dgesvxx.c
index 4f2600c..602bb16 100644
--- a/CLAPACK-3.2.1/SRC/dgesvxx.c
+++ b/CLAPACK-3.2.1/SRC/dgesvxx.c
@@ -44,7 +44,8 @@
     logical nofact;
     extern /* Subroutine */ int dgetrf_(integer *, integer *, doublereal *, 
 	    integer *, integer *, integer *), dlacpy_(char *, integer *, 
-	    integer *, doublereal *, integer *, doublereal *, integer *), xerbla_(char *, integer *);
+	    integer *, doublereal *, integer *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
     doublereal bignum;
     integer infequ;
     logical colequ;
diff --git a/CLAPACK-3.2.1/SRC/dgetf2.c b/CLAPACK-3.2.1/SRC/dgetf2.c
index be6639a..04b568e 100644
--- a/CLAPACK-3.2.1/SRC/dgetf2.c
+++ b/CLAPACK-3.2.1/SRC/dgetf2.c
@@ -36,7 +36,7 @@ static doublereal c_b8 = -1.;
 	    doublereal *, integer *);
     extern doublereal dlamch_(char *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dgetrf.c b/CLAPACK-3.2.1/SRC/dgetrf.c
index 8a945af..2582984 100644
--- a/CLAPACK-3.2.1/SRC/dgetrf.c
+++ b/CLAPACK-3.2.1/SRC/dgetrf.c
@@ -36,7 +36,8 @@ static doublereal c_b19 = -1.;
 	    integer *, integer *, doublereal *, doublereal *, integer *, 
 	    doublereal *, integer *), dgetf2_(
 	    integer *, integer *, doublereal *, integer *, integer *, integer 
-	    *), xerbla_(char *, integer *);
+	    *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int dlaswp_(integer *, doublereal *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dgetri.c b/CLAPACK-3.2.1/SRC/dgetri.c
index d075f0c..5543996 100644
--- a/CLAPACK-3.2.1/SRC/dgetri.c
+++ b/CLAPACK-3.2.1/SRC/dgetri.c
@@ -39,7 +39,8 @@ static doublereal c_b22 = 1.;
     extern /* Subroutine */ int dswap_(integer *, doublereal *, integer *, 
 	    doublereal *, integer *), dtrsm_(char *, char *, char *, char *, 
 	    integer *, integer *, doublereal *, doublereal *, integer *, 
-	    doublereal *, integer *), xerbla_(
+	    doublereal *, integer *);
+    void xerbla_(
 	    char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dgetrs.c b/CLAPACK-3.2.1/SRC/dgetrs.c
index 943e22f..5740cfe 100644
--- a/CLAPACK-3.2.1/SRC/dgetrs.c
+++ b/CLAPACK-3.2.1/SRC/dgetrs.c
@@ -30,8 +30,10 @@ static integer c_n1 = -1;
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int dtrsm_(char *, char *, char *, char *, 
 	    integer *, integer *, doublereal *, doublereal *, integer *, 
-	    doublereal *, integer *), xerbla_(
-	    char *, integer *), dlaswp_(integer *, doublereal *, 
+	    doublereal *, integer *);
+    void xerbla_(
+	    char *, integer *);
+    int dlaswp_(integer *, doublereal *, 
 	    integer *, integer *, integer *, integer *, integer *);
     logical notran;
 
diff --git a/CLAPACK-3.2.1/SRC/dggbak.c b/CLAPACK-3.2.1/SRC/dggbak.c
index a581392..bdb95f9 100644
--- a/CLAPACK-3.2.1/SRC/dggbak.c
+++ b/CLAPACK-3.2.1/SRC/dggbak.c
@@ -28,7 +28,7 @@
     extern /* Subroutine */ int dswap_(integer *, doublereal *, integer *, 
 	    doublereal *, integer *);
     logical leftv;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical rightv;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dggbal.c b/CLAPACK-3.2.1/SRC/dggbal.c
index 27a4b34..e87f9f7 100644
--- a/CLAPACK-3.2.1/SRC/dggbal.c
+++ b/CLAPACK-3.2.1/SRC/dggbal.c
@@ -61,7 +61,7 @@ static doublereal c_b71 = .5;
     extern doublereal dlamch_(char *);
     doublereal pgamma;
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer lsfmin, lsfmax;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dgges.c b/CLAPACK-3.2.1/SRC/dgges.c
index 57a40f7..49fdb76 100644
--- a/CLAPACK-3.2.1/SRC/dgges.c
+++ b/CLAPACK-3.2.1/SRC/dgges.c
@@ -69,7 +69,7 @@ static doublereal c_b39 = 1.;
     extern /* Subroutine */ int dlaset_(char *, integer *, integer *, 
 	    doublereal *, doublereal *, doublereal *, integer *);
     doublereal safmax;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     extern /* Subroutine */ int dhgeqz_(char *, char *, char *, integer *, 
 	    integer *, integer *, doublereal *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dggesx.c b/CLAPACK-3.2.1/SRC/dggesx.c
index c0bd11f..fecc75d 100644
--- a/CLAPACK-3.2.1/SRC/dggesx.c
+++ b/CLAPACK-3.2.1/SRC/dggesx.c
@@ -71,7 +71,7 @@ static doublereal c_b43 = 1.;
     extern /* Subroutine */ int dlaset_(char *, integer *, integer *, 
 	    doublereal *, doublereal *, doublereal *, integer *);
     doublereal safmax;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     extern /* Subroutine */ int dhgeqz_(char *, char *, char *, integer *, 
 	    integer *, integer *, doublereal *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dggev.c b/CLAPACK-3.2.1/SRC/dggev.c
index 4b47f8b..715b1ac 100644
--- a/CLAPACK-3.2.1/SRC/dggev.c
+++ b/CLAPACK-3.2.1/SRC/dggev.c
@@ -74,7 +74,8 @@ static doublereal c_b37 = 1.;
 	    integer *, integer *, doublereal *, integer *, doublereal *, 
 	    integer *, doublereal *, doublereal *, doublereal *, doublereal *, 
 	     integer *, doublereal *, integer *, doublereal *, integer *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ijobvl, iright, ijobvr;
diff --git a/CLAPACK-3.2.1/SRC/dggevx.c b/CLAPACK-3.2.1/SRC/dggevx.c
index 50bb670..65fe6c4 100644
--- a/CLAPACK-3.2.1/SRC/dggevx.c
+++ b/CLAPACK-3.2.1/SRC/dggevx.c
@@ -84,7 +84,8 @@ static doublereal c_b60 = 1.;
 	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
 	    integer *, doublereal *, integer *, doublereal *, doublereal *, 
 	    integer *, integer *, doublereal *, integer *, integer *, integer 
-	    *), xerbla_(char *, integer *);
+	    *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ijobvr;
diff --git a/CLAPACK-3.2.1/SRC/dggglm.c b/CLAPACK-3.2.1/SRC/dggglm.c
index 378885e..bd7290a 100644
--- a/CLAPACK-3.2.1/SRC/dggglm.c
+++ b/CLAPACK-3.2.1/SRC/dggglm.c
@@ -36,7 +36,8 @@ static doublereal c_b34 = 1.;
 	    doublereal *, integer *, doublereal *, integer *), dggqrf_(
 	    integer *, integer *, integer *, doublereal *, integer *, 
 	    doublereal *, doublereal *, integer *, doublereal *, doublereal *, 
-	     integer *, integer *), xerbla_(char *, integer *);
+	     integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer lwkmin;
diff --git a/CLAPACK-3.2.1/SRC/dgghrd.c b/CLAPACK-3.2.1/SRC/dgghrd.c
index 2d73bfa..73ee450 100644
--- a/CLAPACK-3.2.1/SRC/dgghrd.c
+++ b/CLAPACK-3.2.1/SRC/dgghrd.c
@@ -40,7 +40,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int dlaset_(char *, integer *, integer *, 
 	    doublereal *, doublereal *, doublereal *, integer *), 
 	    dlartg_(doublereal *, doublereal *, doublereal *, doublereal *, 
-	    doublereal *), xerbla_(char *, integer *);
+	    doublereal *);
+    void xerbla_(char *, integer *);
     integer icompq, icompz;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dgglse.c b/CLAPACK-3.2.1/SRC/dgglse.c
index 4a02183..c4e556a 100644
--- a/CLAPACK-3.2.1/SRC/dgglse.c
+++ b/CLAPACK-3.2.1/SRC/dgglse.c
@@ -39,7 +39,8 @@ static doublereal c_b33 = 1.;
 	    *, doublereal *, integer *), dggrqf_(
 	    integer *, integer *, integer *, doublereal *, integer *, 
 	    doublereal *, doublereal *, integer *, doublereal *, doublereal *, 
-	     integer *, integer *), xerbla_(char *, integer *);
+	     integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer lwkmin;
diff --git a/CLAPACK-3.2.1/SRC/dggqrf.c b/CLAPACK-3.2.1/SRC/dggqrf.c
index b75d005..4f8d6fb 100644
--- a/CLAPACK-3.2.1/SRC/dggqrf.c
+++ b/CLAPACK-3.2.1/SRC/dggqrf.c
@@ -30,7 +30,8 @@ static integer c_n1 = -1;
     extern /* Subroutine */ int dgeqrf_(integer *, integer *, doublereal *, 
 	    integer *, doublereal *, doublereal *, integer *, integer *), 
 	    dgerqf_(integer *, integer *, doublereal *, integer *, doublereal 
-	    *, doublereal *, integer *, integer *), xerbla_(char *, integer *);
+	    *, doublereal *, integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int dormqr_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dggrqf.c b/CLAPACK-3.2.1/SRC/dggrqf.c
index 1a49ec9..5fcfbfa 100644
--- a/CLAPACK-3.2.1/SRC/dggrqf.c
+++ b/CLAPACK-3.2.1/SRC/dggrqf.c
@@ -30,7 +30,8 @@ static integer c_n1 = -1;
     extern /* Subroutine */ int dgeqrf_(integer *, integer *, doublereal *, 
 	    integer *, doublereal *, doublereal *, integer *, integer *), 
 	    dgerqf_(integer *, integer *, doublereal *, integer *, doublereal 
-	    *, doublereal *, integer *, integer *), xerbla_(char *, integer *);
+	    *, doublereal *, integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int dormrq_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dggsvd.c b/CLAPACK-3.2.1/SRC/dggsvd.c
index b9b567e..77cfb3e 100644
--- a/CLAPACK-3.2.1/SRC/dggsvd.c
+++ b/CLAPACK-3.2.1/SRC/dggsvd.c
@@ -49,7 +49,8 @@ static integer c__1 = 1;
 	     integer *, doublereal *, integer *, doublereal *, integer *, 
 	    integer *);
     integer ncycle;
-    extern /* Subroutine */ int xerbla_(char *, integer *), dggsvp_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dggsvp_(
 	    char *, char *, char *, integer *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
 	    doublereal *, integer *, integer *, doublereal *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dggsvp.c b/CLAPACK-3.2.1/SRC/dggsvp.c
index 7cf51c2..73577e8 100644
--- a/CLAPACK-3.2.1/SRC/dggsvp.c
+++ b/CLAPACK-3.2.1/SRC/dggsvp.c
@@ -47,7 +47,9 @@ static doublereal c_b22 = 1.;
 	    integer *, integer *, doublereal *, doublereal *, integer *), 
 	    dlacpy_(char *, integer *, integer *, doublereal *, integer *, 
 	    doublereal *, integer *), dlaset_(char *, integer *, 
-	    integer *, doublereal *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *), dlapmt_(logical *, 
+	    integer *, doublereal *, doublereal *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
+    int dlapmt_(logical *, 
 	    integer *, integer *, doublereal *, integer *, integer *);
     logical forwrd;
 
diff --git a/CLAPACK-3.2.1/SRC/dgsvj0.c b/CLAPACK-3.2.1/SRC/dgsvj0.c
index c10304b..32bd5ee 100644
--- a/CLAPACK-3.2.1/SRC/dgsvj0.c
+++ b/CLAPACK-3.2.1/SRC/dgsvj0.c
@@ -63,7 +63,7 @@ static doublereal c_b42 = 1.;
 	    doublereal *, doublereal *, integer *, integer *, doublereal *, 
 	    integer *, integer *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer ijblsk, swband, blskip;
     doublereal mxaapq;
     extern /* Subroutine */ int dlassq_(integer *, doublereal *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dgsvj1.c b/CLAPACK-3.2.1/SRC/dgsvj1.c
index eb6a967..15ee90b 100644
--- a/CLAPACK-3.2.1/SRC/dgsvj1.c
+++ b/CLAPACK-3.2.1/SRC/dgsvj1.c
@@ -63,7 +63,7 @@ static doublereal c_b35 = 1.;
 	    doublereal *, doublereal *, integer *, integer *, doublereal *, 
 	    integer *, integer *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer ijblsk, swband, blskip;
     doublereal mxaapq;
     extern /* Subroutine */ int dlassq_(integer *, doublereal *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dgtcon.c b/CLAPACK-3.2.1/SRC/dgtcon.c
index ef4721d..58d38e1 100644
--- a/CLAPACK-3.2.1/SRC/dgtcon.c
+++ b/CLAPACK-3.2.1/SRC/dgtcon.c
@@ -30,7 +30,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     integer isave[3];
     extern /* Subroutine */ int dlacn2_(integer *, doublereal *, doublereal *, 
-	     integer *, doublereal *, integer *, integer *), xerbla_(char *, 
+	     integer *, doublereal *, integer *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     doublereal ainvnm;
     logical onenrm;
diff --git a/CLAPACK-3.2.1/SRC/dgtrfs.c b/CLAPACK-3.2.1/SRC/dgtrfs.c
index fa9a4c6..b456290 100644
--- a/CLAPACK-3.2.1/SRC/dgtrfs.c
+++ b/CLAPACK-3.2.1/SRC/dgtrfs.c
@@ -50,7 +50,7 @@ static doublereal c_b19 = 1.;
 	    doublereal *, doublereal *, doublereal *, doublereal *, 
 	    doublereal *, integer *, doublereal *, doublereal *, integer *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
     char transn[1];
     extern /* Subroutine */ int dgttrs_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dgtsv.c b/CLAPACK-3.2.1/SRC/dgtsv.c
index 3d5995a..4b4099d 100644
--- a/CLAPACK-3.2.1/SRC/dgtsv.c
+++ b/CLAPACK-3.2.1/SRC/dgtsv.c
@@ -24,7 +24,7 @@
     /* Local variables */
     integer i__, j;
     doublereal fact, temp;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dgtsvx.c b/CLAPACK-3.2.1/SRC/dgtsvx.c
index 807c6e8..0dd7407 100644
--- a/CLAPACK-3.2.1/SRC/dgtsvx.c
+++ b/CLAPACK-3.2.1/SRC/dgtsvx.c
@@ -37,8 +37,9 @@ static integer c__1 = 1;
 	    doublereal *, doublereal *, doublereal *);
     logical nofact;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *), dgtcon_(char *, integer *, 
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
+    int dgtcon_(char *, integer *, 
 	    doublereal *, doublereal *, doublereal *, doublereal *, integer *, 
 	     doublereal *, doublereal *, doublereal *, integer *, integer *), dgtrfs_(char *, integer *, integer *, doublereal *, 
 	    doublereal *, doublereal *, doublereal *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dgttrf.c b/CLAPACK-3.2.1/SRC/dgttrf.c
index 510bc02..679de7c 100644
--- a/CLAPACK-3.2.1/SRC/dgttrf.c
+++ b/CLAPACK-3.2.1/SRC/dgttrf.c
@@ -23,7 +23,7 @@
     /* Local variables */
     integer i__;
     doublereal fact, temp;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dgttrs.c b/CLAPACK-3.2.1/SRC/dgttrs.c
index 7b4c5b3..8045850 100644
--- a/CLAPACK-3.2.1/SRC/dgttrs.c
+++ b/CLAPACK-3.2.1/SRC/dgttrs.c
@@ -29,7 +29,8 @@ static integer c_n1 = -1;
     integer j, jb, nb;
     extern /* Subroutine */ int dgtts2_(integer *, integer *, integer *, 
 	    doublereal *, doublereal *, doublereal *, doublereal *, integer *, 
-	     doublereal *, integer *), xerbla_(char *, integer *);
+	     doublereal *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer itrans;
diff --git a/CLAPACK-3.2.1/SRC/dhgeqz.c b/CLAPACK-3.2.1/SRC/dhgeqz.c
index b594c95..2076621 100644
--- a/CLAPACK-3.2.1/SRC/dhgeqz.c
+++ b/CLAPACK-3.2.1/SRC/dhgeqz.c
@@ -82,7 +82,7 @@ static integer c__3 = 3;
     extern /* Subroutine */ int dlartg_(doublereal *, doublereal *, 
 	    doublereal *, doublereal *, doublereal *);
     doublereal safmax;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal eshift;
     logical ilschr;
     integer icompq, ilastm, ischur;
diff --git a/CLAPACK-3.2.1/SRC/dhsein.c b/CLAPACK-3.2.1/SRC/dhsein.c
index 7220f14..b07372c 100644
--- a/CLAPACK-3.2.1/SRC/dhsein.c
+++ b/CLAPACK-3.2.1/SRC/dhsein.c
@@ -47,7 +47,7 @@ static logical c_true = TRUE_;
 , doublereal *, doublereal *, integer *);
     extern doublereal dlanhs_(char *, integer *, doublereal *, integer *, 
 	    doublereal *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     logical noinit;
     integer ldwork;
diff --git a/CLAPACK-3.2.1/SRC/dhseqr.c b/CLAPACK-3.2.1/SRC/dhseqr.c
index 48ad560..219a170 100644
--- a/CLAPACK-3.2.1/SRC/dhseqr.c
+++ b/CLAPACK-3.2.1/SRC/dhseqr.c
@@ -33,7 +33,7 @@ static integer c__49 = 49;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -55,7 +55,7 @@ static integer c__49 = 49;
 	    doublereal *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical lquery;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dla_gbamv.c b/CLAPACK-3.2.1/SRC/dla_gbamv.c
index 21c540e..c2bb62d 100644
--- a/CLAPACK-3.2.1/SRC/dla_gbamv.c
+++ b/CLAPACK-3.2.1/SRC/dla_gbamv.c
@@ -34,7 +34,7 @@
     integer lenx, leny;
     doublereal safe1;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*     -- LAPACK routine (version 3.2)                                 -- */
diff --git a/CLAPACK-3.2.1/SRC/dla_gbrcond.c b/CLAPACK-3.2.1/SRC/dla_gbrcond.c
index 462fa17..83f9177 100644
--- a/CLAPACK-3.2.1/SRC/dla_gbrcond.c
+++ b/CLAPACK-3.2.1/SRC/dla_gbrcond.c
@@ -33,8 +33,10 @@ doublereal dla_gbrcond__(char *trans, integer *n, integer *kl, integer *ku,
     extern logical lsame_(char *, char *);
     integer isave[3];
     extern /* Subroutine */ int dlacn2_(integer *, doublereal *, doublereal *, 
-	     integer *, doublereal *, integer *, integer *), xerbla_(char *, 
-	    integer *), dgbtrs_(char *, integer *, integer *, integer 
+	     integer *, doublereal *, integer *, integer *);
+    void xerbla_(char *, 
+	    integer *);
+    int dgbtrs_(char *, integer *, integer *, integer 
 	    *, integer *, doublereal *, integer *, integer *, doublereal *, 
 	    integer *, integer *);
     doublereal ainvnm;
diff --git a/CLAPACK-3.2.1/SRC/dla_geamv.c b/CLAPACK-3.2.1/SRC/dla_geamv.c
index c7e11f8..cc7cb7d 100644
--- a/CLAPACK-3.2.1/SRC/dla_geamv.c
+++ b/CLAPACK-3.2.1/SRC/dla_geamv.c
@@ -33,7 +33,7 @@
     integer lenx, leny;
     doublereal safe1;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*     -- LAPACK routine (version 3.2)                                 -- */
diff --git a/CLAPACK-3.2.1/SRC/dla_gercond.c b/CLAPACK-3.2.1/SRC/dla_gercond.c
index a90ba0b..d757c23 100644
--- a/CLAPACK-3.2.1/SRC/dla_gercond.c
+++ b/CLAPACK-3.2.1/SRC/dla_gercond.c
@@ -33,7 +33,8 @@ doublereal dla_gercond__(char *trans, integer *n, doublereal *a, integer *lda,
     extern logical lsame_(char *, char *);
     integer isave[3];
     extern /* Subroutine */ int dlacn2_(integer *, doublereal *, doublereal *, 
-	     integer *, doublereal *, integer *, integer *), xerbla_(char *, 
+	     integer *, doublereal *, integer *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int dgetrs_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dla_porcond.c b/CLAPACK-3.2.1/SRC/dla_porcond.c
index e7674f8..8ea9396 100644
--- a/CLAPACK-3.2.1/SRC/dla_porcond.c
+++ b/CLAPACK-3.2.1/SRC/dla_porcond.c
@@ -33,7 +33,8 @@ doublereal dla_porcond__(char *uplo, integer *n, doublereal *a, integer *lda,
     extern logical lsame_(char *, char *);
     integer isave[3];
     extern /* Subroutine */ int dlacn2_(integer *, doublereal *, doublereal *, 
-	     integer *, doublereal *, integer *, integer *), xerbla_(char *, 
+	     integer *, doublereal *, integer *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int dpotrs_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dla_syamv.c b/CLAPACK-3.2.1/SRC/dla_syamv.c
index cc9aefa..ff501e9 100644
--- a/CLAPACK-3.2.1/SRC/dla_syamv.c
+++ b/CLAPACK-3.2.1/SRC/dla_syamv.c
@@ -30,7 +30,7 @@
     integer iy, jx, kx, ky, info;
     doublereal temp, safe1;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilauplo_(char *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/dla_syrcond.c b/CLAPACK-3.2.1/SRC/dla_syrcond.c
index 0371ccf..5bc758c 100644
--- a/CLAPACK-3.2.1/SRC/dla_syrcond.c
+++ b/CLAPACK-3.2.1/SRC/dla_syrcond.c
@@ -36,7 +36,7 @@ doublereal dla_syrcond__(char *uplo, integer *n, doublereal *a, integer *lda,
     extern /* Subroutine */ int dlacn2_(integer *, doublereal *, doublereal *, 
 	     integer *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal ainvnm;
     char normin[1];
     doublereal smlnum;
diff --git a/CLAPACK-3.2.1/SRC/dlaed0.c b/CLAPACK-3.2.1/SRC/dlaed0.c
index e9cb080..06fa29b 100644
--- a/CLAPACK-3.2.1/SRC/dlaed0.c
+++ b/CLAPACK-3.2.1/SRC/dlaed0.c
@@ -59,7 +59,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *);
     integer igivcl;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer igivnm, submat, curprb, subpbs, igivpt;
diff --git a/CLAPACK-3.2.1/SRC/dlaed1.c b/CLAPACK-3.2.1/SRC/dlaed1.c
index 170f2a0..c524f89 100644
--- a/CLAPACK-3.2.1/SRC/dlaed1.c
+++ b/CLAPACK-3.2.1/SRC/dlaed1.c
@@ -39,7 +39,8 @@ static integer c_n1 = -1;
 	    doublereal *, doublereal *, integer *);
     integer idlmda;
     extern /* Subroutine */ int dlamrg_(integer *, integer *, doublereal *, 
-	    integer *, integer *, integer *), xerbla_(char *, integer *);
+	    integer *, integer *, integer *);
+    void xerbla_(char *, integer *);
     integer coltyp;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dlaed2.c b/CLAPACK-3.2.1/SRC/dlaed2.c
index 20d93a0..ca8d892 100644
--- a/CLAPACK-3.2.1/SRC/dlaed2.c
+++ b/CLAPACK-3.2.1/SRC/dlaed2.c
@@ -48,7 +48,8 @@ static integer c__1 = 1;
     extern integer idamax_(integer *, doublereal *, integer *);
     extern /* Subroutine */ int dlamrg_(integer *, integer *, doublereal *, 
 	    integer *, integer *, integer *), dlacpy_(char *, integer *, 
-	    integer *, doublereal *, integer *, doublereal *, integer *), xerbla_(char *, integer *);
+	    integer *, doublereal *, integer *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dlaed3.c b/CLAPACK-3.2.1/SRC/dlaed3.c
index ce4f772..3e1602f 100644
--- a/CLAPACK-3.2.1/SRC/dlaed3.c
+++ b/CLAPACK-3.2.1/SRC/dlaed3.c
@@ -45,7 +45,8 @@ static doublereal c_b23 = 0.;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *), 
 	    dlaset_(char *, integer *, integer *, doublereal *, doublereal *, 
-	    doublereal *, integer *), xerbla_(char *, integer *);
+	    doublereal *, integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dlaed7.c b/CLAPACK-3.2.1/SRC/dlaed7.c
index 93a1848..7315b8b 100644
--- a/CLAPACK-3.2.1/SRC/dlaed7.c
+++ b/CLAPACK-3.2.1/SRC/dlaed7.c
@@ -53,7 +53,8 @@ static integer c_n1 = -1;
 	    ;
     integer idlmda;
     extern /* Subroutine */ int dlamrg_(integer *, integer *, doublereal *, 
-	    integer *, integer *, integer *), xerbla_(char *, integer *);
+	    integer *, integer *, integer *);
+    void xerbla_(char *, integer *);
     integer coltyp;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dlaed8.c b/CLAPACK-3.2.1/SRC/dlaed8.c
index 6c1656b..9b0bae4 100644
--- a/CLAPACK-3.2.1/SRC/dlaed8.c
+++ b/CLAPACK-3.2.1/SRC/dlaed8.c
@@ -47,7 +47,8 @@ static integer c__1 = 1;
     extern integer idamax_(integer *, doublereal *, integer *);
     extern /* Subroutine */ int dlamrg_(integer *, integer *, doublereal *, 
 	    integer *, integer *, integer *), dlacpy_(char *, integer *, 
-	    integer *, doublereal *, integer *, doublereal *, integer *), xerbla_(char *, integer *);
+	    integer *, doublereal *, integer *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dlaed9.c b/CLAPACK-3.2.1/SRC/dlaed9.c
index 25b3466..b8aeefa 100644
--- a/CLAPACK-3.2.1/SRC/dlaed9.c
+++ b/CLAPACK-3.2.1/SRC/dlaed9.c
@@ -38,7 +38,7 @@ static integer c__1 = 1;
 	    doublereal *, doublereal *, doublereal *, doublereal *, 
 	    doublereal *, integer *);
     extern doublereal dlamc3_(doublereal *, doublereal *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dlaeda.c b/CLAPACK-3.2.1/SRC/dlaeda.c
index f9d8536..341cec4 100644
--- a/CLAPACK-3.2.1/SRC/dlaeda.c
+++ b/CLAPACK-3.2.1/SRC/dlaeda.c
@@ -40,7 +40,8 @@ static doublereal c_b26 = 0.;
     extern /* Subroutine */ int dgemv_(char *, integer *, integer *, 
 	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
 	    doublereal *, doublereal *, integer *), dcopy_(integer *, 
-	    doublereal *, integer *, doublereal *, integer *), xerbla_(char *, 
+	    doublereal *, integer *, doublereal *, integer *);
+    void xerbla_(char *, 
 	     integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/dlagtf.c b/CLAPACK-3.2.1/SRC/dlagtf.c
index 533f53d..6887ae1 100644
--- a/CLAPACK-3.2.1/SRC/dlagtf.c
+++ b/CLAPACK-3.2.1/SRC/dlagtf.c
@@ -25,7 +25,7 @@
     integer k;
     doublereal tl, eps, piv1, piv2, temp, mult, scale1, scale2;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dlagts.c b/CLAPACK-3.2.1/SRC/dlagts.c
index 91e1ba1..e385b4a 100644
--- a/CLAPACK-3.2.1/SRC/dlagts.c
+++ b/CLAPACK-3.2.1/SRC/dlagts.c
@@ -28,7 +28,7 @@
     integer k;
     doublereal ak, eps, temp, pert, absak, sfmin;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dlals0.c b/CLAPACK-3.2.1/SRC/dlals0.c
index 9f55866..0f4a0e3 100644
--- a/CLAPACK-3.2.1/SRC/dlals0.c
+++ b/CLAPACK-3.2.1/SRC/dlals0.c
@@ -53,8 +53,8 @@ static integer c__0 = 0;
     extern /* Subroutine */ int dlascl_(char *, integer *, integer *, 
 	    doublereal *, doublereal *, integer *, integer *, doublereal *, 
 	    integer *, integer *), dlacpy_(char *, integer *, integer 
-	    *, doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    *, doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     doublereal dsigjp;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dlalsa.c b/CLAPACK-3.2.1/SRC/dlalsa.c
index 7c01dee..bbbfa4f 100644
--- a/CLAPACK-3.2.1/SRC/dlalsa.c
+++ b/CLAPACK-3.2.1/SRC/dlalsa.c
@@ -51,7 +51,8 @@ static integer c__2 = 2;
 	    *, integer *, doublereal *, doublereal *, doublereal *, 
 	    doublereal *, integer *, doublereal *, doublereal *, doublereal *, 
 	     integer *), dlasdt_(integer *, integer *, integer *, integer *, 
-	    integer *, integer *, integer *), xerbla_(char *, integer *);
+	    integer *, integer *, integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dlalsd.c b/CLAPACK-3.2.1/SRC/dlalsd.c
index 2e52d50..933801e 100644
--- a/CLAPACK-3.2.1/SRC/dlalsd.c
+++ b/CLAPACK-3.2.1/SRC/dlalsd.c
@@ -76,8 +76,8 @@ static doublereal c_b11 = 1.;
 	    doublereal *, integer *), dlacpy_(char *, integer *, 
 	    integer *, doublereal *, integer *, doublereal *, integer *), dlartg_(doublereal *, doublereal *, doublereal *, 
 	    doublereal *, doublereal *), dlaset_(char *, integer *, integer *, 
-	     doublereal *, doublereal *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	     doublereal *, doublereal *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     integer givcol;
     extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
     extern /* Subroutine */ int dlasrt_(char *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dlarzb.c b/CLAPACK-3.2.1/SRC/dlarzb.c
index 2cf3e7f..14da177 100644
--- a/CLAPACK-3.2.1/SRC/dlarzb.c
+++ b/CLAPACK-3.2.1/SRC/dlarzb.c
@@ -37,7 +37,8 @@ static doublereal c_b23 = -1.;
     extern /* Subroutine */ int dcopy_(integer *, doublereal *, integer *, 
 	    doublereal *, integer *), dtrmm_(char *, char *, char *, char *, 
 	    integer *, integer *, doublereal *, doublereal *, integer *, 
-	    doublereal *, integer *), xerbla_(
+	    doublereal *, integer *);
+    void xerbla_(
 	    char *, integer *);
     char transt[1];
 
diff --git a/CLAPACK-3.2.1/SRC/dlarzt.c b/CLAPACK-3.2.1/SRC/dlarzt.c
index 8e8450a..d6f9f59 100644
--- a/CLAPACK-3.2.1/SRC/dlarzt.c
+++ b/CLAPACK-3.2.1/SRC/dlarzt.c
@@ -33,7 +33,8 @@ static integer c__1 = 1;
 	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
 	    doublereal *, doublereal *, integer *), dtrmv_(char *, 
 	    char *, char *, integer *, doublereal *, integer *, doublereal *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dlascl.c b/CLAPACK-3.2.1/SRC/dlascl.c
index b39a68b..1300195 100644
--- a/CLAPACK-3.2.1/SRC/dlascl.c
+++ b/CLAPACK-3.2.1/SRC/dlascl.c
@@ -31,7 +31,7 @@
     extern doublereal dlamch_(char *);
     doublereal cfromc;
     extern logical disnan_(doublereal *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum, smlnum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dlasd0.c b/CLAPACK-3.2.1/SRC/dlasd0.c
index a8b7197..654090d 100644
--- a/CLAPACK-3.2.1/SRC/dlasd0.c
+++ b/CLAPACK-3.2.1/SRC/dlasd0.c
@@ -43,7 +43,8 @@ static integer c__2 = 2;
 	    integer *, integer *, doublereal *, doublereal *, doublereal *, 
 	    integer *, doublereal *, integer *, doublereal *, integer *, 
 	    doublereal *, integer *), dlasdt_(integer *, integer *, 
-	    integer *, integer *, integer *, integer *, integer *), xerbla_(
+	    integer *, integer *, integer *, integer *, integer *);
+    void xerbla_(
 	    char *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/dlasd1.c b/CLAPACK-3.2.1/SRC/dlasd1.c
index 84fb8e5..bad876c 100644
--- a/CLAPACK-3.2.1/SRC/dlasd1.c
+++ b/CLAPACK-3.2.1/SRC/dlasd1.c
@@ -46,7 +46,7 @@ static integer c_n1 = -1;
 	     dlamrg_(integer *, integer *, doublereal *, integer *, integer *, 
 	     integer *);
     integer isigma;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal orgnrm;
     integer coltyp;
 
diff --git a/CLAPACK-3.2.1/SRC/dlasd2.c b/CLAPACK-3.2.1/SRC/dlasd2.c
index 441aa7d..2c0ffa6 100644
--- a/CLAPACK-3.2.1/SRC/dlasd2.c
+++ b/CLAPACK-3.2.1/SRC/dlasd2.c
@@ -49,7 +49,8 @@ static doublereal c_b30 = 0.;
     extern /* Subroutine */ int dlamrg_(integer *, integer *, doublereal *, 
 	    integer *, integer *, integer *), dlacpy_(char *, integer *, 
 	    integer *, doublereal *, integer *, doublereal *, integer *), dlaset_(char *, integer *, integer *, doublereal *, 
-	    doublereal *, doublereal *, integer *), xerbla_(char *, 
+	    doublereal *, doublereal *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     doublereal hlftol;
 
diff --git a/CLAPACK-3.2.1/SRC/dlasd3.c b/CLAPACK-3.2.1/SRC/dlasd3.c
index db8089b..5eef8b4 100644
--- a/CLAPACK-3.2.1/SRC/dlasd3.c
+++ b/CLAPACK-3.2.1/SRC/dlasd3.c
@@ -53,8 +53,8 @@ static doublereal c_b26 = 0.;
 	    doublereal *, integer *), dlascl_(char *, integer *, integer *, 
 	    doublereal *, doublereal *, integer *, integer *, doublereal *, 
 	    integer *, integer *), dlacpy_(char *, integer *, integer 
-	    *, doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    *, doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK auxiliary routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dlasd6.c b/CLAPACK-3.2.1/SRC/dlasd6.c
index f1d0ec6..d7b6b5c 100644
--- a/CLAPACK-3.2.1/SRC/dlasd6.c
+++ b/CLAPACK-3.2.1/SRC/dlasd6.c
@@ -49,7 +49,7 @@ static integer c_n1 = -1;
 	    integer *, integer *), dlamrg_(integer *, integer *, 
 	    doublereal *, integer *, integer *, integer *);
     integer isigma;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal orgnrm;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dlasd7.c b/CLAPACK-3.2.1/SRC/dlasd7.c
index ea4ca05..642fe4e 100644
--- a/CLAPACK-3.2.1/SRC/dlasd7.c
+++ b/CLAPACK-3.2.1/SRC/dlasd7.c
@@ -43,7 +43,8 @@ static integer c__1 = 1;
     integer jprev;
     extern doublereal dlapy2_(doublereal *, doublereal *), dlamch_(char *);
     extern /* Subroutine */ int dlamrg_(integer *, integer *, doublereal *, 
-	    integer *, integer *, integer *), xerbla_(char *, integer *);
+	    integer *, integer *, integer *);
+    void xerbla_(char *, integer *);
     doublereal hlftol;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dlasd8.c b/CLAPACK-3.2.1/SRC/dlasd8.c
index ab1b6c2..3ab3ed4 100644
--- a/CLAPACK-3.2.1/SRC/dlasd8.c
+++ b/CLAPACK-3.2.1/SRC/dlasd8.c
@@ -49,8 +49,8 @@ static doublereal c_b8 = 1.;
 	    doublereal *, integer *), dlascl_(char *, integer *, integer *, 
 	    doublereal *, doublereal *, integer *, integer *, doublereal *, 
 	    integer *, integer *), dlaset_(char *, integer *, integer 
-	    *, doublereal *, doublereal *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    *, doublereal *, doublereal *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     doublereal dsigjp;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dlasda.c b/CLAPACK-3.2.1/SRC/dlasda.c
index 4a501d1..758b46e 100644
--- a/CLAPACK-3.2.1/SRC/dlasda.c
+++ b/CLAPACK-3.2.1/SRC/dlasda.c
@@ -60,7 +60,8 @@ static integer c__2 = 2;
 	    doublereal *, integer *), dlasdt_(integer *, integer *, 
 	    integer *, integer *, integer *, integer *, integer *), dlaset_(
 	    char *, integer *, integer *, doublereal *, doublereal *, 
-	    doublereal *, integer *), xerbla_(char *, integer *);
+	    doublereal *, integer *);
+    void xerbla_(char *, integer *);
     integer smlszp;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dlasdq.c b/CLAPACK-3.2.1/SRC/dlasdq.c
index 581a872..b8af7b7 100644
--- a/CLAPACK-3.2.1/SRC/dlasdq.c
+++ b/CLAPACK-3.2.1/SRC/dlasdq.c
@@ -38,8 +38,10 @@ static integer c__1 = 1;
 , doublereal *, integer *);
     integer iuplo;
     extern /* Subroutine */ int dlartg_(doublereal *, doublereal *, 
-	    doublereal *, doublereal *, doublereal *), xerbla_(char *, 
-	    integer *), dbdsqr_(char *, integer *, integer *, integer 
+	    doublereal *, doublereal *, doublereal *);
+    void xerbla_(char *, 
+	    integer *);
+    int dbdsqr_(char *, integer *, integer *, integer 
 	    *, integer *, doublereal *, doublereal *, doublereal *, integer *, 
 	     doublereal *, integer *, doublereal *, integer *, doublereal *, 
 	    integer *);
diff --git a/CLAPACK-3.2.1/SRC/dlasq1.c b/CLAPACK-3.2.1/SRC/dlasq1.c
index 7a6e8b7..7fcf5de 100644
--- a/CLAPACK-3.2.1/SRC/dlasq1.c
+++ b/CLAPACK-3.2.1/SRC/dlasq1.c
@@ -46,7 +46,8 @@ static integer c__0 = 0;
 	    doublereal *, doublereal *, integer *, integer *, doublereal *, 
 	    integer *, integer *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), dlasrt_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dlasrt_(
 	    char *, integer *, doublereal *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/dlasq2.c b/CLAPACK-3.2.1/SRC/dlasq2.c
index 3b041a2..2d4ba56 100644
--- a/CLAPACK-3.2.1/SRC/dlasq2.c
+++ b/CLAPACK-3.2.1/SRC/dlasq2.c
@@ -60,7 +60,7 @@ static integer c__11 = 11;
     doublereal deemin;
     integer iwhila, iwhilb;
     doublereal oldemn, safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int dlasrt_(char *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dlasr.c b/CLAPACK-3.2.1/SRC/dlasr.c
index 6abfa81..54c3905 100644
--- a/CLAPACK-3.2.1/SRC/dlasr.c
+++ b/CLAPACK-3.2.1/SRC/dlasr.c
@@ -25,7 +25,7 @@
     doublereal temp;
     extern logical lsame_(char *, char *);
     doublereal ctemp, stemp;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK auxiliary routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dlasrt.c b/CLAPACK-3.2.1/SRC/dlasrt.c
index 5df285c..8efcbd5 100644
--- a/CLAPACK-3.2.1/SRC/dlasrt.c
+++ b/CLAPACK-3.2.1/SRC/dlasrt.c
@@ -29,7 +29,7 @@
     integer stack[64]	/* was [2][32] */;
     doublereal dmnmx;
     integer start;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer stkpnt;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dlatbs.c b/CLAPACK-3.2.1/SRC/dlatbs.c
index cfd8566..aba6bae 100644
--- a/CLAPACK-3.2.1/SRC/dlatbs.c
+++ b/CLAPACK-3.2.1/SRC/dlatbs.c
@@ -48,7 +48,7 @@ static doublereal c_b36 = .5;
     logical upper;
     extern doublereal dlamch_(char *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     logical notran;
     integer jfirst;
diff --git a/CLAPACK-3.2.1/SRC/dlatps.c b/CLAPACK-3.2.1/SRC/dlatps.c
index ebaa06c..34fcd5f 100644
--- a/CLAPACK-3.2.1/SRC/dlatps.c
+++ b/CLAPACK-3.2.1/SRC/dlatps.c
@@ -48,7 +48,7 @@ static doublereal c_b36 = .5;
 	    doublereal *, doublereal *, integer *);
     extern doublereal dlamch_(char *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     logical notran;
     integer jfirst;
diff --git a/CLAPACK-3.2.1/SRC/dlatrs.c b/CLAPACK-3.2.1/SRC/dlatrs.c
index 2bb2784..5f27afe 100644
--- a/CLAPACK-3.2.1/SRC/dlatrs.c
+++ b/CLAPACK-3.2.1/SRC/dlatrs.c
@@ -48,7 +48,7 @@ static doublereal c_b36 = .5;
 	    doublereal *, integer *, doublereal *, integer *);
     extern doublereal dlamch_(char *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     logical notran;
     integer jfirst;
diff --git a/CLAPACK-3.2.1/SRC/dlauu2.c b/CLAPACK-3.2.1/SRC/dlauu2.c
index 1f8f03f..12db409 100644
--- a/CLAPACK-3.2.1/SRC/dlauu2.c
+++ b/CLAPACK-3.2.1/SRC/dlauu2.c
@@ -36,7 +36,7 @@ static integer c__1 = 1;
 	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
 	    doublereal *, doublereal *, integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK auxiliary routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dlauum.c b/CLAPACK-3.2.1/SRC/dlauum.c
index 0d5d706..5546c5d 100644
--- a/CLAPACK-3.2.1/SRC/dlauum.c
+++ b/CLAPACK-3.2.1/SRC/dlauum.c
@@ -38,7 +38,8 @@ static doublereal c_b15 = 1.;
     extern /* Subroutine */ int dsyrk_(char *, char *, integer *, integer *, 
 	    doublereal *, doublereal *, integer *, doublereal *, doublereal *, 
 	     integer *), dlauu2_(char *, integer *, 
-	    doublereal *, integer *, integer *), xerbla_(char *, 
+	    doublereal *, integer *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dopgtr.c b/CLAPACK-3.2.1/SRC/dopgtr.c
index ea1541c..75f7a3c 100644
--- a/CLAPACK-3.2.1/SRC/dopgtr.c
+++ b/CLAPACK-3.2.1/SRC/dopgtr.c
@@ -28,7 +28,8 @@
     extern /* Subroutine */ int dorg2l_(integer *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, doublereal *, integer *), 
 	    dorg2r_(integer *, integer *, integer *, doublereal *, integer *, 
-	    doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
+	    doublereal *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dopmtr.c b/CLAPACK-3.2.1/SRC/dopmtr.c
index fda595a..1641ce7 100644
--- a/CLAPACK-3.2.1/SRC/dopmtr.c
+++ b/CLAPACK-3.2.1/SRC/dopmtr.c
@@ -33,7 +33,7 @@ static integer c__1 = 1;
 	    doublereal *);
     extern logical lsame_(char *, char *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran, forwrd;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dorg2l.c b/CLAPACK-3.2.1/SRC/dorg2l.c
index 0fa59f1..2b09bdf 100644
--- a/CLAPACK-3.2.1/SRC/dorg2l.c
+++ b/CLAPACK-3.2.1/SRC/dorg2l.c
@@ -28,7 +28,8 @@ static integer c__1 = 1;
     integer i__, j, l, ii;
     extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *, 
 	    integer *), dlarf_(char *, integer *, integer *, doublereal *, 
-	    integer *, doublereal *, doublereal *, integer *, doublereal *), xerbla_(char *, integer *);
+	    integer *, doublereal *, doublereal *, integer *, doublereal *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dorg2r.c b/CLAPACK-3.2.1/SRC/dorg2r.c
index 892807c..345f226 100644
--- a/CLAPACK-3.2.1/SRC/dorg2r.c
+++ b/CLAPACK-3.2.1/SRC/dorg2r.c
@@ -28,7 +28,8 @@ static integer c__1 = 1;
     integer i__, j, l;
     extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *, 
 	    integer *), dlarf_(char *, integer *, integer *, doublereal *, 
-	    integer *, doublereal *, doublereal *, integer *, doublereal *), xerbla_(char *, integer *);
+	    integer *, doublereal *, doublereal *, integer *, doublereal *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dorgbr.c b/CLAPACK-3.2.1/SRC/dorgbr.c
index e649640..d97c50c 100644
--- a/CLAPACK-3.2.1/SRC/dorgbr.c
+++ b/CLAPACK-3.2.1/SRC/dorgbr.c
@@ -30,7 +30,7 @@ static integer c_n1 = -1;
     extern logical lsame_(char *, char *);
     integer iinfo;
     logical wantq;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int dorglq_(integer *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dorghr.c b/CLAPACK-3.2.1/SRC/dorghr.c
index 291825b..f2164ba 100644
--- a/CLAPACK-3.2.1/SRC/dorghr.c
+++ b/CLAPACK-3.2.1/SRC/dorghr.c
@@ -27,7 +27,7 @@ static integer c_n1 = -1;
 
     /* Local variables */
     integer i__, j, nb, nh, iinfo;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int dorgqr_(integer *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dorgl2.c b/CLAPACK-3.2.1/SRC/dorgl2.c
index f880992..56905f8 100644
--- a/CLAPACK-3.2.1/SRC/dorgl2.c
+++ b/CLAPACK-3.2.1/SRC/dorgl2.c
@@ -24,7 +24,8 @@
     integer i__, j, l;
     extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *, 
 	    integer *), dlarf_(char *, integer *, integer *, doublereal *, 
-	    integer *, doublereal *, doublereal *, integer *, doublereal *), xerbla_(char *, integer *);
+	    integer *, doublereal *, doublereal *, integer *, doublereal *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dorglq.c b/CLAPACK-3.2.1/SRC/dorglq.c
index a5b9019..ed8bcfd 100644
--- a/CLAPACK-3.2.1/SRC/dorglq.c
+++ b/CLAPACK-3.2.1/SRC/dorglq.c
@@ -34,7 +34,8 @@ static integer c__2 = 2;
 	    dlarfb_(char *, char *, char *, char *, integer *, integer *, 
 	    integer *, doublereal *, integer *, doublereal *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *), dlarft_(char *, char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwork, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/dorgql.c b/CLAPACK-3.2.1/SRC/dorgql.c
index 85d2f8a..8809ca9 100644
--- a/CLAPACK-3.2.1/SRC/dorgql.c
+++ b/CLAPACK-3.2.1/SRC/dorgql.c
@@ -34,7 +34,8 @@ static integer c__2 = 2;
 	    dlarfb_(char *, char *, char *, char *, integer *, integer *, 
 	    integer *, doublereal *, integer *, doublereal *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *), dlarft_(char *, char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwork, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/dorgqr.c b/CLAPACK-3.2.1/SRC/dorgqr.c
index 3b72b73..9d8b703 100644
--- a/CLAPACK-3.2.1/SRC/dorgqr.c
+++ b/CLAPACK-3.2.1/SRC/dorgqr.c
@@ -34,7 +34,8 @@ static integer c__2 = 2;
 	    dlarfb_(char *, char *, char *, char *, integer *, integer *, 
 	    integer *, doublereal *, integer *, doublereal *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *), dlarft_(char *, char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwork, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/dorgr2.c b/CLAPACK-3.2.1/SRC/dorgr2.c
index ab2ce59..94ba94f 100644
--- a/CLAPACK-3.2.1/SRC/dorgr2.c
+++ b/CLAPACK-3.2.1/SRC/dorgr2.c
@@ -24,7 +24,8 @@
     integer i__, j, l, ii;
     extern /* Subroutine */ int dscal_(integer *, doublereal *, doublereal *, 
 	    integer *), dlarf_(char *, integer *, integer *, doublereal *, 
-	    integer *, doublereal *, doublereal *, integer *, doublereal *), xerbla_(char *, integer *);
+	    integer *, doublereal *, doublereal *, integer *, doublereal *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dorgrq.c b/CLAPACK-3.2.1/SRC/dorgrq.c
index 5927a41..f3ff044 100644
--- a/CLAPACK-3.2.1/SRC/dorgrq.c
+++ b/CLAPACK-3.2.1/SRC/dorgrq.c
@@ -34,7 +34,8 @@ static integer c__2 = 2;
 	    dlarfb_(char *, char *, char *, char *, integer *, integer *, 
 	    integer *, doublereal *, integer *, doublereal *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *), dlarft_(char *, char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwork, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/dorgtr.c b/CLAPACK-3.2.1/SRC/dorgtr.c
index c380681..a0acbe4 100644
--- a/CLAPACK-3.2.1/SRC/dorgtr.c
+++ b/CLAPACK-3.2.1/SRC/dorgtr.c
@@ -29,7 +29,7 @@ static integer c_n1 = -1;
     extern logical lsame_(char *, char *);
     integer iinfo;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int dorgql_(integer *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dorm2l.c b/CLAPACK-3.2.1/SRC/dorm2l.c
index de18e08..2ef83b0 100644
--- a/CLAPACK-3.2.1/SRC/dorm2l.c
+++ b/CLAPACK-3.2.1/SRC/dorm2l.c
@@ -32,7 +32,7 @@ static integer c__1 = 1;
 	    doublereal *, integer *, doublereal *, doublereal *, integer *, 
 	    doublereal *);
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dorm2r.c b/CLAPACK-3.2.1/SRC/dorm2r.c
index 3a71756..dc7a6ce 100644
--- a/CLAPACK-3.2.1/SRC/dorm2r.c
+++ b/CLAPACK-3.2.1/SRC/dorm2r.c
@@ -32,7 +32,7 @@ static integer c__1 = 1;
 	    doublereal *, integer *, doublereal *, doublereal *, integer *, 
 	    doublereal *);
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dormbr.c b/CLAPACK-3.2.1/SRC/dormbr.c
index ca7e42a..58365f1 100644
--- a/CLAPACK-3.2.1/SRC/dormbr.c
+++ b/CLAPACK-3.2.1/SRC/dormbr.c
@@ -30,14 +30,14 @@ static integer c__2 = 2;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i1, i2, nb, mi, ni, nq, nw;
     logical left;
     extern logical lsame_(char *, char *);
     integer iinfo;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int dormlq_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dormhr.c b/CLAPACK-3.2.1/SRC/dormhr.c
index aa47061..e488f31 100644
--- a/CLAPACK-3.2.1/SRC/dormhr.c
+++ b/CLAPACK-3.2.1/SRC/dormhr.c
@@ -30,14 +30,14 @@ static integer c__2 = 2;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i1, i2, nb, mi, nh, ni, nq, nw;
     logical left;
     extern logical lsame_(char *, char *);
     integer iinfo;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int dormqr_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dorml2.c b/CLAPACK-3.2.1/SRC/dorml2.c
index d482168..67b6f49 100644
--- a/CLAPACK-3.2.1/SRC/dorml2.c
+++ b/CLAPACK-3.2.1/SRC/dorml2.c
@@ -28,7 +28,7 @@
 	    doublereal *, integer *, doublereal *, doublereal *, integer *, 
 	    doublereal *);
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dormlq.c b/CLAPACK-3.2.1/SRC/dormlq.c
index c0d4b7b..9c2d258 100644
--- a/CLAPACK-3.2.1/SRC/dormlq.c
+++ b/CLAPACK-3.2.1/SRC/dormlq.c
@@ -31,7 +31,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -46,7 +46,8 @@ static integer c__65 = 65;
 	    *, char *, char *, char *, integer *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
 	    integer *, doublereal *, integer *), dlarft_(char *, char *, integer *, integer *, doublereal 
-	    *, integer *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
+	    *, integer *, doublereal *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/dormql.c b/CLAPACK-3.2.1/SRC/dormql.c
index c2de211..e6dfdbf 100644
--- a/CLAPACK-3.2.1/SRC/dormql.c
+++ b/CLAPACK-3.2.1/SRC/dormql.c
@@ -31,7 +31,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -46,7 +46,8 @@ static integer c__65 = 65;
 	    *, char *, char *, char *, integer *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
 	    integer *, doublereal *, integer *), dlarft_(char *, char *, integer *, integer *, doublereal 
-	    *, integer *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
+	    *, integer *, doublereal *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/dormqr.c b/CLAPACK-3.2.1/SRC/dormqr.c
index aed95f2..39c4b18 100644
--- a/CLAPACK-3.2.1/SRC/dormqr.c
+++ b/CLAPACK-3.2.1/SRC/dormqr.c
@@ -31,7 +31,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -46,7 +46,8 @@ static integer c__65 = 65;
 	    *, char *, char *, char *, integer *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
 	    integer *, doublereal *, integer *), dlarft_(char *, char *, integer *, integer *, doublereal 
-	    *, integer *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
+	    *, integer *, doublereal *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/dormr2.c b/CLAPACK-3.2.1/SRC/dormr2.c
index 78f726b..a47e8d8 100644
--- a/CLAPACK-3.2.1/SRC/dormr2.c
+++ b/CLAPACK-3.2.1/SRC/dormr2.c
@@ -28,7 +28,7 @@
 	    doublereal *, integer *, doublereal *, doublereal *, integer *, 
 	    doublereal *);
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dormr3.c b/CLAPACK-3.2.1/SRC/dormr3.c
index 5fb412a..139c7dd 100644
--- a/CLAPACK-3.2.1/SRC/dormr3.c
+++ b/CLAPACK-3.2.1/SRC/dormr3.c
@@ -26,7 +26,8 @@
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int dlarz_(char *, integer *, integer *, integer *
 , doublereal *, integer *, doublereal *, doublereal *, integer *, 
-	    doublereal *), xerbla_(char *, integer *);
+	    doublereal *);
+    void xerbla_(char *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dormrq.c b/CLAPACK-3.2.1/SRC/dormrq.c
index d52843b..d0dfca9 100644
--- a/CLAPACK-3.2.1/SRC/dormrq.c
+++ b/CLAPACK-3.2.1/SRC/dormrq.c
@@ -31,7 +31,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -46,7 +46,8 @@ static integer c__65 = 65;
 	    *, char *, char *, char *, integer *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
 	    integer *, doublereal *, integer *), dlarft_(char *, char *, integer *, integer *, doublereal 
-	    *, integer *, doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
+	    *, integer *, doublereal *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/dormrz.c b/CLAPACK-3.2.1/SRC/dormrz.c
index ec368fa..3a3f864 100644
--- a/CLAPACK-3.2.1/SRC/dormrz.c
+++ b/CLAPACK-3.2.1/SRC/dormrz.c
@@ -32,7 +32,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -43,8 +43,8 @@ static integer c__65 = 65;
     integer nbmin, iinfo;
     extern /* Subroutine */ int dormr3_(char *, char *, integer *, integer *, 
 	    integer *, integer *, doublereal *, integer *, doublereal *, 
-	    doublereal *, integer *, doublereal *, integer *),
-	     xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int dlarzb_(char *, char *, char *, char *, 
diff --git a/CLAPACK-3.2.1/SRC/dormtr.c b/CLAPACK-3.2.1/SRC/dormtr.c
index da2691f..fbc87d4 100644
--- a/CLAPACK-3.2.1/SRC/dormtr.c
+++ b/CLAPACK-3.2.1/SRC/dormtr.c
@@ -29,7 +29,7 @@ static integer c__2 = 2;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i1, i2, nb, mi, ni, nq, nw;
@@ -37,7 +37,7 @@ static integer c__2 = 2;
     extern logical lsame_(char *, char *);
     integer iinfo;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int dormql_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dpbcon.c b/CLAPACK-3.2.1/SRC/dpbcon.c
index 0971a58..c6dec53 100644
--- a/CLAPACK-3.2.1/SRC/dpbcon.c
+++ b/CLAPACK-3.2.1/SRC/dpbcon.c
@@ -42,7 +42,7 @@ static integer c__1 = 1;
 	    integer *, integer *, doublereal *, integer *, doublereal *, 
 	    doublereal *, doublereal *, integer *);
     doublereal scaleu;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal ainvnm;
     char normin[1];
     doublereal smlnum;
diff --git a/CLAPACK-3.2.1/SRC/dpbequ.c b/CLAPACK-3.2.1/SRC/dpbequ.c
index 18baa51..436c18f 100644
--- a/CLAPACK-3.2.1/SRC/dpbequ.c
+++ b/CLAPACK-3.2.1/SRC/dpbequ.c
@@ -29,7 +29,7 @@
     doublereal smin;
     extern logical lsame_(char *, char *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dpbrfs.c b/CLAPACK-3.2.1/SRC/dpbrfs.c
index 9239551..b6c20ae 100644
--- a/CLAPACK-3.2.1/SRC/dpbrfs.c
+++ b/CLAPACK-3.2.1/SRC/dpbrfs.c
@@ -51,7 +51,8 @@ static doublereal c_b14 = 1.;
 	     integer *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), dpbtrs_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dpbtrs_(
 	    char *, integer *, integer *, integer *, doublereal *, integer *, 
 	    doublereal *, integer *, integer *);
     doublereal lstres;
diff --git a/CLAPACK-3.2.1/SRC/dpbstf.c b/CLAPACK-3.2.1/SRC/dpbstf.c
index 83ae6c2..9f4d7d2 100644
--- a/CLAPACK-3.2.1/SRC/dpbstf.c
+++ b/CLAPACK-3.2.1/SRC/dpbstf.c
@@ -37,7 +37,7 @@ static doublereal c_b9 = -1.;
 	    integer *, doublereal *, doublereal *, integer *);
     extern logical lsame_(char *, char *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dpbsv.c b/CLAPACK-3.2.1/SRC/dpbsv.c
index 510dd25..0267205 100644
--- a/CLAPACK-3.2.1/SRC/dpbsv.c
+++ b/CLAPACK-3.2.1/SRC/dpbsv.c
@@ -22,7 +22,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), dpbtrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dpbtrf_(
 	    char *, integer *, integer *, doublereal *, integer *, integer *), dpbtrs_(char *, integer *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/dpbsvx.c b/CLAPACK-3.2.1/SRC/dpbsvx.c
index 5ba6e22..f95e6b7 100644
--- a/CLAPACK-3.2.1/SRC/dpbsvx.c
+++ b/CLAPACK-3.2.1/SRC/dpbsvx.c
@@ -45,8 +45,9 @@ static integer c__1 = 1;
 	    doublereal *, char *);
     logical nofact;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *), dpbequ_(char *, integer *, 
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
+    int dpbequ_(char *, integer *, 
 	    integer *, doublereal *, integer *, doublereal *, doublereal *, 
 	    doublereal *, integer *);
     doublereal bignum;
diff --git a/CLAPACK-3.2.1/SRC/dpbtf2.c b/CLAPACK-3.2.1/SRC/dpbtf2.c
index 8937241..5b57946 100644
--- a/CLAPACK-3.2.1/SRC/dpbtf2.c
+++ b/CLAPACK-3.2.1/SRC/dpbtf2.c
@@ -37,7 +37,7 @@ static integer c__1 = 1;
 	    integer *, doublereal *, doublereal *, integer *);
     extern logical lsame_(char *, char *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dpbtrf.c b/CLAPACK-3.2.1/SRC/dpbtrf.c
index 36a8a25..692b120 100644
--- a/CLAPACK-3.2.1/SRC/dpbtrf.c
+++ b/CLAPACK-3.2.1/SRC/dpbtrf.c
@@ -41,7 +41,8 @@ static integer c__33 = 33;
 	    integer *, doublereal *, doublereal *, integer *),
 	     dpbtf2_(char *, integer *, integer *, doublereal *, integer *, 
 	    integer *), dpotf2_(char *, integer *, doublereal *, 
-	    integer *, integer *), xerbla_(char *, integer *);
+	    integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/dpbtrs.c b/CLAPACK-3.2.1/SRC/dpbtrs.c
index b850b9f..4a70400 100644
--- a/CLAPACK-3.2.1/SRC/dpbtrs.c
+++ b/CLAPACK-3.2.1/SRC/dpbtrs.c
@@ -30,7 +30,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int dtbsv_(char *, char *, char *, integer *, 
 	    integer *, doublereal *, integer *, doublereal *, integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dpftrf.c b/CLAPACK-3.2.1/SRC/dpftrf.c
index d7a5300..4ca801b 100644
--- a/CLAPACK-3.2.1/SRC/dpftrf.c
+++ b/CLAPACK-3.2.1/SRC/dpftrf.c
@@ -33,8 +33,8 @@ static doublereal c_b15 = -1.;
 	    integer *, integer *, doublereal *, doublereal *, integer *, 
 	    doublereal *, integer *), dsyrk_(
 	    char *, char *, integer *, integer *, doublereal *, doublereal *, 
-	    integer *, doublereal *, doublereal *, integer *),
-	     xerbla_(char *, integer *);
+	    integer *, doublereal *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     logical nisodd;
     extern /* Subroutine */ int dpotrf_(char *, integer *, doublereal *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dpftri.c b/CLAPACK-3.2.1/SRC/dpftri.c
index c7331f6..cac5d7f 100644
--- a/CLAPACK-3.2.1/SRC/dpftri.c
+++ b/CLAPACK-3.2.1/SRC/dpftri.c
@@ -33,7 +33,8 @@ static doublereal c_b11 = 1.;
     logical lower;
     extern /* Subroutine */ int dsyrk_(char *, char *, integer *, integer *, 
 	    doublereal *, doublereal *, integer *, doublereal *, doublereal *, 
-	     integer *), xerbla_(char *, integer *);
+	     integer *);
+    void xerbla_(char *, integer *);
     logical nisodd;
     extern /* Subroutine */ int dlauum_(char *, integer *, doublereal *, 
 	    integer *, integer *), dtftri_(char *, char *, char *, 
diff --git a/CLAPACK-3.2.1/SRC/dpftrs.c b/CLAPACK-3.2.1/SRC/dpftrs.c
index c0da3c5..82bfbea 100644
--- a/CLAPACK-3.2.1/SRC/dpftrs.c
+++ b/CLAPACK-3.2.1/SRC/dpftrs.c
@@ -30,7 +30,7 @@ static doublereal c_b10 = 1.;
 	     integer *, integer *, doublereal *, doublereal *, doublereal *, 
 	    integer *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2)                                    -- */
diff --git a/CLAPACK-3.2.1/SRC/dpocon.c b/CLAPACK-3.2.1/SRC/dpocon.c
index 3613498..5070eca 100644
--- a/CLAPACK-3.2.1/SRC/dpocon.c
+++ b/CLAPACK-3.2.1/SRC/dpocon.c
@@ -39,7 +39,7 @@ static integer c__1 = 1;
     doublereal scalel;
     extern integer idamax_(integer *, doublereal *, integer *);
     doublereal scaleu;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int dlatrs_(char *, char *, char *, char *, 
 	    integer *, doublereal *, integer *, doublereal *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dpoequ.c b/CLAPACK-3.2.1/SRC/dpoequ.c
index bde3798..8d7afbc 100644
--- a/CLAPACK-3.2.1/SRC/dpoequ.c
+++ b/CLAPACK-3.2.1/SRC/dpoequ.c
@@ -26,7 +26,7 @@
     /* Local variables */
     integer i__;
     doublereal smin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dpoequb.c b/CLAPACK-3.2.1/SRC/dpoequb.c
index a963fc3..5ade884 100644
--- a/CLAPACK-3.2.1/SRC/dpoequb.c
+++ b/CLAPACK-3.2.1/SRC/dpoequb.c
@@ -27,7 +27,7 @@
     integer i__;
     doublereal tmp, base, smin;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*     -- LAPACK routine (version 3.2)                                 -- */
diff --git a/CLAPACK-3.2.1/SRC/dporfs.c b/CLAPACK-3.2.1/SRC/dporfs.c
index 842f1a2..d0c707d 100644
--- a/CLAPACK-3.2.1/SRC/dporfs.c
+++ b/CLAPACK-3.2.1/SRC/dporfs.c
@@ -50,7 +50,8 @@ static doublereal c_b14 = 1.;
 	     doublereal *, integer *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), dpotrs_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dpotrs_(
 	    char *, integer *, integer *, doublereal *, integer *, doublereal 
 	    *, integer *, integer *);
     doublereal lstres;
diff --git a/CLAPACK-3.2.1/SRC/dporfsx.c b/CLAPACK-3.2.1/SRC/dporfsx.c
index c0c23cb..52865ee 100644
--- a/CLAPACK-3.2.1/SRC/dporfsx.c
+++ b/CLAPACK-3.2.1/SRC/dporfsx.c
@@ -58,7 +58,8 @@ static integer c__1 = 1;
     doublereal anorm;
     logical rcequ;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), dpocon_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dpocon_(
 	    char *, integer *, doublereal *, integer *, doublereal *, 
 	    doublereal *, doublereal *, integer *, integer *);
     extern doublereal dlansy_(char *, char *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dposv.c b/CLAPACK-3.2.1/SRC/dposv.c
index 745ff73..89f0645 100644
--- a/CLAPACK-3.2.1/SRC/dposv.c
+++ b/CLAPACK-3.2.1/SRC/dposv.c
@@ -21,7 +21,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), dpotrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dpotrf_(
 	    char *, integer *, doublereal *, integer *, integer *), 
 	    dpotrs_(char *, integer *, integer *, doublereal *, integer *, 
 	    doublereal *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dposvx.c b/CLAPACK-3.2.1/SRC/dposvx.c
index 1304556..6a8f987 100644
--- a/CLAPACK-3.2.1/SRC/dposvx.c
+++ b/CLAPACK-3.2.1/SRC/dposvx.c
@@ -33,8 +33,8 @@
     extern doublereal dlamch_(char *);
     logical nofact;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     doublereal bignum;
     extern /* Subroutine */ int dpocon_(char *, integer *, doublereal *, 
 	    integer *, doublereal *, doublereal *, doublereal *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dposvxx.c b/CLAPACK-3.2.1/SRC/dposvxx.c
index 3613211..deb9d78 100644
--- a/CLAPACK-3.2.1/SRC/dposvxx.c
+++ b/CLAPACK-3.2.1/SRC/dposvxx.c
@@ -38,8 +38,8 @@
     extern doublereal dlamch_(char *);
     logical nofact;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     doublereal bignum;
     integer infequ;
     extern /* Subroutine */ int dlaqsy_(char *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dpotf2.c b/CLAPACK-3.2.1/SRC/dpotf2.c
index fb237c3..89a9b2f 100644
--- a/CLAPACK-3.2.1/SRC/dpotf2.c
+++ b/CLAPACK-3.2.1/SRC/dpotf2.c
@@ -42,7 +42,7 @@ static doublereal c_b12 = 1.;
 	    doublereal *, doublereal *, integer *);
     logical upper;
     extern logical disnan_(doublereal *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dpotrf.c b/CLAPACK-3.2.1/SRC/dpotrf.c
index 5ebdcfc..bbeeda7 100644
--- a/CLAPACK-3.2.1/SRC/dpotrf.c
+++ b/CLAPACK-3.2.1/SRC/dpotrf.c
@@ -39,7 +39,8 @@ static doublereal c_b14 = 1.;
     extern /* Subroutine */ int dsyrk_(char *, char *, integer *, integer *, 
 	    doublereal *, doublereal *, integer *, doublereal *, doublereal *, 
 	     integer *), dpotf2_(char *, integer *, 
-	    doublereal *, integer *, integer *), xerbla_(char *, 
+	    doublereal *, integer *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dpotri.c b/CLAPACK-3.2.1/SRC/dpotri.c
index 9141e4c..9e6f8f8 100644
--- a/CLAPACK-3.2.1/SRC/dpotri.c
+++ b/CLAPACK-3.2.1/SRC/dpotri.c
@@ -21,7 +21,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), dlauum_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dlauum_(
 	    char *, integer *, doublereal *, integer *, integer *), 
 	    dtrtri_(char *, char *, integer *, doublereal *, integer *, 
 	    integer *);
diff --git a/CLAPACK-3.2.1/SRC/dpotrs.c b/CLAPACK-3.2.1/SRC/dpotrs.c
index 888a96f..67c7a15 100644
--- a/CLAPACK-3.2.1/SRC/dpotrs.c
+++ b/CLAPACK-3.2.1/SRC/dpotrs.c
@@ -30,7 +30,7 @@ static doublereal c_b9 = 1.;
 	    integer *, integer *, doublereal *, doublereal *, integer *, 
 	    doublereal *, integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dppcon.c b/CLAPACK-3.2.1/SRC/dppcon.c
index cfac4a1..1c911d6 100644
--- a/CLAPACK-3.2.1/SRC/dppcon.c
+++ b/CLAPACK-3.2.1/SRC/dppcon.c
@@ -39,7 +39,8 @@ static integer c__1 = 1;
     doublereal scalel;
     extern integer idamax_(integer *, doublereal *, integer *);
     doublereal scaleu;
-    extern /* Subroutine */ int xerbla_(char *, integer *), dlatps_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dlatps_(
 	    char *, char *, char *, char *, integer *, doublereal *, 
 	    doublereal *, doublereal *, doublereal *, integer *);
     doublereal ainvnm;
diff --git a/CLAPACK-3.2.1/SRC/dppequ.c b/CLAPACK-3.2.1/SRC/dppequ.c
index d9eda2d..b329e3a 100644
--- a/CLAPACK-3.2.1/SRC/dppequ.c
+++ b/CLAPACK-3.2.1/SRC/dppequ.c
@@ -28,7 +28,7 @@
     doublereal smin;
     extern logical lsame_(char *, char *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dpprfs.c b/CLAPACK-3.2.1/SRC/dpprfs.c
index 2eef815..2ca2fe2 100644
--- a/CLAPACK-3.2.1/SRC/dpprfs.c
+++ b/CLAPACK-3.2.1/SRC/dpprfs.c
@@ -51,7 +51,7 @@ static doublereal c_b14 = 1.;
 	     integer *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal lstres;
     extern /* Subroutine */ int dpptrs_(char *, integer *, integer *, 
 	    doublereal *, doublereal *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dppsv.c b/CLAPACK-3.2.1/SRC/dppsv.c
index 924d429..23df41e 100644
--- a/CLAPACK-3.2.1/SRC/dppsv.c
+++ b/CLAPACK-3.2.1/SRC/dppsv.c
@@ -21,7 +21,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), dpptrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dpptrf_(
 	    char *, integer *, doublereal *, integer *), dpptrs_(char 
 	    *, integer *, integer *, doublereal *, doublereal *, integer *, 
 	    integer *);
diff --git a/CLAPACK-3.2.1/SRC/dppsvx.c b/CLAPACK-3.2.1/SRC/dppsvx.c
index d0db687..438c3f0 100644
--- a/CLAPACK-3.2.1/SRC/dppsvx.c
+++ b/CLAPACK-3.2.1/SRC/dppsvx.c
@@ -38,8 +38,8 @@ static integer c__1 = 1;
     extern doublereal dlamch_(char *);
     logical nofact;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     doublereal bignum;
     extern doublereal dlansp_(char *, char *, integer *, doublereal *, 
 	    doublereal *);
diff --git a/CLAPACK-3.2.1/SRC/dpptrf.c b/CLAPACK-3.2.1/SRC/dpptrf.c
index dff1a79..10e1d22 100644
--- a/CLAPACK-3.2.1/SRC/dpptrf.c
+++ b/CLAPACK-3.2.1/SRC/dpptrf.c
@@ -39,8 +39,8 @@ static doublereal c_b16 = -1.;
     extern logical lsame_(char *, char *);
     logical upper;
     extern /* Subroutine */ int dtpsv_(char *, char *, char *, integer *, 
-	    doublereal *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dpptri.c b/CLAPACK-3.2.1/SRC/dpptri.c
index 5de72f0..7fd1365 100644
--- a/CLAPACK-3.2.1/SRC/dpptri.c
+++ b/CLAPACK-3.2.1/SRC/dpptri.c
@@ -37,7 +37,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int dtpmv_(char *, char *, char *, integer *, 
 	    doublereal *, doublereal *, integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *), dtptri_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dtptri_(
 	    char *, char *, integer *, doublereal *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/dpptrs.c b/CLAPACK-3.2.1/SRC/dpptrs.c
index 888bfef..121da5a 100644
--- a/CLAPACK-3.2.1/SRC/dpptrs.c
+++ b/CLAPACK-3.2.1/SRC/dpptrs.c
@@ -28,8 +28,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     logical upper;
     extern /* Subroutine */ int dtpsv_(char *, char *, char *, integer *, 
-	    doublereal *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dpstf2.c b/CLAPACK-3.2.1/SRC/dpstf2.c
index a66b614..1acd997 100644
--- a/CLAPACK-3.2.1/SRC/dpstf2.c
+++ b/CLAPACK-3.2.1/SRC/dpstf2.c
@@ -48,7 +48,7 @@ static doublereal c_b18 = 1.;
     logical upper;
     extern doublereal dlamch_(char *);
     extern logical disnan_(doublereal *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer dmaxloc_(doublereal *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/dpstrf.c b/CLAPACK-3.2.1/SRC/dpstrf.c
index 909c525..6508c6f 100644
--- a/CLAPACK-3.2.1/SRC/dpstrf.c
+++ b/CLAPACK-3.2.1/SRC/dpstrf.c
@@ -54,7 +54,7 @@ static doublereal c_b24 = 1.;
 	    doublereal *, integer *);
     extern doublereal dlamch_(char *);
     extern logical disnan_(doublereal *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern integer dmaxloc_(doublereal *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dptcon.c b/CLAPACK-3.2.1/SRC/dptcon.c
index a2ffc13..2a53578 100644
--- a/CLAPACK-3.2.1/SRC/dptcon.c
+++ b/CLAPACK-3.2.1/SRC/dptcon.c
@@ -27,7 +27,7 @@ static integer c__1 = 1;
     /* Local variables */
     integer i__, ix;
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal ainvnm;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dpteqr.c b/CLAPACK-3.2.1/SRC/dpteqr.c
index 1da0bea..b26d31b 100644
--- a/CLAPACK-3.2.1/SRC/dpteqr.c
+++ b/CLAPACK-3.2.1/SRC/dpteqr.c
@@ -37,8 +37,9 @@ static integer c__1 = 1;
     integer nru;
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int dlaset_(char *, integer *, integer *, 
-	    doublereal *, doublereal *, doublereal *, integer *), 
-	    xerbla_(char *, integer *), dbdsqr_(char *, integer *, 
+	    doublereal *, doublereal *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
+    int dbdsqr_(char *, integer *, 
 	    integer *, integer *, integer *, doublereal *, doublereal *, 
 	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
 	    integer *, doublereal *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dptrfs.c b/CLAPACK-3.2.1/SRC/dptrfs.c
index 2a0491c..f1accfa 100644
--- a/CLAPACK-3.2.1/SRC/dptrfs.c
+++ b/CLAPACK-3.2.1/SRC/dptrfs.c
@@ -38,7 +38,7 @@ static doublereal c_b11 = 1.;
     extern doublereal dlamch_(char *);
     extern integer idamax_(integer *, doublereal *, integer *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal lstres;
     extern /* Subroutine */ int dpttrs_(integer *, integer *, doublereal *, 
 	    doublereal *, doublereal *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dptsv.c b/CLAPACK-3.2.1/SRC/dptsv.c
index 2c09ce9..bf87f2b 100644
--- a/CLAPACK-3.2.1/SRC/dptsv.c
+++ b/CLAPACK-3.2.1/SRC/dptsv.c
@@ -20,7 +20,8 @@
     integer b_dim1, b_offset, i__1;
 
     /* Local variables */
-    extern /* Subroutine */ int xerbla_(char *, integer *), dpttrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dpttrf_(
 	    integer *, doublereal *, doublereal *, integer *), dpttrs_(
 	    integer *, integer *, doublereal *, doublereal *, doublereal *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dptsvx.c b/CLAPACK-3.2.1/SRC/dptsvx.c
index ba37b18..69af6d1 100644
--- a/CLAPACK-3.2.1/SRC/dptsvx.c
+++ b/CLAPACK-3.2.1/SRC/dptsvx.c
@@ -34,8 +34,8 @@ static integer c__1 = 1;
     extern doublereal dlamch_(char *);
     logical nofact;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
     extern /* Subroutine */ int dptcon_(integer *, doublereal *, doublereal *, 
 	     doublereal *, doublereal *, doublereal *, integer *), dptrfs_(
diff --git a/CLAPACK-3.2.1/SRC/dpttrf.c b/CLAPACK-3.2.1/SRC/dpttrf.c
index 070ef34..e0bb7c1 100644
--- a/CLAPACK-3.2.1/SRC/dpttrf.c
+++ b/CLAPACK-3.2.1/SRC/dpttrf.c
@@ -22,7 +22,7 @@
     /* Local variables */
     integer i__, i4;
     doublereal ei;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dpttrs.c b/CLAPACK-3.2.1/SRC/dpttrs.c
index 52aaa90..21dfe20 100644
--- a/CLAPACK-3.2.1/SRC/dpttrs.c
+++ b/CLAPACK-3.2.1/SRC/dpttrs.c
@@ -27,7 +27,8 @@ static integer c_n1 = -1;
     /* Local variables */
     integer j, jb, nb;
     extern /* Subroutine */ int dptts2_(integer *, integer *, doublereal *, 
-	    doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
+	    doublereal *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/dsbev.c b/CLAPACK-3.2.1/SRC/dsbev.c
index 2d1efc5..77ed9cd 100644
--- a/CLAPACK-3.2.1/SRC/dsbev.c
+++ b/CLAPACK-3.2.1/SRC/dsbev.c
@@ -49,7 +49,7 @@ static integer c__1 = 1;
     extern doublereal dlansb_(char *, char *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     extern /* Subroutine */ int dsbtrd_(char *, char *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, doublereal *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dsbevd.c b/CLAPACK-3.2.1/SRC/dsbevd.c
index e2717d0..233f6ab 100644
--- a/CLAPACK-3.2.1/SRC/dsbevd.c
+++ b/CLAPACK-3.2.1/SRC/dsbevd.c
@@ -56,7 +56,7 @@ static integer c__1 = 1;
 	    integer *, integer *, integer *), dlacpy_(char *, integer 
 	    *, integer *, doublereal *, integer *, doublereal *, integer *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     extern /* Subroutine */ int dsbtrd_(char *, char *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, doublereal *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dsbevx.c b/CLAPACK-3.2.1/SRC/dsbevx.c
index 29916a0..0facd37 100644
--- a/CLAPACK-3.2.1/SRC/dsbevx.c
+++ b/CLAPACK-3.2.1/SRC/dsbevx.c
@@ -68,7 +68,7 @@ static doublereal c_b34 = 0.;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal abstll, bignum;
     extern /* Subroutine */ int dsbtrd_(char *, char *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, doublereal *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dsbgst.c b/CLAPACK-3.2.1/SRC/dsbgst.c
index 24c9aad..aa32351 100644
--- a/CLAPACK-3.2.1/SRC/dsbgst.c
+++ b/CLAPACK-3.2.1/SRC/dsbgst.c
@@ -50,8 +50,10 @@ static doublereal c_b20 = -1.;
 	     doublereal *, integer *, doublereal *, doublereal *, integer *), 
 	    dlaset_(char *, integer *, integer *, doublereal *, doublereal *, 
 	    doublereal *, integer *), dlartg_(doublereal *, 
-	    doublereal *, doublereal *, doublereal *, doublereal *), xerbla_(
-	    char *, integer *), dlargv_(integer *, doublereal *, 
+	    doublereal *, doublereal *, doublereal *, doublereal *);
+    void xerbla_(
+	    char *, integer *);
+    int dlargv_(integer *, doublereal *, 
 	    integer *, doublereal *, integer *, doublereal *, integer *);
     logical update;
     extern /* Subroutine */ int dlartv_(integer *, doublereal *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dsbgv.c b/CLAPACK-3.2.1/SRC/dsbgv.c
index 0fcf767..0b4efb8 100644
--- a/CLAPACK-3.2.1/SRC/dsbgv.c
+++ b/CLAPACK-3.2.1/SRC/dsbgv.c
@@ -27,7 +27,8 @@
     extern logical lsame_(char *, char *);
     integer iinfo;
     logical upper, wantz;
-    extern /* Subroutine */ int xerbla_(char *, integer *), dpbstf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dpbstf_(
 	    char *, integer *, integer *, doublereal *, integer *, integer *), dsbtrd_(char *, char *, integer *, integer *, doublereal 
 	    *, integer *, doublereal *, doublereal *, doublereal *, integer *, 
 	     doublereal *, integer *), dsbgst_(char *, char *, 
diff --git a/CLAPACK-3.2.1/SRC/dsbgvd.c b/CLAPACK-3.2.1/SRC/dsbgvd.c
index 28f87a0..64f0e47 100644
--- a/CLAPACK-3.2.1/SRC/dsbgvd.c
+++ b/CLAPACK-3.2.1/SRC/dsbgvd.c
@@ -39,7 +39,9 @@ static doublereal c_b13 = 0.;
     extern /* Subroutine */ int dstedc_(char *, integer *, doublereal *, 
 	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
 	    integer *, integer *, integer *), dlacpy_(char *, integer 
-	    *, integer *, doublereal *, integer *, doublereal *, integer *), xerbla_(char *, integer *), dpbstf_(char *, 
+	    *, integer *, doublereal *, integer *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
+    int dpbstf_(char *, 
 	    integer *, integer *, doublereal *, integer *, integer *),
 	     dsbtrd_(char *, char *, integer *, integer *, doublereal *, 
 	    integer *, doublereal *, doublereal *, doublereal *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dsbgvx.c b/CLAPACK-3.2.1/SRC/dsbgvx.c
index b810b3a..da6a087 100644
--- a/CLAPACK-3.2.1/SRC/dsbgvx.c
+++ b/CLAPACK-3.2.1/SRC/dsbgvx.c
@@ -50,8 +50,9 @@ static doublereal c_b27 = 0.;
     integer indibl;
     logical valeig;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *), dpbstf_(char *, integer *, 
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
+    int dpbstf_(char *, integer *, 
 	    integer *, doublereal *, integer *, integer *), dsbtrd_(
 	    char *, char *, integer *, integer *, doublereal *, integer *, 
 	    doublereal *, doublereal *, doublereal *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dsbtrd.c b/CLAPACK-3.2.1/SRC/dsbtrd.c
index 70bddbd..b6db660 100644
--- a/CLAPACK-3.2.1/SRC/dsbtrd.c
+++ b/CLAPACK-3.2.1/SRC/dsbtrd.c
@@ -42,7 +42,9 @@ static integer c__1 = 1;
     extern /* Subroutine */ int dlaset_(char *, integer *, integer *, 
 	    doublereal *, doublereal *, doublereal *, integer *), 
 	    dlartg_(doublereal *, doublereal *, doublereal *, doublereal *, 
-	    doublereal *), xerbla_(char *, integer *), dlargv_(
+	    doublereal *);
+    void xerbla_(char *, integer *);
+    int dlargv_(
 	    integer *, doublereal *, integer *, doublereal *, integer *, 
 	    doublereal *, integer *), dlartv_(integer *, doublereal *, 
 	    integer *, doublereal *, integer *, doublereal *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dsfrk.c b/CLAPACK-3.2.1/SRC/dsfrk.c
index 53c9268..582b543 100644
--- a/CLAPACK-3.2.1/SRC/dsfrk.c
+++ b/CLAPACK-3.2.1/SRC/dsfrk.c
@@ -31,7 +31,8 @@
     logical lower;
     extern /* Subroutine */ int dsyrk_(char *, char *, integer *, integer *, 
 	    doublereal *, doublereal *, integer *, doublereal *, doublereal *, 
-	     integer *), xerbla_(char *, integer *);
+	     integer *);
+    void xerbla_(char *, integer *);
     logical nisodd, notrans;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dsgesv.c b/CLAPACK-3.2.1/SRC/dsgesv.c
index 44252af..b90071e 100644
--- a/CLAPACK-3.2.1/SRC/dsgesv.c
+++ b/CLAPACK-3.2.1/SRC/dsgesv.c
@@ -51,8 +51,9 @@ static integer c__1 = 1;
 	    integer *, doublereal *, integer *, doublereal *);
     extern integer idamax_(integer *, doublereal *, integer *);
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *), dgetrf_(integer *, integer *, 
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
+    int dgetrf_(integer *, integer *, 
 	    doublereal *, integer *, integer *, integer *), dgetrs_(char *, 
 	    integer *, integer *, doublereal *, integer *, integer *, 
 	    doublereal *, integer *, integer *), sgetrf_(integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dspcon.c b/CLAPACK-3.2.1/SRC/dspcon.c
index 5a826cd..61295a5 100644
--- a/CLAPACK-3.2.1/SRC/dspcon.c
+++ b/CLAPACK-3.2.1/SRC/dspcon.c
@@ -30,7 +30,8 @@ static integer c__1 = 1;
     integer isave[3];
     logical upper;
     extern /* Subroutine */ int dlacn2_(integer *, doublereal *, doublereal *, 
-	     integer *, doublereal *, integer *, integer *), xerbla_(char *, 
+	     integer *, doublereal *, integer *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int dsptrs_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dspev.c b/CLAPACK-3.2.1/SRC/dspev.c
index 3e9d3c1..f36dbb9 100644
--- a/CLAPACK-3.2.1/SRC/dspev.c
+++ b/CLAPACK-3.2.1/SRC/dspev.c
@@ -43,7 +43,7 @@ static integer c__1 = 1;
     extern doublereal dlamch_(char *);
     integer iscale;
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     extern doublereal dlansp_(char *, char *, integer *, doublereal *, 
 	    doublereal *);
diff --git a/CLAPACK-3.2.1/SRC/dspevd.c b/CLAPACK-3.2.1/SRC/dspevd.c
index ff663f9..516aceb 100644
--- a/CLAPACK-3.2.1/SRC/dspevd.c
+++ b/CLAPACK-3.2.1/SRC/dspevd.c
@@ -44,7 +44,7 @@ static integer c__1 = 1;
 	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
 	    integer *, integer *, integer *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     extern doublereal dlansp_(char *, char *, integer *, doublereal *, 
 	    doublereal *);
diff --git a/CLAPACK-3.2.1/SRC/dspevx.c b/CLAPACK-3.2.1/SRC/dspevx.c
index f1f6053..f29bcbc 100644
--- a/CLAPACK-3.2.1/SRC/dspevx.c
+++ b/CLAPACK-3.2.1/SRC/dspevx.c
@@ -54,7 +54,7 @@ static integer c__1 = 1;
     integer iscale, indibl;
     logical valeig;
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal abstll, bignum;
     extern doublereal dlansp_(char *, char *, integer *, doublereal *, 
 	    doublereal *);
diff --git a/CLAPACK-3.2.1/SRC/dspgst.c b/CLAPACK-3.2.1/SRC/dspgst.c
index f42db72..fe5a880 100644
--- a/CLAPACK-3.2.1/SRC/dspgst.c
+++ b/CLAPACK-3.2.1/SRC/dspgst.c
@@ -46,7 +46,8 @@ static doublereal c_b11 = 1.;
     extern /* Subroutine */ int dtpmv_(char *, char *, char *, integer *, 
 	    doublereal *, doublereal *, integer *), 
 	    dtpsv_(char *, char *, char *, integer *, doublereal *, 
-	    doublereal *, integer *), xerbla_(char *, 
+	    doublereal *, integer *);
+    void xerbla_(char *, 
 	    integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/dspgv.c b/CLAPACK-3.2.1/SRC/dspgv.c
index 6b14de3..8abe276 100644
--- a/CLAPACK-3.2.1/SRC/dspgv.c
+++ b/CLAPACK-3.2.1/SRC/dspgv.c
@@ -36,7 +36,8 @@ static integer c__1 = 1;
 	    dtpsv_(char *, char *, char *, integer *, doublereal *, 
 	    doublereal *, integer *);
     logical wantz;
-    extern /* Subroutine */ int xerbla_(char *, integer *), dpptrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dpptrf_(
 	    char *, integer *, doublereal *, integer *), dspgst_(
 	    integer *, char *, integer *, doublereal *, doublereal *, integer 
 	    *);
diff --git a/CLAPACK-3.2.1/SRC/dspgvd.c b/CLAPACK-3.2.1/SRC/dspgvd.c
index 75ceb69..c86e50e 100644
--- a/CLAPACK-3.2.1/SRC/dspgvd.c
+++ b/CLAPACK-3.2.1/SRC/dspgvd.c
@@ -37,7 +37,8 @@ static integer c__1 = 1;
 	    dtpsv_(char *, char *, char *, integer *, doublereal *, 
 	    doublereal *, integer *);
     logical wantz;
-    extern /* Subroutine */ int xerbla_(char *, integer *), dspevd_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dspevd_(
 	    char *, char *, integer *, doublereal *, doublereal *, doublereal 
 	    *, integer *, doublereal *, integer *, integer *, integer *, 
 	    integer *);
diff --git a/CLAPACK-3.2.1/SRC/dspgvx.c b/CLAPACK-3.2.1/SRC/dspgvx.c
index 90c8aa5..597ea1f 100644
--- a/CLAPACK-3.2.1/SRC/dspgvx.c
+++ b/CLAPACK-3.2.1/SRC/dspgvx.c
@@ -36,7 +36,8 @@ static integer c__1 = 1;
 	    dtpsv_(char *, char *, char *, integer *, doublereal *, 
 	    doublereal *, integer *);
     logical wantz, alleig, indeig, valeig;
-    extern /* Subroutine */ int xerbla_(char *, integer *), dpptrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dpptrf_(
 	    char *, integer *, doublereal *, integer *), dspgst_(
 	    integer *, char *, integer *, doublereal *, doublereal *, integer 
 	    *), dspevx_(char *, char *, char *, integer *, doublereal 
diff --git a/CLAPACK-3.2.1/SRC/dsposv.c b/CLAPACK-3.2.1/SRC/dsposv.c
index c7892b4..0082ed7 100644
--- a/CLAPACK-3.2.1/SRC/dsposv.c
+++ b/CLAPACK-3.2.1/SRC/dsposv.c
@@ -51,8 +51,8 @@ static integer c__1 = 1;
     extern doublereal dlamch_(char *);
     extern integer idamax_(integer *, doublereal *, integer *);
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     extern doublereal dlansy_(char *, char *, integer *, doublereal *, 
 	    integer *, doublereal *);
     extern /* Subroutine */ int dpotrf_(char *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dsprfs.c b/CLAPACK-3.2.1/SRC/dsprfs.c
index 4b0bb0d..47d3582 100644
--- a/CLAPACK-3.2.1/SRC/dsprfs.c
+++ b/CLAPACK-3.2.1/SRC/dsprfs.c
@@ -51,7 +51,7 @@ static doublereal c_b14 = 1.;
 	     integer *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal lstres;
     extern /* Subroutine */ int dsptrs_(char *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dspsv.c b/CLAPACK-3.2.1/SRC/dspsv.c
index ebf99a2..f330f29 100644
--- a/CLAPACK-3.2.1/SRC/dspsv.c
+++ b/CLAPACK-3.2.1/SRC/dspsv.c
@@ -21,7 +21,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), dsptrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dsptrf_(
 	    char *, integer *, doublereal *, integer *, integer *), 
 	    dsptrs_(char *, integer *, integer *, doublereal *, integer *, 
 	    doublereal *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dspsvx.c b/CLAPACK-3.2.1/SRC/dspsvx.c
index 2737ef3..62c9608 100644
--- a/CLAPACK-3.2.1/SRC/dspsvx.c
+++ b/CLAPACK-3.2.1/SRC/dspsvx.c
@@ -34,8 +34,8 @@ static integer c__1 = 1;
     extern doublereal dlamch_(char *);
     logical nofact;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     extern doublereal dlansp_(char *, char *, integer *, doublereal *, 
 	    doublereal *);
     extern /* Subroutine */ int dspcon_(char *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dsptrd.c b/CLAPACK-3.2.1/SRC/dsptrd.c
index f5814b8..012e7ad 100644
--- a/CLAPACK-3.2.1/SRC/dsptrd.c
+++ b/CLAPACK-3.2.1/SRC/dsptrd.c
@@ -40,7 +40,8 @@ static doublereal c_b14 = -1.;
 	     doublereal *, integer *);
     logical upper;
     extern /* Subroutine */ int dlarfg_(integer *, doublereal *, doublereal *, 
-	     integer *, doublereal *), xerbla_(char *, integer *);
+	     integer *, doublereal *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dsptrf.c b/CLAPACK-3.2.1/SRC/dsptrf.c
index 35ad473..5d47666 100644
--- a/CLAPACK-3.2.1/SRC/dsptrf.c
+++ b/CLAPACK-3.2.1/SRC/dsptrf.c
@@ -47,7 +47,7 @@ static integer c__1 = 1;
     logical upper;
     doublereal absakk;
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal colmax, rowmax;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dsptri.c b/CLAPACK-3.2.1/SRC/dsptri.c
index 962be35..062d38c 100644
--- a/CLAPACK-3.2.1/SRC/dsptri.c
+++ b/CLAPACK-3.2.1/SRC/dsptri.c
@@ -44,7 +44,7 @@ static doublereal c_b13 = 0.;
 	    doublereal *, doublereal *, integer *, doublereal *, doublereal *, 
 	     integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer kcnext;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dsptrs.c b/CLAPACK-3.2.1/SRC/dsptrs.c
index 4dc105b..9eb107a 100644
--- a/CLAPACK-3.2.1/SRC/dsptrs.c
+++ b/CLAPACK-3.2.1/SRC/dsptrs.c
@@ -45,7 +45,7 @@ static doublereal c_b19 = 1.;
 	    doublereal *, doublereal *, integer *), dswap_(integer *, 
 	    doublereal *, integer *, doublereal *, integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dstebz.c b/CLAPACK-3.2.1/SRC/dstebz.c
index c4c7521..e2dcbe4 100644
--- a/CLAPACK-3.2.1/SRC/dstebz.c
+++ b/CLAPACK-3.2.1/SRC/dstebz.c
@@ -63,7 +63,7 @@ static integer c__0 = 0;
     integer irange, idiscl;
     doublereal safemn;
     integer idumma[1];
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer idiscu, iorder;
diff --git a/CLAPACK-3.2.1/SRC/dstedc.c b/CLAPACK-3.2.1/SRC/dstedc.c
index 6824ecc..2c62d78 100644
--- a/CLAPACK-3.2.1/SRC/dstedc.c
+++ b/CLAPACK-3.2.1/SRC/dstedc.c
@@ -60,7 +60,7 @@ static integer c__1 = 1;
 	    doublereal *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer finish;
     extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
     extern /* Subroutine */ int dsterf_(integer *, doublereal *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dstein.c b/CLAPACK-3.2.1/SRC/dstein.c
index 1035c8c..6dfe221 100644
--- a/CLAPACK-3.2.1/SRC/dstein.c
+++ b/CLAPACK-3.2.1/SRC/dstein.c
@@ -55,7 +55,8 @@ static integer c_n1 = -1;
 	     doublereal *, doublereal *, doublereal *, doublereal *, integer *
 , integer *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), dlagts_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dlagts_(
 	    integer *, integer *, doublereal *, doublereal *, doublereal *, 
 	    doublereal *, integer *, doublereal *, doublereal *, integer *);
     integer nrmchk;
diff --git a/CLAPACK-3.2.1/SRC/dstemr.c b/CLAPACK-3.2.1/SRC/dstemr.c
index abea3d6..a6c0e36 100644
--- a/CLAPACK-3.2.1/SRC/dstemr.c
+++ b/CLAPACK-3.2.1/SRC/dstemr.c
@@ -81,7 +81,8 @@ static doublereal c_b18 = .001;
     extern /* Subroutine */ int dlarrj_(integer *, doublereal *, doublereal *, 
 	     integer *, integer *, doublereal *, integer *, doublereal *, 
 	    doublereal *, doublereal *, integer *, doublereal *, doublereal *, 
-	     integer *), xerbla_(char *, integer *);
+	     integer *);
+    void xerbla_(char *, integer *);
     doublereal bignum;
     integer inderr, iindwk, indgrs, offset;
     extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
diff --git a/CLAPACK-3.2.1/SRC/dsteqr.c b/CLAPACK-3.2.1/SRC/dsteqr.c
index 2d57ebb..8390625 100644
--- a/CLAPACK-3.2.1/SRC/dsteqr.c
+++ b/CLAPACK-3.2.1/SRC/dsteqr.c
@@ -62,7 +62,7 @@ static integer c__2 = 2;
     extern /* Subroutine */ int dlartg_(doublereal *, doublereal *, 
 	    doublereal *, doublereal *, doublereal *);
     doublereal safmax;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
     extern /* Subroutine */ int dlasrt_(char *, integer *, doublereal *, 
 	    integer *);
diff --git a/CLAPACK-3.2.1/SRC/dsterf.c b/CLAPACK-3.2.1/SRC/dsterf.c
index a950e5b..5a69701 100644
--- a/CLAPACK-3.2.1/SRC/dsterf.c
+++ b/CLAPACK-3.2.1/SRC/dsterf.c
@@ -47,7 +47,7 @@ static doublereal c_b32 = 1.;
 	    doublereal *, doublereal *, integer *, integer *, doublereal *, 
 	    integer *, integer *);
     doublereal oldgam, safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal safmax;
     extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
     extern /* Subroutine */ int dlasrt_(char *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dstev.c b/CLAPACK-3.2.1/SRC/dstev.c
index db343ac..3c66f39 100644
--- a/CLAPACK-3.2.1/SRC/dstev.c
+++ b/CLAPACK-3.2.1/SRC/dstev.c
@@ -40,7 +40,7 @@ static integer c__1 = 1;
     extern doublereal dlamch_(char *);
     integer iscale;
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
     extern /* Subroutine */ int dsterf_(integer *, doublereal *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dstevd.c b/CLAPACK-3.2.1/SRC/dstevd.c
index ffd0167..574778d 100644
--- a/CLAPACK-3.2.1/SRC/dstevd.c
+++ b/CLAPACK-3.2.1/SRC/dstevd.c
@@ -42,7 +42,7 @@ static integer c__1 = 1;
 	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
 	    integer *, integer *, integer *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
     extern /* Subroutine */ int dsterf_(integer *, doublereal *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dstevr.c b/CLAPACK-3.2.1/SRC/dstevr.c
index db78da6..862dd42 100644
--- a/CLAPACK-3.2.1/SRC/dstevr.c
+++ b/CLAPACK-3.2.1/SRC/dstevr.c
@@ -59,7 +59,7 @@ static integer c__4 = 4;
     doublereal safmin;
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
     integer indisp;
diff --git a/CLAPACK-3.2.1/SRC/dstevx.c b/CLAPACK-3.2.1/SRC/dstevx.c
index d9f1bb1..69a573d 100644
--- a/CLAPACK-3.2.1/SRC/dstevx.c
+++ b/CLAPACK-3.2.1/SRC/dstevx.c
@@ -52,7 +52,7 @@ static integer c__1 = 1;
     integer iscale, indibl;
     logical valeig;
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
     integer indisp;
diff --git a/CLAPACK-3.2.1/SRC/dsycon.c b/CLAPACK-3.2.1/SRC/dsycon.c
index c72e8ce..0e6c76e 100644
--- a/CLAPACK-3.2.1/SRC/dsycon.c
+++ b/CLAPACK-3.2.1/SRC/dsycon.c
@@ -30,7 +30,8 @@ static integer c__1 = 1;
     integer isave[3];
     logical upper;
     extern /* Subroutine */ int dlacn2_(integer *, doublereal *, doublereal *, 
-	     integer *, doublereal *, integer *, integer *), xerbla_(char *, 
+	     integer *, doublereal *, integer *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int dsytrs_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dsyequb.c b/CLAPACK-3.2.1/SRC/dsyequb.c
index 4485427..dc5c37f 100644
--- a/CLAPACK-3.2.1/SRC/dsyequb.c
+++ b/CLAPACK-3.2.1/SRC/dsyequb.c
@@ -39,7 +39,7 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     doublereal sumsq;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     extern /* Subroutine */ int dlassq_(integer *, doublereal *, integer *, 
 	    doublereal *, doublereal *);
diff --git a/CLAPACK-3.2.1/SRC/dsyev.c b/CLAPACK-3.2.1/SRC/dsyev.c
index 0fdcb3a..7ad5a63 100644
--- a/CLAPACK-3.2.1/SRC/dsyev.c
+++ b/CLAPACK-3.2.1/SRC/dsyev.c
@@ -52,7 +52,7 @@ static doublereal c_b17 = 1.;
     doublereal safmin;
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     integer indtau;
     extern /* Subroutine */ int dsterf_(integer *, doublereal *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dsyevd.c b/CLAPACK-3.2.1/SRC/dsyevd.c
index cd7f6d3..139b187 100644
--- a/CLAPACK-3.2.1/SRC/dsyevd.c
+++ b/CLAPACK-3.2.1/SRC/dsyevd.c
@@ -55,7 +55,7 @@ static doublereal c_b17 = 1.;
     doublereal safmin;
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     integer indtau;
     extern /* Subroutine */ int dsterf_(integer *, doublereal *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dsyevr.c b/CLAPACK-3.2.1/SRC/dsyevr.c
index 4574299..a404428 100644
--- a/CLAPACK-3.2.1/SRC/dsyevr.c
+++ b/CLAPACK-3.2.1/SRC/dsyevr.c
@@ -62,7 +62,7 @@ static integer c_n1 = -1;
     doublereal safmin;
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal abstll, bignum;
     integer indtau, indisp;
     extern /* Subroutine */ int dstein_(integer *, doublereal *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dsyevx.c b/CLAPACK-3.2.1/SRC/dsyevx.c
index 1b6a3c2..37aab1f 100644
--- a/CLAPACK-3.2.1/SRC/dsyevx.c
+++ b/CLAPACK-3.2.1/SRC/dsyevx.c
@@ -59,7 +59,7 @@ static integer c_n1 = -1;
     doublereal safmin;
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal abstll, bignum;
     integer indtau, indisp;
     extern /* Subroutine */ int dstein_(integer *, doublereal *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dsygs2.c b/CLAPACK-3.2.1/SRC/dsygs2.c
index 9a12cef..a1f1302 100644
--- a/CLAPACK-3.2.1/SRC/dsygs2.c
+++ b/CLAPACK-3.2.1/SRC/dsygs2.c
@@ -40,8 +40,8 @@ static doublereal c_b27 = 1.;
     logical upper;
     extern /* Subroutine */ int dtrmv_(char *, char *, char *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *), dtrsv_(char *, char *, char *, integer *, doublereal *, 
-	    integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dsygst.c b/CLAPACK-3.2.1/SRC/dsygst.c
index 55635fe..33b363f 100644
--- a/CLAPACK-3.2.1/SRC/dsygst.c
+++ b/CLAPACK-3.2.1/SRC/dsygst.c
@@ -46,7 +46,8 @@ static doublereal c_b52 = .5;
 	    *, integer *, integer *), dsyr2k_(char *, char *, integer 
 	    *, integer *, doublereal *, doublereal *, integer *, doublereal *, 
 	     integer *, doublereal *, doublereal *, integer *)
-	    , xerbla_(char *, integer *);
+	    ;
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/dsygv.c b/CLAPACK-3.2.1/SRC/dsygv.c
index 47a80c6..983f926 100644
--- a/CLAPACK-3.2.1/SRC/dsygv.c
+++ b/CLAPACK-3.2.1/SRC/dsygv.c
@@ -40,7 +40,7 @@ static doublereal c_b16 = 1.;
     extern /* Subroutine */ int dsyev_(char *, char *, integer *, doublereal *
 , integer *, doublereal *, doublereal *, integer *, integer *);
     logical wantz;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int dpotrf_(char *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dsygvd.c b/CLAPACK-3.2.1/SRC/dsygvd.c
index c7469cb..bb23ba4 100644
--- a/CLAPACK-3.2.1/SRC/dsygvd.c
+++ b/CLAPACK-3.2.1/SRC/dsygvd.c
@@ -39,7 +39,8 @@ static doublereal c_b11 = 1.;
 	    integer *, integer *, doublereal *, doublereal *, integer *, 
 	    doublereal *, integer *);
     logical upper, wantz;
-    extern /* Subroutine */ int xerbla_(char *, integer *), dpotrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dpotrf_(
 	    char *, integer *, doublereal *, integer *, integer *);
     integer liwmin;
     extern /* Subroutine */ int dsyevd_(char *, char *, integer *, doublereal 
diff --git a/CLAPACK-3.2.1/SRC/dsygvx.c b/CLAPACK-3.2.1/SRC/dsygvx.c
index fa9756c..bb735dd 100644
--- a/CLAPACK-3.2.1/SRC/dsygvx.c
+++ b/CLAPACK-3.2.1/SRC/dsygvx.c
@@ -40,7 +40,7 @@ static doublereal c_b19 = 1.;
 	    integer *, integer *, doublereal *, doublereal *, integer *, 
 	    doublereal *, integer *);
     logical upper, wantz, alleig, indeig, valeig;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int dpotrf_(char *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dsyrfs.c b/CLAPACK-3.2.1/SRC/dsyrfs.c
index 399d2f5..90a2c8c 100644
--- a/CLAPACK-3.2.1/SRC/dsyrfs.c
+++ b/CLAPACK-3.2.1/SRC/dsyrfs.c
@@ -50,7 +50,7 @@ static doublereal c_b14 = 1.;
 	     doublereal *, integer *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal lstres;
     extern /* Subroutine */ int dsytrs_(char *, integer *, integer *, 
 	    doublereal *, integer *, integer *, doublereal *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dsyrfsx.c b/CLAPACK-3.2.1/SRC/dsyrfsx.c
index 98f69a7..e5c62a5 100644
--- a/CLAPACK-3.2.1/SRC/dsyrfsx.c
+++ b/CLAPACK-3.2.1/SRC/dsyrfsx.c
@@ -58,7 +58,7 @@ static integer c__1 = 1;
     doublereal anorm;
     logical rcequ;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal dlansy_(char *, char *, integer *, doublereal *, 
 	    integer *, doublereal *);
     extern /* Subroutine */ int dsycon_(char *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dsysv.c b/CLAPACK-3.2.1/SRC/dsysv.c
index e53c638..20c2a23 100644
--- a/CLAPACK-3.2.1/SRC/dsysv.c
+++ b/CLAPACK-3.2.1/SRC/dsysv.c
@@ -28,7 +28,7 @@ static integer c_n1 = -1;
     /* Local variables */
     integer nb;
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int dsytrf_(char *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dsysvx.c b/CLAPACK-3.2.1/SRC/dsysvx.c
index 0877279..1e4b543 100644
--- a/CLAPACK-3.2.1/SRC/dsysvx.c
+++ b/CLAPACK-3.2.1/SRC/dsysvx.c
@@ -35,8 +35,8 @@ static integer c_n1 = -1;
     extern doublereal dlamch_(char *);
     logical nofact;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern doublereal dlansy_(char *, char *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dsysvxx.c b/CLAPACK-3.2.1/SRC/dsysvxx.c
index abe75da..fd8883a 100644
--- a/CLAPACK-3.2.1/SRC/dsysvxx.c
+++ b/CLAPACK-3.2.1/SRC/dsysvxx.c
@@ -39,8 +39,8 @@
     extern doublereal dlamch_(char *);
     logical nofact;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     doublereal bignum;
     integer infequ;
     extern /* Subroutine */ int dlaqsy_(char *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/dsytd2.c b/CLAPACK-3.2.1/SRC/dsytd2.c
index 2f98901..246502f 100644
--- a/CLAPACK-3.2.1/SRC/dsytd2.c
+++ b/CLAPACK-3.2.1/SRC/dsytd2.c
@@ -41,7 +41,8 @@ static doublereal c_b14 = -1.;
     extern /* Subroutine */ int dsymv_(char *, integer *, doublereal *, 
 	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
 	    doublereal *, integer *), dlarfg_(integer *, doublereal *, 
-	     doublereal *, integer *, doublereal *), xerbla_(char *, integer *
+	     doublereal *, integer *, doublereal *);
+    void xerbla_(char *, integer *
 );
 
 
diff --git a/CLAPACK-3.2.1/SRC/dsytf2.c b/CLAPACK-3.2.1/SRC/dsytf2.c
index 11d3947..9625ef5 100644
--- a/CLAPACK-3.2.1/SRC/dsytf2.c
+++ b/CLAPACK-3.2.1/SRC/dsytf2.c
@@ -46,7 +46,7 @@ static integer c__1 = 1;
     doublereal absakk;
     extern integer idamax_(integer *, doublereal *, integer *);
     extern logical disnan_(doublereal *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal colmax, rowmax;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dsytrd.c b/CLAPACK-3.2.1/SRC/dsytrd.c
index f0f9ded..2e9800a 100644
--- a/CLAPACK-3.2.1/SRC/dsytrd.c
+++ b/CLAPACK-3.2.1/SRC/dsytrd.c
@@ -39,7 +39,8 @@ static doublereal c_b23 = 1.;
 	    *, doublereal *, integer *, doublereal *, integer *, doublereal *, 
 	     doublereal *, integer *), dlatrd_(char *, 
 	    integer *, integer *, doublereal *, integer *, doublereal *, 
-	    doublereal *, doublereal *, integer *), xerbla_(char *, 
+	    doublereal *, doublereal *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dsytrf.c b/CLAPACK-3.2.1/SRC/dsytrf.c
index 8492793..ac6f78c 100644
--- a/CLAPACK-3.2.1/SRC/dsytrf.c
+++ b/CLAPACK-3.2.1/SRC/dsytrf.c
@@ -31,7 +31,8 @@ static integer c__2 = 2;
     integer nbmin, iinfo;
     logical upper;
     extern /* Subroutine */ int dsytf2_(char *, integer *, doublereal *, 
-	    integer *, integer *, integer *), xerbla_(char *, integer 
+	    integer *, integer *, integer *);
+    void xerbla_(char *, integer 
 	    *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dsytri.c b/CLAPACK-3.2.1/SRC/dsytri.c
index 3ed3d7c..79a13f8 100644
--- a/CLAPACK-3.2.1/SRC/dsytri.c
+++ b/CLAPACK-3.2.1/SRC/dsytri.c
@@ -43,7 +43,8 @@ static doublereal c_b13 = 0.;
     logical upper;
     extern /* Subroutine */ int dsymv_(char *, integer *, doublereal *, 
 	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
-	    doublereal *, integer *), xerbla_(char *, integer *);
+	    doublereal *, integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dsytrs.c b/CLAPACK-3.2.1/SRC/dsytrs.c
index 26db5a7..b459619 100644
--- a/CLAPACK-3.2.1/SRC/dsytrs.c
+++ b/CLAPACK-3.2.1/SRC/dsytrs.c
@@ -45,7 +45,7 @@ static doublereal c_b19 = 1.;
 	    doublereal *, doublereal *, integer *), dswap_(integer *, 
 	    doublereal *, integer *, doublereal *, integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dtbcon.c b/CLAPACK-3.2.1/SRC/dtbcon.c
index 1c4e89c..5f19361 100644
--- a/CLAPACK-3.2.1/SRC/dtbcon.c
+++ b/CLAPACK-3.2.1/SRC/dtbcon.c
@@ -43,7 +43,8 @@ static integer c__1 = 1;
 	    doublereal *, integer *, doublereal *);
     extern /* Subroutine */ int dlatbs_(char *, char *, char *, char *, 
 	    integer *, integer *, doublereal *, integer *, doublereal *, 
-	    doublereal *, doublereal *, integer *), xerbla_(char *, integer *);
+	    doublereal *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
     doublereal ainvnm;
     logical onenrm;
     char normin[1];
diff --git a/CLAPACK-3.2.1/SRC/dtbrfs.c b/CLAPACK-3.2.1/SRC/dtbrfs.c
index e1e50c8..cd57b2e 100644
--- a/CLAPACK-3.2.1/SRC/dtbrfs.c
+++ b/CLAPACK-3.2.1/SRC/dtbrfs.c
@@ -48,7 +48,7 @@ static doublereal c_b19 = -1.;
 	     integer *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
     char transt[1];
     logical nounit;
diff --git a/CLAPACK-3.2.1/SRC/dtbtrs.c b/CLAPACK-3.2.1/SRC/dtbtrs.c
index aee820c..9726d40 100644
--- a/CLAPACK-3.2.1/SRC/dtbtrs.c
+++ b/CLAPACK-3.2.1/SRC/dtbtrs.c
@@ -30,7 +30,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int dtbsv_(char *, char *, char *, integer *, 
 	    integer *, doublereal *, integer *, doublereal *, integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nounit;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dtfsm.c b/CLAPACK-3.2.1/SRC/dtfsm.c
index 0b28fc5..17ebfdb 100644
--- a/CLAPACK-3.2.1/SRC/dtfsm.c
+++ b/CLAPACK-3.2.1/SRC/dtfsm.c
@@ -36,7 +36,8 @@ static doublereal c_b27 = 1.;
     logical lower;
     extern /* Subroutine */ int dtrsm_(char *, char *, char *, char *, 
 	    integer *, integer *, doublereal *, doublereal *, integer *, 
-	    doublereal *, integer *), xerbla_(
+	    doublereal *, integer *);
+    void xerbla_(
 	    char *, integer *);
     logical misodd, nisodd, notrans;
 
diff --git a/CLAPACK-3.2.1/SRC/dtftri.c b/CLAPACK-3.2.1/SRC/dtftri.c
index 1f9edc1..8117240 100644
--- a/CLAPACK-3.2.1/SRC/dtftri.c
+++ b/CLAPACK-3.2.1/SRC/dtftri.c
@@ -32,7 +32,7 @@ static doublereal c_b18 = 1.;
 	    integer *, integer *, doublereal *, doublereal *, integer *, 
 	    doublereal *, integer *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd;
     extern /* Subroutine */ int dtrtri_(char *, char *, integer *, doublereal 
 	    *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dtfttp.c b/CLAPACK-3.2.1/SRC/dtfttp.c
index 3322618..e346b7f 100644
--- a/CLAPACK-3.2.1/SRC/dtfttp.c
+++ b/CLAPACK-3.2.1/SRC/dtfttp.c
@@ -24,7 +24,7 @@
     logical normaltransr;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dtfttr.c b/CLAPACK-3.2.1/SRC/dtfttr.c
index 4f02d0c..42ddfde 100644
--- a/CLAPACK-3.2.1/SRC/dtfttr.c
+++ b/CLAPACK-3.2.1/SRC/dtfttr.c
@@ -24,7 +24,7 @@
     logical normaltransr;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dtgevc.c b/CLAPACK-3.2.1/SRC/dtgevc.c
index e411ffc..a2ac4d4 100644
--- a/CLAPACK-3.2.1/SRC/dtgevc.c
+++ b/CLAPACK-3.2.1/SRC/dtgevc.c
@@ -73,7 +73,7 @@ static logical c_false = FALSE_;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *);
     doublereal xscale, bignum;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical ilcomp, ilcplx;
     integer ihwmny;
 
diff --git a/CLAPACK-3.2.1/SRC/dtgexc.c b/CLAPACK-3.2.1/SRC/dtgexc.c
index d816a06..a11816f 100644
--- a/CLAPACK-3.2.1/SRC/dtgexc.c
+++ b/CLAPACK-3.2.1/SRC/dtgexc.c
@@ -32,7 +32,8 @@ static integer c__2 = 2;
     extern /* Subroutine */ int dtgex2_(logical *, logical *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
 	    integer *, doublereal *, integer *, integer *, integer *, integer 
-	    *, doublereal *, integer *, integer *), xerbla_(char *, integer *);
+	    *, doublereal *, integer *, integer *);
+    void xerbla_(char *, integer *);
     integer nbnext;
     logical lquery;
 
diff --git a/CLAPACK-3.2.1/SRC/dtgsen.c b/CLAPACK-3.2.1/SRC/dtgsen.c
index 053390b..9e8082c 100644
--- a/CLAPACK-3.2.1/SRC/dtgsen.c
+++ b/CLAPACK-3.2.1/SRC/dtgsen.c
@@ -56,8 +56,9 @@ static doublereal c_b28 = 1.;
     extern doublereal dlamch_(char *);
     doublereal dscale, rdscal;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *), dtgexc_(logical *, logical *, 
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
+    int dtgexc_(logical *, logical *, 
 	    integer *, doublereal *, integer *, doublereal *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *, integer *, 
 	    integer *, doublereal *, integer *, integer *), dlassq_(integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dtgsja.c b/CLAPACK-3.2.1/SRC/dtgsja.c
index 5b295b9..dfa4168 100644
--- a/CLAPACK-3.2.1/SRC/dtgsja.c
+++ b/CLAPACK-3.2.1/SRC/dtgsja.c
@@ -55,7 +55,8 @@ static doublereal c_b43 = -1.;
     extern /* Subroutine */ int dlartg_(doublereal *, doublereal *, 
 	    doublereal *, doublereal *, doublereal *), dlaset_(char *, 
 	    integer *, integer *, doublereal *, doublereal *, doublereal *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dtgsna.c b/CLAPACK-3.2.1/SRC/dtgsna.c
index 0dc3509..26955a1 100644
--- a/CLAPACK-3.2.1/SRC/dtgsna.c
+++ b/CLAPACK-3.2.1/SRC/dtgsna.c
@@ -68,8 +68,9 @@ static integer c__3 = 3;
     extern doublereal dlamch_(char *);
     doublereal alphai, alphar;
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *), dtgexc_(logical *, logical *, 
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
+    int dtgexc_(logical *, logical *, 
 	    integer *, doublereal *, integer *, doublereal *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *, integer *, 
 	    integer *, doublereal *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dtgsy2.c b/CLAPACK-3.2.1/SRC/dtgsy2.c
index ed0a92d..07e4859 100644
--- a/CLAPACK-3.2.1/SRC/dtgsy2.c
+++ b/CLAPACK-3.2.1/SRC/dtgsy2.c
@@ -60,8 +60,8 @@ static doublereal c_b56 = 0.;
 	    *, doublereal *, doublereal *, integer *, integer *);
     doublereal scaloc;
     extern /* Subroutine */ int dlaset_(char *, integer *, integer *, 
-	    doublereal *, doublereal *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, doublereal *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dtgsyl.c b/CLAPACK-3.2.1/SRC/dtgsyl.c
index 5c44e8a..6cbc21b 100644
--- a/CLAPACK-3.2.1/SRC/dtgsyl.c
+++ b/CLAPACK-3.2.1/SRC/dtgsyl.c
@@ -61,7 +61,7 @@ static doublereal c_b52 = 1.;
 	    doublereal *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer iround;
     logical notran;
     integer isolve;
diff --git a/CLAPACK-3.2.1/SRC/dtpcon.c b/CLAPACK-3.2.1/SRC/dtpcon.c
index b789722..b851c3f 100644
--- a/CLAPACK-3.2.1/SRC/dtpcon.c
+++ b/CLAPACK-3.2.1/SRC/dtpcon.c
@@ -39,7 +39,7 @@ static integer c__1 = 1;
 	     integer *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal dlantp_(char *, char *, char *, integer *, doublereal *, 
 	     doublereal *);
     doublereal ainvnm;
diff --git a/CLAPACK-3.2.1/SRC/dtprfs.c b/CLAPACK-3.2.1/SRC/dtprfs.c
index 8226412..3ba6aea 100644
--- a/CLAPACK-3.2.1/SRC/dtprfs.c
+++ b/CLAPACK-3.2.1/SRC/dtprfs.c
@@ -49,7 +49,7 @@ static doublereal c_b19 = -1.;
 	    doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
     char transt[1];
     logical nounit;
diff --git a/CLAPACK-3.2.1/SRC/dtptri.c b/CLAPACK-3.2.1/SRC/dtptri.c
index a6ce4b4..1356174 100644
--- a/CLAPACK-3.2.1/SRC/dtptri.c
+++ b/CLAPACK-3.2.1/SRC/dtptri.c
@@ -32,7 +32,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int dtpmv_(char *, char *, char *, integer *, 
 	    doublereal *, doublereal *, integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer jclast;
     logical nounit;
 
diff --git a/CLAPACK-3.2.1/SRC/dtptrs.c b/CLAPACK-3.2.1/SRC/dtptrs.c
index e180254..0f1287c 100644
--- a/CLAPACK-3.2.1/SRC/dtptrs.c
+++ b/CLAPACK-3.2.1/SRC/dtptrs.c
@@ -29,8 +29,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     logical upper;
     extern /* Subroutine */ int dtpsv_(char *, char *, char *, integer *, 
-	    doublereal *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     logical nounit;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dtpttf.c b/CLAPACK-3.2.1/SRC/dtpttf.c
index 86a7ba0..8c2077b 100644
--- a/CLAPACK-3.2.1/SRC/dtpttf.c
+++ b/CLAPACK-3.2.1/SRC/dtpttf.c
@@ -24,7 +24,7 @@
     logical normaltransr;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dtpttr.c b/CLAPACK-3.2.1/SRC/dtpttr.c
index d08841b..28a9a28 100644
--- a/CLAPACK-3.2.1/SRC/dtpttr.c
+++ b/CLAPACK-3.2.1/SRC/dtpttr.c
@@ -23,7 +23,7 @@
     integer i__, j, k;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2)                                    -- */
diff --git a/CLAPACK-3.2.1/SRC/dtrcon.c b/CLAPACK-3.2.1/SRC/dtrcon.c
index aa424e9..904ee95 100644
--- a/CLAPACK-3.2.1/SRC/dtrcon.c
+++ b/CLAPACK-3.2.1/SRC/dtrcon.c
@@ -39,7 +39,7 @@ static integer c__1 = 1;
 	     integer *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal dlantr_(char *, char *, char *, integer *, integer *, 
 	    doublereal *, integer *, doublereal *);
     doublereal ainvnm;
diff --git a/CLAPACK-3.2.1/SRC/dtrevc.c b/CLAPACK-3.2.1/SRC/dtrevc.c
index 84dc510..67c9a06 100644
--- a/CLAPACK-3.2.1/SRC/dtrevc.c
+++ b/CLAPACK-3.2.1/SRC/dtrevc.c
@@ -72,7 +72,7 @@ static logical c_true = TRUE_;
 	     dlabad_(doublereal *, doublereal *);
     extern doublereal dlamch_(char *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     logical rightv;
     doublereal smlnum;
diff --git a/CLAPACK-3.2.1/SRC/dtrexc.c b/CLAPACK-3.2.1/SRC/dtrexc.c
index 9d77fbe..def6741 100644
--- a/CLAPACK-3.2.1/SRC/dtrexc.c
+++ b/CLAPACK-3.2.1/SRC/dtrexc.c
@@ -31,7 +31,8 @@ static integer c__2 = 2;
     logical wantq;
     extern /* Subroutine */ int dlaexc_(logical *, integer *, doublereal *, 
 	    integer *, doublereal *, integer *, integer *, integer *, integer 
-	    *, doublereal *, integer *), xerbla_(char *, integer *);
+	    *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
     integer nbnext;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dtrrfs.c b/CLAPACK-3.2.1/SRC/dtrrfs.c
index d07a7df..520cc36 100644
--- a/CLAPACK-3.2.1/SRC/dtrrfs.c
+++ b/CLAPACK-3.2.1/SRC/dtrrfs.c
@@ -48,7 +48,7 @@ static doublereal c_b19 = -1.;
 	    doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
     char transt[1];
     logical nounit;
diff --git a/CLAPACK-3.2.1/SRC/dtrsen.c b/CLAPACK-3.2.1/SRC/dtrsen.c
index 193ed02..d82fa52 100644
--- a/CLAPACK-3.2.1/SRC/dtrsen.c
+++ b/CLAPACK-3.2.1/SRC/dtrsen.c
@@ -47,8 +47,8 @@ static integer c_n1 = -1;
     extern doublereal dlange_(char *, integer *, integer *, doublereal *, 
 	    integer *, doublereal *);
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     logical wantbh;
     extern /* Subroutine */ int dtrexc_(char *, integer *, doublereal *, 
 	    integer *, doublereal *, integer *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dtrsna.c b/CLAPACK-3.2.1/SRC/dtrsna.c
index d0f26f1..8356e92 100644
--- a/CLAPACK-3.2.1/SRC/dtrsna.c
+++ b/CLAPACK-3.2.1/SRC/dtrsna.c
@@ -61,8 +61,8 @@ static logical c_false = FALSE_;
     extern /* Subroutine */ int dlabad_(doublereal *, doublereal *);
     extern doublereal dlamch_(char *);
     extern /* Subroutine */ int dlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
     doublereal bignum;
     logical wantbh;
     extern /* Subroutine */ int dlaqtr_(logical *, logical *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/dtrsyl.c b/CLAPACK-3.2.1/SRC/dtrsyl.c
index a23f564..f80ce1f 100644
--- a/CLAPACK-3.2.1/SRC/dtrsyl.c
+++ b/CLAPACK-3.2.1/SRC/dtrsyl.c
@@ -56,7 +56,7 @@ static logical c_true = TRUE_;
     extern doublereal dlamch_(char *), dlange_(char *, integer *, 
 	    integer *, doublereal *, integer *, doublereal *);
     doublereal scaloc;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     logical notrna, notrnb;
     doublereal smlnum;
diff --git a/CLAPACK-3.2.1/SRC/dtrti2.c b/CLAPACK-3.2.1/SRC/dtrti2.c
index 2631b19..c8092ec 100644
--- a/CLAPACK-3.2.1/SRC/dtrti2.c
+++ b/CLAPACK-3.2.1/SRC/dtrti2.c
@@ -31,7 +31,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     logical upper;
     extern /* Subroutine */ int dtrmv_(char *, char *, char *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), xerbla_(char *, integer *);
+	    doublereal *, integer *, doublereal *, integer *);
+    void xerbla_(char *, integer *);
     logical nounit;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dtrtri.c b/CLAPACK-3.2.1/SRC/dtrtri.c
index cbc2264..f4c4c0a 100644
--- a/CLAPACK-3.2.1/SRC/dtrtri.c
+++ b/CLAPACK-3.2.1/SRC/dtrtri.c
@@ -30,7 +30,7 @@ static doublereal c_b22 = -1.;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer j, jb, nb, nn;
@@ -42,7 +42,8 @@ static doublereal c_b22 = -1.;
 , doublereal *, integer *, doublereal *, integer *);
     logical upper;
     extern /* Subroutine */ int dtrti2_(char *, char *, integer *, doublereal 
-	    *, integer *, integer *), xerbla_(char *, integer 
+	    *, integer *, integer *);
+    void xerbla_(char *, integer 
 	    *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/dtrtrs.c b/CLAPACK-3.2.1/SRC/dtrtrs.c
index da458c5..13b6c2a 100644
--- a/CLAPACK-3.2.1/SRC/dtrtrs.c
+++ b/CLAPACK-3.2.1/SRC/dtrtrs.c
@@ -28,7 +28,8 @@ static doublereal c_b12 = 1.;
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int dtrsm_(char *, char *, char *, char *, 
 	    integer *, integer *, doublereal *, doublereal *, integer *, 
-	    doublereal *, integer *), xerbla_(
+	    doublereal *, integer *);
+    void xerbla_(
 	    char *, integer *);
     logical nounit;
 
diff --git a/CLAPACK-3.2.1/SRC/dtrttf.c b/CLAPACK-3.2.1/SRC/dtrttf.c
index 0e1746e..8a1457f 100644
--- a/CLAPACK-3.2.1/SRC/dtrttf.c
+++ b/CLAPACK-3.2.1/SRC/dtrttf.c
@@ -24,7 +24,7 @@
     logical normaltransr;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd;
 
 
diff --git a/CLAPACK-3.2.1/SRC/dtrttp.c b/CLAPACK-3.2.1/SRC/dtrttp.c
index 1af49f1..097956f 100644
--- a/CLAPACK-3.2.1/SRC/dtrttp.c
+++ b/CLAPACK-3.2.1/SRC/dtrttp.c
@@ -23,7 +23,7 @@
     integer i__, j, k;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dtzrqf.c b/CLAPACK-3.2.1/SRC/dtzrqf.c
index 08a3e71..19e4327 100644
--- a/CLAPACK-3.2.1/SRC/dtzrqf.c
+++ b/CLAPACK-3.2.1/SRC/dtzrqf.c
@@ -34,8 +34,8 @@ static doublereal c_b8 = 1.;
 	    doublereal *, integer *), dcopy_(integer *, doublereal *, 
 	    integer *, doublereal *, integer *), daxpy_(integer *, doublereal 
 	    *, doublereal *, integer *, doublereal *, integer *), dlarfp_(
-	    integer *, doublereal *, doublereal *, integer *, doublereal *), 
-	    xerbla_(char *, integer *);
+	    integer *, doublereal *, doublereal *, integer *, doublereal *);
+	void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/dtzrzf.c b/CLAPACK-3.2.1/SRC/dtzrzf.c
index ee5e09e..71ae4c6 100644
--- a/CLAPACK-3.2.1/SRC/dtzrzf.c
+++ b/CLAPACK-3.2.1/SRC/dtzrzf.c
@@ -28,7 +28,8 @@ static integer c__2 = 2;
 
     /* Local variables */
     integer i__, m1, ib, nb, ki, kk, mu, nx, iws, nbmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), dlarzb_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dlarzb_(
 	    char *, char *, char *, char *, integer *, integer *, integer *, 
 	    integer *, doublereal *, integer *, doublereal *, integer *, 
 	    doublereal *, integer *, doublereal *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/ilaenv.c b/CLAPACK-3.2.1/SRC/ilaenv.c
index fb07230..0abd636 100644
--- a/CLAPACK-3.2.1/SRC/ilaenv.c
+++ b/CLAPACK-3.2.1/SRC/ilaenv.c
@@ -28,7 +28,7 @@ integer ilaenv_(integer *ispec, char *name__, char *opts, integer *n1,
     integer ret_val;
 
     /* Builtin functions */
-    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
+    /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
     integer s_cmp(char *, char *, ftnlen, ftnlen);
 
     /* Local variables */
diff --git a/CLAPACK-3.2.1/SRC/sbdsdc.c b/CLAPACK-3.2.1/SRC/sbdsdc.c
index 0794f6d..ed386f0 100644
--- a/CLAPACK-3.2.1/SRC/sbdsdc.c
+++ b/CLAPACK-3.2.1/SRC/sbdsdc.c
@@ -55,8 +55,8 @@ static real c_b29 = 0.f;
     extern /* Subroutine */ int slasda_(integer *, integer *, integer *, 
 	    integer *, real *, real *, real *, integer *, real *, integer *, 
 	    real *, real *, real *, real *, integer *, integer *, integer *, 
-	    integer *, real *, real *, real *, real *, integer *, integer *), 
-	    xerbla_(char *, integer *);
+	    integer *, real *, real *, real *, real *, integer *, integer *);
+	void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/sbdsqr.c b/CLAPACK-3.2.1/SRC/sbdsqr.c
index 954f88c..e1c412e 100644
--- a/CLAPACK-3.2.1/SRC/sbdsqr.c
+++ b/CLAPACK-3.2.1/SRC/sbdsqr.c
@@ -67,7 +67,7 @@ static real c_b72 = -1.f;
 	     slasv2_(real *, real *, real *, real *, real *, real *, real *, 
 	    real *, real *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real sminoa;
     extern /* Subroutine */ int slartg_(real *, real *, real *, real *, real *
 );
diff --git a/CLAPACK-3.2.1/SRC/sdisna.c b/CLAPACK-3.2.1/SRC/sdisna.c
index a47cb17..7f95070 100644
--- a/CLAPACK-3.2.1/SRC/sdisna.c
+++ b/CLAPACK-3.2.1/SRC/sdisna.c
@@ -30,7 +30,7 @@
     real oldgap;
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real newgap, thresh;
 
 
diff --git a/CLAPACK-3.2.1/SRC/sgbbrd.c b/CLAPACK-3.2.1/SRC/sgbbrd.c
index 451b1be..073df53 100644
--- a/CLAPACK-3.2.1/SRC/sgbbrd.c
+++ b/CLAPACK-3.2.1/SRC/sgbbrd.c
@@ -40,7 +40,8 @@ static integer c__1 = 1;
     logical wantb, wantc;
     integer minmn;
     logical wantq;
-    extern /* Subroutine */ int xerbla_(char *, integer *), slaset_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slaset_(
 	    char *, integer *, integer *, real *, real *, real *, integer *), slartg_(real *, real *, real *, real *, real *), slargv_(
 	    integer *, real *, integer *, real *, integer *, real *, integer *
 ), slartv_(integer *, real *, integer *, real *, integer *, real *
diff --git a/CLAPACK-3.2.1/SRC/sgbcon.c b/CLAPACK-3.2.1/SRC/sgbcon.c
index 78fd7c1..fd95cbb 100644
--- a/CLAPACK-3.2.1/SRC/sgbcon.c
+++ b/CLAPACK-3.2.1/SRC/sgbcon.c
@@ -40,7 +40,7 @@ static integer c__1 = 1;
 	    slacn2_(integer *, real *, real *, integer *, real *, integer *, 
 	    integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
     real ainvnm;
     extern /* Subroutine */ int slatbs_(char *, char *, char *, char *, 
diff --git a/CLAPACK-3.2.1/SRC/sgbequ.c b/CLAPACK-3.2.1/SRC/sgbequ.c
index 1f04493..364f9ee 100644
--- a/CLAPACK-3.2.1/SRC/sgbequ.c
+++ b/CLAPACK-3.2.1/SRC/sgbequ.c
@@ -25,7 +25,7 @@
     integer i__, j, kd;
     real rcmin, rcmax;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum, smlnum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/sgbequb.c b/CLAPACK-3.2.1/SRC/sgbequb.c
index 062eb8b..d1aeb97 100644
--- a/CLAPACK-3.2.1/SRC/sgbequb.c
+++ b/CLAPACK-3.2.1/SRC/sgbequb.c
@@ -28,7 +28,7 @@
     integer i__, j, kd;
     real radix, rcmin, rcmax;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum, logrdx, smlnum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/sgbrfs.c b/CLAPACK-3.2.1/SRC/sgbrfs.c
index d5e5d7e..cb6a9c6 100644
--- a/CLAPACK-3.2.1/SRC/sgbrfs.c
+++ b/CLAPACK-3.2.1/SRC/sgbrfs.c
@@ -50,7 +50,7 @@ static real c_b17 = 1.f;
 	    integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
     extern /* Subroutine */ int sgbtrs_(char *, integer *, integer *, integer 
 	    *, integer *, real *, integer *, integer *, real *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/sgbrfsx.c b/CLAPACK-3.2.1/SRC/sgbrfsx.c
index b0e96ab..a112e8c 100644
--- a/CLAPACK-3.2.1/SRC/sgbrfsx.c
+++ b/CLAPACK-3.2.1/SRC/sgbrfsx.c
@@ -60,7 +60,8 @@ static integer c__1 = 1;
 	     integer *, real *), slamch_(char *);
     extern /* Subroutine */ int sgbcon_(char *, integer *, integer *, integer 
 	    *, real *, integer *, integer *, real *, real *, real *, integer *
-, integer *), xerbla_(char *, integer *);
+, integer *);
+    void xerbla_(char *, integer *);
     logical colequ, notran, rowequ;
     extern integer ilaprec_(char *);
     integer ithresh, n_norms__;
diff --git a/CLAPACK-3.2.1/SRC/sgbsv.c b/CLAPACK-3.2.1/SRC/sgbsv.c
index ee6db5e..c17ce8c 100644
--- a/CLAPACK-3.2.1/SRC/sgbsv.c
+++ b/CLAPACK-3.2.1/SRC/sgbsv.c
@@ -21,7 +21,8 @@
     integer ab_dim1, ab_offset, b_dim1, b_offset, i__1;
 
     /* Local variables */
-    extern /* Subroutine */ int xerbla_(char *, integer *), sgbtrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  sgbtrf_(
 	    integer *, integer *, integer *, integer *, real *, integer *, 
 	    integer *, integer *), sgbtrs_(char *, integer *, integer *, 
 	    integer *, integer *, real *, integer *, integer *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/sgbsvx.c b/CLAPACK-3.2.1/SRC/sgbsvx.c
index 69346f4..77d1f65 100644
--- a/CLAPACK-3.2.1/SRC/sgbsvx.c
+++ b/CLAPACK-3.2.1/SRC/sgbsvx.c
@@ -46,7 +46,8 @@ static integer c__1 = 1;
     logical nofact;
     extern /* Subroutine */ int sgbcon_(char *, integer *, integer *, integer 
 	    *, real *, integer *, integer *, real *, real *, real *, integer *
-, integer *), xerbla_(char *, integer *);
+, integer *);
+    void xerbla_(char *, integer *);
     real bignum;
     extern doublereal slantb_(char *, char *, char *, integer *, integer *, 
 	    real *, integer *, real *);
diff --git a/CLAPACK-3.2.1/SRC/sgbsvxx.c b/CLAPACK-3.2.1/SRC/sgbsvxx.c
index 0d5e113..facb561 100644
--- a/CLAPACK-3.2.1/SRC/sgbsvxx.c
+++ b/CLAPACK-3.2.1/SRC/sgbsvxx.c
@@ -41,7 +41,7 @@
 	    integer *, real *, integer *, real *, real *, real *, real *, 
 	    real *, char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     integer infequ;
     logical colequ;
diff --git a/CLAPACK-3.2.1/SRC/sgbtf2.c b/CLAPACK-3.2.1/SRC/sgbtf2.c
index 0d0fbfb..7446e98 100644
--- a/CLAPACK-3.2.1/SRC/sgbtf2.c
+++ b/CLAPACK-3.2.1/SRC/sgbtf2.c
@@ -30,7 +30,8 @@ static real c_b9 = -1.f;
     extern /* Subroutine */ int sger_(integer *, integer *, real *, real *, 
 	    integer *, real *, integer *, real *, integer *), sscal_(integer *
 , real *, real *, integer *), sswap_(integer *, real *, integer *, 
-	     real *, integer *), xerbla_(char *, integer *);
+	     real *, integer *);
+    void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/sgbtrf.c b/CLAPACK-3.2.1/SRC/sgbtrf.c
index fead045..80b54c3 100644
--- a/CLAPACK-3.2.1/SRC/sgbtrf.c
+++ b/CLAPACK-3.2.1/SRC/sgbtrf.c
@@ -42,7 +42,8 @@ static real c_b31 = 1.f;
 	    integer *), sswap_(integer *, real *, integer *, real *, integer *
 ), strsm_(char *, char *, char *, char *, integer *, integer *, 
 	    real *, real *, integer *, real *, integer *), sgbtf2_(integer *, integer *, integer *, integer 
-	    *, real *, integer *, integer *, integer *), xerbla_(char *, 
+	    *, real *, integer *, integer *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *), isamax_(integer *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/sgbtrs.c b/CLAPACK-3.2.1/SRC/sgbtrs.c
index b99d3d2..b0cc9ee 100644
--- a/CLAPACK-3.2.1/SRC/sgbtrs.c
+++ b/CLAPACK-3.2.1/SRC/sgbtrs.c
@@ -36,8 +36,8 @@ static real c_b23 = 1.f;
     logical lnoti;
     extern /* Subroutine */ int sswap_(integer *, real *, integer *, real *, 
 	    integer *), stbsv_(char *, char *, char *, integer *, integer *, 
-	    real *, integer *, real *, integer *), 
-	    xerbla_(char *, integer *);
+	    real *, integer *, real *, integer *);
+	void xerbla_(char *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/sgebak.c b/CLAPACK-3.2.1/SRC/sgebak.c
index 349055f..b67ac3f 100644
--- a/CLAPACK-3.2.1/SRC/sgebak.c
+++ b/CLAPACK-3.2.1/SRC/sgebak.c
@@ -28,7 +28,8 @@
     extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *);
     logical leftv;
     extern /* Subroutine */ int sswap_(integer *, real *, integer *, real *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     logical rightv;
 
 
diff --git a/CLAPACK-3.2.1/SRC/sgebal.c b/CLAPACK-3.2.1/SRC/sgebal.c
index 4c8c9b5..0fc95e2 100644
--- a/CLAPACK-3.2.1/SRC/sgebal.c
+++ b/CLAPACK-3.2.1/SRC/sgebal.c
@@ -34,7 +34,7 @@ static integer c__1 = 1;
 	    sswap_(integer *, real *, integer *, real *, integer *);
     real sfmin1, sfmin2, sfmax1, sfmax2;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
     logical noconv;
 
diff --git a/CLAPACK-3.2.1/SRC/sgebd2.c b/CLAPACK-3.2.1/SRC/sgebd2.c
index a5855ac..d394347 100644
--- a/CLAPACK-3.2.1/SRC/sgebd2.c
+++ b/CLAPACK-3.2.1/SRC/sgebd2.c
@@ -26,8 +26,10 @@ static integer c__1 = 1;
     /* Local variables */
     integer i__;
     extern /* Subroutine */ int slarf_(char *, integer *, integer *, real *, 
-	    integer *, real *, real *, integer *, real *), xerbla_(
-	    char *, integer *), slarfg_(integer *, real *, real *, 
+	    integer *, real *, real *, integer *, real *);
+    void xerbla_(
+	    char *, integer *);
+    int slarfg_(integer *, real *, real *, 
 	    integer *, real *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/sgebrd.c b/CLAPACK-3.2.1/SRC/sgebrd.c
index d0a0cef..89473f9 100644
--- a/CLAPACK-3.2.1/SRC/sgebrd.c
+++ b/CLAPACK-3.2.1/SRC/sgebrd.c
@@ -40,7 +40,8 @@ static real c_b22 = 1.f;
     extern /* Subroutine */ int sgebd2_(integer *, integer *, real *, integer 
 	    *, real *, real *, real *, real *, real *, integer *), slabrd_(
 	    integer *, integer *, integer *, real *, integer *, real *, real *
-, real *, real *, real *, integer *, real *, integer *), xerbla_(
+, real *, real *, real *, integer *, real *, integer *);
+    void xerbla_(
 	    char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sgecon.c b/CLAPACK-3.2.1/SRC/sgecon.c
index 83a6655..2008b26 100644
--- a/CLAPACK-3.2.1/SRC/sgecon.c
+++ b/CLAPACK-3.2.1/SRC/sgecon.c
@@ -36,7 +36,7 @@ static integer c__1 = 1;
 	    slacn2_(integer *, real *, real *, integer *, real *, integer *, 
 	    integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
     real ainvnm;
     logical onenrm;
diff --git a/CLAPACK-3.2.1/SRC/sgeequ.c b/CLAPACK-3.2.1/SRC/sgeequ.c
index baa44c9..6e1c35d 100644
--- a/CLAPACK-3.2.1/SRC/sgeequ.c
+++ b/CLAPACK-3.2.1/SRC/sgeequ.c
@@ -25,7 +25,7 @@
     integer i__, j;
     real rcmin, rcmax;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum, smlnum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/sgeequb.c b/CLAPACK-3.2.1/SRC/sgeequb.c
index 607f5be..6cd9d06 100644
--- a/CLAPACK-3.2.1/SRC/sgeequb.c
+++ b/CLAPACK-3.2.1/SRC/sgeequb.c
@@ -28,7 +28,7 @@
     integer i__, j;
     real radix, rcmin, rcmax;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum, logrdx, smlnum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/sgees.c b/CLAPACK-3.2.1/SRC/sgees.c
index be6b052..0ec7b8d 100644
--- a/CLAPACK-3.2.1/SRC/sgees.c
+++ b/CLAPACK-3.2.1/SRC/sgees.c
@@ -53,7 +53,8 @@ static integer c_n1 = -1;
     extern doublereal slamch_(char *), slange_(char *, integer *, 
 	    integer *, real *, integer *, real *);
     extern /* Subroutine */ int sgehrd_(integer *, integer *, integer *, real 
-	    *, integer *, real *, real *, integer *, integer *), xerbla_(char 
+	    *, integer *, real *, real *, integer *, integer *);
+    void xerbla_(char 
 	    *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sgeesx.c b/CLAPACK-3.2.1/SRC/sgeesx.c
index 8f9cafa..ef317e7 100644
--- a/CLAPACK-3.2.1/SRC/sgeesx.c
+++ b/CLAPACK-3.2.1/SRC/sgeesx.c
@@ -53,7 +53,8 @@ static integer c_n1 = -1;
     extern doublereal slamch_(char *), slange_(char *, integer *, 
 	    integer *, real *, integer *, real *);
     extern /* Subroutine */ int sgehrd_(integer *, integer *, integer *, real 
-	    *, integer *, real *, real *, integer *, integer *), xerbla_(char 
+	    *, integer *, real *, real *, integer *, integer *);
+    void xerbla_(char 
 	    *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sgeev.c b/CLAPACK-3.2.1/SRC/sgeev.c
index e4d639f..9b04593 100644
--- a/CLAPACK-3.2.1/SRC/sgeev.c
+++ b/CLAPACK-3.2.1/SRC/sgeev.c
@@ -57,7 +57,8 @@ static integer c_n1 = -1;
     extern doublereal slamch_(char *), slange_(char *, integer *, 
 	    integer *, real *, integer *, real *);
     extern /* Subroutine */ int sgehrd_(integer *, integer *, integer *, real 
-	    *, integer *, real *, real *, integer *, integer *), xerbla_(char 
+	    *, integer *, real *, real *, integer *, integer *);
+    void xerbla_(char 
 	    *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sgeevx.c b/CLAPACK-3.2.1/SRC/sgeevx.c
index 2e94a12..f81a61e 100644
--- a/CLAPACK-3.2.1/SRC/sgeevx.c
+++ b/CLAPACK-3.2.1/SRC/sgeevx.c
@@ -57,7 +57,8 @@ static integer c_n1 = -1;
     extern doublereal slamch_(char *), slange_(char *, integer *, 
 	    integer *, real *, integer *, real *);
     extern /* Subroutine */ int sgehrd_(integer *, integer *, integer *, real 
-	    *, integer *, real *, real *, integer *, integer *), xerbla_(char 
+	    *, integer *, real *, real *, integer *, integer *);
+    void xerbla_(char 
 	    *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sgegs.c b/CLAPACK-3.2.1/SRC/sgegs.c
index 8671962..b36793e 100644
--- a/CLAPACK-3.2.1/SRC/sgegs.c
+++ b/CLAPACK-3.2.1/SRC/sgegs.c
@@ -50,7 +50,8 @@ static real c_b37 = 1.f;
     real safmin;
     extern /* Subroutine */ int sgghrd_(char *, char *, integer *, integer *, 
 	    integer *, real *, integer *, real *, integer *, real *, integer *
-, real *, integer *, integer *), xerbla_(char *, 
+, real *, integer *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sgegv.c b/CLAPACK-3.2.1/SRC/sgegv.c
index 34704c6..196a763 100644
--- a/CLAPACK-3.2.1/SRC/sgegv.c
+++ b/CLAPACK-3.2.1/SRC/sgegv.c
@@ -59,7 +59,8 @@ static real c_b38 = 0.f;
     char chtemp[1];
     logical ldumma[1];
     extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *, 
-	    real *, integer *, integer *, real *, integer *, integer *), xerbla_(char *, integer *);
+	    real *, integer *, integer *, real *, integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ijobvl, iright;
diff --git a/CLAPACK-3.2.1/SRC/sgehd2.c b/CLAPACK-3.2.1/SRC/sgehd2.c
index e7ba694..b6aa8b0 100644
--- a/CLAPACK-3.2.1/SRC/sgehd2.c
+++ b/CLAPACK-3.2.1/SRC/sgehd2.c
@@ -27,8 +27,10 @@ static integer c__1 = 1;
     integer i__;
     real aii;
     extern /* Subroutine */ int slarf_(char *, integer *, integer *, real *, 
-	    integer *, real *, real *, integer *, real *), xerbla_(
-	    char *, integer *), slarfg_(integer *, real *, real *, 
+	    integer *, real *, real *, integer *, real *);
+    void xerbla_(
+	    char *, integer *);
+    int slarfg_(integer *, real *, real *, 
 	    integer *, real *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/sgehrd.c b/CLAPACK-3.2.1/SRC/sgehrd.c
index 7d6e3cd..677f32b 100644
--- a/CLAPACK-3.2.1/SRC/sgehrd.c
+++ b/CLAPACK-3.2.1/SRC/sgehrd.c
@@ -46,7 +46,8 @@ static real c_b26 = 1.f;
 	    real *, real *, integer *, real *, integer *), slarfb_(char *, 
 	    char *, char *, char *, integer *, integer *, integer *, real *, 
 	    integer *, real *, integer *, real *, integer *, real *, integer *
-), xerbla_(char *, integer *);
+);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwork, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/sgejsv.c b/CLAPACK-3.2.1/SRC/sgejsv.c
index 57fe148..638e82d 100644
--- a/CLAPACK-3.2.1/SRC/sgejsv.c
+++ b/CLAPACK-3.2.1/SRC/sgejsv.c
@@ -68,7 +68,7 @@ static integer c_n1 = -1;
     real aatmin;
     extern doublereal slamch_(char *);
     real aatmax;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noscal;
     extern /* Subroutine */ int sgelqf_(integer *, integer *, real *, integer 
 	    *, real *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sgelq2.c b/CLAPACK-3.2.1/SRC/sgelq2.c
index a4082b4..98e262c 100644
--- a/CLAPACK-3.2.1/SRC/sgelq2.c
+++ b/CLAPACK-3.2.1/SRC/sgelq2.c
@@ -23,8 +23,10 @@
     integer i__, k;
     real aii;
     extern /* Subroutine */ int slarf_(char *, integer *, integer *, real *, 
-	    integer *, real *, real *, integer *, real *), xerbla_(
-	    char *, integer *), slarfp_(integer *, real *, real *, 
+	    integer *, real *, real *, integer *, real *);
+    void xerbla_(
+	    char *, integer *);
+    int slarfp_(integer *, real *, real *, 
 	    integer *, real *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/sgelqf.c b/CLAPACK-3.2.1/SRC/sgelqf.c
index a3eb98f..a896898 100644
--- a/CLAPACK-3.2.1/SRC/sgelqf.c
+++ b/CLAPACK-3.2.1/SRC/sgelqf.c
@@ -31,7 +31,8 @@ static integer c__2 = 2;
     extern /* Subroutine */ int sgelq2_(integer *, integer *, real *, integer 
 	    *, real *, real *, integer *), slarfb_(char *, char *, char *, 
 	    char *, integer *, integer *, integer *, real *, integer *, real *
-, integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
+, integer *, real *, integer *, real *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int slarft_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/sgels.c b/CLAPACK-3.2.1/SRC/sgels.c
index 2cb9e73..4a89482 100644
--- a/CLAPACK-3.2.1/SRC/sgels.c
+++ b/CLAPACK-3.2.1/SRC/sgels.c
@@ -39,7 +39,7 @@ static integer c__0 = 0;
     extern /* Subroutine */ int slabad_(real *, real *);
     extern doublereal slamch_(char *), slange_(char *, integer *, 
 	    integer *, real *, integer *, real *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer scllen;
diff --git a/CLAPACK-3.2.1/SRC/sgelsd.c b/CLAPACK-3.2.1/SRC/sgelsd.c
index 8d2b911..dde4472 100644
--- a/CLAPACK-3.2.1/SRC/sgelsd.c
+++ b/CLAPACK-3.2.1/SRC/sgelsd.c
@@ -43,7 +43,7 @@ static real c_b81 = 0.f;
 	    real *, integer *, integer *);
     extern doublereal slamch_(char *), slange_(char *, integer *, 
 	    integer *, real *, integer *, real *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     real bignum;
diff --git a/CLAPACK-3.2.1/SRC/sgelss.c b/CLAPACK-3.2.1/SRC/sgelss.c
index 6de4676..d359de0 100644
--- a/CLAPACK-3.2.1/SRC/sgelss.c
+++ b/CLAPACK-3.2.1/SRC/sgelss.c
@@ -53,7 +53,7 @@ static real c_b108 = 1.f;
 	    *, real *, real *, real *, real *, real *, integer *, integer *);
     extern doublereal slamch_(char *), slange_(char *, integer *, 
 	    integer *, real *, integer *, real *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     real bignum;
diff --git a/CLAPACK-3.2.1/SRC/sgelsx.c b/CLAPACK-3.2.1/SRC/sgelsx.c
index d678656..d3171a3 100644
--- a/CLAPACK-3.2.1/SRC/sgelsx.c
+++ b/CLAPACK-3.2.1/SRC/sgelsx.c
@@ -44,7 +44,7 @@ static real c_b36 = 1.f;
 	    slabad_(real *, real *);
     extern doublereal slamch_(char *), slange_(char *, integer *, 
 	    integer *, real *, integer *, real *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *, 
 	    real *, integer *, integer *, real *, integer *, integer *), sgeqpf_(integer *, integer *, real *, integer *, integer 
diff --git a/CLAPACK-3.2.1/SRC/sgelsy.c b/CLAPACK-3.2.1/SRC/sgelsy.c
index c910c23..070c6f2 100644
--- a/CLAPACK-3.2.1/SRC/sgelsy.c
+++ b/CLAPACK-3.2.1/SRC/sgelsy.c
@@ -47,7 +47,7 @@ static real c_b54 = 1.f;
 , integer *, integer *), slabad_(real *, real *);
     extern doublereal slamch_(char *), slange_(char *, integer *, 
 	    integer *, real *, integer *, real *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     real bignum;
diff --git a/CLAPACK-3.2.1/SRC/sgeql2.c b/CLAPACK-3.2.1/SRC/sgeql2.c
index 13e292c..05c3254 100644
--- a/CLAPACK-3.2.1/SRC/sgeql2.c
+++ b/CLAPACK-3.2.1/SRC/sgeql2.c
@@ -27,8 +27,10 @@ static integer c__1 = 1;
     integer i__, k;
     real aii;
     extern /* Subroutine */ int slarf_(char *, integer *, integer *, real *, 
-	    integer *, real *, real *, integer *, real *), xerbla_(
-	    char *, integer *), slarfp_(integer *, real *, real *, 
+	    integer *, real *, real *, integer *, real *);
+    void xerbla_(
+	    char *, integer *);
+    int slarfp_(integer *, real *, real *, 
 	    integer *, real *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/sgeqlf.c b/CLAPACK-3.2.1/SRC/sgeqlf.c
index 3d2b2e6..49213b5 100644
--- a/CLAPACK-3.2.1/SRC/sgeqlf.c
+++ b/CLAPACK-3.2.1/SRC/sgeqlf.c
@@ -31,7 +31,8 @@ static integer c__2 = 2;
     extern /* Subroutine */ int sgeql2_(integer *, integer *, real *, integer 
 	    *, real *, real *, integer *), slarfb_(char *, char *, char *, 
 	    char *, integer *, integer *, integer *, real *, integer *, real *
-, integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
+, integer *, real *, integer *, real *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int slarft_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/sgeqp3.c b/CLAPACK-3.2.1/SRC/sgeqp3.c
index b9c8817..892a427 100644
--- a/CLAPACK-3.2.1/SRC/sgeqp3.c
+++ b/CLAPACK-3.2.1/SRC/sgeqp3.c
@@ -32,7 +32,8 @@ static integer c__2 = 2;
     integer nbmin, minmn, minws;
     extern /* Subroutine */ int sswap_(integer *, real *, integer *, real *, 
 	    integer *), slaqp2_(integer *, integer *, integer *, real *, 
-	    integer *, integer *, real *, real *, real *, real *), xerbla_(
+	    integer *, integer *, real *, real *, real *, real *);
+    void xerbla_(
 	    char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sgeqpf.c b/CLAPACK-3.2.1/SRC/sgeqpf.c
index 1610cfd..e118e3c 100644
--- a/CLAPACK-3.2.1/SRC/sgeqpf.c
+++ b/CLAPACK-3.2.1/SRC/sgeqpf.c
@@ -43,7 +43,7 @@ static integer c__1 = 1;
 	    *, integer *, real *, integer *, real *, real *, integer *, real *
 , integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
     extern /* Subroutine */ int slarfp_(integer *, real *, real *, integer *, 
 	    real *);
diff --git a/CLAPACK-3.2.1/SRC/sgeqr2.c b/CLAPACK-3.2.1/SRC/sgeqr2.c
index 7698d16..eeb2792 100644
--- a/CLAPACK-3.2.1/SRC/sgeqr2.c
+++ b/CLAPACK-3.2.1/SRC/sgeqr2.c
@@ -27,8 +27,10 @@ static integer c__1 = 1;
     integer i__, k;
     real aii;
     extern /* Subroutine */ int slarf_(char *, integer *, integer *, real *, 
-	    integer *, real *, real *, integer *, real *), xerbla_(
-	    char *, integer *), slarfp_(integer *, real *, real *, 
+	    integer *, real *, real *, integer *, real *);
+    void xerbla_(
+	    char *, integer *);
+    int slarfp_(integer *, real *, real *, 
 	    integer *, real *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/sgeqrf.c b/CLAPACK-3.2.1/SRC/sgeqrf.c
index 64c165b..3353153 100644
--- a/CLAPACK-3.2.1/SRC/sgeqrf.c
+++ b/CLAPACK-3.2.1/SRC/sgeqrf.c
@@ -31,7 +31,8 @@ static integer c__2 = 2;
     extern /* Subroutine */ int sgeqr2_(integer *, integer *, real *, integer 
 	    *, real *, real *, integer *), slarfb_(char *, char *, char *, 
 	    char *, integer *, integer *, integer *, real *, integer *, real *
-, integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
+, integer *, real *, integer *, real *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int slarft_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/sgerfs.c b/CLAPACK-3.2.1/SRC/sgerfs.c
index d053026..03a0663 100644
--- a/CLAPACK-3.2.1/SRC/sgerfs.c
+++ b/CLAPACK-3.2.1/SRC/sgerfs.c
@@ -47,7 +47,7 @@ static real c_b17 = 1.f;
 	    integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
     extern /* Subroutine */ int sgetrs_(char *, integer *, integer *, real *, 
 	    integer *, integer *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sgerfsx.c b/CLAPACK-3.2.1/SRC/sgerfsx.c
index 5d10054..5545511 100644
--- a/CLAPACK-3.2.1/SRC/sgerfsx.c
+++ b/CLAPACK-3.2.1/SRC/sgerfsx.c
@@ -57,7 +57,8 @@ static integer c__1 = 1;
     real anorm;
     extern doublereal slamch_(char *), slange_(char *, integer *, 
 	    integer *, real *, integer *, real *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), sgecon_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  sgecon_(
 	    char *, integer *, real *, integer *, real *, real *, real *, 
 	    integer *, integer *);
     logical colequ, notran, rowequ;
diff --git a/CLAPACK-3.2.1/SRC/sgerq2.c b/CLAPACK-3.2.1/SRC/sgerq2.c
index 9a902f0..c8eec1e 100644
--- a/CLAPACK-3.2.1/SRC/sgerq2.c
+++ b/CLAPACK-3.2.1/SRC/sgerq2.c
@@ -23,8 +23,10 @@
     integer i__, k;
     real aii;
     extern /* Subroutine */ int slarf_(char *, integer *, integer *, real *, 
-	    integer *, real *, real *, integer *, real *), xerbla_(
-	    char *, integer *), slarfp_(integer *, real *, real *, 
+	    integer *, real *, real *, integer *, real *);
+    void xerbla_(
+	    char *, integer *);
+    int slarfp_(integer *, real *, real *, 
 	    integer *, real *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/sgerqf.c b/CLAPACK-3.2.1/SRC/sgerqf.c
index 749609e..72ea112 100644
--- a/CLAPACK-3.2.1/SRC/sgerqf.c
+++ b/CLAPACK-3.2.1/SRC/sgerqf.c
@@ -31,7 +31,8 @@ static integer c__2 = 2;
     extern /* Subroutine */ int sgerq2_(integer *, integer *, real *, integer 
 	    *, real *, real *, integer *), slarfb_(char *, char *, char *, 
 	    char *, integer *, integer *, integer *, real *, integer *, real *
-, integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
+, integer *, real *, integer *, real *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int slarft_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/sgesdd.c b/CLAPACK-3.2.1/SRC/sgesdd.c
index b9680da..b2e1fc9 100644
--- a/CLAPACK-3.2.1/SRC/sgesdd.c
+++ b/CLAPACK-3.2.1/SRC/sgesdd.c
@@ -55,7 +55,7 @@ static real c_b248 = 1.f;
 	    real *, integer *, integer *);
     extern doublereal slamch_(char *), slange_(char *, integer *, 
 	    integer *, real *, integer *, real *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     real bignum;
diff --git a/CLAPACK-3.2.1/SRC/sgesv.c b/CLAPACK-3.2.1/SRC/sgesv.c
index ae114ce..21b196c 100644
--- a/CLAPACK-3.2.1/SRC/sgesv.c
+++ b/CLAPACK-3.2.1/SRC/sgesv.c
@@ -20,7 +20,8 @@
     integer a_dim1, a_offset, b_dim1, b_offset, i__1;
 
     /* Local variables */
-    extern /* Subroutine */ int xerbla_(char *, integer *), sgetrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  sgetrf_(
 	    integer *, integer *, real *, integer *, integer *, integer *), 
 	    sgetrs_(char *, integer *, integer *, real *, integer *, integer *
 , real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sgesvd.c b/CLAPACK-3.2.1/SRC/sgesvd.c
index 358cbd6..45f63cd 100644
--- a/CLAPACK-3.2.1/SRC/sgesvd.c
+++ b/CLAPACK-3.2.1/SRC/sgesvd.c
@@ -34,7 +34,7 @@ static real c_b443 = 1.f;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
     double sqrt(doublereal);
 
     /* Local variables */
@@ -55,7 +55,7 @@ static real c_b443 = 1.f;
 	    *, real *, real *, real *, real *, real *, integer *, integer *);
     extern doublereal slamch_(char *), slange_(char *, integer *, 
 	    integer *, real *, integer *, real *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     real bignum;
diff --git a/CLAPACK-3.2.1/SRC/sgesvj.c b/CLAPACK-3.2.1/SRC/sgesvj.c
index 0510c99..99e5696 100644
--- a/CLAPACK-3.2.1/SRC/sgesvj.c
+++ b/CLAPACK-3.2.1/SRC/sgesvj.c
@@ -71,7 +71,7 @@ static integer c__2 = 2;
 , real *, integer *, real *, integer *, real *, real *, real *, 
 	    integer *, real *, integer *, integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer ijblsk, swband;
     extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *, 
 	    real *, integer *, integer *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sgesvx.c b/CLAPACK-3.2.1/SRC/sgesvx.c
index 932cccf..374bcf0 100644
--- a/CLAPACK-3.2.1/SRC/sgesvx.c
+++ b/CLAPACK-3.2.1/SRC/sgesvx.c
@@ -36,8 +36,9 @@
 	    integer *, real *, integer *, real *);
     logical nofact;
     extern /* Subroutine */ int slaqge_(integer *, integer *, real *, integer 
-	    *, real *, real *, real *, real *, real *, char *), 
-	    xerbla_(char *, integer *), sgecon_(char *, integer *, 
+	    *, real *, real *, real *, real *, real *, char *);
+	void xerbla_(char *, integer *);
+    int sgecon_(char *, integer *, 
 	    real *, integer *, real *, real *, real *, integer *, integer *);
     real bignum;
     integer infequ;
diff --git a/CLAPACK-3.2.1/SRC/sgesvxx.c b/CLAPACK-3.2.1/SRC/sgesvxx.c
index eef0b9a..9e913cc 100644
--- a/CLAPACK-3.2.1/SRC/sgesvxx.c
+++ b/CLAPACK-3.2.1/SRC/sgesvxx.c
@@ -38,8 +38,8 @@
     extern doublereal slamch_(char *);
     logical nofact;
     extern /* Subroutine */ int slaqge_(integer *, integer *, real *, integer 
-	    *, real *, real *, real *, real *, real *, char *), 
-	    xerbla_(char *, integer *);
+	    *, real *, real *, real *, real *, real *, char *);
+	void xerbla_(char *, integer *);
     real bignum;
     integer infequ;
     logical colequ;
diff --git a/CLAPACK-3.2.1/SRC/sgetf2.c b/CLAPACK-3.2.1/SRC/sgetf2.c
index a8393fb..a578fbb 100644
--- a/CLAPACK-3.2.1/SRC/sgetf2.c
+++ b/CLAPACK-3.2.1/SRC/sgetf2.c
@@ -34,7 +34,7 @@ static real c_b8 = -1.f;
     extern /* Subroutine */ int sswap_(integer *, real *, integer *, real *, 
 	    integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/sgetrf.c b/CLAPACK-3.2.1/SRC/sgetrf.c
index fc9e564..005f3ca 100644
--- a/CLAPACK-3.2.1/SRC/sgetrf.c
+++ b/CLAPACK-3.2.1/SRC/sgetrf.c
@@ -33,7 +33,8 @@ static real c_b19 = -1.f;
 	    real *, integer *), strsm_(char *, char *, char *, 
 	     char *, integer *, integer *, real *, real *, integer *, real *, 
 	    integer *), sgetf2_(integer *, 
-	    integer *, real *, integer *, integer *, integer *), xerbla_(char 
+	    integer *, real *, integer *, integer *, integer *);
+    void xerbla_(char 
 	    *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sgetri.c b/CLAPACK-3.2.1/SRC/sgetri.c
index af5156b..31cba97 100644
--- a/CLAPACK-3.2.1/SRC/sgetri.c
+++ b/CLAPACK-3.2.1/SRC/sgetri.c
@@ -36,7 +36,8 @@ static real c_b22 = 1.f;
 	    real *, integer *), sswap_(integer *, real *, integer *, 
 	    real *, integer *), strsm_(char *, char *, char *, char *, 
 	    integer *, integer *, real *, real *, integer *, real *, integer *
-), xerbla_(char *, integer *);
+);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwork, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/sgetrs.c b/CLAPACK-3.2.1/SRC/sgetrs.c
index 2ab2c4d..fdd95e4 100644
--- a/CLAPACK-3.2.1/SRC/sgetrs.c
+++ b/CLAPACK-3.2.1/SRC/sgetrs.c
@@ -29,7 +29,8 @@ static integer c_n1 = -1;
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int strsm_(char *, char *, char *, char *, 
 	    integer *, integer *, real *, real *, integer *, real *, integer *
-), xerbla_(char *, integer *);
+);
+    void xerbla_(char *, integer *);
     logical notran;
     extern /* Subroutine */ int slaswp_(integer *, real *, integer *, integer 
 	    *, integer *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sggbak.c b/CLAPACK-3.2.1/SRC/sggbak.c
index 30460ae..4279faa 100644
--- a/CLAPACK-3.2.1/SRC/sggbak.c
+++ b/CLAPACK-3.2.1/SRC/sggbak.c
@@ -26,7 +26,8 @@
     extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *);
     logical leftv;
     extern /* Subroutine */ int sswap_(integer *, real *, integer *, real *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     logical rightv;
 
 
diff --git a/CLAPACK-3.2.1/SRC/sggbal.c b/CLAPACK-3.2.1/SRC/sggbal.c
index c2df1fe..e7507f4 100644
--- a/CLAPACK-3.2.1/SRC/sggbal.c
+++ b/CLAPACK-3.2.1/SRC/sggbal.c
@@ -56,7 +56,7 @@ static real c_b71 = .5f;
 	    real *, integer *);
     real pgamma;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
     integer lsfmin, lsfmax;
 
diff --git a/CLAPACK-3.2.1/SRC/sgges.c b/CLAPACK-3.2.1/SRC/sgges.c
index 925f150..2b95e25 100644
--- a/CLAPACK-3.2.1/SRC/sgges.c
+++ b/CLAPACK-3.2.1/SRC/sgges.c
@@ -60,7 +60,7 @@ static real c_b39 = 1.f;
 	    integer *, real *, integer *, real *, integer *, real *, integer *
 , real *, integer *, integer *);
     real safmax;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *, 
 	    real *, integer *, integer *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sggesx.c b/CLAPACK-3.2.1/SRC/sggesx.c
index 9128e03..38132ba 100644
--- a/CLAPACK-3.2.1/SRC/sggesx.c
+++ b/CLAPACK-3.2.1/SRC/sggesx.c
@@ -62,7 +62,7 @@ static real c_b43 = 1.f;
 	    integer *, real *, integer *, real *, integer *, real *, integer *
 , real *, integer *, integer *);
     real safmax;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *, 
 	    real *, integer *, integer *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sggev.c b/CLAPACK-3.2.1/SRC/sggev.c
index 7c3537e..91736ae 100644
--- a/CLAPACK-3.2.1/SRC/sggev.c
+++ b/CLAPACK-3.2.1/SRC/sggev.c
@@ -53,7 +53,8 @@ static real c_b37 = 1.f;
     logical ilascl, ilbscl;
     extern doublereal slamch_(char *), slange_(char *, integer *, 
 	    integer *, real *, integer *, real *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), sgghrd_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  sgghrd_(
 	    char *, char *, integer *, integer *, integer *, real *, integer *
 , real *, integer *, real *, integer *, real *, integer *, 
 	    integer *);
diff --git a/CLAPACK-3.2.1/SRC/sggevx.c b/CLAPACK-3.2.1/SRC/sggevx.c
index 7130d3a..ae10b25 100644
--- a/CLAPACK-3.2.1/SRC/sggevx.c
+++ b/CLAPACK-3.2.1/SRC/sggevx.c
@@ -55,7 +55,8 @@ static real c_b58 = 1.f;
 	    integer *, real *, real *, real *, integer *);
     logical ilascl, ilbscl;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), sgghrd_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  sgghrd_(
 	    char *, char *, integer *, integer *, integer *, real *, integer *
 , real *, integer *, real *, integer *, real *, integer *, 
 	    integer *);
diff --git a/CLAPACK-3.2.1/SRC/sggglm.c b/CLAPACK-3.2.1/SRC/sggglm.c
index 254ea8c..68f16a6 100644
--- a/CLAPACK-3.2.1/SRC/sggglm.c
+++ b/CLAPACK-3.2.1/SRC/sggglm.c
@@ -30,8 +30,8 @@ static real c_b34 = 1.f;
     /* Local variables */
     integer i__, nb, np, nb1, nb2, nb3, nb4, lopt;
     extern /* Subroutine */ int sgemv_(char *, integer *, integer *, real *, 
-	    real *, integer *, real *, integer *, real *, real *, integer *), scopy_(integer *, real *, integer *, real *, integer *), 
-	    xerbla_(char *, integer *);
+	    real *, integer *, real *, integer *, real *, real *, integer *), scopy_(integer *, real *, integer *, real *, integer *);
+	void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int sggqrf_(integer *, integer *, integer *, real 
diff --git a/CLAPACK-3.2.1/SRC/sgghrd.c b/CLAPACK-3.2.1/SRC/sgghrd.c
index c78893c..6c24985 100644
--- a/CLAPACK-3.2.1/SRC/sgghrd.c
+++ b/CLAPACK-3.2.1/SRC/sgghrd.c
@@ -36,7 +36,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int srot_(integer *, real *, integer *, real *, 
 	    integer *, real *, real *);
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer icompq;
     extern /* Subroutine */ int slaset_(char *, integer *, integer *, real *, 
 	    real *, real *, integer *), slartg_(real *, real *, real *
diff --git a/CLAPACK-3.2.1/SRC/sgglse.c b/CLAPACK-3.2.1/SRC/sgglse.c
index fb87eb9..a3d4a36 100644
--- a/CLAPACK-3.2.1/SRC/sgglse.c
+++ b/CLAPACK-3.2.1/SRC/sgglse.c
@@ -33,7 +33,8 @@ static real c_b33 = 1.f;
 	    real *, integer *, real *, integer *, real *, real *, integer *), scopy_(integer *, real *, integer *, real *, integer *), 
 	    saxpy_(integer *, real *, real *, integer *, real *, integer *), 
 	    strmv_(char *, char *, char *, integer *, real *, integer *, real 
-	    *, integer *), xerbla_(char *, integer *);
+	    *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int sggrqf_(integer *, integer *, integer *, real 
diff --git a/CLAPACK-3.2.1/SRC/sggqrf.c b/CLAPACK-3.2.1/SRC/sggqrf.c
index c8ba376..2e3cbc4 100644
--- a/CLAPACK-3.2.1/SRC/sggqrf.c
+++ b/CLAPACK-3.2.1/SRC/sggqrf.c
@@ -27,7 +27,7 @@ static integer c_n1 = -1;
 
     /* Local variables */
     integer nb, nb1, nb2, nb3, lopt;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int sgeqrf_(integer *, integer *, real *, integer 
diff --git a/CLAPACK-3.2.1/SRC/sggrqf.c b/CLAPACK-3.2.1/SRC/sggrqf.c
index 2979920..205d89f 100644
--- a/CLAPACK-3.2.1/SRC/sggrqf.c
+++ b/CLAPACK-3.2.1/SRC/sggrqf.c
@@ -27,7 +27,7 @@ static integer c_n1 = -1;
 
     /* Local variables */
     integer nb, nb1, nb2, nb3, lopt;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int sgeqrf_(integer *, integer *, real *, integer 
diff --git a/CLAPACK-3.2.1/SRC/sggsvd.c b/CLAPACK-3.2.1/SRC/sggsvd.c
index 48ad249..8955fd7 100644
--- a/CLAPACK-3.2.1/SRC/sggsvd.c
+++ b/CLAPACK-3.2.1/SRC/sggsvd.c
@@ -43,7 +43,8 @@ static integer c__1 = 1;
     extern doublereal slamch_(char *), slange_(char *, integer *, 
 	    integer *, real *, integer *, real *);
     integer ncycle;
-    extern /* Subroutine */ int xerbla_(char *, integer *), stgsja_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  stgsja_(
 	    char *, char *, char *, integer *, integer *, integer *, integer *
 , integer *, real *, integer *, real *, integer *, real *, real *, 
 	     real *, real *, real *, integer *, real *, integer *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/sggsvp.c b/CLAPACK-3.2.1/SRC/sggsvp.c
index 97fa0de..b424a1b 100644
--- a/CLAPACK-3.2.1/SRC/sggsvp.c
+++ b/CLAPACK-3.2.1/SRC/sggsvp.c
@@ -39,7 +39,9 @@ static real c_b22 = 1.f;
 	    integer *, integer *, real *, integer *, real *, real *, integer *
 ), sorm2r_(char *, char *, integer *, integer *, integer *, real *
 , integer *, real *, real *, integer *, real *, integer *), sormr2_(char *, char *, integer *, integer *, integer *, 
-	     real *, integer *, real *, real *, integer *, real *, integer *), xerbla_(char *, integer *), sgeqpf_(
+	     real *, integer *, real *, real *, integer *, real *, integer *);
+    void xerbla_(char *, integer *);
+    int sgeqpf_(
 	    integer *, integer *, real *, integer *, integer *, real *, real *
 , integer *), slacpy_(char *, integer *, integer *, real *, 
 	    integer *, real *, integer *), slaset_(char *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/sgsvj0.c b/CLAPACK-3.2.1/SRC/sgsvj0.c
index b254b5b..1b858c1 100644
--- a/CLAPACK-3.2.1/SRC/sgsvj0.c
+++ b/CLAPACK-3.2.1/SRC/sgsvj0.c
@@ -54,7 +54,8 @@ static real c_b42 = 1.f;
     extern /* Subroutine */ int sswap_(integer *, real *, integer *, real *, 
 	    integer *), saxpy_(integer *, real *, real *, integer *, real *, 
 	    integer *), srotm_(integer *, real *, integer *, real *, integer *
-, real *), xerbla_(char *, integer *);
+, real *);
+    void xerbla_(char *, integer *);
     integer ijblsk, swband;
     extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *, 
 	    real *, integer *, integer *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sgsvj1.c b/CLAPACK-3.2.1/SRC/sgsvj1.c
index 584b7f5..f28314a 100644
--- a/CLAPACK-3.2.1/SRC/sgsvj1.c
+++ b/CLAPACK-3.2.1/SRC/sgsvj1.c
@@ -54,7 +54,8 @@ static real c_b35 = 1.f;
     extern /* Subroutine */ int sswap_(integer *, real *, integer *, real *, 
 	    integer *), saxpy_(integer *, real *, real *, integer *, real *, 
 	    integer *), srotm_(integer *, real *, integer *, real *, integer *
-, real *), xerbla_(char *, integer *);
+, real *);
+    void xerbla_(char *, integer *);
     integer ijblsk, swband;
     extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *, 
 	    real *, integer *, integer *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sgtcon.c b/CLAPACK-3.2.1/SRC/sgtcon.c
index 2410e50..3d12f14 100644
--- a/CLAPACK-3.2.1/SRC/sgtcon.c
+++ b/CLAPACK-3.2.1/SRC/sgtcon.c
@@ -29,7 +29,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     integer isave[3];
     extern /* Subroutine */ int slacn2_(integer *, real *, real *, integer *, 
-	    real *, integer *, integer *), xerbla_(char *, integer *);
+	    real *, integer *, integer *);
+    void xerbla_(char *, integer *);
     real ainvnm;
     logical onenrm;
     extern /* Subroutine */ int sgttrs_(char *, integer *, integer *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/sgtrfs.c b/CLAPACK-3.2.1/SRC/sgtrfs.c
index 0168d1d..c635753 100644
--- a/CLAPACK-3.2.1/SRC/sgtrfs.c
+++ b/CLAPACK-3.2.1/SRC/sgtrfs.c
@@ -43,7 +43,8 @@ static real c_b19 = 1.f;
 	    integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), slagtm_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slagtm_(
 	    char *, integer *, integer *, real *, real *, real *, real *, 
 	    real *, integer *, real *, real *, integer *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/sgtsv.c b/CLAPACK-3.2.1/SRC/sgtsv.c
index 1fff65d..2e92429 100644
--- a/CLAPACK-3.2.1/SRC/sgtsv.c
+++ b/CLAPACK-3.2.1/SRC/sgtsv.c
@@ -23,7 +23,7 @@
     /* Local variables */
     integer i__, j;
     real fact, temp;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/sgtsvx.c b/CLAPACK-3.2.1/SRC/sgtsvx.c
index e3ca06a..a89fb92 100644
--- a/CLAPACK-3.2.1/SRC/sgtsvx.c
+++ b/CLAPACK-3.2.1/SRC/sgtsvx.c
@@ -34,7 +34,7 @@ static integer c__1 = 1;
 	    integer *);
     extern doublereal slamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal slangt_(char *, integer *, real *, real *, real *);
     extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *, 
 	    integer *, real *, integer *), sgtcon_(char *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/sgttrf.c b/CLAPACK-3.2.1/SRC/sgttrf.c
index 16f18a9..aaa00f9 100644
--- a/CLAPACK-3.2.1/SRC/sgttrf.c
+++ b/CLAPACK-3.2.1/SRC/sgttrf.c
@@ -23,7 +23,7 @@
     /* Local variables */
     integer i__;
     real fact, temp;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/sgttrs.c b/CLAPACK-3.2.1/SRC/sgttrs.c
index 0b41a13..ae02516 100644
--- a/CLAPACK-3.2.1/SRC/sgttrs.c
+++ b/CLAPACK-3.2.1/SRC/sgttrs.c
@@ -28,7 +28,8 @@ static integer c_n1 = -1;
     /* Local variables */
     integer j, jb, nb;
     extern /* Subroutine */ int sgtts2_(integer *, integer *, integer *, real 
-	    *, real *, real *, real *, integer *, real *, integer *), xerbla_(
+	    *, real *, real *, real *, integer *, real *, integer *);
+    void xerbla_(
 	    char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/shgeqz.c b/CLAPACK-3.2.1/SRC/shgeqz.c
index 32951fb..75928f0 100644
--- a/CLAPACK-3.2.1/SRC/shgeqz.c
+++ b/CLAPACK-3.2.1/SRC/shgeqz.c
@@ -71,7 +71,7 @@ static integer c__3 = 3;
     extern /* Subroutine */ int slarfg_(integer *, real *, real *, integer *, 
 	    real *);
     real safmax;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real eshift;
     logical ilschr;
     integer icompq, ilastm;
diff --git a/CLAPACK-3.2.1/SRC/shsein.c b/CLAPACK-3.2.1/SRC/shsein.c
index 51e1d36..8abb316 100644
--- a/CLAPACK-3.2.1/SRC/shsein.c
+++ b/CLAPACK-3.2.1/SRC/shsein.c
@@ -42,7 +42,8 @@ static logical c_true = TRUE_;
     extern doublereal slamch_(char *);
     extern /* Subroutine */ int slaein_(logical *, logical *, integer *, real 
 	    *, integer *, real *, real *, real *, real *, real *, integer *, 
-	    real *, real *, real *, real *, integer *), xerbla_(char *, 
+	    real *, real *, real *, real *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     real bignum;
     extern doublereal slanhs_(char *, integer *, real *, integer *, real *);
diff --git a/CLAPACK-3.2.1/SRC/shseqr.c b/CLAPACK-3.2.1/SRC/shseqr.c
index 533949d..37bc40b 100644
--- a/CLAPACK-3.2.1/SRC/shseqr.c
+++ b/CLAPACK-3.2.1/SRC/shseqr.c
@@ -32,7 +32,7 @@ static integer c__49 = 49;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -44,8 +44,8 @@ static integer c__49 = 49;
     logical wantt, wantz;
     extern /* Subroutine */ int slaqr0_(logical *, logical *, integer *, 
 	    integer *, integer *, real *, integer *, real *, real *, integer *
-, integer *, real *, integer *, real *, integer *, integer *), 
-	    xerbla_(char *, integer *);
+, integer *, real *, integer *, real *, integer *, integer *);
+	void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int slahqr_(logical *, logical *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/sla_gbamv.c b/CLAPACK-3.2.1/SRC/sla_gbamv.c
index 39e6adc..9207f78 100644
--- a/CLAPACK-3.2.1/SRC/sla_gbamv.c
+++ b/CLAPACK-3.2.1/SRC/sla_gbamv.c
@@ -33,7 +33,7 @@
     integer lenx, leny;
     real safe1;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*     -- LAPACK routine (version 3.2)                                 -- */
diff --git a/CLAPACK-3.2.1/SRC/sla_gbrcond.c b/CLAPACK-3.2.1/SRC/sla_gbrcond.c
index e5e50b6..e462932 100644
--- a/CLAPACK-3.2.1/SRC/sla_gbrcond.c
+++ b/CLAPACK-3.2.1/SRC/sla_gbrcond.c
@@ -33,7 +33,8 @@ doublereal sla_gbrcond__(char *trans, integer *n, integer *kl, integer *ku,
     extern logical lsame_(char *, char *);
     integer isave[3];
     extern /* Subroutine */ int slacn2_(integer *, real *, real *, integer *, 
-	    real *, integer *, integer *), xerbla_(char *, integer *);
+	    real *, integer *, integer *);
+    void xerbla_(char *, integer *);
     real ainvnm;
     extern /* Subroutine */ int sgbtrs_(char *, integer *, integer *, integer 
 	    *, integer *, real *, integer *, integer *, real *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/sla_geamv.c b/CLAPACK-3.2.1/SRC/sla_geamv.c
index cfb2951..8abc2c5 100644
--- a/CLAPACK-3.2.1/SRC/sla_geamv.c
+++ b/CLAPACK-3.2.1/SRC/sla_geamv.c
@@ -33,7 +33,7 @@
     integer lenx, leny;
     real safe1;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*     -- LAPACK routine (version 3.2)                                 -- */
diff --git a/CLAPACK-3.2.1/SRC/sla_gercond.c b/CLAPACK-3.2.1/SRC/sla_gercond.c
index 031ee7a..37a7972 100644
--- a/CLAPACK-3.2.1/SRC/sla_gercond.c
+++ b/CLAPACK-3.2.1/SRC/sla_gercond.c
@@ -32,7 +32,8 @@ doublereal sla_gercond__(char *trans, integer *n, real *a, integer *lda, real
     extern logical lsame_(char *, char *);
     integer isave[3];
     extern /* Subroutine */ int slacn2_(integer *, real *, real *, integer *, 
-	    real *, integer *, integer *), xerbla_(char *, integer *);
+	    real *, integer *, integer *);
+    void xerbla_(char *, integer *);
     real ainvnm;
     extern /* Subroutine */ int sgetrs_(char *, integer *, integer *, real *, 
 	    integer *, integer *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sla_porcond.c b/CLAPACK-3.2.1/SRC/sla_porcond.c
index 6c844ff..eb18a06 100644
--- a/CLAPACK-3.2.1/SRC/sla_porcond.c
+++ b/CLAPACK-3.2.1/SRC/sla_porcond.c
@@ -33,7 +33,8 @@ doublereal sla_porcond__(char *uplo, integer *n, real *a, integer *lda, real *
     extern logical lsame_(char *, char *);
     integer isave[3];
     extern /* Subroutine */ int slacn2_(integer *, real *, real *, integer *, 
-	    real *, integer *, integer *), xerbla_(char *, integer *);
+	    real *, integer *, integer *);
+    void xerbla_(char *, integer *);
     real ainvnm;
     extern /* Subroutine */ int spotrs_(char *, integer *, integer *, real *, 
 	    integer *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sla_syamv.c b/CLAPACK-3.2.1/SRC/sla_syamv.c
index 6822b8a..b6a451f 100644
--- a/CLAPACK-3.2.1/SRC/sla_syamv.c
+++ b/CLAPACK-3.2.1/SRC/sla_syamv.c
@@ -30,7 +30,7 @@
     integer iy, jx, kx, ky, info;
     real temp, safe1;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilauplo_(char *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/sla_syrcond.c b/CLAPACK-3.2.1/SRC/sla_syrcond.c
index d2f2f79..721432f 100644
--- a/CLAPACK-3.2.1/SRC/sla_syrcond.c
+++ b/CLAPACK-3.2.1/SRC/sla_syrcond.c
@@ -35,7 +35,7 @@ doublereal sla_syrcond__(char *uplo, integer *n, real *a, integer *lda, real *
     extern /* Subroutine */ int slacn2_(integer *, real *, real *, integer *, 
 	    real *, integer *, integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real ainvnm;
     char normin[1];
     real smlnum;
diff --git a/CLAPACK-3.2.1/SRC/slaed0.c b/CLAPACK-3.2.1/SRC/slaed0.c
index 589956a..3a8bdc0 100644
--- a/CLAPACK-3.2.1/SRC/slaed0.c
+++ b/CLAPACK-3.2.1/SRC/slaed0.c
@@ -52,7 +52,7 @@ static integer c__1 = 1;
 , real *, integer *, integer *, integer *, integer *, integer *, 
 	    real *, real *, integer *, integer *);
     integer igivcl;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer igivnm, submat;
diff --git a/CLAPACK-3.2.1/SRC/slaed1.c b/CLAPACK-3.2.1/SRC/slaed1.c
index 3c95598..7717d67 100644
--- a/CLAPACK-3.2.1/SRC/slaed1.c
+++ b/CLAPACK-3.2.1/SRC/slaed1.c
@@ -35,7 +35,8 @@ static integer c_n1 = -1;
 , real *, real *, integer *, integer *, real *, real *, integer *)
 	    ;
     integer idlmda;
-    extern /* Subroutine */ int xerbla_(char *, integer *), slamrg_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slamrg_(
 	    integer *, integer *, real *, integer *, integer *, integer *);
     integer coltyp;
 
diff --git a/CLAPACK-3.2.1/SRC/slaed2.c b/CLAPACK-3.2.1/SRC/slaed2.c
index ad04cf5..2b45ffa 100644
--- a/CLAPACK-3.2.1/SRC/slaed2.c
+++ b/CLAPACK-3.2.1/SRC/slaed2.c
@@ -42,7 +42,7 @@ static integer c__1 = 1;
 	    integer *), scopy_(integer *, real *, integer *, real *, integer *
 );
     extern doublereal slapy2_(real *, real *), slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
     extern /* Subroutine */ int slamrg_(integer *, integer *, real *, integer 
 	    *, integer *, integer *), slacpy_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/slaed3.c b/CLAPACK-3.2.1/SRC/slaed3.c
index f95a5cc..4649cb3 100644
--- a/CLAPACK-3.2.1/SRC/slaed3.c
+++ b/CLAPACK-3.2.1/SRC/slaed3.c
@@ -40,7 +40,8 @@ static real c_b23 = 0.f;
 	    integer *, real *, integer *), slaed4_(integer *, integer *, real 
 	    *, real *, real *, real *, real *, integer *);
     extern doublereal slamc3_(real *, real *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), slacpy_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slacpy_(
 	    char *, integer *, integer *, real *, integer *, real *, integer *
 ), slaset_(char *, integer *, integer *, real *, real *, 
 	    real *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/slaed7.c b/CLAPACK-3.2.1/SRC/slaed7.c
index d263193..c94c1e5 100644
--- a/CLAPACK-3.2.1/SRC/slaed7.c
+++ b/CLAPACK-3.2.1/SRC/slaed7.c
@@ -50,7 +50,8 @@ static integer c_n1 = -1;
 	    integer *, integer *, integer *, real *, real *, integer *, real *
 , real *, integer *);
     integer idlmda;
-    extern /* Subroutine */ int xerbla_(char *, integer *), slamrg_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slamrg_(
 	    integer *, integer *, real *, integer *, integer *, integer *);
     integer coltyp;
 
diff --git a/CLAPACK-3.2.1/SRC/slaed8.c b/CLAPACK-3.2.1/SRC/slaed8.c
index 25776f8..8abee1f 100644
--- a/CLAPACK-3.2.1/SRC/slaed8.c
+++ b/CLAPACK-3.2.1/SRC/slaed8.c
@@ -43,7 +43,7 @@ static integer c__1 = 1;
 	    integer *), scopy_(integer *, real *, integer *, real *, integer *
 );
     extern doublereal slapy2_(real *, real *), slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
     extern /* Subroutine */ int slamrg_(integer *, integer *, real *, integer 
 	    *, integer *, integer *), slacpy_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/slaed9.c b/CLAPACK-3.2.1/SRC/slaed9.c
index df4c0bd..a31d549 100644
--- a/CLAPACK-3.2.1/SRC/slaed9.c
+++ b/CLAPACK-3.2.1/SRC/slaed9.c
@@ -36,7 +36,7 @@ static integer c__1 = 1;
 	    integer *), slaed4_(integer *, integer *, real *, real *, real *, 
 	    real *, real *, integer *);
     extern doublereal slamc3_(real *, real *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/slaeda.c b/CLAPACK-3.2.1/SRC/slaeda.c
index f9ffbd3..11ef381 100644
--- a/CLAPACK-3.2.1/SRC/slaeda.c
+++ b/CLAPACK-3.2.1/SRC/slaeda.c
@@ -38,8 +38,8 @@ static real c_b26 = 0.f;
 	    integer *, real *, real *);
     integer bsiz1, bsiz2, psiz1, psiz2, zptr1;
     extern /* Subroutine */ int sgemv_(char *, integer *, integer *, real *, 
-	    real *, integer *, real *, integer *, real *, real *, integer *), scopy_(integer *, real *, integer *, real *, integer *), 
-	    xerbla_(char *, integer *);
+	    real *, integer *, real *, integer *, real *, real *, integer *), scopy_(integer *, real *, integer *, real *, integer *);
+	void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/slagtf.c b/CLAPACK-3.2.1/SRC/slagtf.c
index 9046c23..edf25e1 100644
--- a/CLAPACK-3.2.1/SRC/slagtf.c
+++ b/CLAPACK-3.2.1/SRC/slagtf.c
@@ -24,7 +24,7 @@
     integer k;
     real tl, eps, piv1, piv2, temp, mult, scale1, scale2;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/slagts.c b/CLAPACK-3.2.1/SRC/slagts.c
index dc828f8..ef39ad2 100644
--- a/CLAPACK-3.2.1/SRC/slagts.c
+++ b/CLAPACK-3.2.1/SRC/slagts.c
@@ -27,7 +27,7 @@
     integer k;
     real ak, eps, temp, pert, absak, sfmin;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/slals0.c b/CLAPACK-3.2.1/SRC/slals0.c
index 5d29eaa..7e41f04 100644
--- a/CLAPACK-3.2.1/SRC/slals0.c
+++ b/CLAPACK-3.2.1/SRC/slals0.c
@@ -48,7 +48,7 @@ static integer c__0 = 0;
 	    real *, integer *, real *, real *, integer *), scopy_(
 	    integer *, real *, integer *, real *, integer *);
     extern doublereal slamc3_(real *, real *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real dsigjp;
     extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *, 
 	    real *, integer *, integer *, real *, integer *, integer *), slacpy_(char *, integer *, integer *, real *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/slalsa.c b/CLAPACK-3.2.1/SRC/slalsa.c
index d349576..c08eee6 100644
--- a/CLAPACK-3.2.1/SRC/slalsa.c
+++ b/CLAPACK-3.2.1/SRC/slalsa.c
@@ -47,8 +47,9 @@ static integer c__2 = 2;
 	    integer *), slals0_(integer *, integer *, integer *, integer *, 
 	    integer *, real *, integer *, real *, integer *, integer *, 
 	    integer *, integer *, integer *, real *, integer *, real *, real *
-, real *, real *, integer *, real *, real *, real *, integer *), 
-	    xerbla_(char *, integer *), slasdt_(integer *, integer *, 
+, real *, real *, integer *, real *, real *, real *, integer *);
+	void xerbla_(char *, integer *);
+    int slasdt_(integer *, integer *, 
 	    integer *, integer *, integer *, integer *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/slalsd.c b/CLAPACK-3.2.1/SRC/slalsd.c
index b90ddbf..ee575f2 100644
--- a/CLAPACK-3.2.1/SRC/slalsd.c
+++ b/CLAPACK-3.2.1/SRC/slalsd.c
@@ -57,8 +57,9 @@ static real c_b11 = 1.f;
     extern /* Subroutine */ int slasda_(integer *, integer *, integer *, 
 	    integer *, real *, real *, real *, integer *, real *, integer *, 
 	    real *, real *, real *, real *, integer *, integer *, integer *, 
-	    integer *, real *, real *, real *, real *, integer *, integer *), 
-	    xerbla_(char *, integer *), slalsa_(integer *, integer *, 
+	    integer *, real *, real *, real *, real *, integer *, integer *);
+	void xerbla_(char *, integer *);
+    int slalsa_(integer *, integer *, 
 	    integer *, integer *, real *, integer *, real *, integer *, real *
 , integer *, real *, integer *, real *, real *, real *, real *, 
 	    integer *, integer *, integer *, integer *, real *, real *, real *
diff --git a/CLAPACK-3.2.1/SRC/slarzb.c b/CLAPACK-3.2.1/SRC/slarzb.c
index b472224..79348e4 100644
--- a/CLAPACK-3.2.1/SRC/slarzb.c
+++ b/CLAPACK-3.2.1/SRC/slarzb.c
@@ -36,7 +36,8 @@ static real c_b23 = -1.f;
 	    real *, integer *), scopy_(integer *, real *, 
 	    integer *, real *, integer *), strmm_(char *, char *, char *, 
 	    char *, integer *, integer *, real *, real *, integer *, real *, 
-	    integer *), xerbla_(char *, 
+	    integer *);
+    void xerbla_(char *, 
 	    integer *);
     char transt[1];
 
diff --git a/CLAPACK-3.2.1/SRC/slarzt.c b/CLAPACK-3.2.1/SRC/slarzt.c
index ed5c92a..b65cb2b 100644
--- a/CLAPACK-3.2.1/SRC/slarzt.c
+++ b/CLAPACK-3.2.1/SRC/slarzt.c
@@ -30,7 +30,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int sgemv_(char *, integer *, integer *, real *, 
 	    real *, integer *, real *, integer *, real *, real *, integer *), strmv_(char *, char *, char *, integer *, real *, 
-	    integer *, real *, integer *), xerbla_(
+	    integer *, real *, integer *);
+    void xerbla_(
 	    char *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/slascl.c b/CLAPACK-3.2.1/SRC/slascl.c
index 6afa7ef..4750595 100644
--- a/CLAPACK-3.2.1/SRC/slascl.c
+++ b/CLAPACK-3.2.1/SRC/slascl.c
@@ -30,7 +30,7 @@
     real cfrom1;
     extern doublereal slamch_(char *);
     real cfromc;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     extern logical sisnan_(real *);
     real smlnum;
diff --git a/CLAPACK-3.2.1/SRC/slasd0.c b/CLAPACK-3.2.1/SRC/slasd0.c
index 41f3ee7..f19771a 100644
--- a/CLAPACK-3.2.1/SRC/slasd0.c
+++ b/CLAPACK-3.2.1/SRC/slasd0.c
@@ -37,7 +37,9 @@ static integer c__2 = 2;
     integer inode, ndiml, idxqc, ndimr, itemp, sqrei;
     extern /* Subroutine */ int slasd1_(integer *, integer *, integer *, real 
 	    *, real *, real *, real *, integer *, real *, integer *, integer *
-, integer *, real *, integer *), xerbla_(char *, integer *), slasdq_(char *, integer *, integer *, integer *, integer 
+, integer *, real *, integer *);
+    void xerbla_(char *, integer *);
+    int slasdq_(char *, integer *, integer *, integer *, integer 
 	    *, integer *, real *, real *, real *, integer *, real *, integer *
 , real *, integer *, real *, integer *), slasdt_(integer *
 , integer *, integer *, integer *, integer *, integer *, integer *
diff --git a/CLAPACK-3.2.1/SRC/slasd1.c b/CLAPACK-3.2.1/SRC/slasd1.c
index 5341356..22a882c 100644
--- a/CLAPACK-3.2.1/SRC/slasd1.c
+++ b/CLAPACK-3.2.1/SRC/slasd1.c
@@ -41,7 +41,8 @@ static integer c_n1 = -1;
 , integer *, real *, integer *, integer *, integer *, real *, 
 	    integer *);
     integer isigma;
-    extern /* Subroutine */ int xerbla_(char *, integer *), slascl_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slascl_(
 	    char *, integer *, integer *, real *, real *, integer *, integer *
 , real *, integer *, integer *), slamrg_(integer *, 
 	    integer *, real *, integer *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/slasd2.c b/CLAPACK-3.2.1/SRC/slasd2.c
index 15e3e47..9259f94 100644
--- a/CLAPACK-3.2.1/SRC/slasd2.c
+++ b/CLAPACK-3.2.1/SRC/slasd2.c
@@ -44,7 +44,8 @@ static real c_b30 = 0.f;
     extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *, 
 	    integer *);
     extern doublereal slapy2_(real *, real *), slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), slamrg_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slamrg_(
 	    integer *, integer *, real *, integer *, integer *, integer *);
     real hlftol;
     extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/slasd3.c b/CLAPACK-3.2.1/SRC/slasd3.c
index d4b3ab0..8e37d44 100644
--- a/CLAPACK-3.2.1/SRC/slasd3.c
+++ b/CLAPACK-3.2.1/SRC/slasd3.c
@@ -49,8 +49,10 @@ static real c_b26 = 0.f;
 	    integer *);
     extern doublereal slamc3_(real *, real *);
     extern /* Subroutine */ int slasd4_(integer *, integer *, real *, real *, 
-	    real *, real *, real *, real *, integer *), xerbla_(char *, 
-	    integer *), slascl_(char *, integer *, integer *, real *, 
+	    real *, real *, real *, real *, integer *);
+    void xerbla_(char *, 
+	    integer *);
+    int slascl_(char *, integer *, integer *, real *, 
 	    real *, integer *, integer *, real *, integer *, integer *), slacpy_(char *, integer *, integer *, real *, integer *, 
 	    real *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/slasd6.c b/CLAPACK-3.2.1/SRC/slasd6.c
index 3be8d74..fd09acf 100644
--- a/CLAPACK-3.2.1/SRC/slasd6.c
+++ b/CLAPACK-3.2.1/SRC/slasd6.c
@@ -43,7 +43,8 @@ static integer c_n1 = -1;
 	    real *, real *, real *, real *, integer *, real *, real *, 
 	    integer *);
     integer isigma;
-    extern /* Subroutine */ int xerbla_(char *, integer *), slascl_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slascl_(
 	    char *, integer *, integer *, real *, real *, integer *, integer *
 , real *, integer *, integer *), slamrg_(integer *, 
 	    integer *, real *, integer *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/slasd7.c b/CLAPACK-3.2.1/SRC/slasd7.c
index 01a0542..7d67c36 100644
--- a/CLAPACK-3.2.1/SRC/slasd7.c
+++ b/CLAPACK-3.2.1/SRC/slasd7.c
@@ -40,7 +40,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *, 
 	    integer *);
     extern doublereal slapy2_(real *, real *), slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), slamrg_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slamrg_(
 	    integer *, integer *, real *, integer *, integer *, integer *);
     real hlftol;
 
diff --git a/CLAPACK-3.2.1/SRC/slasd8.c b/CLAPACK-3.2.1/SRC/slasd8.c
index b0079d5..ebd8919 100644
--- a/CLAPACK-3.2.1/SRC/slasd8.c
+++ b/CLAPACK-3.2.1/SRC/slasd8.c
@@ -43,7 +43,8 @@ static real c_b8 = 1.f;
 	    integer *);
     extern doublereal slamc3_(real *, real *);
     extern /* Subroutine */ int slasd4_(integer *, integer *, real *, real *, 
-	    real *, real *, real *, real *, integer *), xerbla_(char *, 
+	    real *, real *, real *, real *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     real dsigjp;
     extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/slasda.c b/CLAPACK-3.2.1/SRC/slasda.c
index 694a4e2..1282e5b 100644
--- a/CLAPACK-3.2.1/SRC/slasda.c
+++ b/CLAPACK-3.2.1/SRC/slasda.c
@@ -50,7 +50,8 @@ static integer c__2 = 2;
 , real *, real *, integer *, real *, real *, real *, integer *, 
 	    integer *);
     integer nwork1, nwork2;
-    extern /* Subroutine */ int xerbla_(char *, integer *), slasdq_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slasdq_(
 	    char *, integer *, integer *, integer *, integer *, integer *, 
 	    real *, real *, real *, integer *, real *, integer *, real *, 
 	    integer *, real *, integer *), slasdt_(integer *, integer 
diff --git a/CLAPACK-3.2.1/SRC/slasdq.c b/CLAPACK-3.2.1/SRC/slasdq.c
index fae6a16..30cc58f 100644
--- a/CLAPACK-3.2.1/SRC/slasdq.c
+++ b/CLAPACK-3.2.1/SRC/slasdq.c
@@ -37,7 +37,9 @@ static integer c__1 = 1;
 	    integer *, real *, real *, real *, integer *);
     integer iuplo;
     extern /* Subroutine */ int sswap_(integer *, real *, integer *, real *, 
-	    integer *), xerbla_(char *, integer *), slartg_(real *, 
+	    integer *);
+    void xerbla_(char *, integer *);
+    int slartg_(real *, 
 	    real *, real *, real *, real *);
     logical rotate;
     extern /* Subroutine */ int sbdsqr_(char *, integer *, integer *, integer 
diff --git a/CLAPACK-3.2.1/SRC/slasq1.c b/CLAPACK-3.2.1/SRC/slasq1.c
index b812d23..b7e07d8 100644
--- a/CLAPACK-3.2.1/SRC/slasq1.c
+++ b/CLAPACK-3.2.1/SRC/slasq1.c
@@ -41,7 +41,8 @@ static integer c__0 = 0;
 	    integer *), slasq2_(integer *, real *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), slascl_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slascl_(
 	    char *, integer *, integer *, real *, real *, integer *, integer *
 , real *, integer *, integer *), slasrt_(char *, integer *
 , real *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/slasq2.c b/CLAPACK-3.2.1/SRC/slasq2.c
index 00d11cc..09d9a4d 100644
--- a/CLAPACK-3.2.1/SRC/slasq2.c
+++ b/CLAPACK-3.2.1/SRC/slasq2.c
@@ -55,7 +55,8 @@ static integer c__2 = 2;
     extern doublereal slamch_(char *);
     integer iwhila, iwhilb;
     real oldemn, safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), slasrt_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slasrt_(
 	    char *, integer *, real *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/slasr.c b/CLAPACK-3.2.1/SRC/slasr.c
index 2b22242..78d2aef 100644
--- a/CLAPACK-3.2.1/SRC/slasr.c
+++ b/CLAPACK-3.2.1/SRC/slasr.c
@@ -24,7 +24,7 @@
     real temp;
     extern logical lsame_(char *, char *);
     real ctemp, stemp;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK auxiliary routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/slasrt.c b/CLAPACK-3.2.1/SRC/slasrt.c
index d844db5..cc1873b 100644
--- a/CLAPACK-3.2.1/SRC/slasrt.c
+++ b/CLAPACK-3.2.1/SRC/slasrt.c
@@ -28,7 +28,7 @@
     integer stack[64]	/* was [2][32] */;
     real dmnmx;
     integer start;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer stkpnt;
 
 
diff --git a/CLAPACK-3.2.1/SRC/slatbs.c b/CLAPACK-3.2.1/SRC/slatbs.c
index 9a3e867..6e0daf8 100644
--- a/CLAPACK-3.2.1/SRC/slatbs.c
+++ b/CLAPACK-3.2.1/SRC/slatbs.c
@@ -46,7 +46,7 @@ static real c_b36 = .5f;
 	    integer *, real *, integer *, real *, integer *), saxpy_(integer *, real *, real *, integer *, real *, 
 	    integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     extern integer isamax_(integer *, real *, integer *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/slatps.c b/CLAPACK-3.2.1/SRC/slatps.c
index 6ce1742..5037db5 100644
--- a/CLAPACK-3.2.1/SRC/slatps.c
+++ b/CLAPACK-3.2.1/SRC/slatps.c
@@ -45,7 +45,7 @@ static real c_b36 = .5f;
 	    real *, integer *), stpsv_(char *, char *, char *, integer *, 
 	    real *, real *, integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     extern integer isamax_(integer *, real *, integer *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/slatrs.c b/CLAPACK-3.2.1/SRC/slatrs.c
index f996294..7b8608f 100644
--- a/CLAPACK-3.2.1/SRC/slatrs.c
+++ b/CLAPACK-3.2.1/SRC/slatrs.c
@@ -45,7 +45,7 @@ static real c_b36 = .5f;
 	    real *, integer *), strsv_(char *, char *, char *, integer *, 
 	    real *, integer *, real *, integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     extern integer isamax_(integer *, real *, integer *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/slauu2.c b/CLAPACK-3.2.1/SRC/slauu2.c
index ad80d23..88380ec 100644
--- a/CLAPACK-3.2.1/SRC/slauu2.c
+++ b/CLAPACK-3.2.1/SRC/slauu2.c
@@ -33,7 +33,7 @@ static integer c__1 = 1;
 	    sgemv_(char *, integer *, integer *, real *, real *, integer *, 
 	    real *, integer *, real *, real *, integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK auxiliary routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/slauum.c b/CLAPACK-3.2.1/SRC/slauum.c
index d65e5bc..42937cd 100644
--- a/CLAPACK-3.2.1/SRC/slauum.c
+++ b/CLAPACK-3.2.1/SRC/slauum.c
@@ -37,7 +37,8 @@ static real c_b15 = 1.f;
 ), ssyrk_(char *, char *, integer 
 	    *, integer *, real *, real *, integer *, real *, real *, integer *
 ), slauu2_(char *, integer *, real *, integer *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/sopgtr.c b/CLAPACK-3.2.1/SRC/sopgtr.c
index 7296c2e..e2e8332 100644
--- a/CLAPACK-3.2.1/SRC/sopgtr.c
+++ b/CLAPACK-3.2.1/SRC/sopgtr.c
@@ -27,7 +27,8 @@
     extern /* Subroutine */ int sorg2l_(integer *, integer *, integer *, real 
 	    *, integer *, real *, real *, integer *), sorg2r_(integer *, 
 	    integer *, integer *, real *, integer *, real *, real *, integer *
-), xerbla_(char *, integer *);
+);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/sopmtr.c b/CLAPACK-3.2.1/SRC/sopmtr.c
index f85bfd7..6e59000 100644
--- a/CLAPACK-3.2.1/SRC/sopmtr.c
+++ b/CLAPACK-3.2.1/SRC/sopmtr.c
@@ -32,7 +32,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int slarf_(char *, integer *, integer *, real *, 
 	    integer *, real *, real *, integer *, real *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran, forwrd;
 
 
diff --git a/CLAPACK-3.2.1/SRC/sorg2l.c b/CLAPACK-3.2.1/SRC/sorg2l.c
index a668c6a..7544fc3 100644
--- a/CLAPACK-3.2.1/SRC/sorg2l.c
+++ b/CLAPACK-3.2.1/SRC/sorg2l.c
@@ -28,7 +28,8 @@ static integer c__1 = 1;
     integer i__, j, l, ii;
     extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *), 
 	    slarf_(char *, integer *, integer *, real *, integer *, real *, 
-	    real *, integer *, real *), xerbla_(char *, integer *);
+	    real *, integer *, real *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/sorg2r.c b/CLAPACK-3.2.1/SRC/sorg2r.c
index 4fbbded..da62399 100644
--- a/CLAPACK-3.2.1/SRC/sorg2r.c
+++ b/CLAPACK-3.2.1/SRC/sorg2r.c
@@ -28,7 +28,8 @@ static integer c__1 = 1;
     integer i__, j, l;
     extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *), 
 	    slarf_(char *, integer *, integer *, real *, integer *, real *, 
-	    real *, integer *, real *), xerbla_(char *, integer *);
+	    real *, integer *, real *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/sorgbr.c b/CLAPACK-3.2.1/SRC/sorgbr.c
index 8274482..9a3d461 100644
--- a/CLAPACK-3.2.1/SRC/sorgbr.c
+++ b/CLAPACK-3.2.1/SRC/sorgbr.c
@@ -30,7 +30,7 @@ static integer c_n1 = -1;
     extern logical lsame_(char *, char *);
     integer iinfo;
     logical wantq;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int sorglq_(integer *, integer *, integer *, real 
diff --git a/CLAPACK-3.2.1/SRC/sorghr.c b/CLAPACK-3.2.1/SRC/sorghr.c
index 3e5186c..cd9581f 100644
--- a/CLAPACK-3.2.1/SRC/sorghr.c
+++ b/CLAPACK-3.2.1/SRC/sorghr.c
@@ -26,7 +26,7 @@ static integer c_n1 = -1;
 
     /* Local variables */
     integer i__, j, nb, nh, iinfo;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int sorgqr_(integer *, integer *, integer *, real 
diff --git a/CLAPACK-3.2.1/SRC/sorgl2.c b/CLAPACK-3.2.1/SRC/sorgl2.c
index 8b0ac9f..8036ad4 100644
--- a/CLAPACK-3.2.1/SRC/sorgl2.c
+++ b/CLAPACK-3.2.1/SRC/sorgl2.c
@@ -24,7 +24,8 @@
     integer i__, j, l;
     extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *), 
 	    slarf_(char *, integer *, integer *, real *, integer *, real *, 
-	    real *, integer *, real *), xerbla_(char *, integer *);
+	    real *, integer *, real *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/sorglq.c b/CLAPACK-3.2.1/SRC/sorglq.c
index c72fb8f..5e30f03 100644
--- a/CLAPACK-3.2.1/SRC/sorglq.c
+++ b/CLAPACK-3.2.1/SRC/sorglq.c
@@ -31,7 +31,8 @@ static integer c__2 = 2;
     extern /* Subroutine */ int sorgl2_(integer *, integer *, integer *, real 
 	    *, integer *, real *, real *, integer *), slarfb_(char *, char *, 
 	    char *, char *, integer *, integer *, integer *, real *, integer *
-, real *, integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
+, real *, integer *, real *, integer *, real *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int slarft_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/sorgql.c b/CLAPACK-3.2.1/SRC/sorgql.c
index 46fb3ea..6456666 100644
--- a/CLAPACK-3.2.1/SRC/sorgql.c
+++ b/CLAPACK-3.2.1/SRC/sorgql.c
@@ -31,7 +31,8 @@ static integer c__2 = 2;
     extern /* Subroutine */ int sorg2l_(integer *, integer *, integer *, real 
 	    *, integer *, real *, real *, integer *), slarfb_(char *, char *, 
 	    char *, char *, integer *, integer *, integer *, real *, integer *
-, real *, integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
+, real *, integer *, real *, integer *, real *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int slarft_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/sorgqr.c b/CLAPACK-3.2.1/SRC/sorgqr.c
index 667255d..3ed9ddb 100644
--- a/CLAPACK-3.2.1/SRC/sorgqr.c
+++ b/CLAPACK-3.2.1/SRC/sorgqr.c
@@ -31,7 +31,8 @@ static integer c__2 = 2;
     extern /* Subroutine */ int sorg2r_(integer *, integer *, integer *, real 
 	    *, integer *, real *, real *, integer *), slarfb_(char *, char *, 
 	    char *, char *, integer *, integer *, integer *, real *, integer *
-, real *, integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
+, real *, integer *, real *, integer *, real *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int slarft_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/sorgr2.c b/CLAPACK-3.2.1/SRC/sorgr2.c
index c47f5b7..e7c047f 100644
--- a/CLAPACK-3.2.1/SRC/sorgr2.c
+++ b/CLAPACK-3.2.1/SRC/sorgr2.c
@@ -24,7 +24,8 @@
     integer i__, j, l, ii;
     extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *), 
 	    slarf_(char *, integer *, integer *, real *, integer *, real *, 
-	    real *, integer *, real *), xerbla_(char *, integer *);
+	    real *, integer *, real *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/sorgrq.c b/CLAPACK-3.2.1/SRC/sorgrq.c
index 36d853c..d4b81d2 100644
--- a/CLAPACK-3.2.1/SRC/sorgrq.c
+++ b/CLAPACK-3.2.1/SRC/sorgrq.c
@@ -31,7 +31,8 @@ static integer c__2 = 2;
     extern /* Subroutine */ int sorgr2_(integer *, integer *, integer *, real 
 	    *, integer *, real *, real *, integer *), slarfb_(char *, char *, 
 	    char *, char *, integer *, integer *, integer *, real *, integer *
-, real *, integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
+, real *, integer *, real *, integer *, real *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int slarft_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/sorgtr.c b/CLAPACK-3.2.1/SRC/sorgtr.c
index 47e521e..a64f9d0 100644
--- a/CLAPACK-3.2.1/SRC/sorgtr.c
+++ b/CLAPACK-3.2.1/SRC/sorgtr.c
@@ -29,7 +29,7 @@ static integer c_n1 = -1;
     extern logical lsame_(char *, char *);
     integer iinfo;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int sorgql_(integer *, integer *, integer *, real 
diff --git a/CLAPACK-3.2.1/SRC/sorm2l.c b/CLAPACK-3.2.1/SRC/sorm2l.c
index 2a727ad..f4b461a 100644
--- a/CLAPACK-3.2.1/SRC/sorm2l.c
+++ b/CLAPACK-3.2.1/SRC/sorm2l.c
@@ -30,7 +30,8 @@ static integer c__1 = 1;
     logical left;
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int slarf_(char *, integer *, integer *, real *, 
-	    integer *, real *, real *, integer *, real *), xerbla_(
+	    integer *, real *, real *, integer *, real *);
+    void xerbla_(
 	    char *, integer *);
     logical notran;
 
diff --git a/CLAPACK-3.2.1/SRC/sorm2r.c b/CLAPACK-3.2.1/SRC/sorm2r.c
index f12cbbb..16d3357 100644
--- a/CLAPACK-3.2.1/SRC/sorm2r.c
+++ b/CLAPACK-3.2.1/SRC/sorm2r.c
@@ -30,7 +30,8 @@ static integer c__1 = 1;
     logical left;
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int slarf_(char *, integer *, integer *, real *, 
-	    integer *, real *, real *, integer *, real *), xerbla_(
+	    integer *, real *, real *, integer *, real *);
+    void xerbla_(
 	    char *, integer *);
     logical notran;
 
diff --git a/CLAPACK-3.2.1/SRC/sormbr.c b/CLAPACK-3.2.1/SRC/sormbr.c
index 1e86631..fd72ffc 100644
--- a/CLAPACK-3.2.1/SRC/sormbr.c
+++ b/CLAPACK-3.2.1/SRC/sormbr.c
@@ -29,14 +29,14 @@ static integer c__2 = 2;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i1, i2, nb, mi, ni, nq, nw;
     logical left;
     extern logical lsame_(char *, char *);
     integer iinfo;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical notran, applyq;
diff --git a/CLAPACK-3.2.1/SRC/sormhr.c b/CLAPACK-3.2.1/SRC/sormhr.c
index 7fd17f7..b5b8617 100644
--- a/CLAPACK-3.2.1/SRC/sormhr.c
+++ b/CLAPACK-3.2.1/SRC/sormhr.c
@@ -29,14 +29,14 @@ static integer c__2 = 2;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i1, i2, nb, mi, nh, ni, nq, nw;
     logical left;
     extern logical lsame_(char *, char *);
     integer iinfo;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/sorml2.c b/CLAPACK-3.2.1/SRC/sorml2.c
index c2a6038..22edff6 100644
--- a/CLAPACK-3.2.1/SRC/sorml2.c
+++ b/CLAPACK-3.2.1/SRC/sorml2.c
@@ -26,7 +26,8 @@
     logical left;
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int slarf_(char *, integer *, integer *, real *, 
-	    integer *, real *, real *, integer *, real *), xerbla_(
+	    integer *, real *, real *, integer *, real *);
+    void xerbla_(
 	    char *, integer *);
     logical notran;
 
diff --git a/CLAPACK-3.2.1/SRC/sormlq.c b/CLAPACK-3.2.1/SRC/sormlq.c
index a5b8632..ac8bdef 100644
--- a/CLAPACK-3.2.1/SRC/sormlq.c
+++ b/CLAPACK-3.2.1/SRC/sormlq.c
@@ -31,7 +31,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -44,7 +44,8 @@ static integer c__65 = 65;
 	    integer *, real *, integer *, real *, real *, integer *, real *, 
 	    integer *), slarfb_(char *, char *, char *, char *
 , integer *, integer *, integer *, real *, integer *, real *, 
-	    integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
+	    integer *, real *, integer *, real *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int slarft_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/sormql.c b/CLAPACK-3.2.1/SRC/sormql.c
index 60d78d4..c3b1224 100644
--- a/CLAPACK-3.2.1/SRC/sormql.c
+++ b/CLAPACK-3.2.1/SRC/sormql.c
@@ -31,7 +31,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -44,7 +44,8 @@ static integer c__65 = 65;
 	    integer *, real *, integer *, real *, real *, integer *, real *, 
 	    integer *), slarfb_(char *, char *, char *, char *
 , integer *, integer *, integer *, real *, integer *, real *, 
-	    integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
+	    integer *, real *, integer *, real *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int slarft_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/sormqr.c b/CLAPACK-3.2.1/SRC/sormqr.c
index 2e965b8..743b049 100644
--- a/CLAPACK-3.2.1/SRC/sormqr.c
+++ b/CLAPACK-3.2.1/SRC/sormqr.c
@@ -31,7 +31,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -44,7 +44,8 @@ static integer c__65 = 65;
 	    integer *, real *, integer *, real *, real *, integer *, real *, 
 	    integer *), slarfb_(char *, char *, char *, char *
 , integer *, integer *, integer *, real *, integer *, real *, 
-	    integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
+	    integer *, real *, integer *, real *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int slarft_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/sormr2.c b/CLAPACK-3.2.1/SRC/sormr2.c
index b3bc353..c027ce3 100644
--- a/CLAPACK-3.2.1/SRC/sormr2.c
+++ b/CLAPACK-3.2.1/SRC/sormr2.c
@@ -26,7 +26,8 @@
     logical left;
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int slarf_(char *, integer *, integer *, real *, 
-	    integer *, real *, real *, integer *, real *), xerbla_(
+	    integer *, real *, real *, integer *, real *);
+    void xerbla_(
 	    char *, integer *);
     logical notran;
 
diff --git a/CLAPACK-3.2.1/SRC/sormr3.c b/CLAPACK-3.2.1/SRC/sormr3.c
index 33ad1e8..3c1363d 100644
--- a/CLAPACK-3.2.1/SRC/sormr3.c
+++ b/CLAPACK-3.2.1/SRC/sormr3.c
@@ -25,8 +25,8 @@
     logical left;
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int slarz_(char *, integer *, integer *, integer *
-, real *, integer *, real *, real *, integer *, real *), 
-	    xerbla_(char *, integer *);
+, real *, integer *, real *, real *, integer *, real *);
+	void xerbla_(char *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/sormrq.c b/CLAPACK-3.2.1/SRC/sormrq.c
index aa97bd5..72bee66 100644
--- a/CLAPACK-3.2.1/SRC/sormrq.c
+++ b/CLAPACK-3.2.1/SRC/sormrq.c
@@ -31,7 +31,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -44,7 +44,8 @@ static integer c__65 = 65;
 	    integer *, real *, integer *, real *, real *, integer *, real *, 
 	    integer *), slarfb_(char *, char *, char *, char *
 , integer *, integer *, integer *, real *, integer *, real *, 
-	    integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
+	    integer *, real *, integer *, real *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int slarft_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/sormrz.c b/CLAPACK-3.2.1/SRC/sormrz.c
index db1aed0..796703d 100644
--- a/CLAPACK-3.2.1/SRC/sormrz.c
+++ b/CLAPACK-3.2.1/SRC/sormrz.c
@@ -31,7 +31,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -42,7 +42,8 @@ static integer c__65 = 65;
     integer nbmin, iinfo;
     extern /* Subroutine */ int sormr3_(char *, char *, integer *, integer *, 
 	    integer *, integer *, real *, integer *, real *, real *, integer *
-, real *, integer *), xerbla_(char *, integer *);
+, real *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int slarzb_(char *, char *, char *, char *, 
diff --git a/CLAPACK-3.2.1/SRC/sormtr.c b/CLAPACK-3.2.1/SRC/sormtr.c
index 0865f72..49f03cd 100644
--- a/CLAPACK-3.2.1/SRC/sormtr.c
+++ b/CLAPACK-3.2.1/SRC/sormtr.c
@@ -29,7 +29,7 @@ static integer c__2 = 2;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i1, i2, nb, mi, ni, nq, nw;
@@ -37,7 +37,7 @@ static integer c__2 = 2;
     extern logical lsame_(char *, char *);
     integer iinfo;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int sormql_(char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/spbcon.c b/CLAPACK-3.2.1/SRC/spbcon.c
index 620291e..d7fc69c 100644
--- a/CLAPACK-3.2.1/SRC/spbcon.c
+++ b/CLAPACK-3.2.1/SRC/spbcon.c
@@ -37,7 +37,7 @@ static integer c__1 = 1;
     real scalel;
     extern doublereal slamch_(char *);
     real scaleu;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
     real ainvnm;
     extern /* Subroutine */ int slatbs_(char *, char *, char *, char *, 
diff --git a/CLAPACK-3.2.1/SRC/spbequ.c b/CLAPACK-3.2.1/SRC/spbequ.c
index 215af52..402d3e4 100644
--- a/CLAPACK-3.2.1/SRC/spbequ.c
+++ b/CLAPACK-3.2.1/SRC/spbequ.c
@@ -28,7 +28,7 @@
     real smin;
     extern logical lsame_(char *, char *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/spbrfs.c b/CLAPACK-3.2.1/SRC/spbrfs.c
index bbcab5a..105bbf0 100644
--- a/CLAPACK-3.2.1/SRC/spbrfs.c
+++ b/CLAPACK-3.2.1/SRC/spbrfs.c
@@ -47,7 +47,7 @@ static real c_b14 = 1.f;
 	    integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real lstres;
     extern /* Subroutine */ int spbtrs_(char *, integer *, integer *, integer 
 	    *, real *, integer *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/spbstf.c b/CLAPACK-3.2.1/SRC/spbstf.c
index 6c79ba8..d732dfc 100644
--- a/CLAPACK-3.2.1/SRC/spbstf.c
+++ b/CLAPACK-3.2.1/SRC/spbstf.c
@@ -37,7 +37,7 @@ static real c_b9 = -1.f;
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/spbsv.c b/CLAPACK-3.2.1/SRC/spbsv.c
index 804dd54..51d3165 100644
--- a/CLAPACK-3.2.1/SRC/spbsv.c
+++ b/CLAPACK-3.2.1/SRC/spbsv.c
@@ -21,7 +21,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), spbtrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  spbtrf_(
 	    char *, integer *, integer *, real *, integer *, integer *), spbtrs_(char *, integer *, integer *, integer *, real *, 
 	    integer *, real *, integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/spbsvx.c b/CLAPACK-3.2.1/SRC/spbsvx.c
index d61997d..b8431f0 100644
--- a/CLAPACK-3.2.1/SRC/spbsvx.c
+++ b/CLAPACK-3.2.1/SRC/spbsvx.c
@@ -38,7 +38,7 @@ static integer c__1 = 1;
 	    integer *);
     extern doublereal slamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     extern doublereal slansb_(char *, char *, integer *, integer *, real *, 
 	    integer *, real *);
diff --git a/CLAPACK-3.2.1/SRC/spbtf2.c b/CLAPACK-3.2.1/SRC/spbtf2.c
index e3d2dd2..a4f0860 100644
--- a/CLAPACK-3.2.1/SRC/spbtf2.c
+++ b/CLAPACK-3.2.1/SRC/spbtf2.c
@@ -37,7 +37,7 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/spbtrf.c b/CLAPACK-3.2.1/SRC/spbtrf.c
index 8f8ccca..c2ee4b4 100644
--- a/CLAPACK-3.2.1/SRC/spbtrf.c
+++ b/CLAPACK-3.2.1/SRC/spbtrf.c
@@ -39,7 +39,8 @@ static integer c__33 = 33;
 	     integer *, integer *, real *, real *, integer *, real *, real *, 
 	    integer *), spbtf2_(char *, integer *, integer *, 
 	    real *, integer *, integer *), spotf2_(char *, integer *, 
-	    real *, integer *, integer *), xerbla_(char *, integer *);
+	    real *, integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/spbtrs.c b/CLAPACK-3.2.1/SRC/spbtrs.c
index dd15ab8..9f61af4 100644
--- a/CLAPACK-3.2.1/SRC/spbtrs.c
+++ b/CLAPACK-3.2.1/SRC/spbtrs.c
@@ -28,7 +28,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     logical upper;
     extern /* Subroutine */ int stbsv_(char *, char *, char *, integer *, 
-	    integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
+	    integer *, real *, integer *, real *, integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/spftrf.c b/CLAPACK-3.2.1/SRC/spftrf.c
index 64a2358..d1e870f 100644
--- a/CLAPACK-3.2.1/SRC/spftrf.c
+++ b/CLAPACK-3.2.1/SRC/spftrf.c
@@ -33,7 +33,8 @@ static real c_b15 = -1.f;
 	    integer *, integer *, real *, real *, integer *, real *, integer *
 ), ssyrk_(char *, char *, integer 
 	    *, integer *, real *, real *, integer *, real *, real *, integer *
-), xerbla_(char *, integer *);
+);
+    void xerbla_(char *, integer *);
     logical nisodd;
     extern /* Subroutine */ int spotrf_(char *, integer *, real *, integer *, 
 	    integer *);
diff --git a/CLAPACK-3.2.1/SRC/spftri.c b/CLAPACK-3.2.1/SRC/spftri.c
index fde795a..313fcfa 100644
--- a/CLAPACK-3.2.1/SRC/spftri.c
+++ b/CLAPACK-3.2.1/SRC/spftri.c
@@ -32,7 +32,8 @@ static real c_b11 = 1.f;
 	    integer *, integer *, real *, real *, integer *, real *, integer *
 ), ssyrk_(char *, char *, integer 
 	    *, integer *, real *, real *, integer *, real *, real *, integer *
-), xerbla_(char *, integer *);
+);
+    void xerbla_(char *, integer *);
     logical nisodd;
     extern /* Subroutine */ int slauum_(char *, integer *, real *, integer *, 
 	    integer *), stftri_(char *, char *, char *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/spftrs.c b/CLAPACK-3.2.1/SRC/spftrs.c
index d8b3f6a..be672c0 100644
--- a/CLAPACK-3.2.1/SRC/spftrs.c
+++ b/CLAPACK-3.2.1/SRC/spftrs.c
@@ -28,7 +28,8 @@ static real c_b10 = 1.f;
     extern logical lsame_(char *, char *);
     logical lower;
     extern /* Subroutine */ int stfsm_(char *, char *, char *, char *, char *, 
-	     integer *, integer *, real *, real *, real *, integer *), xerbla_(char *, integer *);
+	     integer *, integer *, real *, real *, real *, integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2)                                    -- */
diff --git a/CLAPACK-3.2.1/SRC/spocon.c b/CLAPACK-3.2.1/SRC/spocon.c
index 6d1804d..c2bafb2 100644
--- a/CLAPACK-3.2.1/SRC/spocon.c
+++ b/CLAPACK-3.2.1/SRC/spocon.c
@@ -36,7 +36,7 @@ static integer c__1 = 1;
     real scalel;
     extern doublereal slamch_(char *);
     real scaleu;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
     real ainvnm;
     char normin[1];
diff --git a/CLAPACK-3.2.1/SRC/spoequ.c b/CLAPACK-3.2.1/SRC/spoequ.c
index 9b23897..65a92c8 100644
--- a/CLAPACK-3.2.1/SRC/spoequ.c
+++ b/CLAPACK-3.2.1/SRC/spoequ.c
@@ -26,7 +26,7 @@
     /* Local variables */
     integer i__;
     real smin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/spoequb.c b/CLAPACK-3.2.1/SRC/spoequb.c
index cd6865a..6375286 100644
--- a/CLAPACK-3.2.1/SRC/spoequb.c
+++ b/CLAPACK-3.2.1/SRC/spoequb.c
@@ -27,7 +27,7 @@
     integer i__;
     real tmp, base, smin;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*     -- LAPACK routine (version 3.2)                                 -- */
diff --git a/CLAPACK-3.2.1/SRC/sporfs.c b/CLAPACK-3.2.1/SRC/sporfs.c
index d0ef95e..642fb93 100644
--- a/CLAPACK-3.2.1/SRC/sporfs.c
+++ b/CLAPACK-3.2.1/SRC/sporfs.c
@@ -47,7 +47,7 @@ static real c_b14 = 1.f;
 );
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real lstres;
     extern /* Subroutine */ int spotrs_(char *, integer *, integer *, real *, 
 	    integer *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sporfsx.c b/CLAPACK-3.2.1/SRC/sporfsx.c
index ac4ccec..6dd1e15 100644
--- a/CLAPACK-3.2.1/SRC/sporfsx.c
+++ b/CLAPACK-3.2.1/SRC/sporfsx.c
@@ -55,7 +55,8 @@ static integer c__1 = 1;
     real anorm;
     logical rcequ;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), spocon_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  spocon_(
 	    char *, integer *, real *, integer *, real *, real *, real *, 
 	    integer *, integer *);
     extern doublereal slansy_(char *, char *, integer *, real *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/sposv.c b/CLAPACK-3.2.1/SRC/sposv.c
index 02d37ee..c43e452 100644
--- a/CLAPACK-3.2.1/SRC/sposv.c
+++ b/CLAPACK-3.2.1/SRC/sposv.c
@@ -21,7 +21,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), spotrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  spotrf_(
 	    char *, integer *, real *, integer *, integer *), spotrs_(
 	    char *, integer *, integer *, real *, integer *, real *, integer *
 , integer *);
diff --git a/CLAPACK-3.2.1/SRC/sposvx.c b/CLAPACK-3.2.1/SRC/sposvx.c
index 16ca811..c9ceea1 100644
--- a/CLAPACK-3.2.1/SRC/sposvx.c
+++ b/CLAPACK-3.2.1/SRC/sposvx.c
@@ -31,7 +31,7 @@
     logical equil, rcequ;
     extern doublereal slamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     integer infequ;
     extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/sposvxx.c b/CLAPACK-3.2.1/SRC/sposvxx.c
index a5d859b..9073ffa 100644
--- a/CLAPACK-3.2.1/SRC/sposvxx.c
+++ b/CLAPACK-3.2.1/SRC/sposvxx.c
@@ -36,7 +36,7 @@
     logical equil, rcequ;
     extern doublereal slamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     integer infequ;
     extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/spotf2.c b/CLAPACK-3.2.1/SRC/spotf2.c
index 2349774..a34bdea 100644
--- a/CLAPACK-3.2.1/SRC/spotf2.c
+++ b/CLAPACK-3.2.1/SRC/spotf2.c
@@ -38,7 +38,7 @@ static real c_b12 = 1.f;
 	    sgemv_(char *, integer *, integer *, real *, real *, integer *, 
 	    real *, integer *, real *, real *, integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern logical sisnan_(real *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/spotrf.c b/CLAPACK-3.2.1/SRC/spotrf.c
index ff33e9e..05f8e0e 100644
--- a/CLAPACK-3.2.1/SRC/spotrf.c
+++ b/CLAPACK-3.2.1/SRC/spotrf.c
@@ -38,7 +38,8 @@ static real c_b14 = 1.f;
 ), ssyrk_(char *, char *, integer 
 	    *, integer *, real *, real *, integer *, real *, real *, integer *
 ), spotf2_(char *, integer *, real *, integer *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/spotri.c b/CLAPACK-3.2.1/SRC/spotri.c
index 2669838..2c3805f 100644
--- a/CLAPACK-3.2.1/SRC/spotri.c
+++ b/CLAPACK-3.2.1/SRC/spotri.c
@@ -21,7 +21,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), slauum_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slauum_(
 	    char *, integer *, real *, integer *, integer *), strtri_(
 	    char *, char *, integer *, real *, integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/spotrs.c b/CLAPACK-3.2.1/SRC/spotrs.c
index ba0d324..4d3cda0 100644
--- a/CLAPACK-3.2.1/SRC/spotrs.c
+++ b/CLAPACK-3.2.1/SRC/spotrs.c
@@ -28,7 +28,8 @@ static real c_b9 = 1.f;
     logical upper;
     extern /* Subroutine */ int strsm_(char *, char *, char *, char *, 
 	    integer *, integer *, real *, real *, integer *, real *, integer *
-), xerbla_(char *, integer *);
+);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/sppcon.c b/CLAPACK-3.2.1/SRC/sppcon.c
index 8e3d0c1..6fbbce0 100644
--- a/CLAPACK-3.2.1/SRC/sppcon.c
+++ b/CLAPACK-3.2.1/SRC/sppcon.c
@@ -36,7 +36,7 @@ static integer c__1 = 1;
     real scalel;
     extern doublereal slamch_(char *);
     real scaleu;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
     real ainvnm;
     char normin[1];
diff --git a/CLAPACK-3.2.1/SRC/sppequ.c b/CLAPACK-3.2.1/SRC/sppequ.c
index 44142dd..24e9078 100644
--- a/CLAPACK-3.2.1/SRC/sppequ.c
+++ b/CLAPACK-3.2.1/SRC/sppequ.c
@@ -28,7 +28,7 @@
     real smin;
     extern logical lsame_(char *, char *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/spprfs.c b/CLAPACK-3.2.1/SRC/spprfs.c
index b12391f..deb33f5 100644
--- a/CLAPACK-3.2.1/SRC/spprfs.c
+++ b/CLAPACK-3.2.1/SRC/spprfs.c
@@ -46,7 +46,7 @@ static real c_b14 = 1.f;
 	    real *, real *, integer *, real *, integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real lstres;
     extern /* Subroutine */ int spptrs_(char *, integer *, integer *, real *, 
 	    real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sppsv.c b/CLAPACK-3.2.1/SRC/sppsv.c
index cbeb78b..e23019a 100644
--- a/CLAPACK-3.2.1/SRC/sppsv.c
+++ b/CLAPACK-3.2.1/SRC/sppsv.c
@@ -21,7 +21,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), spptrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  spptrf_(
 	    char *, integer *, real *, integer *), spptrs_(char *, 
 	    integer *, integer *, real *, real *, integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/sppsvx.c b/CLAPACK-3.2.1/SRC/sppsvx.c
index 15f5d6e..f9dac74 100644
--- a/CLAPACK-3.2.1/SRC/sppsvx.c
+++ b/CLAPACK-3.2.1/SRC/sppsvx.c
@@ -36,7 +36,7 @@ static integer c__1 = 1;
 	    integer *);
     extern doublereal slamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     integer infequ;
     extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/spptrf.c b/CLAPACK-3.2.1/SRC/spptrf.c
index 997337b..46570e3 100644
--- a/CLAPACK-3.2.1/SRC/spptrf.c
+++ b/CLAPACK-3.2.1/SRC/spptrf.c
@@ -37,7 +37,8 @@ static real c_b16 = -1.f;
     extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *);
     logical upper;
     extern /* Subroutine */ int stpsv_(char *, char *, char *, integer *, 
-	    real *, real *, integer *), xerbla_(char *
+	    real *, real *, integer *);
+    void xerbla_(char *
 , integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/spptri.c b/CLAPACK-3.2.1/SRC/spptri.c
index c4e7e95..293e734 100644
--- a/CLAPACK-3.2.1/SRC/spptri.c
+++ b/CLAPACK-3.2.1/SRC/spptri.c
@@ -34,8 +34,10 @@ static integer c__1 = 1;
     extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *);
     logical upper;
     extern /* Subroutine */ int stpmv_(char *, char *, char *, integer *, 
-	    real *, real *, integer *), xerbla_(char *
-, integer *), stptri_(char *, char *, integer *, real *, 
+	    real *, real *, integer *);
+    void xerbla_(char *
+, integer *);
+    int stptri_(char *, char *, integer *, real *, 
 	    integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/spptrs.c b/CLAPACK-3.2.1/SRC/spptrs.c
index 6d0d30e..71ef205 100644
--- a/CLAPACK-3.2.1/SRC/spptrs.c
+++ b/CLAPACK-3.2.1/SRC/spptrs.c
@@ -28,7 +28,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     logical upper;
     extern /* Subroutine */ int stpsv_(char *, char *, char *, integer *, 
-	    real *, real *, integer *), xerbla_(char *
+	    real *, real *, integer *);
+    void xerbla_(char *
 , integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/spstf2.c b/CLAPACK-3.2.1/SRC/spstf2.c
index 0eab03e..090e05e 100644
--- a/CLAPACK-3.2.1/SRC/spstf2.c
+++ b/CLAPACK-3.2.1/SRC/spstf2.c
@@ -44,7 +44,7 @@ static real c_b18 = 1.f;
 	    integer *);
     real sstop;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern logical sisnan_(real *);
     extern integer smaxloc_(real *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/spstrf.c b/CLAPACK-3.2.1/SRC/spstrf.c
index 0f46f2f..5eb9029 100644
--- a/CLAPACK-3.2.1/SRC/spstrf.c
+++ b/CLAPACK-3.2.1/SRC/spstrf.c
@@ -48,7 +48,7 @@ static real c_b24 = 1.f;
 	    real *, real *, integer *, real *, real *, integer *), spstf2_(char *, integer *, real *, integer *, integer *, 
 	    integer *, real *, real *, integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern logical sisnan_(real *);
diff --git a/CLAPACK-3.2.1/SRC/sptcon.c b/CLAPACK-3.2.1/SRC/sptcon.c
index 1861ebe..0b0a7b0 100644
--- a/CLAPACK-3.2.1/SRC/sptcon.c
+++ b/CLAPACK-3.2.1/SRC/sptcon.c
@@ -26,7 +26,7 @@ static integer c__1 = 1;
 
     /* Local variables */
     integer i__, ix;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
     real ainvnm;
 
diff --git a/CLAPACK-3.2.1/SRC/spteqr.c b/CLAPACK-3.2.1/SRC/spteqr.c
index 90fd206..ebf950d 100644
--- a/CLAPACK-3.2.1/SRC/spteqr.c
+++ b/CLAPACK-3.2.1/SRC/spteqr.c
@@ -35,7 +35,8 @@ static integer c__1 = 1;
     real vt[1]	/* was [1][1] */;
     integer nru;
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), slaset_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slaset_(
 	    char *, integer *, integer *, real *, real *, real *, integer *), sbdsqr_(char *, integer *, integer *, integer *, integer 
 	    *, real *, real *, real *, integer *, real *, integer *, real *, 
 	    integer *, real *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sptrfs.c b/CLAPACK-3.2.1/SRC/sptrfs.c
index f6d9adb..310b65e 100644
--- a/CLAPACK-3.2.1/SRC/sptrfs.c
+++ b/CLAPACK-3.2.1/SRC/sptrfs.c
@@ -36,7 +36,7 @@ static real c_b11 = 1.f;
 	    real *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
     real lstres;
     extern /* Subroutine */ int spttrs_(integer *, integer *, real *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/sptsv.c b/CLAPACK-3.2.1/SRC/sptsv.c
index f39fe1e..44cae65 100644
--- a/CLAPACK-3.2.1/SRC/sptsv.c
+++ b/CLAPACK-3.2.1/SRC/sptsv.c
@@ -20,7 +20,8 @@
     integer b_dim1, b_offset, i__1;
 
     /* Local variables */
-    extern /* Subroutine */ int xerbla_(char *, integer *), spttrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  spttrf_(
 	    integer *, real *, real *, integer *), spttrs_(integer *, integer 
 	    *, real *, real *, real *, integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/sptsvx.c b/CLAPACK-3.2.1/SRC/sptsvx.c
index d8f5203..2e2ce67 100644
--- a/CLAPACK-3.2.1/SRC/sptsvx.c
+++ b/CLAPACK-3.2.1/SRC/sptsvx.c
@@ -31,7 +31,8 @@ static integer c__1 = 1;
 	    integer *);
     extern doublereal slamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *), slacpy_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slacpy_(
 	    char *, integer *, integer *, real *, integer *, real *, integer *
 );
     extern doublereal slanst_(char *, integer *, real *, real *);
diff --git a/CLAPACK-3.2.1/SRC/spttrf.c b/CLAPACK-3.2.1/SRC/spttrf.c
index f3cda23..ea6d974 100644
--- a/CLAPACK-3.2.1/SRC/spttrf.c
+++ b/CLAPACK-3.2.1/SRC/spttrf.c
@@ -21,7 +21,7 @@
     /* Local variables */
     integer i__, i4;
     real ei;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/spttrs.c b/CLAPACK-3.2.1/SRC/spttrs.c
index bac3da4..55971bc 100644
--- a/CLAPACK-3.2.1/SRC/spttrs.c
+++ b/CLAPACK-3.2.1/SRC/spttrs.c
@@ -27,7 +27,8 @@ static integer c_n1 = -1;
     /* Local variables */
     integer j, jb, nb;
     extern /* Subroutine */ int sptts2_(integer *, integer *, real *, real *, 
-	    real *, integer *), xerbla_(char *, integer *);
+	    real *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/ssbev.c b/CLAPACK-3.2.1/SRC/ssbev.c
index bb0af95..cc93ce3 100644
--- a/CLAPACK-3.2.1/SRC/ssbev.c
+++ b/CLAPACK-3.2.1/SRC/ssbev.c
@@ -42,7 +42,7 @@ static integer c__1 = 1;
     integer iscale;
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     extern doublereal slansb_(char *, char *, integer *, integer *, real *, 
 	    integer *, real *);
diff --git a/CLAPACK-3.2.1/SRC/ssbevd.c b/CLAPACK-3.2.1/SRC/ssbevd.c
index 7d58eaf..3a32e4f 100644
--- a/CLAPACK-3.2.1/SRC/ssbevd.c
+++ b/CLAPACK-3.2.1/SRC/ssbevd.c
@@ -44,7 +44,7 @@ static integer c__1 = 1;
     integer indwk2, llwrk2, iscale;
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     extern doublereal slansb_(char *, char *, integer *, integer *, real *, 
 	    integer *, real *);
diff --git a/CLAPACK-3.2.1/SRC/ssbevx.c b/CLAPACK-3.2.1/SRC/ssbevx.c
index d9d1ce4..9a68bf7 100644
--- a/CLAPACK-3.2.1/SRC/ssbevx.c
+++ b/CLAPACK-3.2.1/SRC/ssbevx.c
@@ -58,7 +58,7 @@ static real c_b34 = 0.f;
     logical valeig;
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real abstll, bignum;
     extern doublereal slansb_(char *, char *, integer *, integer *, real *, 
 	    integer *, real *);
diff --git a/CLAPACK-3.2.1/SRC/ssbgst.c b/CLAPACK-3.2.1/SRC/ssbgst.c
index 1698683..3901139 100644
--- a/CLAPACK-3.2.1/SRC/ssbgst.c
+++ b/CLAPACK-3.2.1/SRC/ssbgst.c
@@ -46,7 +46,8 @@ static real c_b20 = -1.f;
     extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *);
     logical upper, wantx;
     extern /* Subroutine */ int slar2v_(integer *, real *, real *, real *, 
-	    integer *, real *, real *, integer *), xerbla_(char *, integer *);
+	    integer *, real *, real *, integer *);
+    void xerbla_(char *, integer *);
     logical update;
     extern /* Subroutine */ int slaset_(char *, integer *, integer *, real *, 
 	    real *, real *, integer *), slartg_(real *, real *, real *
diff --git a/CLAPACK-3.2.1/SRC/ssbgv.c b/CLAPACK-3.2.1/SRC/ssbgv.c
index bdd9525..69a72d4 100644
--- a/CLAPACK-3.2.1/SRC/ssbgv.c
+++ b/CLAPACK-3.2.1/SRC/ssbgv.c
@@ -26,7 +26,7 @@
     extern logical lsame_(char *, char *);
     integer iinfo;
     logical upper, wantz;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer indwrk;
     extern /* Subroutine */ int spbstf_(char *, integer *, integer *, real *, 
 	    integer *, integer *), ssbtrd_(char *, char *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/ssbgvd.c b/CLAPACK-3.2.1/SRC/ssbgvd.c
index a3cebb6..19a8d4d 100644
--- a/CLAPACK-3.2.1/SRC/ssbgvd.c
+++ b/CLAPACK-3.2.1/SRC/ssbgvd.c
@@ -37,7 +37,8 @@ static real c_b13 = 0.f;
     integer lwmin;
     logical upper, wantz;
     integer indwk2, llwrk2;
-    extern /* Subroutine */ int xerbla_(char *, integer *), sstedc_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  sstedc_(
 	    char *, integer *, real *, real *, real *, integer *, real *, 
 	    integer *, integer *, integer *, integer *), slacpy_(char 
 	    *, integer *, integer *, real *, integer *, real *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/ssbgvx.c b/CLAPACK-3.2.1/SRC/ssbgvx.c
index 39873e5..35736c5 100644
--- a/CLAPACK-3.2.1/SRC/ssbgvx.c
+++ b/CLAPACK-3.2.1/SRC/ssbgvx.c
@@ -48,7 +48,7 @@ static real c_b27 = 0.f;
     logical wantz, alleig, indeig;
     integer indibl;
     logical valeig;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer indisp, indiwo;
     extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *, 
 	    integer *, real *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/ssbtrd.c b/CLAPACK-3.2.1/SRC/ssbtrd.c
index 32b9bcd..6c6249c 100644
--- a/CLAPACK-3.2.1/SRC/ssbtrd.c
+++ b/CLAPACK-3.2.1/SRC/ssbtrd.c
@@ -39,7 +39,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int slar2v_(integer *, real *, real *, real *, 
 	    integer *, real *, real *, integer *);
     integer iqaend;
-    extern /* Subroutine */ int xerbla_(char *, integer *), slaset_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slaset_(
 	    char *, integer *, integer *, real *, real *, real *, integer *), slartg_(real *, real *, real *, real *, real *), slargv_(
 	    integer *, real *, integer *, real *, integer *, real *, integer *
 ), slartv_(integer *, real *, integer *, real *, integer *, real *
diff --git a/CLAPACK-3.2.1/SRC/ssfrk.c b/CLAPACK-3.2.1/SRC/ssfrk.c
index 0b84159..ca9d3e1 100644
--- a/CLAPACK-3.2.1/SRC/ssfrk.c
+++ b/CLAPACK-3.2.1/SRC/ssfrk.c
@@ -30,7 +30,8 @@
     integer nrowa;
     logical lower;
     extern /* Subroutine */ int ssyrk_(char *, char *, integer *, integer *, 
-	    real *, real *, integer *, real *, real *, integer *), xerbla_(char *, integer *);
+	    real *, real *, integer *, real *, real *, integer *);
+    void xerbla_(char *, integer *);
     logical nisodd, notrans;
 
 
diff --git a/CLAPACK-3.2.1/SRC/sspcon.c b/CLAPACK-3.2.1/SRC/sspcon.c
index efbc487..37198d0 100644
--- a/CLAPACK-3.2.1/SRC/sspcon.c
+++ b/CLAPACK-3.2.1/SRC/sspcon.c
@@ -29,7 +29,8 @@ static integer c__1 = 1;
     integer isave[3];
     logical upper;
     extern /* Subroutine */ int slacn2_(integer *, real *, real *, integer *, 
-	    real *, integer *, integer *), xerbla_(char *, integer *);
+	    real *, integer *, integer *);
+    void xerbla_(char *, integer *);
     real ainvnm;
     extern /* Subroutine */ int ssptrs_(char *, integer *, integer *, real *, 
 	    integer *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sspev.c b/CLAPACK-3.2.1/SRC/sspev.c
index 7b6176f..4ba2a81 100644
--- a/CLAPACK-3.2.1/SRC/sspev.c
+++ b/CLAPACK-3.2.1/SRC/sspev.c
@@ -40,7 +40,7 @@ static integer c__1 = 1;
     integer iscale;
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     integer indtau, indwrk;
     extern doublereal slansp_(char *, char *, integer *, real *, real *);
diff --git a/CLAPACK-3.2.1/SRC/sspevd.c b/CLAPACK-3.2.1/SRC/sspevd.c
index 7abae02..f6aafd6 100644
--- a/CLAPACK-3.2.1/SRC/sspevd.c
+++ b/CLAPACK-3.2.1/SRC/sspevd.c
@@ -40,7 +40,7 @@ static integer c__1 = 1;
     integer iscale;
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     integer indtau;
     extern /* Subroutine */ int sstedc_(char *, integer *, real *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/sspevx.c b/CLAPACK-3.2.1/SRC/sspevx.c
index 172aa32..705f749 100644
--- a/CLAPACK-3.2.1/SRC/sspevx.c
+++ b/CLAPACK-3.2.1/SRC/sspevx.c
@@ -51,7 +51,7 @@ static integer c__1 = 1;
     logical valeig;
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real abstll, bignum;
     integer indtau, indisp, indiwo, indwrk;
     extern doublereal slansp_(char *, char *, integer *, real *, real *);
diff --git a/CLAPACK-3.2.1/SRC/sspgst.c b/CLAPACK-3.2.1/SRC/sspgst.c
index a86622a..9d44d94 100644
--- a/CLAPACK-3.2.1/SRC/sspgst.c
+++ b/CLAPACK-3.2.1/SRC/sspgst.c
@@ -43,7 +43,8 @@ static real c_b11 = 1.f;
 	    real *, integer *), sspmv_(char *, integer *, real *, real *, 
 	    real *, integer *, real *, real *, integer *), stpmv_(
 	    char *, char *, char *, integer *, real *, real *, integer *), stpsv_(char *, char *, char *, integer *, 
-	     real *, real *, integer *), xerbla_(char 
+	     real *, real *, integer *);
+    void xerbla_(char 
 	    *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/sspgv.c b/CLAPACK-3.2.1/SRC/sspgv.c
index 1433001..a512c9c 100644
--- a/CLAPACK-3.2.1/SRC/sspgv.c
+++ b/CLAPACK-3.2.1/SRC/sspgv.c
@@ -34,7 +34,9 @@ static integer c__1 = 1;
     logical wantz;
     extern /* Subroutine */ int stpmv_(char *, char *, char *, integer *, 
 	    real *, real *, integer *), stpsv_(char *, 
-	     char *, char *, integer *, real *, real *, integer *), xerbla_(char *, integer *), spptrf_(char 
+	     char *, char *, integer *, real *, real *, integer *);
+    void xerbla_(char *, integer *);
+    int spptrf_(char 
 	    *, integer *, real *, integer *), sspgst_(integer *, char 
 	    *, integer *, real *, real *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/sspgvd.c b/CLAPACK-3.2.1/SRC/sspgvd.c
index 0ad98eb..49025f3 100644
--- a/CLAPACK-3.2.1/SRC/sspgvd.c
+++ b/CLAPACK-3.2.1/SRC/sspgvd.c
@@ -33,7 +33,8 @@ static integer c__1 = 1;
     logical upper, wantz;
     extern /* Subroutine */ int stpmv_(char *, char *, char *, integer *, 
 	    real *, real *, integer *), stpsv_(char *, 
-	     char *, char *, integer *, real *, real *, integer *), xerbla_(char *, integer *);
+	     char *, char *, integer *, real *, real *, integer *);
+    void xerbla_(char *, integer *);
     integer liwmin;
     extern /* Subroutine */ int sspevd_(char *, char *, integer *, real *, 
 	    real *, real *, integer *, real *, integer *, integer *, integer *
diff --git a/CLAPACK-3.2.1/SRC/sspgvx.c b/CLAPACK-3.2.1/SRC/sspgvx.c
index 30271be..3a11719 100644
--- a/CLAPACK-3.2.1/SRC/sspgvx.c
+++ b/CLAPACK-3.2.1/SRC/sspgvx.c
@@ -34,7 +34,8 @@ static integer c__1 = 1;
 	    real *, real *, integer *), stpsv_(char *, 
 	     char *, char *, integer *, real *, real *, integer *);
     logical alleig, indeig, valeig;
-    extern /* Subroutine */ int xerbla_(char *, integer *), spptrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  spptrf_(
 	    char *, integer *, real *, integer *), sspgst_(integer *, 
 	    char *, integer *, real *, real *, integer *), sspevx_(
 	    char *, char *, char *, integer *, real *, real *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/ssprfs.c b/CLAPACK-3.2.1/SRC/ssprfs.c
index 9e02bea..fb29be5 100644
--- a/CLAPACK-3.2.1/SRC/ssprfs.c
+++ b/CLAPACK-3.2.1/SRC/ssprfs.c
@@ -47,7 +47,7 @@ static real c_b14 = 1.f;
 	    real *, real *, integer *, real *, integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real lstres;
     extern /* Subroutine */ int ssptrs_(char *, integer *, integer *, real *, 
 	    integer *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sspsv.c b/CLAPACK-3.2.1/SRC/sspsv.c
index e902d61..692012c 100644
--- a/CLAPACK-3.2.1/SRC/sspsv.c
+++ b/CLAPACK-3.2.1/SRC/sspsv.c
@@ -21,7 +21,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), ssptrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  ssptrf_(
 	    char *, integer *, real *, integer *, integer *), ssptrs_(
 	    char *, integer *, integer *, real *, integer *, real *, integer *
 , integer *);
diff --git a/CLAPACK-3.2.1/SRC/sspsvx.c b/CLAPACK-3.2.1/SRC/sspsvx.c
index 96b88fe..698b591 100644
--- a/CLAPACK-3.2.1/SRC/sspsvx.c
+++ b/CLAPACK-3.2.1/SRC/sspsvx.c
@@ -32,7 +32,8 @@ static integer c__1 = 1;
 	    integer *);
     extern doublereal slamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *), slacpy_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slacpy_(
 	    char *, integer *, integer *, real *, integer *, real *, integer *
 );
     extern doublereal slansp_(char *, char *, integer *, real *, real *);
diff --git a/CLAPACK-3.2.1/SRC/ssptrd.c b/CLAPACK-3.2.1/SRC/ssptrd.c
index db5eb88..ef28a8b 100644
--- a/CLAPACK-3.2.1/SRC/ssptrd.c
+++ b/CLAPACK-3.2.1/SRC/ssptrd.c
@@ -36,8 +36,10 @@ static real c_b14 = -1.f;
     logical upper;
     extern /* Subroutine */ int saxpy_(integer *, real *, real *, integer *, 
 	    real *, integer *), sspmv_(char *, integer *, real *, real *, 
-	    real *, integer *, real *, real *, integer *), xerbla_(
-	    char *, integer *), slarfg_(integer *, real *, real *, 
+	    real *, integer *, real *, real *, integer *);
+    void xerbla_(
+	    char *, integer *);
+    int slarfg_(integer *, real *, real *, 
 	    integer *, real *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/ssptrf.c b/CLAPACK-3.2.1/SRC/ssptrf.c
index df4bb43..06438ee 100644
--- a/CLAPACK-3.2.1/SRC/ssptrf.c
+++ b/CLAPACK-3.2.1/SRC/ssptrf.c
@@ -45,7 +45,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int sswap_(integer *, real *, integer *, real *, 
 	    integer *);
     real absakk;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
     real colmax, rowmax;
 
diff --git a/CLAPACK-3.2.1/SRC/ssptri.c b/CLAPACK-3.2.1/SRC/ssptri.c
index bdaa884..0ce180c 100644
--- a/CLAPACK-3.2.1/SRC/ssptri.c
+++ b/CLAPACK-3.2.1/SRC/ssptri.c
@@ -40,7 +40,8 @@ static real c_b13 = 0.f;
     extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *, 
 	    integer *), sswap_(integer *, real *, integer *, real *, integer *
 ), sspmv_(char *, integer *, real *, real *, real *, integer *, 
-	    real *, real *, integer *), xerbla_(char *, integer *);
+	    real *, real *, integer *);
+    void xerbla_(char *, integer *);
     integer kcnext;
 
 
diff --git a/CLAPACK-3.2.1/SRC/ssptrs.c b/CLAPACK-3.2.1/SRC/ssptrs.c
index c83efd6..a9192c1 100644
--- a/CLAPACK-3.2.1/SRC/ssptrs.c
+++ b/CLAPACK-3.2.1/SRC/ssptrs.c
@@ -41,7 +41,8 @@ static real c_b19 = 1.f;
 	    real *, integer *, real *, real *, integer *);
     logical upper;
     extern /* Subroutine */ int sswap_(integer *, real *, integer *, real *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/sstebz.c b/CLAPACK-3.2.1/SRC/sstebz.c
index c2457fd..1089a6f 100644
--- a/CLAPACK-3.2.1/SRC/sstebz.c
+++ b/CLAPACK-3.2.1/SRC/sstebz.c
@@ -56,7 +56,7 @@ static integer c__0 = 0;
     extern doublereal slamch_(char *);
     real safemn;
     integer idumma[1];
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer idiscu;
diff --git a/CLAPACK-3.2.1/SRC/sstedc.c b/CLAPACK-3.2.1/SRC/sstedc.c
index 950f318..9777e34 100644
--- a/CLAPACK-3.2.1/SRC/sstedc.c
+++ b/CLAPACK-3.2.1/SRC/sstedc.c
@@ -50,7 +50,7 @@ static integer c__1 = 1;
 	    *, real *, integer *, real *, integer *, real *, integer *, 
 	    integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer finish;
diff --git a/CLAPACK-3.2.1/SRC/sstein.c b/CLAPACK-3.2.1/SRC/sstein.c
index cd9ae76..620af4b 100644
--- a/CLAPACK-3.2.1/SRC/sstein.c
+++ b/CLAPACK-3.2.1/SRC/sstein.c
@@ -48,7 +48,8 @@ static integer c_n1 = -1;
 	    real *, integer *);
     integer indrv1, indrv2, indrv3, indrv4, indrv5;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), slagtf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slagtf_(
 	    integer *, real *, real *, real *, real *, real *, real *, 
 	    integer *, integer *);
     integer nrmchk;
diff --git a/CLAPACK-3.2.1/SRC/sstemr.c b/CLAPACK-3.2.1/SRC/sstemr.c
index 64a646b..2e8a4e8 100644
--- a/CLAPACK-3.2.1/SRC/sstemr.c
+++ b/CLAPACK-3.2.1/SRC/sstemr.c
@@ -68,7 +68,7 @@ static real c_b18 = .003f;
     extern doublereal slamch_(char *);
     integer wbegin;
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     integer inderr, iindwk, indgrs, offset;
     extern /* Subroutine */ int slarrc_(char *, integer *, real *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/ssteqr.c b/CLAPACK-3.2.1/SRC/ssteqr.c
index a4740fe..39d1ef8 100644
--- a/CLAPACK-3.2.1/SRC/ssteqr.c
+++ b/CLAPACK-3.2.1/SRC/ssteqr.c
@@ -53,7 +53,7 @@ static integer c__2 = 2;
     integer iscale;
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real safmax;
     extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *, 
 	    real *, integer *, integer *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/ssterf.c b/CLAPACK-3.2.1/SRC/ssterf.c
index 653dce0..960085d 100644
--- a/CLAPACK-3.2.1/SRC/ssterf.c
+++ b/CLAPACK-3.2.1/SRC/ssterf.c
@@ -45,7 +45,7 @@ static real c_b32 = 1.f;
     real oldgam;
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real safmax;
     extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *, 
 	    real *, integer *, integer *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sstev.c b/CLAPACK-3.2.1/SRC/sstev.c
index 5fe9ab2..8211c2a 100644
--- a/CLAPACK-3.2.1/SRC/sstev.c
+++ b/CLAPACK-3.2.1/SRC/sstev.c
@@ -37,7 +37,7 @@ static integer c__1 = 1;
     integer iscale;
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     extern doublereal slanst_(char *, integer *, real *, real *);
     extern /* Subroutine */ int ssterf_(integer *, real *, real *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/sstevd.c b/CLAPACK-3.2.1/SRC/sstevd.c
index d7e6ce2..4fe47ab 100644
--- a/CLAPACK-3.2.1/SRC/sstevd.c
+++ b/CLAPACK-3.2.1/SRC/sstevd.c
@@ -37,7 +37,7 @@ static integer c__1 = 1;
     integer iscale;
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     extern /* Subroutine */ int sstedc_(char *, integer *, real *, real *, 
 	    real *, integer *, real *, integer *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/sstevr.c b/CLAPACK-3.2.1/SRC/sstevr.c
index 279446a..957f1f8 100644
--- a/CLAPACK-3.2.1/SRC/sstevr.c
+++ b/CLAPACK-3.2.1/SRC/sstevr.c
@@ -54,7 +54,7 @@ static integer c__4 = 4;
     real safmin;
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     integer indisp, indiwo, liwmin;
     logical tryrac;
diff --git a/CLAPACK-3.2.1/SRC/sstevx.c b/CLAPACK-3.2.1/SRC/sstevx.c
index 5c3df45..4d28862 100644
--- a/CLAPACK-3.2.1/SRC/sstevx.c
+++ b/CLAPACK-3.2.1/SRC/sstevx.c
@@ -49,7 +49,7 @@ static integer c__1 = 1;
     logical valeig;
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     integer indisp, indiwo, indwrk;
     extern doublereal slanst_(char *, integer *, real *, real *);
diff --git a/CLAPACK-3.2.1/SRC/ssycon.c b/CLAPACK-3.2.1/SRC/ssycon.c
index e553108..25ac487 100644
--- a/CLAPACK-3.2.1/SRC/ssycon.c
+++ b/CLAPACK-3.2.1/SRC/ssycon.c
@@ -30,7 +30,8 @@ static integer c__1 = 1;
     integer isave[3];
     logical upper;
     extern /* Subroutine */ int slacn2_(integer *, real *, real *, integer *, 
-	    real *, integer *, integer *), xerbla_(char *, integer *);
+	    real *, integer *, integer *);
+    void xerbla_(char *, integer *);
     real ainvnm;
     extern /* Subroutine */ int ssytrs_(char *, integer *, integer *, real *, 
 	    integer *, integer *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/ssyequb.c b/CLAPACK-3.2.1/SRC/ssyequb.c
index 0ed411f..30a0177 100644
--- a/CLAPACK-3.2.1/SRC/ssyequb.c
+++ b/CLAPACK-3.2.1/SRC/ssyequb.c
@@ -38,7 +38,7 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     real sumsq;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     extern /* Subroutine */ int slassq_(integer *, real *, integer *, real *, 
 	    real *);
diff --git a/CLAPACK-3.2.1/SRC/ssyev.c b/CLAPACK-3.2.1/SRC/ssyev.c
index 49319d0..38cc332 100644
--- a/CLAPACK-3.2.1/SRC/ssyev.c
+++ b/CLAPACK-3.2.1/SRC/ssyev.c
@@ -46,7 +46,7 @@ static real c_b17 = 1.f;
     real safmin;
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *, 
 	    real *, integer *, integer *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/ssyevd.c b/CLAPACK-3.2.1/SRC/ssyevd.c
index 430de7d..ad6c30f 100644
--- a/CLAPACK-3.2.1/SRC/ssyevd.c
+++ b/CLAPACK-3.2.1/SRC/ssyevd.c
@@ -47,7 +47,7 @@ static real c_b17 = 1.f;
     real safmin;
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     extern /* Subroutine */ int slascl_(char *, integer *, integer *, real *, 
 	    real *, integer *, integer *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/ssyevr.c b/CLAPACK-3.2.1/SRC/ssyevr.c
index af26cb0..40fbc9d 100644
--- a/CLAPACK-3.2.1/SRC/ssyevr.c
+++ b/CLAPACK-3.2.1/SRC/ssyevr.c
@@ -61,7 +61,7 @@ static integer c_n1 = -1;
     real safmin;
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real abstll, bignum;
     integer indtau, indisp, indiwo, indwkn, liwmin;
     logical tryrac;
diff --git a/CLAPACK-3.2.1/SRC/ssyevx.c b/CLAPACK-3.2.1/SRC/ssyevx.c
index 8b6679c..ae64b88 100644
--- a/CLAPACK-3.2.1/SRC/ssyevx.c
+++ b/CLAPACK-3.2.1/SRC/ssyevx.c
@@ -55,7 +55,7 @@ static integer c_n1 = -1;
     real safmin;
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real abstll, bignum;
     integer indtau, indisp, indiwo, indwkn;
     extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/ssygs2.c b/CLAPACK-3.2.1/SRC/ssygs2.c
index bb683e1..ad9ec91 100644
--- a/CLAPACK-3.2.1/SRC/ssygs2.c
+++ b/CLAPACK-3.2.1/SRC/ssygs2.c
@@ -38,7 +38,8 @@ static real c_b27 = 1.f;
 	    real *, integer *), strmv_(char *, char *, char *, integer *, 
 	    real *, integer *, real *, integer *), 
 	    strsv_(char *, char *, char *, integer *, real *, integer *, real 
-	    *, integer *), xerbla_(char *, integer *);
+	    *, integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/ssygst.c b/CLAPACK-3.2.1/SRC/ssygst.c
index 4dffa59..1b683b1 100644
--- a/CLAPACK-3.2.1/SRC/ssygst.c
+++ b/CLAPACK-3.2.1/SRC/ssygst.c
@@ -41,7 +41,8 @@ static real c_b52 = .5f;
 , integer *), ssygs2_(integer *, 
 	    char *, integer *, real *, integer *, real *, integer *, integer *
 ), ssyr2k_(char *, char *, integer *, integer *, real *, 
-	    real *, integer *, real *, integer *, real *, real *, integer *), xerbla_(char *, integer *);
+	    real *, integer *, real *, integer *, real *, real *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/ssygv.c b/CLAPACK-3.2.1/SRC/ssygv.c
index b27e8d5..7286065 100644
--- a/CLAPACK-3.2.1/SRC/ssygv.c
+++ b/CLAPACK-3.2.1/SRC/ssygv.c
@@ -38,7 +38,8 @@ static real c_b16 = 1.f;
     extern /* Subroutine */ int strsm_(char *, char *, char *, char *, 
 	    integer *, integer *, real *, real *, integer *, real *, integer *
 ), ssyev_(char *, char *, integer 
-	    *, real *, integer *, real *, real *, integer *, integer *), xerbla_(char *, integer *);
+	    *, real *, integer *, real *, real *, integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer lwkmin;
diff --git a/CLAPACK-3.2.1/SRC/ssygvd.c b/CLAPACK-3.2.1/SRC/ssygvd.c
index fb1a2d0..464b50f 100644
--- a/CLAPACK-3.2.1/SRC/ssygvd.c
+++ b/CLAPACK-3.2.1/SRC/ssygvd.c
@@ -38,7 +38,8 @@ static real c_b11 = 1.f;
     logical wantz;
     extern /* Subroutine */ int strsm_(char *, char *, char *, char *, 
 	    integer *, integer *, real *, real *, integer *, real *, integer *
-), xerbla_(char *, integer *);
+);
+    void xerbla_(char *, integer *);
     integer liwmin;
     extern /* Subroutine */ int spotrf_(char *, integer *, real *, integer *, 
 	    integer *), ssyevd_(char *, char *, integer *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/ssygvx.c b/CLAPACK-3.2.1/SRC/ssygvx.c
index 28c8c3a..3c996a5 100644
--- a/CLAPACK-3.2.1/SRC/ssygvx.c
+++ b/CLAPACK-3.2.1/SRC/ssygvx.c
@@ -41,7 +41,7 @@ static real c_b19 = 1.f;
 	    integer *, integer *, real *, real *, integer *, real *, integer *
 );
     logical alleig, indeig, valeig;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer lwkmin;
diff --git a/CLAPACK-3.2.1/SRC/ssyrfs.c b/CLAPACK-3.2.1/SRC/ssyrfs.c
index 09a9585..1d8e6e5 100644
--- a/CLAPACK-3.2.1/SRC/ssyrfs.c
+++ b/CLAPACK-3.2.1/SRC/ssyrfs.c
@@ -47,7 +47,7 @@ static real c_b14 = 1.f;
 );
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real lstres;
     extern /* Subroutine */ int ssytrs_(char *, integer *, integer *, real *, 
 	    integer *, integer *, real *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/ssyrfsx.c b/CLAPACK-3.2.1/SRC/ssyrfsx.c
index 056c209..23581c9 100644
--- a/CLAPACK-3.2.1/SRC/ssyrfsx.c
+++ b/CLAPACK-3.2.1/SRC/ssyrfsx.c
@@ -56,7 +56,7 @@ static integer c__1 = 1;
     real anorm;
     logical rcequ;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal slansy_(char *, char *, integer *, real *, integer *, 
 	    real *);
     extern /* Subroutine */ int ssycon_(char *, integer *, real *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/ssysv.c b/CLAPACK-3.2.1/SRC/ssysv.c
index 15b4ef7..5884d31 100644
--- a/CLAPACK-3.2.1/SRC/ssysv.c
+++ b/CLAPACK-3.2.1/SRC/ssysv.c
@@ -28,7 +28,7 @@ static integer c_n1 = -1;
     /* Local variables */
     integer nb;
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/ssysvx.c b/CLAPACK-3.2.1/SRC/ssysvx.c
index df5e801..101012e 100644
--- a/CLAPACK-3.2.1/SRC/ssysvx.c
+++ b/CLAPACK-3.2.1/SRC/ssysvx.c
@@ -34,7 +34,7 @@ static integer c_n1 = -1;
     real anorm;
     extern doublereal slamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/ssysvxx.c b/CLAPACK-3.2.1/SRC/ssysvxx.c
index 29e74dd..119934c 100644
--- a/CLAPACK-3.2.1/SRC/ssysvxx.c
+++ b/CLAPACK-3.2.1/SRC/ssysvxx.c
@@ -40,7 +40,7 @@
     logical equil, rcequ;
     extern doublereal slamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     integer infequ;
     extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/ssytd2.c b/CLAPACK-3.2.1/SRC/ssytd2.c
index f202635..887b0b6 100644
--- a/CLAPACK-3.2.1/SRC/ssytd2.c
+++ b/CLAPACK-3.2.1/SRC/ssytd2.c
@@ -36,8 +36,9 @@ static real c_b14 = -1.f;
     logical upper;
     extern /* Subroutine */ int saxpy_(integer *, real *, real *, integer *, 
 	    real *, integer *), ssymv_(char *, integer *, real *, real *, 
-	    integer *, real *, integer *, real *, real *, integer *), 
-	    xerbla_(char *, integer *), slarfg_(integer *, real *, 
+	    integer *, real *, integer *, real *, real *, integer *);
+	void xerbla_(char *, integer *);
+    int slarfg_(integer *, real *, 
 	    real *, integer *, real *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/ssytf2.c b/CLAPACK-3.2.1/SRC/ssytf2.c
index 245137d..ff094ff 100644
--- a/CLAPACK-3.2.1/SRC/ssytf2.c
+++ b/CLAPACK-3.2.1/SRC/ssytf2.c
@@ -43,7 +43,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int sswap_(integer *, real *, integer *, real *, 
 	    integer *);
     real absakk;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
     real colmax;
     extern logical sisnan_(real *);
diff --git a/CLAPACK-3.2.1/SRC/ssytrd.c b/CLAPACK-3.2.1/SRC/ssytrd.c
index d4fe7b4..f33c47a 100644
--- a/CLAPACK-3.2.1/SRC/ssytrd.c
+++ b/CLAPACK-3.2.1/SRC/ssytrd.c
@@ -37,7 +37,8 @@ static real c_b23 = 1.f;
     extern /* Subroutine */ int ssytd2_(char *, integer *, real *, integer *, 
 	    real *, real *, real *, integer *), ssyr2k_(char *, char *
 , integer *, integer *, real *, real *, integer *, real *, 
-	    integer *, real *, real *, integer *), xerbla_(
+	    integer *, real *, real *, integer *);
+    void xerbla_(
 	    char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/ssytrf.c b/CLAPACK-3.2.1/SRC/ssytrf.c
index bc70303..f3b43b4 100644
--- a/CLAPACK-3.2.1/SRC/ssytrf.c
+++ b/CLAPACK-3.2.1/SRC/ssytrf.c
@@ -31,7 +31,8 @@ static integer c__2 = 2;
     integer nbmin, iinfo;
     logical upper;
     extern /* Subroutine */ int ssytf2_(char *, integer *, real *, integer *, 
-	    integer *, integer *), xerbla_(char *, integer *);
+	    integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int slasyf_(char *, integer *, integer *, integer 
diff --git a/CLAPACK-3.2.1/SRC/ssytri.c b/CLAPACK-3.2.1/SRC/ssytri.c
index 24700ba..eae5685 100644
--- a/CLAPACK-3.2.1/SRC/ssytri.c
+++ b/CLAPACK-3.2.1/SRC/ssytri.c
@@ -40,7 +40,8 @@ static real c_b13 = 0.f;
     extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *, 
 	    integer *), sswap_(integer *, real *, integer *, real *, integer *
 ), ssymv_(char *, integer *, real *, real *, integer *, real *, 
-	    integer *, real *, real *, integer *), xerbla_(char *, 
+	    integer *, real *, real *, integer *);
+    void xerbla_(char *, 
 	    integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/ssytrs.c b/CLAPACK-3.2.1/SRC/ssytrs.c
index a27e5e1..1426b36 100644
--- a/CLAPACK-3.2.1/SRC/ssytrs.c
+++ b/CLAPACK-3.2.1/SRC/ssytrs.c
@@ -41,7 +41,8 @@ static real c_b19 = 1.f;
 	    real *, integer *, real *, real *, integer *);
     logical upper;
     extern /* Subroutine */ int sswap_(integer *, real *, integer *, real *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/stbcon.c b/CLAPACK-3.2.1/SRC/stbcon.c
index a567270..f1bd3f3 100644
--- a/CLAPACK-3.2.1/SRC/stbcon.c
+++ b/CLAPACK-3.2.1/SRC/stbcon.c
@@ -37,7 +37,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int slacn2_(integer *, real *, real *, integer *, 
 	    real *, integer *, integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
     extern doublereal slantb_(char *, char *, char *, integer *, integer *, 
 	    real *, integer *, real *);
diff --git a/CLAPACK-3.2.1/SRC/stbrfs.c b/CLAPACK-3.2.1/SRC/stbrfs.c
index 3ef7749..1327e14 100644
--- a/CLAPACK-3.2.1/SRC/stbrfs.c
+++ b/CLAPACK-3.2.1/SRC/stbrfs.c
@@ -48,7 +48,7 @@ static real c_b19 = -1.f;
 );
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
     char transt[1];
     logical nounit;
diff --git a/CLAPACK-3.2.1/SRC/stbtrs.c b/CLAPACK-3.2.1/SRC/stbtrs.c
index 3fdcfa2..6581bd5 100644
--- a/CLAPACK-3.2.1/SRC/stbtrs.c
+++ b/CLAPACK-3.2.1/SRC/stbtrs.c
@@ -29,7 +29,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     logical upper;
     extern /* Subroutine */ int stbsv_(char *, char *, char *, integer *, 
-	    integer *, real *, integer *, real *, integer *), xerbla_(char *, integer *);
+	    integer *, real *, integer *, real *, integer *);
+    void xerbla_(char *, integer *);
     logical nounit;
 
 
diff --git a/CLAPACK-3.2.1/SRC/stfsm.c b/CLAPACK-3.2.1/SRC/stfsm.c
index caec119..0a0ad1d 100644
--- a/CLAPACK-3.2.1/SRC/stfsm.c
+++ b/CLAPACK-3.2.1/SRC/stfsm.c
@@ -35,7 +35,8 @@ static real c_b27 = 1.f;
     logical lower;
     extern /* Subroutine */ int strsm_(char *, char *, char *, char *, 
 	    integer *, integer *, real *, real *, integer *, real *, integer *
-), xerbla_(char *, integer *);
+);
+    void xerbla_(char *, integer *);
     logical misodd, nisodd, notrans;
 
 
diff --git a/CLAPACK-3.2.1/SRC/stftri.c b/CLAPACK-3.2.1/SRC/stftri.c
index ac83c97..8f8f9ca 100644
--- a/CLAPACK-3.2.1/SRC/stftri.c
+++ b/CLAPACK-3.2.1/SRC/stftri.c
@@ -31,7 +31,8 @@ static real c_b18 = 1.f;
     logical lower;
     extern /* Subroutine */ int strmm_(char *, char *, char *, char *, 
 	    integer *, integer *, real *, real *, integer *, real *, integer *
-), xerbla_(char *, integer *);
+);
+    void xerbla_(char *, integer *);
     logical nisodd;
     extern /* Subroutine */ int strtri_(char *, char *, integer *, real *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/stfttp.c b/CLAPACK-3.2.1/SRC/stfttp.c
index 2c10db5..ba2aa77 100644
--- a/CLAPACK-3.2.1/SRC/stfttp.c
+++ b/CLAPACK-3.2.1/SRC/stfttp.c
@@ -24,7 +24,7 @@
     logical normaltransr;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd;
 
 
diff --git a/CLAPACK-3.2.1/SRC/stfttr.c b/CLAPACK-3.2.1/SRC/stfttr.c
index c085b80..c7525ec 100644
--- a/CLAPACK-3.2.1/SRC/stfttr.c
+++ b/CLAPACK-3.2.1/SRC/stfttr.c
@@ -24,7 +24,7 @@
     logical normaltransr;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd;
 
 
diff --git a/CLAPACK-3.2.1/SRC/stgevc.c b/CLAPACK-3.2.1/SRC/stgevc.c
index aa7e3f4..effe46d 100644
--- a/CLAPACK-3.2.1/SRC/stgevc.c
+++ b/CLAPACK-3.2.1/SRC/stgevc.c
@@ -65,7 +65,7 @@ static logical c_false = FALSE_;
     real bcoefi, ascale, bscale, creala, crealb, bcoefr;
     extern doublereal slamch_(char *);
     real salfar, safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real xscale, bignum;
     logical ilcomp, ilcplx;
     extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/stgexc.c b/CLAPACK-3.2.1/SRC/stgexc.c
index 1255ee0..7f44b51 100644
--- a/CLAPACK-3.2.1/SRC/stgexc.c
+++ b/CLAPACK-3.2.1/SRC/stgexc.c
@@ -32,7 +32,8 @@ static integer c__2 = 2;
     extern /* Subroutine */ int stgex2_(logical *, logical *, integer *, real 
 	    *, integer *, real *, integer *, real *, integer *, real *, 
 	    integer *, integer *, integer *, integer *, real *, integer *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     integer nbnext;
     logical lquery;
 
diff --git a/CLAPACK-3.2.1/SRC/stgsen.c b/CLAPACK-3.2.1/SRC/stgsen.c
index 93d55c1..ba5d480 100644
--- a/CLAPACK-3.2.1/SRC/stgsen.c
+++ b/CLAPACK-3.2.1/SRC/stgsen.c
@@ -53,7 +53,8 @@ static real c_b28 = 1.f;
     logical wantd1, wantd2;
     real dscale, rdscal;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), slacpy_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slacpy_(
 	    char *, integer *, integer *, real *, integer *, real *, integer *
 ), stgexc_(logical *, logical *, integer *, real *, 
 	    integer *, real *, integer *, real *, integer *, real *, integer *
diff --git a/CLAPACK-3.2.1/SRC/stgsja.c b/CLAPACK-3.2.1/SRC/stgsja.c
index 677fbe3..afa9bdb 100644
--- a/CLAPACK-3.2.1/SRC/stgsja.c
+++ b/CLAPACK-3.2.1/SRC/stgsja.c
@@ -46,7 +46,8 @@ static real c_b43 = -1.f;
 	    integer *), slags2_(logical *, real *, real *, real *, real *, 
 	    real *, real *, real *, real *, real *, real *, real *, real *);
     integer kcycle;
-    extern /* Subroutine */ int xerbla_(char *, integer *), slapll_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slapll_(
 	    integer *, real *, integer *, real *, integer *, real *), slartg_(
 	    real *, real *, real *, real *, real *), slaset_(char *, integer *
 , integer *, real *, real *, real *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/stgsna.c b/CLAPACK-3.2.1/SRC/stgsna.c
index d469299..ee26e0f 100644
--- a/CLAPACK-3.2.1/SRC/stgsna.c
+++ b/CLAPACK-3.2.1/SRC/stgsna.c
@@ -64,7 +64,7 @@ static integer c__3 = 3;
     extern doublereal slapy2_(real *, real *);
     real dummy1[1], alphai, alphar;
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical wantbh, wantdf;
     extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *, 
 	    integer *, real *, integer *), stgexc_(logical *, logical 
diff --git a/CLAPACK-3.2.1/SRC/stgsy2.c b/CLAPACK-3.2.1/SRC/stgsy2.c
index 4c3cd04..a212b7a 100644
--- a/CLAPACK-3.2.1/SRC/stgsy2.c
+++ b/CLAPACK-3.2.1/SRC/stgsy2.c
@@ -52,8 +52,10 @@ static real c_b56 = 0.f;
 	    integer *, integer *);
     real scaloc;
     extern /* Subroutine */ int slatdf_(integer *, integer *, real *, integer 
-	    *, real *, real *, real *, integer *, integer *), xerbla_(char *, 
-	    integer *), slaset_(char *, integer *, integer *, real *, 
+	    *, real *, real *, real *, integer *, integer *);
+    void xerbla_(char *, 
+	    integer *);
+    int slaset_(char *, integer *, integer *, real *, 
 	    real *, real *, integer *);
     logical notran;
 
diff --git a/CLAPACK-3.2.1/SRC/stgsyl.c b/CLAPACK-3.2.1/SRC/stgsyl.c
index 33b33c7..115e2fd 100644
--- a/CLAPACK-3.2.1/SRC/stgsyl.c
+++ b/CLAPACK-3.2.1/SRC/stgsyl.c
@@ -55,7 +55,7 @@ static real c_b52 = 1.f;
 , integer *, real *, integer *, real *, integer *, real *, real *, 
 	     real *, integer *, integer *, integer *);
     real scaloc;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/stpcon.c b/CLAPACK-3.2.1/SRC/stpcon.c
index e16cac8..594e768 100644
--- a/CLAPACK-3.2.1/SRC/stpcon.c
+++ b/CLAPACK-3.2.1/SRC/stpcon.c
@@ -36,7 +36,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int slacn2_(integer *, real *, real *, integer *, 
 	    real *, integer *, integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
     real ainvnm;
     logical onenrm;
diff --git a/CLAPACK-3.2.1/SRC/stprfs.c b/CLAPACK-3.2.1/SRC/stprfs.c
index f72c96b..8738971 100644
--- a/CLAPACK-3.2.1/SRC/stprfs.c
+++ b/CLAPACK-3.2.1/SRC/stprfs.c
@@ -46,7 +46,7 @@ static real c_b19 = -1.f;
 	    integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
     char transt[1];
     logical nounit;
diff --git a/CLAPACK-3.2.1/SRC/stptri.c b/CLAPACK-3.2.1/SRC/stptri.c
index 3f98bb2..80d6f74 100644
--- a/CLAPACK-3.2.1/SRC/stptri.c
+++ b/CLAPACK-3.2.1/SRC/stptri.c
@@ -30,7 +30,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *);
     logical upper;
     extern /* Subroutine */ int stpmv_(char *, char *, char *, integer *, 
-	    real *, real *, integer *), xerbla_(char *
+	    real *, real *, integer *);
+    void xerbla_(char *
 , integer *);
     integer jclast;
     logical nounit;
diff --git a/CLAPACK-3.2.1/SRC/stptrs.c b/CLAPACK-3.2.1/SRC/stptrs.c
index 4835333..b4a0439 100644
--- a/CLAPACK-3.2.1/SRC/stptrs.c
+++ b/CLAPACK-3.2.1/SRC/stptrs.c
@@ -28,7 +28,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     logical upper;
     extern /* Subroutine */ int stpsv_(char *, char *, char *, integer *, 
-	    real *, real *, integer *), xerbla_(char *
+	    real *, real *, integer *);
+    void xerbla_(char *
 , integer *);
     logical nounit;
 
diff --git a/CLAPACK-3.2.1/SRC/stpttf.c b/CLAPACK-3.2.1/SRC/stpttf.c
index 298f266..cfe4fc5 100644
--- a/CLAPACK-3.2.1/SRC/stpttf.c
+++ b/CLAPACK-3.2.1/SRC/stpttf.c
@@ -24,7 +24,7 @@
     logical normaltransr;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd;
 
 
diff --git a/CLAPACK-3.2.1/SRC/stpttr.c b/CLAPACK-3.2.1/SRC/stpttr.c
index 123038f..5430a20 100644
--- a/CLAPACK-3.2.1/SRC/stpttr.c
+++ b/CLAPACK-3.2.1/SRC/stpttr.c
@@ -23,7 +23,7 @@
     integer i__, j, k;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2)                                    -- */
diff --git a/CLAPACK-3.2.1/SRC/strcon.c b/CLAPACK-3.2.1/SRC/strcon.c
index 430ca58..eb754f5 100644
--- a/CLAPACK-3.2.1/SRC/strcon.c
+++ b/CLAPACK-3.2.1/SRC/strcon.c
@@ -37,7 +37,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int slacn2_(integer *, real *, real *, integer *, 
 	    real *, integer *, integer *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer isamax_(integer *, real *, integer *);
     real ainvnm;
     logical onenrm;
diff --git a/CLAPACK-3.2.1/SRC/strevc.c b/CLAPACK-3.2.1/SRC/strevc.c
index 1c95a80..9933357 100644
--- a/CLAPACK-3.2.1/SRC/strevc.c
+++ b/CLAPACK-3.2.1/SRC/strevc.c
@@ -65,7 +65,7 @@ static logical c_true = TRUE_;
 	    real *, real *, real *, integer *, real *, real *, integer *), 
 	    slabad_(real *, real *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     extern integer isamax_(integer *, real *, integer *);
     logical rightv;
diff --git a/CLAPACK-3.2.1/SRC/strexc.c b/CLAPACK-3.2.1/SRC/strexc.c
index cc8c88f..4809167 100644
--- a/CLAPACK-3.2.1/SRC/strexc.c
+++ b/CLAPACK-3.2.1/SRC/strexc.c
@@ -29,7 +29,8 @@ static integer c__2 = 2;
     integer nbf, nbl, here;
     extern logical lsame_(char *, char *);
     logical wantq;
-    extern /* Subroutine */ int xerbla_(char *, integer *), slaexc_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  slaexc_(
 	    logical *, integer *, real *, integer *, real *, integer *, 
 	    integer *, integer *, integer *, real *, integer *);
     integer nbnext;
diff --git a/CLAPACK-3.2.1/SRC/strrfs.c b/CLAPACK-3.2.1/SRC/strrfs.c
index b914b0e..026096f 100644
--- a/CLAPACK-3.2.1/SRC/strrfs.c
+++ b/CLAPACK-3.2.1/SRC/strrfs.c
@@ -47,7 +47,7 @@ static real c_b19 = -1.f;
 	    real *, integer *, real *, integer *, integer *);
     extern doublereal slamch_(char *);
     real safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
     char transt[1];
     logical nounit;
diff --git a/CLAPACK-3.2.1/SRC/strsen.c b/CLAPACK-3.2.1/SRC/strsen.c
index 8698273..406cd00 100644
--- a/CLAPACK-3.2.1/SRC/strsen.c
+++ b/CLAPACK-3.2.1/SRC/strsen.c
@@ -45,7 +45,7 @@ static integer c_n1 = -1;
 	    real *, integer *, integer *);
     extern doublereal slange_(char *, integer *, integer *, real *, integer *, 
 	     real *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical wantbh;
     extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *, 
 	    integer *, real *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/strsna.c b/CLAPACK-3.2.1/SRC/strsna.c
index 9631f4c..d73551c 100644
--- a/CLAPACK-3.2.1/SRC/strsna.c
+++ b/CLAPACK-3.2.1/SRC/strsna.c
@@ -58,7 +58,7 @@ static logical c_false = FALSE_;
     extern doublereal slapy2_(real *, real *);
     extern /* Subroutine */ int slabad_(real *, real *);
     extern doublereal slamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     logical wantbh;
     extern /* Subroutine */ int slacpy_(char *, integer *, integer *, real *, 
diff --git a/CLAPACK-3.2.1/SRC/strsyl.c b/CLAPACK-3.2.1/SRC/strsyl.c
index 42a1b4c..d2dd7a1 100644
--- a/CLAPACK-3.2.1/SRC/strsyl.c
+++ b/CLAPACK-3.2.1/SRC/strsyl.c
@@ -53,7 +53,7 @@ static logical c_true = TRUE_;
     real scaloc;
     extern doublereal slamch_(char *), slange_(char *, integer *, 
 	    integer *, real *, integer *, real *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     real bignum;
     logical notrna, notrnb;
     real smlnum;
diff --git a/CLAPACK-3.2.1/SRC/strti2.c b/CLAPACK-3.2.1/SRC/strti2.c
index e8edd48..bfa2cfc 100644
--- a/CLAPACK-3.2.1/SRC/strti2.c
+++ b/CLAPACK-3.2.1/SRC/strti2.c
@@ -30,8 +30,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *);
     logical upper;
     extern /* Subroutine */ int strmv_(char *, char *, char *, integer *, 
-	    real *, integer *, real *, integer *), 
-	    xerbla_(char *, integer *);
+	    real *, integer *, real *, integer *);
+	void xerbla_(char *, integer *);
     logical nounit;
 
 
diff --git a/CLAPACK-3.2.1/SRC/strtri.c b/CLAPACK-3.2.1/SRC/strtri.c
index f9cc55e..83e1d27 100644
--- a/CLAPACK-3.2.1/SRC/strtri.c
+++ b/CLAPACK-3.2.1/SRC/strtri.c
@@ -30,7 +30,7 @@ static real c_b22 = -1.f;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer j, jb, nb, nn;
@@ -41,8 +41,8 @@ static real c_b22 = -1.f;
 ), strsm_(char *, char *, char *, 
 	    char *, integer *, integer *, real *, real *, integer *, real *, 
 	    integer *), strti2_(char *, char *
-, integer *, real *, integer *, integer *), 
-	    xerbla_(char *, integer *);
+, integer *, real *, integer *, integer *);
+	void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical nounit;
diff --git a/CLAPACK-3.2.1/SRC/strtrs.c b/CLAPACK-3.2.1/SRC/strtrs.c
index d7f1baa..eb67e57 100644
--- a/CLAPACK-3.2.1/SRC/strtrs.c
+++ b/CLAPACK-3.2.1/SRC/strtrs.c
@@ -28,7 +28,8 @@ static real c_b12 = 1.f;
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int strsm_(char *, char *, char *, char *, 
 	    integer *, integer *, real *, real *, integer *, real *, integer *
-), xerbla_(char *, integer *);
+);
+    void xerbla_(char *, integer *);
     logical nounit;
 
 
diff --git a/CLAPACK-3.2.1/SRC/strttf.c b/CLAPACK-3.2.1/SRC/strttf.c
index eb0993b..d29a2a4 100644
--- a/CLAPACK-3.2.1/SRC/strttf.c
+++ b/CLAPACK-3.2.1/SRC/strttf.c
@@ -24,7 +24,7 @@
     logical normaltransr;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd;
 
 
diff --git a/CLAPACK-3.2.1/SRC/strttp.c b/CLAPACK-3.2.1/SRC/strttp.c
index 2d4f203..68bffe6 100644
--- a/CLAPACK-3.2.1/SRC/strttp.c
+++ b/CLAPACK-3.2.1/SRC/strttp.c
@@ -23,7 +23,7 @@
     integer i__, j, k;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/stzrqf.c b/CLAPACK-3.2.1/SRC/stzrqf.c
index 1a31566..f4b1a30 100644
--- a/CLAPACK-3.2.1/SRC/stzrqf.c
+++ b/CLAPACK-3.2.1/SRC/stzrqf.c
@@ -32,8 +32,9 @@ static real c_b8 = 1.f;
 	    integer *, integer *, real *, real *, integer *, real *, integer *
 , real *, real *, integer *), scopy_(integer *, real *, 
 	    integer *, real *, integer *), saxpy_(integer *, real *, real *, 
-	    integer *, real *, integer *), xerbla_(char *, integer *),
-	     slarfp_(integer *, real *, real *, integer *, real *);
+	    integer *, real *, integer *);
+    void xerbla_(char *, integer *);
+    int slarfp_(integer *, real *, real *, integer *, real *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/stzrzf.c b/CLAPACK-3.2.1/SRC/stzrzf.c
index c555951..49a1fc8 100644
--- a/CLAPACK-3.2.1/SRC/stzrzf.c
+++ b/CLAPACK-3.2.1/SRC/stzrzf.c
@@ -28,7 +28,7 @@ static integer c__2 = 2;
 
     /* Local variables */
     integer i__, m1, ib, nb, ki, kk, mu, nx, iws, nbmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int slarzb_(char *, char *, char *, char *, 
diff --git a/CLAPACK-3.2.1/SRC/xerbla.c b/CLAPACK-3.2.1/SRC/xerbla.c
index fb4a9d8..d142dde 100644
--- a/CLAPACK-3.2.1/SRC/xerbla.c
+++ b/CLAPACK-3.2.1/SRC/xerbla.c
@@ -18,7 +18,7 @@
 
 static integer c__1 = 1;
 
-/* Subroutine */ int xerbla_(char *srname, integer *info)
+/* Subroutine */ void xerbla_(char *srname, integer *info)
 {
     
 
@@ -61,5 +61,5 @@ static integer c__1 = 1;
 
 /*     End of XERBLA */
 
-    return 0;
+    return;
 } /* xerbla_ */
diff --git a/CLAPACK-3.2.1/SRC/xerbla_array.c b/CLAPACK-3.2.1/SRC/xerbla_array.c
index d4e4c24..9d79ae4 100644
--- a/CLAPACK-3.2.1/SRC/xerbla_array.c
+++ b/CLAPACK-3.2.1/SRC/xerbla_array.c
@@ -20,12 +20,12 @@
     integer i__1, i__2, i__3;
 
     /* Builtin functions */
-    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
+    /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
     integer i_len(char *, ftnlen);
 
     /* Local variables */
     integer i__;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     char srname[32];
 
 
diff --git a/CLAPACK-3.2.1/SRC/zbdsqr.c b/CLAPACK-3.2.1/SRC/zbdsqr.c
index 7ab5c2d..d3f778f 100644
--- a/CLAPACK-3.2.1/SRC/zbdsqr.c
+++ b/CLAPACK-3.2.1/SRC/zbdsqr.c
@@ -67,8 +67,10 @@ static doublereal c_b72 = -1.;
 	    doublereal *, doublereal *, doublereal *);
     extern doublereal dlamch_(char *);
     extern /* Subroutine */ int dlartg_(doublereal *, doublereal *, 
-	    doublereal *, doublereal *, doublereal *), xerbla_(char *, 
-	    integer *), zdscal_(integer *, doublereal *, 
+	    doublereal *, doublereal *, doublereal *);
+    void xerbla_(char *, 
+	    integer *);
+    int zdscal_(integer *, doublereal *, 
 	    doublecomplex *, integer *);
     doublereal sminoa, thresh;
     logical rotate;
diff --git a/CLAPACK-3.2.1/SRC/zcgesv.c b/CLAPACK-3.2.1/SRC/zcgesv.c
index 796322c..66b0780 100644
--- a/CLAPACK-3.2.1/SRC/zcgesv.c
+++ b/CLAPACK-3.2.1/SRC/zcgesv.c
@@ -48,7 +48,8 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *, complex *, integer *, integer *);
     extern doublereal dlamch_(char *);
     extern /* Subroutine */ int cgetrf_(integer *, integer *, complex *, 
-	    integer *, integer *, integer *), xerbla_(char *, integer *);
+	    integer *, integer *, integer *);
+    void xerbla_(char *, integer *);
     extern doublereal zlange_(char *, integer *, integer *, doublecomplex *, 
 	    integer *, doublereal *);
     extern /* Subroutine */ int cgetrs_(char *, integer *, integer *, complex 
diff --git a/CLAPACK-3.2.1/SRC/zcposv.c b/CLAPACK-3.2.1/SRC/zcposv.c
index 5a2d9c9..90c1691 100644
--- a/CLAPACK-3.2.1/SRC/zcposv.c
+++ b/CLAPACK-3.2.1/SRC/zcposv.c
@@ -49,7 +49,7 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *, integer *), zlat2c_(char *, integer *, 
 	     doublecomplex *, integer *, complex *, integer *, integer *);
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal zlanhe_(char *, char *, integer *, doublecomplex *, 
 	    integer *, doublereal *);
     extern integer izamax_(integer *, doublecomplex *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zgbbrd.c b/CLAPACK-3.2.1/SRC/zgbbrd.c
index 64be234..255bc3b 100644
--- a/CLAPACK-3.2.1/SRC/zgbbrd.c
+++ b/CLAPACK-3.2.1/SRC/zgbbrd.c
@@ -52,7 +52,8 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *);
     integer minmn;
     logical wantq;
-    extern /* Subroutine */ int xerbla_(char *, integer *), zlaset_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zlaset_(
 	    char *, integer *, integer *, doublecomplex *, doublecomplex *, 
 	    doublecomplex *, integer *), zlartg_(doublecomplex *, 
 	    doublecomplex *, doublereal *, doublecomplex *, doublecomplex *), 
diff --git a/CLAPACK-3.2.1/SRC/zgbcon.c b/CLAPACK-3.2.1/SRC/zgbcon.c
index 8f72f3f..b4975e6 100644
--- a/CLAPACK-3.2.1/SRC/zgbcon.c
+++ b/CLAPACK-3.2.1/SRC/zgbcon.c
@@ -45,7 +45,7 @@ static integer c__1 = 1;
 	    integer *, doublecomplex *, doublecomplex *, doublereal *, 
 	    integer *, integer *);
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal ainvnm;
     extern integer izamax_(integer *, doublecomplex *, integer *);
     logical onenrm;
diff --git a/CLAPACK-3.2.1/SRC/zgbequ.c b/CLAPACK-3.2.1/SRC/zgbequ.c
index c9e6d27..dce0d52 100644
--- a/CLAPACK-3.2.1/SRC/zgbequ.c
+++ b/CLAPACK-3.2.1/SRC/zgbequ.c
@@ -29,7 +29,7 @@
     integer i__, j, kd;
     doublereal rcmin, rcmax;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum, smlnum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/zgbequb.c b/CLAPACK-3.2.1/SRC/zgbequb.c
index 80c59a9..b0c0222 100644
--- a/CLAPACK-3.2.1/SRC/zgbequb.c
+++ b/CLAPACK-3.2.1/SRC/zgbequb.c
@@ -30,7 +30,7 @@
     integer i__, j, kd;
     doublereal radix, rcmin, rcmax;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum, logrdx, smlnum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/zgbrfs.c b/CLAPACK-3.2.1/SRC/zgbrfs.c
index f382760..73cd0fd 100644
--- a/CLAPACK-3.2.1/SRC/zgbrfs.c
+++ b/CLAPACK-3.2.1/SRC/zgbrfs.c
@@ -56,7 +56,7 @@ static integer c__1 = 1;
 	    integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
     char transn[1], transt[1];
     doublereal lstres;
diff --git a/CLAPACK-3.2.1/SRC/zgbrfsx.c b/CLAPACK-3.2.1/SRC/zgbrfsx.c
index b3c9c74..345c6c1 100644
--- a/CLAPACK-3.2.1/SRC/zgbrfsx.c
+++ b/CLAPACK-3.2.1/SRC/zgbrfsx.c
@@ -63,7 +63,7 @@ static logical c_false = FALSE_;
 	    *, doublecomplex *, integer *, doublecomplex *, integer *, 
 	    integer *, doublecomplex *, integer *, doublecomplex *, 
 	    doublereal *, ftnlen), dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal zlangb_(char *, integer *, integer *, integer *, 
 	    doublecomplex *, integer *, doublereal *);
     extern /* Subroutine */ int zgbcon_(char *, integer *, integer *, integer 
diff --git a/CLAPACK-3.2.1/SRC/zgbsv.c b/CLAPACK-3.2.1/SRC/zgbsv.c
index 7be165e..7a15ba5 100644
--- a/CLAPACK-3.2.1/SRC/zgbsv.c
+++ b/CLAPACK-3.2.1/SRC/zgbsv.c
@@ -21,7 +21,8 @@
     integer ab_dim1, ab_offset, b_dim1, b_offset, i__1;
 
     /* Local variables */
-    extern /* Subroutine */ int xerbla_(char *, integer *), zgbtrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zgbtrf_(
 	    integer *, integer *, integer *, integer *, doublecomplex *, 
 	    integer *, integer *, integer *), zgbtrs_(char *, integer *, 
 	    integer *, integer *, integer *, doublecomplex *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zgbsvx.c b/CLAPACK-3.2.1/SRC/zgbsvx.c
index 860abf5..0fd570d 100644
--- a/CLAPACK-3.2.1/SRC/zgbsvx.c
+++ b/CLAPACK-3.2.1/SRC/zgbsvx.c
@@ -48,7 +48,8 @@ static integer c__1 = 1;
     logical nofact;
     extern doublereal zlangb_(char *, integer *, integer *, integer *, 
 	    doublecomplex *, integer *, doublereal *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), zlaqgb_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zlaqgb_(
 	    integer *, integer *, integer *, integer *, doublecomplex *, 
 	    integer *, doublereal *, doublereal *, doublereal *, doublereal *, 
 	     doublereal *, char *);
diff --git a/CLAPACK-3.2.1/SRC/zgbsvxx.c b/CLAPACK-3.2.1/SRC/zgbsvxx.c
index 88d7bba..f0f4981 100644
--- a/CLAPACK-3.2.1/SRC/zgbsvxx.c
+++ b/CLAPACK-3.2.1/SRC/zgbsvxx.c
@@ -39,7 +39,8 @@
     extern doublereal dlamch_(char *);
     doublereal colcnd;
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *), zlaqgb_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zlaqgb_(
 	    integer *, integer *, integer *, integer *, doublecomplex *, 
 	    integer *, doublereal *, doublereal *, doublereal *, doublereal *, 
 	     doublereal *, char *);
diff --git a/CLAPACK-3.2.1/SRC/zgbtf2.c b/CLAPACK-3.2.1/SRC/zgbtf2.c
index 354252c..38fbb10 100644
--- a/CLAPACK-3.2.1/SRC/zgbtf2.c
+++ b/CLAPACK-3.2.1/SRC/zgbtf2.c
@@ -34,7 +34,8 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *), zgeru_(integer *, integer *, 
 	    doublecomplex *, doublecomplex *, integer *, doublecomplex *, 
 	    integer *, doublecomplex *, integer *), zswap_(integer *, 
-	    doublecomplex *, integer *, doublecomplex *, integer *), xerbla_(
+	    doublecomplex *, integer *, doublecomplex *, integer *);
+    void xerbla_(
 	    char *, integer *);
     extern integer izamax_(integer *, doublecomplex *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/zgbtrf.c b/CLAPACK-3.2.1/SRC/zgbtrf.c
index 2e5c495..23c3776 100644
--- a/CLAPACK-3.2.1/SRC/zgbtrf.c
+++ b/CLAPACK-3.2.1/SRC/zgbtrf.c
@@ -49,7 +49,8 @@ static integer c__65 = 65;
 	    doublecomplex *, doublecomplex *, integer *, doublecomplex *, 
 	    integer *), zgbtf2_(integer *, 
 	    integer *, integer *, integer *, doublecomplex *, integer *, 
-	    integer *, integer *), xerbla_(char *, integer *);
+	    integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *), izamax_(integer *, 
 	    doublecomplex *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zgbtrs.c b/CLAPACK-3.2.1/SRC/zgbtrs.c
index a4c641a..64ac5f2 100644
--- a/CLAPACK-3.2.1/SRC/zgbtrs.c
+++ b/CLAPACK-3.2.1/SRC/zgbtrs.c
@@ -37,7 +37,9 @@ static integer c__1 = 1;
 	    integer *, doublecomplex *, integer *, doublecomplex *, integer *)
 	    , zswap_(integer *, doublecomplex *, integer *, doublecomplex *, 
 	    integer *), ztbsv_(char *, char *, char *, integer *, integer *, 
-	    doublecomplex *, integer *, doublecomplex *, integer *), xerbla_(char *, integer *), zlacgv_(
+	    doublecomplex *, integer *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
+    int zlacgv_(
 	    integer *, doublecomplex *, integer *);
     logical notran;
 
diff --git a/CLAPACK-3.2.1/SRC/zgebak.c b/CLAPACK-3.2.1/SRC/zgebak.c
index 2e65764..a696b7b 100644
--- a/CLAPACK-3.2.1/SRC/zgebak.c
+++ b/CLAPACK-3.2.1/SRC/zgebak.c
@@ -27,8 +27,9 @@
     extern logical lsame_(char *, char *);
     logical leftv;
     extern /* Subroutine */ int zswap_(integer *, doublecomplex *, integer *, 
-	    doublecomplex *, integer *), xerbla_(char *, integer *), 
-	    zdscal_(integer *, doublereal *, doublecomplex *, integer *);
+	    doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
+    int zdscal_(integer *, doublereal *, doublecomplex *, integer *);
     logical rightv;
 
 
diff --git a/CLAPACK-3.2.1/SRC/zgebal.c b/CLAPACK-3.2.1/SRC/zgebal.c
index a7bfca2..293b448 100644
--- a/CLAPACK-3.2.1/SRC/zgebal.c
+++ b/CLAPACK-3.2.1/SRC/zgebal.c
@@ -37,7 +37,8 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *);
     doublereal sfmin1, sfmin2, sfmax1, sfmax2;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zdscal_(
 	    integer *, doublereal *, doublecomplex *, integer *);
     extern integer izamax_(integer *, doublecomplex *, integer *);
     logical noconv;
diff --git a/CLAPACK-3.2.1/SRC/zgebd2.c b/CLAPACK-3.2.1/SRC/zgebd2.c
index 8522fa8..70f85b4 100644
--- a/CLAPACK-3.2.1/SRC/zgebd2.c
+++ b/CLAPACK-3.2.1/SRC/zgebd2.c
@@ -33,7 +33,9 @@ static integer c__1 = 1;
     doublecomplex alpha;
     extern /* Subroutine */ int zlarf_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *, doublecomplex *), xerbla_(char *, integer *), zlarfg_(integer *, doublecomplex *, doublecomplex *, 
+	    integer *, doublecomplex *);
+    void xerbla_(char *, integer *);
+    int zlarfg_(integer *, doublecomplex *, doublecomplex *, 
 	    integer *, doublecomplex *), zlacgv_(integer *, doublecomplex *, 
 	    integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/zgebrd.c b/CLAPACK-3.2.1/SRC/zgebrd.c
index 8ec2dff..bd73495 100644
--- a/CLAPACK-3.2.1/SRC/zgebrd.c
+++ b/CLAPACK-3.2.1/SRC/zgebrd.c
@@ -40,8 +40,9 @@ static integer c__2 = 2;
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
 	    integer *), zgebd2_(integer *, integer *, 
 	    doublecomplex *, integer *, doublereal *, doublereal *, 
-	    doublecomplex *, doublecomplex *, doublecomplex *, integer *), 
-	    xerbla_(char *, integer *), zlabrd_(integer *, integer *, 
+	    doublecomplex *, doublecomplex *, doublecomplex *, integer *);
+	void xerbla_(char *, integer *);
+    int zlabrd_(integer *, integer *, 
 	    integer *, doublecomplex *, integer *, doublereal *, doublereal *, 
 	     doublecomplex *, doublecomplex *, doublecomplex *, integer *, 
 	    doublecomplex *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zgecon.c b/CLAPACK-3.2.1/SRC/zgecon.c
index 894ab73..9491078 100644
--- a/CLAPACK-3.2.1/SRC/zgecon.c
+++ b/CLAPACK-3.2.1/SRC/zgecon.c
@@ -39,7 +39,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
 	    doublecomplex *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal ainvnm;
     extern integer izamax_(integer *, doublecomplex *, integer *);
     logical onenrm;
diff --git a/CLAPACK-3.2.1/SRC/zgeequ.c b/CLAPACK-3.2.1/SRC/zgeequ.c
index cb53db4..e93d1f7 100644
--- a/CLAPACK-3.2.1/SRC/zgeequ.c
+++ b/CLAPACK-3.2.1/SRC/zgeequ.c
@@ -28,7 +28,7 @@
     integer i__, j;
     doublereal rcmin, rcmax;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum, smlnum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/zgeequb.c b/CLAPACK-3.2.1/SRC/zgeequb.c
index f284cc3..0c05640 100644
--- a/CLAPACK-3.2.1/SRC/zgeequb.c
+++ b/CLAPACK-3.2.1/SRC/zgeequb.c
@@ -29,7 +29,7 @@
     integer i__, j;
     doublereal radix, rcmin, rcmax;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum, logrdx, smlnum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/zgees.c b/CLAPACK-3.2.1/SRC/zgees.c
index ab32998..f6b6a8e 100644
--- a/CLAPACK-3.2.1/SRC/zgees.c
+++ b/CLAPACK-3.2.1/SRC/zgees.c
@@ -48,7 +48,8 @@ static integer c_n1 = -1;
 	    integer *, doublereal *, integer *, doublecomplex *, integer *, 
 	    integer *), zgebal_(char *, integer *, 
 	    doublecomplex *, integer *, integer *, integer *, doublereal *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern doublereal zlange_(char *, integer *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zgeesx.c b/CLAPACK-3.2.1/SRC/zgeesx.c
index c04109e..bd20d97 100644
--- a/CLAPACK-3.2.1/SRC/zgeesx.c
+++ b/CLAPACK-3.2.1/SRC/zgeesx.c
@@ -49,7 +49,8 @@ static integer c_n1 = -1;
 	    integer *, integer *, doublereal *, integer *, doublecomplex *, 
 	    integer *, integer *), zgebal_(char *, integer *, 
 	    doublecomplex *, integer *, integer *, integer *, doublereal *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern doublereal zlange_(char *, integer *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zgeev.c b/CLAPACK-3.2.1/SRC/zgeev.c
index e4690ac..23a58c5 100644
--- a/CLAPACK-3.2.1/SRC/zgeev.c
+++ b/CLAPACK-3.2.1/SRC/zgeev.c
@@ -57,7 +57,7 @@ static integer c_n1 = -1;
 	    doublecomplex *, integer *, integer *, integer *, doublereal *, 
 	    integer *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical select[1];
diff --git a/CLAPACK-3.2.1/SRC/zgeevx.c b/CLAPACK-3.2.1/SRC/zgeevx.c
index 3b3fbdf..2902029 100644
--- a/CLAPACK-3.2.1/SRC/zgeevx.c
+++ b/CLAPACK-3.2.1/SRC/zgeevx.c
@@ -59,7 +59,7 @@ static integer c_n1 = -1;
 	    doublecomplex *, integer *, integer *, integer *, doublereal *, 
 	    integer *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical select[1];
diff --git a/CLAPACK-3.2.1/SRC/zgegs.c b/CLAPACK-3.2.1/SRC/zgegs.c
index 027abc9..0fe2f0a 100644
--- a/CLAPACK-3.2.1/SRC/zgegs.c
+++ b/CLAPACK-3.2.1/SRC/zgegs.c
@@ -48,7 +48,7 @@ static integer c_n1 = -1;
 , integer *, doublereal *, doublereal *, doublereal *, integer *);
     logical ilascl, ilbscl;
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern doublereal zlange_(char *, integer *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zgegv.c b/CLAPACK-3.2.1/SRC/zgegv.c
index a244aa1..7213f0e 100644
--- a/CLAPACK-3.2.1/SRC/zgegv.c
+++ b/CLAPACK-3.2.1/SRC/zgegv.c
@@ -56,7 +56,7 @@ static doublereal c_b29 = 1.;
 	     doublecomplex *, integer *, doublecomplex *, integer *, integer *
 , integer *, doublereal *, doublereal *, doublereal *, integer *);
     doublereal salfar, safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal safmax;
     char chtemp[1];
     logical ldumma[1];
diff --git a/CLAPACK-3.2.1/SRC/zgehd2.c b/CLAPACK-3.2.1/SRC/zgehd2.c
index af1ba28..8027066 100644
--- a/CLAPACK-3.2.1/SRC/zgehd2.c
+++ b/CLAPACK-3.2.1/SRC/zgehd2.c
@@ -33,7 +33,9 @@ static integer c__1 = 1;
     doublecomplex alpha;
     extern /* Subroutine */ int zlarf_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *, doublecomplex *), xerbla_(char *, integer *), zlarfg_(integer *, doublecomplex *, doublecomplex *, 
+	    integer *, doublecomplex *);
+    void xerbla_(char *, integer *);
+    int zlarfg_(integer *, doublecomplex *, doublecomplex *, 
 	    integer *, doublecomplex *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/zgehrd.c b/CLAPACK-3.2.1/SRC/zgehrd.c
index 0a84ef6..d581054 100644
--- a/CLAPACK-3.2.1/SRC/zgehrd.c
+++ b/CLAPACK-3.2.1/SRC/zgehrd.c
@@ -47,7 +47,8 @@ static integer c__65 = 65;
 	    integer *, doublecomplex *, integer *, doublecomplex *, 
 	    doublecomplex *, integer *), zlahr2_(integer *, integer *, 
 	    integer *, doublecomplex *, integer *, doublecomplex *, 
-	    doublecomplex *, integer *, doublecomplex *, integer *), xerbla_(
+	    doublecomplex *, integer *, doublecomplex *, integer *);
+    void xerbla_(
 	    char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zgelq2.c b/CLAPACK-3.2.1/SRC/zgelq2.c
index 30df244..a9618a4 100644
--- a/CLAPACK-3.2.1/SRC/zgelq2.c
+++ b/CLAPACK-3.2.1/SRC/zgelq2.c
@@ -24,7 +24,9 @@
     doublecomplex alpha;
     extern /* Subroutine */ int zlarf_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *, doublecomplex *), xerbla_(char *, integer *), zlacgv_(integer *, doublecomplex *, integer *), zlarfp_(
+	    integer *, doublecomplex *);
+    void xerbla_(char *, integer *);
+    int zlacgv_(integer *, doublecomplex *, integer *), zlarfp_(
 	    integer *, doublecomplex *, doublecomplex *, integer *, 
 	    doublecomplex *);
 
diff --git a/CLAPACK-3.2.1/SRC/zgelqf.c b/CLAPACK-3.2.1/SRC/zgelqf.c
index 36c16da..154c5ab 100644
--- a/CLAPACK-3.2.1/SRC/zgelqf.c
+++ b/CLAPACK-3.2.1/SRC/zgelqf.c
@@ -30,7 +30,8 @@ static integer c__2 = 2;
     /* Local variables */
     integer i__, k, ib, nb, nx, iws, nbmin, iinfo;
     extern /* Subroutine */ int zgelq2_(integer *, integer *, doublecomplex *, 
-	     integer *, doublecomplex *, doublecomplex *, integer *), xerbla_(
+	     integer *, doublecomplex *, doublecomplex *, integer *);
+    void xerbla_(
 	    char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zgels.c b/CLAPACK-3.2.1/SRC/zgels.c
index dac9e32..d84441c 100644
--- a/CLAPACK-3.2.1/SRC/zgels.c
+++ b/CLAPACK-3.2.1/SRC/zgels.c
@@ -39,7 +39,7 @@ static integer c__0 = 0;
     doublereal rwork[1];
     extern /* Subroutine */ int dlabad_(doublereal *, doublereal *);
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer scllen;
diff --git a/CLAPACK-3.2.1/SRC/zgelsd.c b/CLAPACK-3.2.1/SRC/zgelsd.c
index 9b35320..d32e24f 100644
--- a/CLAPACK-3.2.1/SRC/zgelsd.c
+++ b/CLAPACK-3.2.1/SRC/zgelsd.c
@@ -45,8 +45,9 @@ static doublereal c_b80 = 0.;
     extern /* Subroutine */ int dlascl_(char *, integer *, integer *, 
 	    doublereal *, doublereal *, integer *, integer *, doublereal *, 
 	    integer *, integer *), dlaset_(char *, integer *, integer 
-	    *, doublereal *, doublereal *, doublereal *, integer *), 
-	    xerbla_(char *, integer *), zgebrd_(integer *, integer *, 
+	    *, doublereal *, doublereal *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
+    int zgebrd_(integer *, integer *, 
 	    doublecomplex *, integer *, doublereal *, doublereal *, 
 	    doublecomplex *, doublecomplex *, doublecomplex *, integer *, 
 	    integer *);
diff --git a/CLAPACK-3.2.1/SRC/zgelss.c b/CLAPACK-3.2.1/SRC/zgelss.c
index 29caf0e..6ecf777 100644
--- a/CLAPACK-3.2.1/SRC/zgelss.c
+++ b/CLAPACK-3.2.1/SRC/zgelss.c
@@ -55,8 +55,9 @@ static doublereal c_b78 = 0.;
     extern /* Subroutine */ int dlascl_(char *, integer *, integer *, 
 	    doublereal *, doublereal *, integer *, integer *, doublereal *, 
 	    integer *, integer *), dlaset_(char *, integer *, integer 
-	    *, doublereal *, doublereal *, doublereal *, integer *), 
-	    xerbla_(char *, integer *), zgebrd_(integer *, integer *, 
+	    *, doublereal *, doublereal *, doublereal *, integer *);
+	void xerbla_(char *, integer *);
+    int zgebrd_(integer *, integer *, 
 	    doublecomplex *, integer *, doublereal *, doublereal *, 
 	    doublecomplex *, doublecomplex *, doublecomplex *, integer *, 
 	    integer *);
diff --git a/CLAPACK-3.2.1/SRC/zgelsx.c b/CLAPACK-3.2.1/SRC/zgelsx.c
index 556353a..4346ebf 100644
--- a/CLAPACK-3.2.1/SRC/zgelsx.c
+++ b/CLAPACK-3.2.1/SRC/zgelsx.c
@@ -49,7 +49,8 @@ static integer c__1 = 1;
     extern doublereal dlamch_(char *);
     extern /* Subroutine */ int zunm2r_(char *, char *, integer *, integer *, 
 	    integer *, doublecomplex *, integer *, doublecomplex *, 
-	    doublecomplex *, integer *, doublecomplex *, integer *), xerbla_(char *, integer *);
+	    doublecomplex *, integer *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
     extern doublereal zlange_(char *, integer *, integer *, doublecomplex *, 
 	    integer *, doublereal *);
     doublereal bignum;
diff --git a/CLAPACK-3.2.1/SRC/zgelsy.c b/CLAPACK-3.2.1/SRC/zgelsy.c
index 355ac16..0ddc179 100644
--- a/CLAPACK-3.2.1/SRC/zgelsy.c
+++ b/CLAPACK-3.2.1/SRC/zgelsy.c
@@ -53,7 +53,7 @@ static integer c__2 = 2;
 	    doublecomplex *, doublecomplex *, integer *, doublereal *, 
 	    integer *);
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern doublereal zlange_(char *, integer *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zgeql2.c b/CLAPACK-3.2.1/SRC/zgeql2.c
index 28107f3..a5c407e 100644
--- a/CLAPACK-3.2.1/SRC/zgeql2.c
+++ b/CLAPACK-3.2.1/SRC/zgeql2.c
@@ -32,7 +32,9 @@ static integer c__1 = 1;
     doublecomplex alpha;
     extern /* Subroutine */ int zlarf_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *, doublecomplex *), xerbla_(char *, integer *), zlarfp_(integer *, doublecomplex *, doublecomplex *, 
+	    integer *, doublecomplex *);
+    void xerbla_(char *, integer *);
+    int zlarfp_(integer *, doublecomplex *, doublecomplex *, 
 	    integer *, doublecomplex *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/zgeqlf.c b/CLAPACK-3.2.1/SRC/zgeqlf.c
index 749283a..a1990d6 100644
--- a/CLAPACK-3.2.1/SRC/zgeqlf.c
+++ b/CLAPACK-3.2.1/SRC/zgeqlf.c
@@ -30,7 +30,8 @@ static integer c__2 = 2;
     /* Local variables */
     integer i__, k, ib, nb, ki, kk, mu, nu, nx, iws, nbmin, iinfo;
     extern /* Subroutine */ int zgeql2_(integer *, integer *, doublecomplex *, 
-	     integer *, doublecomplex *, doublecomplex *, integer *), xerbla_(
+	     integer *, doublecomplex *, doublecomplex *, integer *);
+    void xerbla_(
 	    char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zgeqp3.c b/CLAPACK-3.2.1/SRC/zgeqp3.c
index 9e95d75..6d61c3f 100644
--- a/CLAPACK-3.2.1/SRC/zgeqp3.c
+++ b/CLAPACK-3.2.1/SRC/zgeqp3.c
@@ -34,7 +34,7 @@ static integer c__2 = 2;
 	    integer *, doublecomplex *, integer *, integer *, doublecomplex *, 
 	     doublereal *, doublereal *, doublecomplex *);
     extern doublereal dznrm2_(integer *, doublecomplex *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zgeqrf_(integer *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zgeqpf.c b/CLAPACK-3.2.1/SRC/zgeqpf.c
index 725c83f..dcdbedd 100644
--- a/CLAPACK-3.2.1/SRC/zgeqpf.c
+++ b/CLAPACK-3.2.1/SRC/zgeqpf.c
@@ -49,7 +49,8 @@ static integer c__1 = 1;
 	    integer *, doublecomplex *, integer *, doublecomplex *, 
 	    doublecomplex *, integer *, doublecomplex *, integer *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), zlarfp_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zlarfp_(
 	    integer *, doublecomplex *, doublecomplex *, integer *, 
 	    doublecomplex *);
 
diff --git a/CLAPACK-3.2.1/SRC/zgeqr2.c b/CLAPACK-3.2.1/SRC/zgeqr2.c
index 4bc74a2..2146885 100644
--- a/CLAPACK-3.2.1/SRC/zgeqr2.c
+++ b/CLAPACK-3.2.1/SRC/zgeqr2.c
@@ -32,7 +32,9 @@ static integer c__1 = 1;
     doublecomplex alpha;
     extern /* Subroutine */ int zlarf_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *, doublecomplex *), xerbla_(char *, integer *), zlarfp_(integer *, doublecomplex *, doublecomplex *, 
+	    integer *, doublecomplex *);
+    void xerbla_(char *, integer *);
+    int zlarfp_(integer *, doublecomplex *, doublecomplex *, 
 	    integer *, doublecomplex *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/zgeqrf.c b/CLAPACK-3.2.1/SRC/zgeqrf.c
index a26e355..fb419a4 100644
--- a/CLAPACK-3.2.1/SRC/zgeqrf.c
+++ b/CLAPACK-3.2.1/SRC/zgeqrf.c
@@ -30,7 +30,8 @@ static integer c__2 = 2;
     /* Local variables */
     integer i__, k, ib, nb, nx, iws, nbmin, iinfo;
     extern /* Subroutine */ int zgeqr2_(integer *, integer *, doublecomplex *, 
-	     integer *, doublecomplex *, doublecomplex *, integer *), xerbla_(
+	     integer *, doublecomplex *, doublecomplex *, integer *);
+    void xerbla_(
 	    char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zgerfs.c b/CLAPACK-3.2.1/SRC/zgerfs.c
index 4fb472e..c418609 100644
--- a/CLAPACK-3.2.1/SRC/zgerfs.c
+++ b/CLAPACK-3.2.1/SRC/zgerfs.c
@@ -52,7 +52,7 @@ static integer c__1 = 1;
 	    integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
     char transn[1], transt[1];
     doublereal lstres;
diff --git a/CLAPACK-3.2.1/SRC/zgerfsx.c b/CLAPACK-3.2.1/SRC/zgerfsx.c
index 2adfab8..35fe6c5 100644
--- a/CLAPACK-3.2.1/SRC/zgerfsx.c
+++ b/CLAPACK-3.2.1/SRC/zgerfsx.c
@@ -60,7 +60,7 @@ static logical c_false = FALSE_;
 	    zla_gercond_x__(char *, integer *, doublecomplex *, integer *, 
 	    doublecomplex *, integer *, integer *, doublecomplex *, integer *,
 	     doublecomplex *, doublereal *, ftnlen), dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal zlange_(char *, integer *, integer *, doublecomplex *, 
 	    integer *, doublereal *);
     extern /* Subroutine */ int zgecon_(char *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zgerq2.c b/CLAPACK-3.2.1/SRC/zgerq2.c
index a91d0cb..dc8006d 100644
--- a/CLAPACK-3.2.1/SRC/zgerq2.c
+++ b/CLAPACK-3.2.1/SRC/zgerq2.c
@@ -24,7 +24,9 @@
     doublecomplex alpha;
     extern /* Subroutine */ int zlarf_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *, doublecomplex *), xerbla_(char *, integer *), zlacgv_(integer *, doublecomplex *, integer *), zlarfp_(
+	    integer *, doublecomplex *);
+    void xerbla_(char *, integer *);
+    int zlacgv_(integer *, doublecomplex *, integer *), zlarfp_(
 	    integer *, doublecomplex *, doublecomplex *, integer *, 
 	    doublecomplex *);
 
diff --git a/CLAPACK-3.2.1/SRC/zgerqf.c b/CLAPACK-3.2.1/SRC/zgerqf.c
index 9510b77..a232274 100644
--- a/CLAPACK-3.2.1/SRC/zgerqf.c
+++ b/CLAPACK-3.2.1/SRC/zgerqf.c
@@ -30,7 +30,8 @@ static integer c__2 = 2;
     /* Local variables */
     integer i__, k, ib, nb, ki, kk, mu, nu, nx, iws, nbmin, iinfo;
     extern /* Subroutine */ int zgerq2_(integer *, integer *, doublecomplex *, 
-	     integer *, doublecomplex *, doublecomplex *, integer *), xerbla_(
+	     integer *, doublecomplex *, doublecomplex *, integer *);
+    void xerbla_(
 	    char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zgesdd.c b/CLAPACK-3.2.1/SRC/zgesdd.c
index 6bc435d..e20f6d0 100644
--- a/CLAPACK-3.2.1/SRC/zgesdd.c
+++ b/CLAPACK-3.2.1/SRC/zgesdd.c
@@ -58,8 +58,9 @@ static integer c__0 = 0;
     extern doublereal dlamch_(char *);
     extern /* Subroutine */ int dlascl_(char *, integer *, integer *, 
 	    doublereal *, doublereal *, integer *, integer *, doublereal *, 
-	    integer *, integer *), xerbla_(char *, integer *),
-	     zgebrd_(integer *, integer *, doublecomplex *, integer *, 
+	    integer *, integer *);
+    void xerbla_(char *, integer *);
+    int zgebrd_(integer *, integer *, doublecomplex *, integer *, 
 	    doublereal *, doublereal *, doublecomplex *, doublecomplex *, 
 	    doublecomplex *, integer *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zgesv.c b/CLAPACK-3.2.1/SRC/zgesv.c
index ec74b35..5a0cfd1 100644
--- a/CLAPACK-3.2.1/SRC/zgesv.c
+++ b/CLAPACK-3.2.1/SRC/zgesv.c
@@ -21,7 +21,8 @@
     integer a_dim1, a_offset, b_dim1, b_offset, i__1;
 
     /* Local variables */
-    extern /* Subroutine */ int xerbla_(char *, integer *), zgetrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zgetrf_(
 	    integer *, integer *, doublecomplex *, integer *, integer *, 
 	    integer *), zgetrs_(char *, integer *, integer *, doublecomplex *, 
 	     integer *, integer *, doublecomplex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zgesvd.c b/CLAPACK-3.2.1/SRC/zgesvd.c
index d8f217a..ee8ecd6 100644
--- a/CLAPACK-3.2.1/SRC/zgesvd.c
+++ b/CLAPACK-3.2.1/SRC/zgesvd.c
@@ -35,7 +35,7 @@ static integer c_n1 = -1;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
     double sqrt(doublereal);
 
     /* Local variables */
@@ -57,8 +57,9 @@ static integer c_n1 = -1;
     extern doublereal dlamch_(char *);
     extern /* Subroutine */ int dlascl_(char *, integer *, integer *, 
 	    doublereal *, doublereal *, integer *, integer *, doublereal *, 
-	    integer *, integer *), xerbla_(char *, integer *),
-	     zgebrd_(integer *, integer *, doublecomplex *, integer *, 
+	    integer *, integer *);
+    void xerbla_(char *, integer *);
+    int zgebrd_(integer *, integer *, doublecomplex *, integer *, 
 	    doublereal *, doublereal *, doublecomplex *, doublecomplex *, 
 	    doublecomplex *, integer *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zgesvx.c b/CLAPACK-3.2.1/SRC/zgesvx.c
index 44a3ff7..684d63b 100644
--- a/CLAPACK-3.2.1/SRC/zgesvx.c
+++ b/CLAPACK-3.2.1/SRC/zgesvx.c
@@ -36,7 +36,7 @@
     extern doublereal dlamch_(char *);
     doublereal colcnd;
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal zlange_(char *, integer *, integer *, doublecomplex *, 
 	    integer *, doublereal *);
     doublereal bignum;
diff --git a/CLAPACK-3.2.1/SRC/zgesvxx.c b/CLAPACK-3.2.1/SRC/zgesvxx.c
index fcd0706..86cbefc 100644
--- a/CLAPACK-3.2.1/SRC/zgesvxx.c
+++ b/CLAPACK-3.2.1/SRC/zgesvxx.c
@@ -39,7 +39,7 @@
     extern doublereal dlamch_(char *);
     doublereal colcnd;
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     extern /* Subroutine */ int zlaqge_(integer *, integer *, doublecomplex *, 
 	     integer *, doublereal *, doublereal *, doublereal *, doublereal *
diff --git a/CLAPACK-3.2.1/SRC/zgetf2.c b/CLAPACK-3.2.1/SRC/zgetf2.c
index ce382e3..e22b4d4 100644
--- a/CLAPACK-3.2.1/SRC/zgetf2.c
+++ b/CLAPACK-3.2.1/SRC/zgetf2.c
@@ -38,7 +38,7 @@ static integer c__1 = 1;
 	    integer *, doublecomplex *, integer *), zswap_(integer *, 
 	    doublecomplex *, integer *, doublecomplex *, integer *);
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer izamax_(integer *, doublecomplex *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/zgetrf.c b/CLAPACK-3.2.1/SRC/zgetrf.c
index 101dcd4..a89794d 100644
--- a/CLAPACK-3.2.1/SRC/zgetrf.c
+++ b/CLAPACK-3.2.1/SRC/zgetrf.c
@@ -35,7 +35,8 @@ static integer c_n1 = -1;
 	     integer *, integer *, doublecomplex *, doublecomplex *, integer *
 , doublecomplex *, integer *), 
 	    zgetf2_(integer *, integer *, doublecomplex *, integer *, integer 
-	    *, integer *), xerbla_(char *, integer *);
+	    *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zlaswp_(integer *, doublecomplex *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zgetri.c b/CLAPACK-3.2.1/SRC/zgetri.c
index 246b34e..4fb96af 100644
--- a/CLAPACK-3.2.1/SRC/zgetri.c
+++ b/CLAPACK-3.2.1/SRC/zgetri.c
@@ -38,8 +38,8 @@ static integer c__2 = 2;
 	    zswap_(integer *, doublecomplex *, integer *, doublecomplex *, 
 	    integer *), ztrsm_(char *, char *, char *, char *, integer *, 
 	    integer *, doublecomplex *, doublecomplex *, integer *, 
-	    doublecomplex *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublecomplex *, integer *);
+	void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwork, lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/zgetrs.c b/CLAPACK-3.2.1/SRC/zgetrs.c
index 2496939..0b3d274 100644
--- a/CLAPACK-3.2.1/SRC/zgetrs.c
+++ b/CLAPACK-3.2.1/SRC/zgetrs.c
@@ -30,8 +30,8 @@ static integer c_n1 = -1;
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int ztrsm_(char *, char *, char *, char *, 
 	    integer *, integer *, doublecomplex *, doublecomplex *, integer *, 
-	     doublecomplex *, integer *), 
-	    xerbla_(char *, integer *);
+	     doublecomplex *, integer *);
+	void xerbla_(char *, integer *);
     logical notran;
     extern /* Subroutine */ int zlaswp_(integer *, doublecomplex *, integer *, 
 	     integer *, integer *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zggbak.c b/CLAPACK-3.2.1/SRC/zggbak.c
index dd25ad9..553a6be 100644
--- a/CLAPACK-3.2.1/SRC/zggbak.c
+++ b/CLAPACK-3.2.1/SRC/zggbak.c
@@ -25,8 +25,9 @@
     extern logical lsame_(char *, char *);
     logical leftv;
     extern /* Subroutine */ int zswap_(integer *, doublecomplex *, integer *, 
-	    doublecomplex *, integer *), xerbla_(char *, integer *), 
-	    zdscal_(integer *, doublereal *, doublecomplex *, integer *);
+	    doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
+    int zdscal_(integer *, doublereal *, doublecomplex *, integer *);
     logical rightv;
 
 
diff --git a/CLAPACK-3.2.1/SRC/zggbal.c b/CLAPACK-3.2.1/SRC/zggbal.c
index f875672..4a9a9b9 100644
--- a/CLAPACK-3.2.1/SRC/zggbal.c
+++ b/CLAPACK-3.2.1/SRC/zggbal.c
@@ -61,7 +61,8 @@ static doublereal c_b72 = .5;
 	    doublecomplex *, integer *);
     extern doublereal dlamch_(char *);
     doublereal pgamma;
-    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zdscal_(
 	    integer *, doublereal *, doublecomplex *, integer *);
     integer lsfmin;
     extern integer izamax_(integer *, doublecomplex *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zgges.c b/CLAPACK-3.2.1/SRC/zgges.c
index 540ae27..ff9ce03 100644
--- a/CLAPACK-3.2.1/SRC/zgges.c
+++ b/CLAPACK-3.2.1/SRC/zgges.c
@@ -54,7 +54,7 @@ static integer c_n1 = -1;
 	     doublecomplex *, integer *, doublecomplex *, integer *, integer *
 , integer *, doublereal *, doublereal *, doublereal *, integer *);
     logical ilascl, ilbscl;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern doublereal zlange_(char *, integer *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zggesx.c b/CLAPACK-3.2.1/SRC/zggesx.c
index b3a5d43..f171060 100644
--- a/CLAPACK-3.2.1/SRC/zggesx.c
+++ b/CLAPACK-3.2.1/SRC/zggesx.c
@@ -56,7 +56,7 @@ static integer c_n1 = -1;
 	     doublecomplex *, integer *, doublecomplex *, integer *, integer *
 , integer *, doublereal *, doublereal *, doublereal *, integer *);
     logical ilascl, ilbscl;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern doublereal zlange_(char *, integer *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zggev.c b/CLAPACK-3.2.1/SRC/zggev.c
index 6adee6b..126996d 100644
--- a/CLAPACK-3.2.1/SRC/zggev.c
+++ b/CLAPACK-3.2.1/SRC/zggev.c
@@ -55,7 +55,7 @@ static integer c_n1 = -1;
 	     doublecomplex *, integer *, doublecomplex *, integer *, integer *
 , integer *, doublereal *, doublereal *, doublereal *, integer *);
     logical ilascl, ilbscl;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical ldumma[1];
diff --git a/CLAPACK-3.2.1/SRC/zggevx.c b/CLAPACK-3.2.1/SRC/zggevx.c
index b589a5a..ecb9dfa 100644
--- a/CLAPACK-3.2.1/SRC/zggevx.c
+++ b/CLAPACK-3.2.1/SRC/zggevx.c
@@ -62,7 +62,7 @@ static integer c__0 = 0;
 	    integer *, integer *, integer *, doublereal *, doublereal *, 
 	    doublereal *, integer *);
     logical ilascl, ilbscl;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical ldumma[1];
diff --git a/CLAPACK-3.2.1/SRC/zggglm.c b/CLAPACK-3.2.1/SRC/zggglm.c
index a6e9095..38cc311 100644
--- a/CLAPACK-3.2.1/SRC/zggglm.c
+++ b/CLAPACK-3.2.1/SRC/zggglm.c
@@ -34,7 +34,8 @@ static integer c_n1 = -1;
 	    doublecomplex *, doublecomplex *, integer *, doublecomplex *, 
 	    integer *, doublecomplex *, doublecomplex *, integer *), 
 	    zcopy_(integer *, doublecomplex *, integer *, doublecomplex *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zggqrf_(integer *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zgghrd.c b/CLAPACK-3.2.1/SRC/zgghrd.c
index 6ad8eb9..e87eb16 100644
--- a/CLAPACK-3.2.1/SRC/zgghrd.c
+++ b/CLAPACK-3.2.1/SRC/zgghrd.c
@@ -41,7 +41,7 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *, doublereal *, doublecomplex *);
     extern logical lsame_(char *, char *);
     doublecomplex ctemp;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer icompq, icompz;
     extern /* Subroutine */ int zlaset_(char *, integer *, integer *, 
 	    doublecomplex *, doublecomplex *, doublecomplex *, integer *), zlartg_(doublecomplex *, doublecomplex *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/zgglse.c b/CLAPACK-3.2.1/SRC/zgglse.c
index 065663e..dfb8248 100644
--- a/CLAPACK-3.2.1/SRC/zgglse.c
+++ b/CLAPACK-3.2.1/SRC/zgglse.c
@@ -37,7 +37,8 @@ static integer c_n1 = -1;
 	    integer *), zaxpy_(integer *, doublecomplex *, doublecomplex *, 
 	    integer *, doublecomplex *, integer *), ztrmv_(char *, char *, 
 	    char *, integer *, doublecomplex *, integer *, doublecomplex *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zggrqf_(integer *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zggqrf.c b/CLAPACK-3.2.1/SRC/zggqrf.c
index dcd18a8..19b3f99 100644
--- a/CLAPACK-3.2.1/SRC/zggqrf.c
+++ b/CLAPACK-3.2.1/SRC/zggqrf.c
@@ -28,7 +28,7 @@ static integer c_n1 = -1;
 
     /* Local variables */
     integer nb, nb1, nb2, nb3, lopt;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zgeqrf_(integer *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zggrqf.c b/CLAPACK-3.2.1/SRC/zggrqf.c
index bc3c559..a3de154 100644
--- a/CLAPACK-3.2.1/SRC/zggrqf.c
+++ b/CLAPACK-3.2.1/SRC/zggrqf.c
@@ -28,7 +28,7 @@ static integer c_n1 = -1;
 
     /* Local variables */
     integer nb, nb1, nb2, nb3, lopt;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zgeqrf_(integer *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zggsvd.c b/CLAPACK-3.2.1/SRC/zggsvd.c
index 00bf0e5..62d84e9 100644
--- a/CLAPACK-3.2.1/SRC/zggsvd.c
+++ b/CLAPACK-3.2.1/SRC/zggsvd.c
@@ -42,7 +42,7 @@ static integer c__1 = 1;
     logical wantq, wantu, wantv;
     extern doublereal dlamch_(char *);
     integer ncycle;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal zlange_(char *, integer *, integer *, doublecomplex *, 
 	    integer *, doublereal *);
     extern /* Subroutine */ int ztgsja_(char *, char *, char *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zggsvp.c b/CLAPACK-3.2.1/SRC/zggsvp.c
index e323ba6..ee7e528 100644
--- a/CLAPACK-3.2.1/SRC/zggsvp.c
+++ b/CLAPACK-3.2.1/SRC/zggsvp.c
@@ -46,8 +46,10 @@ static doublecomplex c_b2 = {1.,0.};
 	    integer *, integer *, doublecomplex *, integer *, doublecomplex *, 
 	     doublecomplex *, integer *, doublecomplex *, integer *), zunmr2_(char *, char *, integer *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *, doublecomplex *, integer *), xerbla_(
-	    char *, integer *), zgeqpf_(integer *, integer *, 
+	    integer *, doublecomplex *, integer *);
+    void xerbla_(
+	    char *, integer *);
+    int zgeqpf_(integer *, integer *, 
 	    doublecomplex *, integer *, integer *, doublecomplex *, 
 	    doublecomplex *, doublereal *, integer *), zlacpy_(char *, 
 	    integer *, integer *, doublecomplex *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zgtcon.c b/CLAPACK-3.2.1/SRC/zgtcon.c
index a7607fd..2aa77e8 100644
--- a/CLAPACK-3.2.1/SRC/zgtcon.c
+++ b/CLAPACK-3.2.1/SRC/zgtcon.c
@@ -30,7 +30,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     integer isave[3];
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
-	    doublecomplex *, doublereal *, integer *, integer *), xerbla_(
+	    doublecomplex *, doublereal *, integer *, integer *);
+    void xerbla_(
 	    char *, integer *);
     doublereal ainvnm;
     logical onenrm;
diff --git a/CLAPACK-3.2.1/SRC/zgtrfs.c b/CLAPACK-3.2.1/SRC/zgtrfs.c
index 53a8337..f18cfbc 100644
--- a/CLAPACK-3.2.1/SRC/zgtrfs.c
+++ b/CLAPACK-3.2.1/SRC/zgtrfs.c
@@ -53,7 +53,8 @@ static doublecomplex c_b26 = {1.,0.};
 	    integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), zlagtm_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zlagtm_(
 	    char *, integer *, integer *, doublereal *, doublecomplex *, 
 	    doublecomplex *, doublecomplex *, doublecomplex *, integer *, 
 	    doublereal *, doublecomplex *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zgtsv.c b/CLAPACK-3.2.1/SRC/zgtsv.c
index e1d9bc2..62dad3b 100644
--- a/CLAPACK-3.2.1/SRC/zgtsv.c
+++ b/CLAPACK-3.2.1/SRC/zgtsv.c
@@ -29,7 +29,7 @@
     /* Local variables */
     integer j, k;
     doublecomplex temp, mult;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zgtsvx.c b/CLAPACK-3.2.1/SRC/zgtsvx.c
index aeffccd..fcdc0d3 100644
--- a/CLAPACK-3.2.1/SRC/zgtsvx.c
+++ b/CLAPACK-3.2.1/SRC/zgtsvx.c
@@ -36,7 +36,7 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *);
     extern doublereal dlamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal zlangt_(char *, integer *, doublecomplex *, 
 	    doublecomplex *, doublecomplex *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/zgttrf.c b/CLAPACK-3.2.1/SRC/zgttrf.c
index 714ae0f..6083949 100644
--- a/CLAPACK-3.2.1/SRC/zgttrf.c
+++ b/CLAPACK-3.2.1/SRC/zgttrf.c
@@ -29,7 +29,7 @@
     /* Local variables */
     integer i__;
     doublecomplex fact, temp;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zgttrs.c b/CLAPACK-3.2.1/SRC/zgttrs.c
index f8130e2..0b7d825 100644
--- a/CLAPACK-3.2.1/SRC/zgttrs.c
+++ b/CLAPACK-3.2.1/SRC/zgttrs.c
@@ -30,7 +30,8 @@ static integer c_n1 = -1;
     integer j, jb, nb;
     extern /* Subroutine */ int zgtts2_(integer *, integer *, integer *, 
 	    doublecomplex *, doublecomplex *, doublecomplex *, doublecomplex *
-, integer *, doublecomplex *, integer *), xerbla_(char *, integer 
+, integer *, doublecomplex *, integer *);
+    void xerbla_(char *, integer 
 	    *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zhbev.c b/CLAPACK-3.2.1/SRC/zhbev.c
index 3195188..600416e 100644
--- a/CLAPACK-3.2.1/SRC/zhbev.c
+++ b/CLAPACK-3.2.1/SRC/zhbev.c
@@ -46,7 +46,7 @@ static integer c__1 = 1;
     doublereal safmin;
     extern doublereal zlanhb_(char *, char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublereal *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     extern /* Subroutine */ int dsterf_(integer *, doublereal *, doublereal *, 
 	     integer *), zlascl_(char *, integer *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/zhbevd.c b/CLAPACK-3.2.1/SRC/zhbevd.c
index dc58f4b..17a6ced 100644
--- a/CLAPACK-3.2.1/SRC/zhbevd.c
+++ b/CLAPACK-3.2.1/SRC/zhbevd.c
@@ -58,7 +58,7 @@ static integer c__1 = 1;
     doublereal safmin;
     extern doublereal zlanhb_(char *, char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublereal *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     extern /* Subroutine */ int dsterf_(integer *, doublereal *, doublereal *, 
 	     integer *), zlascl_(char *, integer *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/zhbevx.c b/CLAPACK-3.2.1/SRC/zhbevx.c
index 2c4bde8..e1b3c84 100644
--- a/CLAPACK-3.2.1/SRC/zhbevx.c
+++ b/CLAPACK-3.2.1/SRC/zhbevx.c
@@ -68,7 +68,7 @@ static integer c__1 = 1;
     doublereal safmin;
     extern doublereal zlanhb_(char *, char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublereal *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal abstll, bignum;
     integer indiwk, indisp;
     extern /* Subroutine */ int dsterf_(integer *, doublereal *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/zhbgst.c b/CLAPACK-3.2.1/SRC/zhbgst.c
index 59ec866..b137ff5 100644
--- a/CLAPACK-3.2.1/SRC/zhbgst.c
+++ b/CLAPACK-3.2.1/SRC/zhbgst.c
@@ -56,8 +56,9 @@ static integer c__1 = 1;
     logical wantx;
     extern /* Subroutine */ int zlar2v_(integer *, doublecomplex *, 
 	    doublecomplex *, doublecomplex *, integer *, doublereal *, 
-	    doublecomplex *, integer *), xerbla_(char *, integer *), 
-	    zdscal_(integer *, doublereal *, doublecomplex *, integer *);
+	    doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
+    int zdscal_(integer *, doublereal *, doublecomplex *, integer *);
     logical update;
     extern /* Subroutine */ int zlacgv_(integer *, doublecomplex *, integer *)
 	    , zlaset_(char *, integer *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zhbgv.c b/CLAPACK-3.2.1/SRC/zhbgv.c
index 5361f0a..b3bd510 100644
--- a/CLAPACK-3.2.1/SRC/zhbgv.c
+++ b/CLAPACK-3.2.1/SRC/zhbgv.c
@@ -27,7 +27,8 @@
     extern logical lsame_(char *, char *);
     integer iinfo;
     logical upper, wantz;
-    extern /* Subroutine */ int xerbla_(char *, integer *), dsterf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dsterf_(
 	    integer *, doublereal *, doublereal *, integer *), zhbtrd_(char *, 
 	     char *, integer *, integer *, doublecomplex *, integer *, 
 	    doublereal *, doublereal *, doublecomplex *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zhbgvd.c b/CLAPACK-3.2.1/SRC/zhbgvd.c
index bcdd4a9..d79b97f 100644
--- a/CLAPACK-3.2.1/SRC/zhbgvd.c
+++ b/CLAPACK-3.2.1/SRC/zhbgvd.c
@@ -42,7 +42,8 @@ static doublecomplex c_b2 = {0.,0.};
     integer llrwk;
     logical wantz;
     integer indwk2;
-    extern /* Subroutine */ int xerbla_(char *, integer *), dsterf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dsterf_(
 	    integer *, doublereal *, doublereal *, integer *), zstedc_(char *, 
 	     integer *, doublereal *, doublereal *, doublecomplex *, integer *
 , doublecomplex *, integer *, doublereal *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zhbgvx.c b/CLAPACK-3.2.1/SRC/zhbgvx.c
index 6663aab..0cc031a 100644
--- a/CLAPACK-3.2.1/SRC/zhbgvx.c
+++ b/CLAPACK-3.2.1/SRC/zhbgvx.c
@@ -52,7 +52,7 @@ static integer c__1 = 1;
     logical alleig, indeig;
     integer indibl;
     logical valeig;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer indiwk, indisp;
     extern /* Subroutine */ int dsterf_(integer *, doublereal *, doublereal *, 
 	     integer *), dstebz_(char *, char *, integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/zhbtrd.c b/CLAPACK-3.2.1/SRC/zhbtrd.c
index f2c3593..2b86ccb 100644
--- a/CLAPACK-3.2.1/SRC/zhbtrd.c
+++ b/CLAPACK-3.2.1/SRC/zhbtrd.c
@@ -52,7 +52,8 @@ static integer c__1 = 1;
 	    doublecomplex *, doublecomplex *, integer *, doublereal *, 
 	    doublecomplex *, integer *);
     integer iqaend;
-    extern /* Subroutine */ int xerbla_(char *, integer *), zlacgv_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zlacgv_(
 	    integer *, doublecomplex *, integer *), zlaset_(char *, integer *, 
 	     integer *, doublecomplex *, doublecomplex *, doublecomplex *, 
 	    integer *), zlartg_(doublecomplex *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zhecon.c b/CLAPACK-3.2.1/SRC/zhecon.c
index 869cdc0..3af5cf7 100644
--- a/CLAPACK-3.2.1/SRC/zhecon.c
+++ b/CLAPACK-3.2.1/SRC/zhecon.c
@@ -30,7 +30,8 @@ static integer c__1 = 1;
     integer isave[3];
     logical upper;
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
-	    doublecomplex *, doublereal *, integer *, integer *), xerbla_(
+	    doublecomplex *, doublereal *, integer *, integer *);
+    void xerbla_(
 	    char *, integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int zhetrs_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zheequb.c b/CLAPACK-3.2.1/SRC/zheequb.c
index eb1bcd7..ce302ad 100644
--- a/CLAPACK-3.2.1/SRC/zheequb.c
+++ b/CLAPACK-3.2.1/SRC/zheequb.c
@@ -41,7 +41,7 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     doublereal sumsq;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum, smlnum;
     extern /* Subroutine */ int zlassq_(integer *, doublecomplex *, integer *, 
 	     doublereal *, doublereal *);
diff --git a/CLAPACK-3.2.1/SRC/zheev.c b/CLAPACK-3.2.1/SRC/zheev.c
index f712fd8..caead1d 100644
--- a/CLAPACK-3.2.1/SRC/zheev.c
+++ b/CLAPACK-3.2.1/SRC/zheev.c
@@ -49,7 +49,7 @@ static doublereal c_b18 = 1.;
     doublereal safmin;
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     extern doublereal zlanhe_(char *, char *, integer *, doublecomplex *, 
 	    integer *, doublereal *);
diff --git a/CLAPACK-3.2.1/SRC/zheevd.c b/CLAPACK-3.2.1/SRC/zheevd.c
index cf766e4..5c5ebd5 100644
--- a/CLAPACK-3.2.1/SRC/zheevd.c
+++ b/CLAPACK-3.2.1/SRC/zheevd.c
@@ -53,7 +53,7 @@ static doublereal c_b18 = 1.;
     doublereal safmin;
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     extern doublereal zlanhe_(char *, char *, integer *, doublecomplex *, 
 	    integer *, doublereal *);
diff --git a/CLAPACK-3.2.1/SRC/zheevr.c b/CLAPACK-3.2.1/SRC/zheevr.c
index 66d725b..5bf6498 100644
--- a/CLAPACK-3.2.1/SRC/zheevr.c
+++ b/CLAPACK-3.2.1/SRC/zheevr.c
@@ -64,7 +64,8 @@ static integer c_n1 = -1;
     doublereal safmin;
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zdscal_(
 	    integer *, doublereal *, doublecomplex *, integer *);
     doublereal abstll, bignum;
     integer indtau, indisp;
diff --git a/CLAPACK-3.2.1/SRC/zheevx.c b/CLAPACK-3.2.1/SRC/zheevx.c
index 30a6090..3b1ae6c 100644
--- a/CLAPACK-3.2.1/SRC/zheevx.c
+++ b/CLAPACK-3.2.1/SRC/zheevx.c
@@ -59,7 +59,8 @@ static integer c_n1 = -1;
     doublereal safmin;
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zdscal_(
 	    integer *, doublereal *, doublecomplex *, integer *);
     doublereal abstll, bignum;
     extern doublereal zlanhe_(char *, char *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zhegs2.c b/CLAPACK-3.2.1/SRC/zhegs2.c
index 3e7f85e..c1d8ce3 100644
--- a/CLAPACK-3.2.1/SRC/zhegs2.c
+++ b/CLAPACK-3.2.1/SRC/zhegs2.c
@@ -41,8 +41,10 @@ static integer c__1 = 1;
 	    char *, char *, char *, integer *, doublecomplex *, integer *, 
 	    doublecomplex *, integer *), ztrsv_(char *
 , char *, char *, integer *, doublecomplex *, integer *, 
-	    doublecomplex *, integer *), xerbla_(char 
-	    *, integer *), zdscal_(integer *, doublereal *, 
+	    doublecomplex *, integer *);
+    void xerbla_(char 
+	    *, integer *);
+    int zdscal_(integer *, doublereal *, 
 	    doublecomplex *, integer *), zlacgv_(integer *, doublecomplex *, 
 	    integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/zhegst.c b/CLAPACK-3.2.1/SRC/zhegst.c
index 12d9fa3..2efaa09 100644
--- a/CLAPACK-3.2.1/SRC/zhegst.c
+++ b/CLAPACK-3.2.1/SRC/zhegst.c
@@ -46,7 +46,8 @@ static doublereal c_b18 = 1.;
 	    integer *, integer *), zher2k_(char *, char *, integer *, 
 	    integer *, doublecomplex *, doublecomplex *, integer *, 
 	    doublecomplex *, integer *, doublereal *, doublecomplex *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/zhegv.c b/CLAPACK-3.2.1/SRC/zhegv.c
index 71eb842..a830e13 100644
--- a/CLAPACK-3.2.1/SRC/zhegv.c
+++ b/CLAPACK-3.2.1/SRC/zhegv.c
@@ -40,7 +40,8 @@ static integer c_n1 = -1;
 	     doublecomplex *, integer *), 
 	    ztrsm_(char *, char *, char *, char *, integer *, integer *, 
 	    doublecomplex *, doublecomplex *, integer *, doublecomplex *, 
-	    integer *), xerbla_(char *, 
+	    integer *);
+    void xerbla_(char *, 
 	    integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zhegvd.c b/CLAPACK-3.2.1/SRC/zhegvd.c
index 6556caf..7a87da6 100644
--- a/CLAPACK-3.2.1/SRC/zhegvd.c
+++ b/CLAPACK-3.2.1/SRC/zhegvd.c
@@ -40,8 +40,10 @@ static doublecomplex c_b1 = {1.,0.};
 	     doublecomplex *, integer *), 
 	    ztrsm_(char *, char *, char *, char *, integer *, integer *, 
 	    doublecomplex *, doublecomplex *, integer *, doublecomplex *, 
-	    integer *), xerbla_(char *, 
-	    integer *), zheevd_(char *, char *, integer *, 
+	    integer *);
+    void xerbla_(char *, 
+	    integer *);
+    int zheevd_(char *, char *, integer *, 
 	    doublecomplex *, integer *, doublereal *, doublecomplex *, 
 	    integer *, doublereal *, integer *, integer *, integer *, integer 
 	    *);
diff --git a/CLAPACK-3.2.1/SRC/zhegvx.c b/CLAPACK-3.2.1/SRC/zhegvx.c
index 889981c..96e2ba4 100644
--- a/CLAPACK-3.2.1/SRC/zhegvx.c
+++ b/CLAPACK-3.2.1/SRC/zhegvx.c
@@ -41,7 +41,7 @@ static integer c_n1 = -1;
 	    doublecomplex *, doublecomplex *, integer *, doublecomplex *, 
 	    integer *);
     logical alleig, indeig, valeig;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zhegst_(integer *, char *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zherfs.c b/CLAPACK-3.2.1/SRC/zherfs.c
index b92d421..91602f1 100644
--- a/CLAPACK-3.2.1/SRC/zherfs.c
+++ b/CLAPACK-3.2.1/SRC/zherfs.c
@@ -53,7 +53,7 @@ static integer c__1 = 1;
 	    integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal lstres;
     extern /* Subroutine */ int zhetrs_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, integer *, doublecomplex *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zherfsx.c b/CLAPACK-3.2.1/SRC/zherfsx.c
index 2b9e6b5..c115dbf 100644
--- a/CLAPACK-3.2.1/SRC/zherfsx.c
+++ b/CLAPACK-3.2.1/SRC/zherfsx.c
@@ -60,7 +60,7 @@ static logical c_false = FALSE_;
 	    zla_hercond_x__(char *, integer *, doublecomplex *, integer *, 
 	    doublecomplex *, integer *, integer *, doublecomplex *, integer *,
 	     doublecomplex *, doublereal *, ftnlen), dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal zlanhe_(char *, char *, integer *, doublecomplex *, 
 	    integer *, doublereal *);
     extern /* Subroutine */ int zhecon_(char *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zhesv.c b/CLAPACK-3.2.1/SRC/zhesv.c
index 76d08b7..a58a1a0 100644
--- a/CLAPACK-3.2.1/SRC/zhesv.c
+++ b/CLAPACK-3.2.1/SRC/zhesv.c
@@ -28,7 +28,7 @@ static integer c_n1 = -1;
     /* Local variables */
     integer nb;
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zhetrf_(char *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zhesvx.c b/CLAPACK-3.2.1/SRC/zhesvx.c
index 71c8492..6529acf 100644
--- a/CLAPACK-3.2.1/SRC/zhesvx.c
+++ b/CLAPACK-3.2.1/SRC/zhesvx.c
@@ -34,7 +34,7 @@ static integer c_n1 = -1;
     doublereal anorm;
     extern doublereal dlamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern doublereal zlanhe_(char *, char *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zhesvxx.c b/CLAPACK-3.2.1/SRC/zhesvxx.c
index 3c10266..be5fdef 100644
--- a/CLAPACK-3.2.1/SRC/zhesvxx.c
+++ b/CLAPACK-3.2.1/SRC/zhesvxx.c
@@ -39,7 +39,7 @@
     logical equil, rcequ;
     extern doublereal dlamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     extern /* Subroutine */ int zlaqhe_(char *, integer *, doublecomplex *, 
 	    integer *, doublereal *, doublereal *, doublereal *, char *);
diff --git a/CLAPACK-3.2.1/SRC/zhetd2.c b/CLAPACK-3.2.1/SRC/zhetd2.c
index a783b5d..cd6c8e9 100644
--- a/CLAPACK-3.2.1/SRC/zhetd2.c
+++ b/CLAPACK-3.2.1/SRC/zhetd2.c
@@ -42,8 +42,10 @@ static integer c__1 = 1;
 	    doublecomplex *, doublecomplex *, integer *);
     logical upper;
     extern /* Subroutine */ int zaxpy_(integer *, doublecomplex *, 
-	    doublecomplex *, integer *, doublecomplex *, integer *), xerbla_(
-	    char *, integer *), zlarfg_(integer *, doublecomplex *, 
+	    doublecomplex *, integer *, doublecomplex *, integer *);
+    void xerbla_(
+	    char *, integer *);
+    int zlarfg_(integer *, doublecomplex *, 
 	    doublecomplex *, integer *, doublecomplex *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/zhetf2.c b/CLAPACK-3.2.1/SRC/zhetf2.c
index 24a5289..7d126fa 100644
--- a/CLAPACK-3.2.1/SRC/zhetf2.c
+++ b/CLAPACK-3.2.1/SRC/zhetf2.c
@@ -53,7 +53,8 @@ static integer c__1 = 1;
     extern doublereal dlapy2_(doublereal *, doublereal *);
     doublereal absakk;
     extern logical disnan_(doublereal *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zdscal_(
 	    integer *, doublereal *, doublecomplex *, integer *);
     doublereal colmax;
     extern integer izamax_(integer *, doublecomplex *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zhetrd.c b/CLAPACK-3.2.1/SRC/zhetrd.c
index fcab44a..bd589d1 100644
--- a/CLAPACK-3.2.1/SRC/zhetrd.c
+++ b/CLAPACK-3.2.1/SRC/zhetrd.c
@@ -37,7 +37,8 @@ static doublereal c_b23 = 1.;
     extern /* Subroutine */ int zhetd2_(char *, integer *, doublecomplex *, 
 	    integer *, doublereal *, doublereal *, doublecomplex *, integer *), zher2k_(char *, char *, integer *, integer *, 
 	    doublecomplex *, doublecomplex *, integer *, doublecomplex *, 
-	    integer *, doublereal *, doublecomplex *, integer *), xerbla_(char *, integer *);
+	    integer *, doublereal *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zlatrd_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zhetrf.c b/CLAPACK-3.2.1/SRC/zhetrf.c
index 7fe2907..3e7f42d 100644
--- a/CLAPACK-3.2.1/SRC/zhetrf.c
+++ b/CLAPACK-3.2.1/SRC/zhetrf.c
@@ -34,7 +34,8 @@ static integer c__2 = 2;
     extern /* Subroutine */ int zhetf2_(char *, integer *, doublecomplex *, 
 	    integer *, integer *, integer *), zlahef_(char *, integer 
 	    *, integer *, integer *, doublecomplex *, integer *, integer *, 
-	    doublecomplex *, integer *, integer *), xerbla_(char *, 
+	    doublecomplex *, integer *, integer *);
+    void xerbla_(char *, 
 	    integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zhetri.c b/CLAPACK-3.2.1/SRC/zhetri.c
index 7dadd4f..8600ba4 100644
--- a/CLAPACK-3.2.1/SRC/zhetri.c
+++ b/CLAPACK-3.2.1/SRC/zhetri.c
@@ -47,7 +47,8 @@ static integer c__1 = 1;
     logical upper;
     extern /* Subroutine */ int zcopy_(integer *, doublecomplex *, integer *, 
 	    doublecomplex *, integer *), zswap_(integer *, doublecomplex *, 
-	    integer *, doublecomplex *, integer *), xerbla_(char *, integer *);
+	    integer *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zhetrs.c b/CLAPACK-3.2.1/SRC/zhetrs.c
index ba56662..eabe761 100644
--- a/CLAPACK-3.2.1/SRC/zhetrs.c
+++ b/CLAPACK-3.2.1/SRC/zhetrs.c
@@ -45,7 +45,9 @@ static integer c__1 = 1;
     extern /* Subroutine */ int zgeru_(integer *, integer *, doublecomplex *, 
 	    doublecomplex *, integer *, doublecomplex *, integer *, 
 	    doublecomplex *, integer *), zswap_(integer *, doublecomplex *, 
-	    integer *, doublecomplex *, integer *), xerbla_(char *, integer *), zdscal_(integer *, doublereal *, doublecomplex *, 
+	    integer *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
+    int zdscal_(integer *, doublereal *, doublecomplex *, 
 	    integer *), zlacgv_(integer *, doublecomplex *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/zhfrk.c b/CLAPACK-3.2.1/SRC/zhfrk.c
index 87f3043..1993777 100644
--- a/CLAPACK-3.2.1/SRC/zhfrk.c
+++ b/CLAPACK-3.2.1/SRC/zhfrk.c
@@ -35,7 +35,7 @@
     integer nrowa;
     logical lower;
     doublecomplex calpha;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd, notrans;
 
 
diff --git a/CLAPACK-3.2.1/SRC/zhgeqz.c b/CLAPACK-3.2.1/SRC/zhgeqz.c
index 7792559..95810be 100644
--- a/CLAPACK-3.2.1/SRC/zhgeqz.c
+++ b/CLAPACK-3.2.1/SRC/zhgeqz.c
@@ -72,7 +72,7 @@ static integer c__2 = 2;
     extern doublereal dlamch_(char *);
     doublecomplex signbc;
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublecomplex eshift;
     logical ilschr;
     integer icompq, ilastm;
diff --git a/CLAPACK-3.2.1/SRC/zhpcon.c b/CLAPACK-3.2.1/SRC/zhpcon.c
index e95fe20..cdd4747 100644
--- a/CLAPACK-3.2.1/SRC/zhpcon.c
+++ b/CLAPACK-3.2.1/SRC/zhpcon.c
@@ -30,7 +30,8 @@ static integer c__1 = 1;
     integer isave[3];
     logical upper;
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
-	    doublecomplex *, doublereal *, integer *, integer *), xerbla_(
+	    doublecomplex *, doublereal *, integer *, integer *);
+    void xerbla_(
 	    char *, integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int zhptrs_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zhpev.c b/CLAPACK-3.2.1/SRC/zhpev.c
index 49193c8..5c92587 100644
--- a/CLAPACK-3.2.1/SRC/zhpev.c
+++ b/CLAPACK-3.2.1/SRC/zhpev.c
@@ -43,7 +43,8 @@ static integer c__1 = 1;
     extern doublereal dlamch_(char *);
     integer iscale;
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zdscal_(
 	    integer *, doublereal *, doublecomplex *, integer *);
     doublereal bignum;
     integer indtau;
diff --git a/CLAPACK-3.2.1/SRC/zhpevd.c b/CLAPACK-3.2.1/SRC/zhpevd.c
index 9bc9ad8..97d69fa 100644
--- a/CLAPACK-3.2.1/SRC/zhpevd.c
+++ b/CLAPACK-3.2.1/SRC/zhpevd.c
@@ -44,7 +44,8 @@ static integer c__1 = 1;
     extern doublereal dlamch_(char *);
     integer iscale;
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zdscal_(
 	    integer *, doublereal *, doublecomplex *, integer *);
     doublereal bignum;
     integer indtau;
diff --git a/CLAPACK-3.2.1/SRC/zhpevx.c b/CLAPACK-3.2.1/SRC/zhpevx.c
index 3f5d87d..70a0a7f 100644
--- a/CLAPACK-3.2.1/SRC/zhpevx.c
+++ b/CLAPACK-3.2.1/SRC/zhpevx.c
@@ -55,7 +55,8 @@ static integer c__1 = 1;
     integer iscale, indibl;
     logical valeig;
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zdscal_(
 	    integer *, doublereal *, doublecomplex *, integer *);
     doublereal abstll, bignum;
     integer indiwk, indisp, indtau;
diff --git a/CLAPACK-3.2.1/SRC/zhpgst.c b/CLAPACK-3.2.1/SRC/zhpgst.c
index 3533152..5dbb143 100644
--- a/CLAPACK-3.2.1/SRC/zhpgst.c
+++ b/CLAPACK-3.2.1/SRC/zhpgst.c
@@ -47,8 +47,10 @@ static integer c__1 = 1;
 	    doublecomplex *, doublecomplex *, integer *, doublecomplex *, 
 	    integer *), ztpmv_(char *, char *, char *, integer *, 
 	    doublecomplex *, doublecomplex *, integer *), ztpsv_(char *, char *, char *, integer *, doublecomplex *
-, doublecomplex *, integer *), xerbla_(
-	    char *, integer *), zdscal_(integer *, doublereal *, 
+, doublecomplex *, integer *);
+    void xerbla_(
+	    char *, integer *);
+    int zdscal_(integer *, doublereal *, 
 	    doublecomplex *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/zhpgv.c b/CLAPACK-3.2.1/SRC/zhpgv.c
index ffd205f..85c71fd 100644
--- a/CLAPACK-3.2.1/SRC/zhpgv.c
+++ b/CLAPACK-3.2.1/SRC/zhpgv.c
@@ -36,8 +36,10 @@ static integer c__1 = 1;
     logical wantz;
     extern /* Subroutine */ int ztpmv_(char *, char *, char *, integer *, 
 	    doublecomplex *, doublecomplex *, integer *), ztpsv_(char *, char *, char *, integer *, doublecomplex *
-, doublecomplex *, integer *), xerbla_(
-	    char *, integer *), zhpgst_(integer *, char *, integer *, 
+, doublecomplex *, integer *);
+    void xerbla_(
+	    char *, integer *);
+    int zhpgst_(integer *, char *, integer *, 
 	    doublecomplex *, doublecomplex *, integer *), zpptrf_(
 	    char *, integer *, doublecomplex *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/zhpgvd.c b/CLAPACK-3.2.1/SRC/zhpgvd.c
index b47f689..ce0d381 100644
--- a/CLAPACK-3.2.1/SRC/zhpgvd.c
+++ b/CLAPACK-3.2.1/SRC/zhpgvd.c
@@ -35,7 +35,8 @@ static integer c__1 = 1;
     logical upper, wantz;
     extern /* Subroutine */ int ztpmv_(char *, char *, char *, integer *, 
 	    doublecomplex *, doublecomplex *, integer *), ztpsv_(char *, char *, char *, integer *, doublecomplex *
-, doublecomplex *, integer *), xerbla_(
+, doublecomplex *, integer *);
+    void xerbla_(
 	    char *, integer *);
     integer liwmin;
     extern /* Subroutine */ int zhpevd_(char *, char *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zhpgvx.c b/CLAPACK-3.2.1/SRC/zhpgvx.c
index 2c76291..8c14699 100644
--- a/CLAPACK-3.2.1/SRC/zhpgvx.c
+++ b/CLAPACK-3.2.1/SRC/zhpgvx.c
@@ -36,7 +36,8 @@ static integer c__1 = 1;
 	    doublecomplex *, doublecomplex *, integer *), ztpsv_(char *, char *, char *, integer *, doublecomplex *
 , doublecomplex *, integer *);
     logical alleig, indeig, valeig;
-    extern /* Subroutine */ int xerbla_(char *, integer *), zhpgst_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zhpgst_(
 	    integer *, char *, integer *, doublecomplex *, doublecomplex *, 
 	    integer *), zhpevx_(char *, char *, char *, integer *, 
 	    doublecomplex *, doublereal *, doublereal *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zhprfs.c b/CLAPACK-3.2.1/SRC/zhprfs.c
index 75e7f05..115c3ba 100644
--- a/CLAPACK-3.2.1/SRC/zhprfs.c
+++ b/CLAPACK-3.2.1/SRC/zhprfs.c
@@ -53,7 +53,7 @@ static integer c__1 = 1;
 	    doublecomplex *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal lstres;
     extern /* Subroutine */ int zhptrs_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zhpsv.c b/CLAPACK-3.2.1/SRC/zhpsv.c
index fe60b30..a7fb67f 100644
--- a/CLAPACK-3.2.1/SRC/zhpsv.c
+++ b/CLAPACK-3.2.1/SRC/zhpsv.c
@@ -22,7 +22,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), zhptrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zhptrf_(
 	    char *, integer *, doublecomplex *, integer *, integer *),
 	     zhptrs_(char *, integer *, integer *, doublecomplex *, integer *, 
 	     doublecomplex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zhpsvx.c b/CLAPACK-3.2.1/SRC/zhpsvx.c
index 2b92743..96a5ace 100644
--- a/CLAPACK-3.2.1/SRC/zhpsvx.c
+++ b/CLAPACK-3.2.1/SRC/zhpsvx.c
@@ -33,7 +33,7 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *);
     extern doublereal dlamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal zlanhp_(char *, char *, integer *, doublecomplex *, 
 	    doublereal *);
     extern /* Subroutine */ int zhpcon_(char *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zhptrd.c b/CLAPACK-3.2.1/SRC/zhptrd.c
index 4829833..93aa519 100644
--- a/CLAPACK-3.2.1/SRC/zhptrd.c
+++ b/CLAPACK-3.2.1/SRC/zhptrd.c
@@ -41,7 +41,9 @@ static integer c__1 = 1;
 	    doublecomplex *, doublecomplex *, integer *, doublecomplex *, 
 	    doublecomplex *, integer *), zaxpy_(integer *, 
 	    doublecomplex *, doublecomplex *, integer *, doublecomplex *, 
-	    integer *), xerbla_(char *, integer *), zlarfg_(integer *, 
+	    integer *);
+    void xerbla_(char *, integer *);
+    int zlarfg_(integer *, 
 	     doublecomplex *, doublecomplex *, integer *, doublecomplex *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/zhptrf.c b/CLAPACK-3.2.1/SRC/zhptrf.c
index 12d1a8a..5f971fb 100644
--- a/CLAPACK-3.2.1/SRC/zhptrf.c
+++ b/CLAPACK-3.2.1/SRC/zhptrf.c
@@ -54,7 +54,8 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *);
     extern doublereal dlapy2_(doublereal *, doublereal *);
     doublereal absakk;
-    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zdscal_(
 	    integer *, doublereal *, doublecomplex *, integer *);
     doublereal colmax;
     extern integer izamax_(integer *, doublecomplex *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zhptri.c b/CLAPACK-3.2.1/SRC/zhptri.c
index f4e4938..49f6220 100644
--- a/CLAPACK-3.2.1/SRC/zhptri.c
+++ b/CLAPACK-3.2.1/SRC/zhptri.c
@@ -47,7 +47,8 @@ static integer c__1 = 1;
 	    doublecomplex *, doublecomplex *, doublecomplex *, integer *, 
 	    doublecomplex *, doublecomplex *, integer *), zswap_(
 	    integer *, doublecomplex *, integer *, doublecomplex *, integer *)
-	    , xerbla_(char *, integer *);
+	    ;
+    void xerbla_(char *, integer *);
     integer kcnext;
 
 
diff --git a/CLAPACK-3.2.1/SRC/zhptrs.c b/CLAPACK-3.2.1/SRC/zhptrs.c
index 0c35c79..1f71a7a 100644
--- a/CLAPACK-3.2.1/SRC/zhptrs.c
+++ b/CLAPACK-3.2.1/SRC/zhptrs.c
@@ -45,7 +45,9 @@ static integer c__1 = 1;
     extern /* Subroutine */ int zgeru_(integer *, integer *, doublecomplex *, 
 	    doublecomplex *, integer *, doublecomplex *, integer *, 
 	    doublecomplex *, integer *), zswap_(integer *, doublecomplex *, 
-	    integer *, doublecomplex *, integer *), xerbla_(char *, integer *), zdscal_(integer *, doublereal *, doublecomplex *, 
+	    integer *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
+    int zdscal_(integer *, doublereal *, doublecomplex *, 
 	    integer *), zlacgv_(integer *, doublecomplex *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/zhsein.c b/CLAPACK-3.2.1/SRC/zhsein.c
index 0e27b9b..ab38a6f 100644
--- a/CLAPACK-3.2.1/SRC/zhsein.c
+++ b/CLAPACK-3.2.1/SRC/zhsein.c
@@ -43,7 +43,8 @@ static logical c_true = TRUE_;
     logical leftv, bothv;
     doublereal hnorm;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), zlaein_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zlaein_(
 	    logical *, logical *, integer *, doublecomplex *, integer *, 
 	    doublecomplex *, doublecomplex *, doublecomplex *, integer *, 
 	    doublereal *, doublereal *, doublereal *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zhseqr.c b/CLAPACK-3.2.1/SRC/zhseqr.c
index dc69792..f2296b6 100644
--- a/CLAPACK-3.2.1/SRC/zhseqr.c
+++ b/CLAPACK-3.2.1/SRC/zhseqr.c
@@ -35,7 +35,7 @@ static integer c__49 = 49;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     doublecomplex hl[2401]	/* was [49][49] */;
@@ -48,7 +48,8 @@ static integer c__49 = 49;
 	    doublecomplex *, integer *), zlaqr0_(logical *, logical *, 
 	    integer *, integer *, integer *, doublecomplex *, integer *, 
 	    doublecomplex *, integer *, integer *, doublecomplex *, integer *, 
-	     doublecomplex *, integer *, integer *), xerbla_(char *, integer *
+	     doublecomplex *, integer *, integer *);
+    void xerbla_(char *, integer *
 );
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zla_gbamv.c b/CLAPACK-3.2.1/SRC/zla_gbamv.c
index 6bf7b5d..b0b75e1 100644
--- a/CLAPACK-3.2.1/SRC/zla_gbamv.c
+++ b/CLAPACK-3.2.1/SRC/zla_gbamv.c
@@ -34,7 +34,7 @@
     integer lenx, leny;
     doublereal safe1;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*     -- LAPACK routine (version 3.2)                                 -- */
diff --git a/CLAPACK-3.2.1/SRC/zla_gbrcond_c.c b/CLAPACK-3.2.1/SRC/zla_gbrcond_c.c
index 7620afa..0bdbe03 100644
--- a/CLAPACK-3.2.1/SRC/zla_gbrcond_c.c
+++ b/CLAPACK-3.2.1/SRC/zla_gbrcond_c.c
@@ -38,7 +38,8 @@ doublereal zla_gbrcond_c__(char *trans, integer *n, integer *kl, integer *ku,
     integer isave[3];
     doublereal anorm;
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
-	    doublecomplex *, doublereal *, integer *, integer *), xerbla_(
+	    doublecomplex *, doublereal *, integer *, integer *);
+    void xerbla_(
 	    char *, integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int zgbtrs_(char *, integer *, integer *, integer 
diff --git a/CLAPACK-3.2.1/SRC/zla_gbrcond_x.c b/CLAPACK-3.2.1/SRC/zla_gbrcond_x.c
index 1a89b34..357edbf 100644
--- a/CLAPACK-3.2.1/SRC/zla_gbrcond_x.c
+++ b/CLAPACK-3.2.1/SRC/zla_gbrcond_x.c
@@ -39,7 +39,8 @@ doublereal zla_gbrcond_x__(char *trans, integer *n, integer *kl, integer *ku,
     integer isave[3];
     doublereal anorm;
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
-	    doublecomplex *, doublereal *, integer *, integer *), xerbla_(
+	    doublecomplex *, doublereal *, integer *, integer *);
+    void xerbla_(
 	    char *, integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int zgbtrs_(char *, integer *, integer *, integer 
diff --git a/CLAPACK-3.2.1/SRC/zla_geamv.c b/CLAPACK-3.2.1/SRC/zla_geamv.c
index b69da5c..e4997e5 100644
--- a/CLAPACK-3.2.1/SRC/zla_geamv.c
+++ b/CLAPACK-3.2.1/SRC/zla_geamv.c
@@ -33,7 +33,7 @@
     integer lenx, leny;
     doublereal safe1;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*     -- LAPACK routine (version 3.2)                                 -- */
diff --git a/CLAPACK-3.2.1/SRC/zla_gercond_c.c b/CLAPACK-3.2.1/SRC/zla_gercond_c.c
index f0b6dc2..d5cc2b5 100644
--- a/CLAPACK-3.2.1/SRC/zla_gercond_c.c
+++ b/CLAPACK-3.2.1/SRC/zla_gercond_c.c
@@ -38,7 +38,8 @@ doublereal zla_gercond_c__(char *trans, integer *n, doublecomplex *a, integer
     integer isave[3];
     doublereal anorm;
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
-	    doublecomplex *, doublereal *, integer *, integer *), xerbla_(
+	    doublecomplex *, doublereal *, integer *, integer *);
+    void xerbla_(
 	    char *, integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int zgetrs_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zla_gercond_x.c b/CLAPACK-3.2.1/SRC/zla_gercond_x.c
index dcb399e..4fd6485 100644
--- a/CLAPACK-3.2.1/SRC/zla_gercond_x.c
+++ b/CLAPACK-3.2.1/SRC/zla_gercond_x.c
@@ -39,7 +39,8 @@ doublereal zla_gercond_x__(char *trans, integer *n, doublecomplex *a, integer
     integer isave[3];
     doublereal anorm;
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
-	    doublecomplex *, doublereal *, integer *, integer *), xerbla_(
+	    doublecomplex *, doublereal *, integer *, integer *);
+    void xerbla_(
 	    char *, integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int zgetrs_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zla_heamv.c b/CLAPACK-3.2.1/SRC/zla_heamv.c
index 1f07857..a4d2443 100644
--- a/CLAPACK-3.2.1/SRC/zla_heamv.c
+++ b/CLAPACK-3.2.1/SRC/zla_heamv.c
@@ -30,7 +30,7 @@
     integer iy, jx, kx, ky, info;
     doublereal temp, safe1;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilauplo_(char *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/zla_hercond_c.c b/CLAPACK-3.2.1/SRC/zla_hercond_c.c
index ab9771d..a2a35a7 100644
--- a/CLAPACK-3.2.1/SRC/zla_hercond_c.c
+++ b/CLAPACK-3.2.1/SRC/zla_hercond_c.c
@@ -39,7 +39,8 @@ doublereal zla_hercond_c__(char *uplo, integer *n, doublecomplex *a, integer *
     integer isave[3];
     doublereal anorm;
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
-	    doublecomplex *, doublereal *, integer *, integer *), xerbla_(
+	    doublecomplex *, doublereal *, integer *, integer *);
+    void xerbla_(
 	    char *, integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int zhetrs_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zla_hercond_x.c b/CLAPACK-3.2.1/SRC/zla_hercond_x.c
index 8105c1d..0e55f59 100644
--- a/CLAPACK-3.2.1/SRC/zla_hercond_x.c
+++ b/CLAPACK-3.2.1/SRC/zla_hercond_x.c
@@ -40,7 +40,8 @@ doublereal zla_hercond_x__(char *uplo, integer *n, doublecomplex *a, integer *
     integer isave[3];
     doublereal anorm;
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
-	    doublecomplex *, doublereal *, integer *, integer *), xerbla_(
+	    doublecomplex *, doublereal *, integer *, integer *);
+    void xerbla_(
 	    char *, integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int zhetrs_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zla_porcond_c.c b/CLAPACK-3.2.1/SRC/zla_porcond_c.c
index 13bb2b9..df8731a 100644
--- a/CLAPACK-3.2.1/SRC/zla_porcond_c.c
+++ b/CLAPACK-3.2.1/SRC/zla_porcond_c.c
@@ -39,7 +39,8 @@ doublereal zla_porcond_c__(char *uplo, integer *n, doublecomplex *a, integer *
     integer isave[3];
     doublereal anorm;
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
-	    doublecomplex *, doublereal *, integer *, integer *), xerbla_(
+	    doublecomplex *, doublereal *, integer *, integer *);
+    void xerbla_(
 	    char *, integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int zpotrs_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zla_porcond_x.c b/CLAPACK-3.2.1/SRC/zla_porcond_x.c
index 7efed2f..9027325 100644
--- a/CLAPACK-3.2.1/SRC/zla_porcond_x.c
+++ b/CLAPACK-3.2.1/SRC/zla_porcond_x.c
@@ -39,7 +39,8 @@ doublereal zla_porcond_x__(char *uplo, integer *n, doublecomplex *a, integer *
     integer isave[3];
     doublereal anorm;
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
-	    doublecomplex *, doublereal *, integer *, integer *), xerbla_(
+	    doublecomplex *, doublereal *, integer *, integer *);
+    void xerbla_(
 	    char *, integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int zpotrs_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zla_syamv.c b/CLAPACK-3.2.1/SRC/zla_syamv.c
index b9b6341..48d3eb5 100644
--- a/CLAPACK-3.2.1/SRC/zla_syamv.c
+++ b/CLAPACK-3.2.1/SRC/zla_syamv.c
@@ -30,7 +30,7 @@
     integer iy, jx, kx, ky, info;
     doublereal temp, safe1;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilauplo_(char *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/zla_syrcond_c.c b/CLAPACK-3.2.1/SRC/zla_syrcond_c.c
index f819da6..31666d2 100644
--- a/CLAPACK-3.2.1/SRC/zla_syrcond_c.c
+++ b/CLAPACK-3.2.1/SRC/zla_syrcond_c.c
@@ -39,7 +39,8 @@ doublereal zla_syrcond_c__(char *uplo, integer *n, doublecomplex *a, integer *
     integer isave[3];
     doublereal anorm;
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
-	    doublecomplex *, doublereal *, integer *, integer *), xerbla_(
+	    doublecomplex *, doublereal *, integer *, integer *);
+    void xerbla_(
 	    char *, integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int zsytrs_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zla_syrcond_x.c b/CLAPACK-3.2.1/SRC/zla_syrcond_x.c
index 682f54d..d4dc629 100644
--- a/CLAPACK-3.2.1/SRC/zla_syrcond_x.c
+++ b/CLAPACK-3.2.1/SRC/zla_syrcond_x.c
@@ -40,7 +40,8 @@ doublereal zla_syrcond_x__(char *uplo, integer *n, doublecomplex *a, integer *
     integer isave[3];
     doublereal anorm;
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
-	    doublecomplex *, doublereal *, integer *, integer *), xerbla_(
+	    doublecomplex *, doublereal *, integer *, integer *);
+    void xerbla_(
 	    char *, integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int zsytrs_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zlaed0.c b/CLAPACK-3.2.1/SRC/zlaed0.c
index c8a76ad..9a39d29 100644
--- a/CLAPACK-3.2.1/SRC/zlaed0.c
+++ b/CLAPACK-3.2.1/SRC/zlaed0.c
@@ -47,7 +47,7 @@ static integer c__1 = 1;
 	    doublereal *, doublecomplex *, doublereal *, integer *, integer *)
 	    ;
     integer igivcl;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zlacrm_(integer *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zlaed7.c b/CLAPACK-3.2.1/SRC/zlaed7.c
index ec956a7..bdc1be6 100644
--- a/CLAPACK-3.2.1/SRC/zlaed7.c
+++ b/CLAPACK-3.2.1/SRC/zlaed7.c
@@ -47,7 +47,9 @@ static integer c_n1 = -1;
 	     integer *);
     integer idlmda;
     extern /* Subroutine */ int dlamrg_(integer *, integer *, doublereal *, 
-	    integer *, integer *, integer *), xerbla_(char *, integer *), zlacrm_(integer *, integer *, doublecomplex *, integer *, 
+	    integer *, integer *, integer *);
+    void xerbla_(char *, integer *);
+    int zlacrm_(integer *, integer *, doublecomplex *, integer *, 
 	     doublereal *, integer *, doublecomplex *, integer *, doublereal *
 );
     integer coltyp;
diff --git a/CLAPACK-3.2.1/SRC/zlaed8.c b/CLAPACK-3.2.1/SRC/zlaed8.c
index 9533c0c..719e26b 100644
--- a/CLAPACK-3.2.1/SRC/zlaed8.c
+++ b/CLAPACK-3.2.1/SRC/zlaed8.c
@@ -48,7 +48,9 @@ static integer c__1 = 1;
     extern doublereal dlapy2_(doublereal *, doublereal *), dlamch_(char *);
     extern integer idamax_(integer *, doublereal *, integer *);
     extern /* Subroutine */ int dlamrg_(integer *, integer *, doublereal *, 
-	    integer *, integer *, integer *), xerbla_(char *, integer *), zlacpy_(char *, integer *, integer *, doublecomplex *, 
+	    integer *, integer *, integer *);
+    void xerbla_(char *, integer *);
+    int zlacpy_(char *, integer *, integer *, doublecomplex *, 
 	    integer *, doublecomplex *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/zlals0.c b/CLAPACK-3.2.1/SRC/zlals0.c
index 354ed21..a7a2168 100644
--- a/CLAPACK-3.2.1/SRC/zlals0.c
+++ b/CLAPACK-3.2.1/SRC/zlals0.c
@@ -54,7 +54,8 @@ static integer c__0 = 0;
 	    doublereal *, doublereal *);
     extern doublereal dlamc3_(doublereal *, doublereal *);
     extern /* Subroutine */ int zcopy_(integer *, doublecomplex *, integer *, 
-	    doublecomplex *, integer *), xerbla_(char *, integer *);
+	    doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
     doublereal dsigjp;
     extern /* Subroutine */ int zdscal_(integer *, doublereal *, 
 	    doublecomplex *, integer *), zlascl_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zlalsa.c b/CLAPACK-3.2.1/SRC/zlalsa.c
index 9b29e00..ab41c63 100644
--- a/CLAPACK-3.2.1/SRC/zlalsa.c
+++ b/CLAPACK-3.2.1/SRC/zlalsa.c
@@ -53,7 +53,8 @@ static integer c__2 = 2;
 	    integer *, doublereal *, integer *, doublereal *, doublereal *, 
 	    doublereal *, doublereal *, integer *, doublereal *, doublereal *, 
 	     doublereal *, integer *), dlasdt_(integer *, integer *, integer *
-, integer *, integer *, integer *, integer *), xerbla_(char *, 
+, integer *, integer *, integer *, integer *);
+    void xerbla_(char *, 
 	    integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/zlalsd.c b/CLAPACK-3.2.1/SRC/zlalsd.c
index 3c37773..b3eaf9b 100644
--- a/CLAPACK-3.2.1/SRC/zlalsd.c
+++ b/CLAPACK-3.2.1/SRC/zlalsd.c
@@ -73,7 +73,8 @@ static doublereal c_b35 = 0.;
 	     integer *, doublereal *, integer *, doublereal *, integer *, 
 	    doublereal *, integer *), dlaset_(char *, integer *, 
 	    integer *, doublereal *, doublereal *, doublereal *, integer *), dlartg_(doublereal *, doublereal *, doublereal *, 
-	    doublereal *, doublereal *), xerbla_(char *, integer *);
+	    doublereal *, doublereal *);
+    void xerbla_(char *, integer *);
     integer givcol;
     extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
     extern /* Subroutine */ int zlalsa_(integer *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zlarzb.c b/CLAPACK-3.2.1/SRC/zlarzb.c
index 624b671..234e877 100644
--- a/CLAPACK-3.2.1/SRC/zlarzb.c
+++ b/CLAPACK-3.2.1/SRC/zlarzb.c
@@ -37,8 +37,9 @@ static integer c__1 = 1;
 	    integer *), zcopy_(integer *, doublecomplex *, 
 	    integer *, doublecomplex *, integer *), ztrmm_(char *, char *, 
 	    char *, char *, integer *, integer *, doublecomplex *, 
-	    doublecomplex *, integer *, doublecomplex *, integer *), xerbla_(char *, integer *), 
-	    zlacgv_(integer *, doublecomplex *, integer *);
+	    doublecomplex *, integer *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
+    int zlacgv_(integer *, doublecomplex *, integer *);
     char transt[1];
 
 
diff --git a/CLAPACK-3.2.1/SRC/zlarzt.c b/CLAPACK-3.2.1/SRC/zlarzt.c
index f9e6a47..36633c3 100644
--- a/CLAPACK-3.2.1/SRC/zlarzt.c
+++ b/CLAPACK-3.2.1/SRC/zlarzt.c
@@ -33,8 +33,9 @@ static integer c__1 = 1;
 	    doublecomplex *, doublecomplex *, integer *, doublecomplex *, 
 	    integer *, doublecomplex *, doublecomplex *, integer *), 
 	    ztrmv_(char *, char *, char *, integer *, doublecomplex *, 
-	    integer *, doublecomplex *, integer *), 
-	    xerbla_(char *, integer *), zlacgv_(integer *, 
+	    integer *, doublecomplex *, integer *);
+	void xerbla_(char *, integer *);
+    int zlacgv_(integer *, 
 	    doublecomplex *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/zlascl.c b/CLAPACK-3.2.1/SRC/zlascl.c
index f0023c0..23b9d4e 100644
--- a/CLAPACK-3.2.1/SRC/zlascl.c
+++ b/CLAPACK-3.2.1/SRC/zlascl.c
@@ -32,7 +32,7 @@
     extern doublereal dlamch_(char *);
     doublereal cfromc;
     extern logical disnan_(doublereal *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum, smlnum;
 
 
diff --git a/CLAPACK-3.2.1/SRC/zlasr.c b/CLAPACK-3.2.1/SRC/zlasr.c
index 5fa4701..7c76993 100644
--- a/CLAPACK-3.2.1/SRC/zlasr.c
+++ b/CLAPACK-3.2.1/SRC/zlasr.c
@@ -26,7 +26,7 @@
     doublecomplex temp;
     extern logical lsame_(char *, char *);
     doublereal ctemp, stemp;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK auxiliary routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zlatbs.c b/CLAPACK-3.2.1/SRC/zlatbs.c
index f9629aa..0af4850 100644
--- a/CLAPACK-3.2.1/SRC/zlatbs.c
+++ b/CLAPACK-3.2.1/SRC/zlatbs.c
@@ -59,7 +59,8 @@ static doublereal c_b36 = .5;
 	    doublereal *, doublereal *);
     extern doublereal dlamch_(char *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zdscal_(
 	    integer *, doublereal *, doublecomplex *, integer *);
     doublereal bignum;
     extern integer izamax_(integer *, doublecomplex *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zlatps.c b/CLAPACK-3.2.1/SRC/zlatps.c
index be62296..b88b99c 100644
--- a/CLAPACK-3.2.1/SRC/zlatps.c
+++ b/CLAPACK-3.2.1/SRC/zlatps.c
@@ -59,7 +59,8 @@ static doublereal c_b36 = .5;
 	    doublereal *);
     extern doublereal dlamch_(char *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zdscal_(
 	    integer *, doublereal *, doublecomplex *, integer *);
     doublereal bignum;
     extern integer izamax_(integer *, doublecomplex *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zlatrs.c b/CLAPACK-3.2.1/SRC/zlatrs.c
index 06fe9bb..6650d33 100644
--- a/CLAPACK-3.2.1/SRC/zlatrs.c
+++ b/CLAPACK-3.2.1/SRC/zlatrs.c
@@ -59,7 +59,8 @@ static doublereal c_b36 = .5;
 	    doublereal *, doublereal *);
     extern doublereal dlamch_(char *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zdscal_(
 	    integer *, doublereal *, doublecomplex *, integer *);
     doublereal bignum;
     extern integer izamax_(integer *, doublecomplex *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zlauu2.c b/CLAPACK-3.2.1/SRC/zlauu2.c
index e593c5a..ff8da70 100644
--- a/CLAPACK-3.2.1/SRC/zlauu2.c
+++ b/CLAPACK-3.2.1/SRC/zlauu2.c
@@ -36,7 +36,8 @@ static integer c__1 = 1;
 	    doublecomplex *, doublecomplex *, integer *, doublecomplex *, 
 	    integer *, doublecomplex *, doublecomplex *, integer *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zdscal_(
 	    integer *, doublereal *, doublecomplex *, integer *), zlacgv_(
 	    integer *, doublecomplex *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/zlauum.c b/CLAPACK-3.2.1/SRC/zlauum.c
index 21c3789..27ff182 100644
--- a/CLAPACK-3.2.1/SRC/zlauum.c
+++ b/CLAPACK-3.2.1/SRC/zlauum.c
@@ -39,7 +39,8 @@ static doublereal c_b21 = 1.;
     extern /* Subroutine */ int ztrmm_(char *, char *, char *, char *, 
 	    integer *, integer *, doublecomplex *, doublecomplex *, integer *, 
 	     doublecomplex *, integer *), 
-	    zlauu2_(char *, integer *, doublecomplex *, integer *, integer *), xerbla_(char *, integer *);
+	    zlauu2_(char *, integer *, doublecomplex *, integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/zpbcon.c b/CLAPACK-3.2.1/SRC/zpbcon.c
index bbfa6df..5e614cb 100644
--- a/CLAPACK-3.2.1/SRC/zpbcon.c
+++ b/CLAPACK-3.2.1/SRC/zpbcon.c
@@ -38,7 +38,7 @@ static integer c__1 = 1;
 	    doublecomplex *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal scalel, scaleu;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal ainvnm;
     extern integer izamax_(integer *, doublecomplex *, integer *);
     extern /* Subroutine */ int zlatbs_(char *, char *, char *, char *, 
diff --git a/CLAPACK-3.2.1/SRC/zpbequ.c b/CLAPACK-3.2.1/SRC/zpbequ.c
index 49bbad0..c5cceee 100644
--- a/CLAPACK-3.2.1/SRC/zpbequ.c
+++ b/CLAPACK-3.2.1/SRC/zpbequ.c
@@ -29,7 +29,7 @@
     doublereal smin;
     extern logical lsame_(char *, char *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zpbrfs.c b/CLAPACK-3.2.1/SRC/zpbrfs.c
index 6df330e..473bba1 100644
--- a/CLAPACK-3.2.1/SRC/zpbrfs.c
+++ b/CLAPACK-3.2.1/SRC/zpbrfs.c
@@ -54,7 +54,7 @@ static integer c__1 = 1;
 	    integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal lstres;
     extern /* Subroutine */ int zpbtrs_(char *, integer *, integer *, integer 
 	    *, doublecomplex *, integer *, doublecomplex *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zpbstf.c b/CLAPACK-3.2.1/SRC/zpbstf.c
index 93481ac..df0f3c2 100644
--- a/CLAPACK-3.2.1/SRC/zpbstf.c
+++ b/CLAPACK-3.2.1/SRC/zpbstf.c
@@ -36,7 +36,8 @@ static doublereal c_b9 = -1.;
 	    doublecomplex *, integer *, doublecomplex *, integer *);
     extern logical lsame_(char *, char *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zdscal_(
 	    integer *, doublereal *, doublecomplex *, integer *), zlacgv_(
 	    integer *, doublecomplex *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/zpbsv.c b/CLAPACK-3.2.1/SRC/zpbsv.c
index bac0f83..5b2aa81 100644
--- a/CLAPACK-3.2.1/SRC/zpbsv.c
+++ b/CLAPACK-3.2.1/SRC/zpbsv.c
@@ -22,7 +22,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), zpbtrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zpbtrf_(
 	    char *, integer *, integer *, doublecomplex *, integer *, integer 
 	    *), zpbtrs_(char *, integer *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zpbsvx.c b/CLAPACK-3.2.1/SRC/zpbsvx.c
index 51e6109..d536225 100644
--- a/CLAPACK-3.2.1/SRC/zpbsvx.c
+++ b/CLAPACK-3.2.1/SRC/zpbsvx.c
@@ -40,7 +40,7 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *);
     extern doublereal dlamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal zlanhb_(char *, char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublereal *);
     doublereal bignum;
diff --git a/CLAPACK-3.2.1/SRC/zpbtf2.c b/CLAPACK-3.2.1/SRC/zpbtf2.c
index de9734c..45b478f 100644
--- a/CLAPACK-3.2.1/SRC/zpbtf2.c
+++ b/CLAPACK-3.2.1/SRC/zpbtf2.c
@@ -36,7 +36,8 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *, doublecomplex *, integer *);
     extern logical lsame_(char *, char *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zdscal_(
 	    integer *, doublereal *, doublecomplex *, integer *), zlacgv_(
 	    integer *, doublecomplex *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/zpbtrf.c b/CLAPACK-3.2.1/SRC/zpbtrf.c
index 79743f3..b0097ff 100644
--- a/CLAPACK-3.2.1/SRC/zpbtrf.c
+++ b/CLAPACK-3.2.1/SRC/zpbtrf.c
@@ -42,8 +42,8 @@ static integer c__33 = 33;
 	    *, char *, char *, integer *, integer *, doublecomplex *, 
 	    doublecomplex *, integer *, doublecomplex *, integer *), zpbtf2_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, integer *), zpotf2_(char *, 
-	    integer *, doublecomplex *, integer *, integer *), 
-	    xerbla_(char *, integer *);
+	    integer *, doublecomplex *, integer *, integer *);
+	void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/zpbtrs.c b/CLAPACK-3.2.1/SRC/zpbtrs.c
index 5ba99f3..c931040 100644
--- a/CLAPACK-3.2.1/SRC/zpbtrs.c
+++ b/CLAPACK-3.2.1/SRC/zpbtrs.c
@@ -29,7 +29,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     logical upper;
     extern /* Subroutine */ int ztbsv_(char *, char *, char *, integer *, 
-	    integer *, doublecomplex *, integer *, doublecomplex *, integer *), xerbla_(char *, integer *);
+	    integer *, doublecomplex *, integer *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zpftrf.c b/CLAPACK-3.2.1/SRC/zpftrf.c
index 7eae706..1fb5f3b 100644
--- a/CLAPACK-3.2.1/SRC/zpftrf.c
+++ b/CLAPACK-3.2.1/SRC/zpftrf.c
@@ -35,8 +35,8 @@ static doublereal c_b16 = 1.;
     logical lower;
     extern /* Subroutine */ int ztrsm_(char *, char *, char *, char *, 
 	    integer *, integer *, doublecomplex *, doublecomplex *, integer *, 
-	     doublecomplex *, integer *), 
-	    xerbla_(char *, integer *);
+	     doublecomplex *, integer *);
+	void xerbla_(char *, integer *);
     logical nisodd;
     extern /* Subroutine */ int zpotrf_(char *, integer *, doublecomplex *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zpftri.c b/CLAPACK-3.2.1/SRC/zpftri.c
index c23659a..b16fe5f 100644
--- a/CLAPACK-3.2.1/SRC/zpftri.c
+++ b/CLAPACK-3.2.1/SRC/zpftri.c
@@ -34,8 +34,8 @@ static doublereal c_b12 = 1.;
     logical lower;
     extern /* Subroutine */ int ztrmm_(char *, char *, char *, char *, 
 	    integer *, integer *, doublecomplex *, doublecomplex *, integer *, 
-	     doublecomplex *, integer *), 
-	    xerbla_(char *, integer *);
+	     doublecomplex *, integer *);
+	void xerbla_(char *, integer *);
     logical nisodd;
     extern /* Subroutine */ int zlauum_(char *, integer *, doublecomplex *, 
 	    integer *, integer *), ztftri_(char *, char *, char *, 
diff --git a/CLAPACK-3.2.1/SRC/zpftrs.c b/CLAPACK-3.2.1/SRC/zpftrs.c
index 9e5b151..0122f28 100644
--- a/CLAPACK-3.2.1/SRC/zpftrs.c
+++ b/CLAPACK-3.2.1/SRC/zpftrs.c
@@ -29,7 +29,8 @@ static doublecomplex c_b1 = {1.,0.};
     logical lower;
     extern /* Subroutine */ int ztfsm_(char *, char *, char *, char *, char *, 
 	     integer *, integer *, doublecomplex *, doublecomplex *, 
-	    doublecomplex *, integer *), xerbla_(char *, integer *);
+	    doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2)                                    -- */
diff --git a/CLAPACK-3.2.1/SRC/zpocon.c b/CLAPACK-3.2.1/SRC/zpocon.c
index f3dc04f..303bd11 100644
--- a/CLAPACK-3.2.1/SRC/zpocon.c
+++ b/CLAPACK-3.2.1/SRC/zpocon.c
@@ -38,7 +38,7 @@ static integer c__1 = 1;
 	    doublecomplex *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal scalel, scaleu;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal ainvnm;
     extern integer izamax_(integer *, doublecomplex *, integer *);
     extern /* Subroutine */ int zdrscl_(integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/zpoequ.c b/CLAPACK-3.2.1/SRC/zpoequ.c
index a6eb77b..e3ee50f 100644
--- a/CLAPACK-3.2.1/SRC/zpoequ.c
+++ b/CLAPACK-3.2.1/SRC/zpoequ.c
@@ -26,7 +26,7 @@
     /* Local variables */
     integer i__;
     doublereal smin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zpoequb.c b/CLAPACK-3.2.1/SRC/zpoequb.c
index e1235c7..0c5b461 100644
--- a/CLAPACK-3.2.1/SRC/zpoequb.c
+++ b/CLAPACK-3.2.1/SRC/zpoequb.c
@@ -27,7 +27,7 @@
     integer i__;
     doublereal tmp, base, smin;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*     -- LAPACK routine (version 3.2)                                 -- */
diff --git a/CLAPACK-3.2.1/SRC/zporfs.c b/CLAPACK-3.2.1/SRC/zporfs.c
index b42267d..9ba6b75 100644
--- a/CLAPACK-3.2.1/SRC/zporfs.c
+++ b/CLAPACK-3.2.1/SRC/zporfs.c
@@ -53,7 +53,7 @@ static integer c__1 = 1;
 	    integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal lstres;
     extern /* Subroutine */ int zpotrs_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zporfsx.c b/CLAPACK-3.2.1/SRC/zporfsx.c
index f775b56..1a9c725 100644
--- a/CLAPACK-3.2.1/SRC/zporfsx.c
+++ b/CLAPACK-3.2.1/SRC/zporfsx.c
@@ -60,7 +60,7 @@ static logical c_false = FALSE_;
 	    zla_porcond_x__(char *, integer *, doublecomplex *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, integer *, 
 	    doublecomplex *, doublereal *, ftnlen), dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal zlanhe_(char *, char *, integer *, doublecomplex *, 
 	    integer *, doublereal *);
     extern /* Subroutine */ int zpocon_(char *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zposv.c b/CLAPACK-3.2.1/SRC/zposv.c
index 134b5bc..ab68888 100644
--- a/CLAPACK-3.2.1/SRC/zposv.c
+++ b/CLAPACK-3.2.1/SRC/zposv.c
@@ -22,7 +22,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), zpotrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zpotrf_(
 	    char *, integer *, doublecomplex *, integer *, integer *),
 	     zpotrs_(char *, integer *, integer *, doublecomplex *, integer *, 
 	     doublecomplex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zposvx.c b/CLAPACK-3.2.1/SRC/zposvx.c
index 7eabf96..a3b4570 100644
--- a/CLAPACK-3.2.1/SRC/zposvx.c
+++ b/CLAPACK-3.2.1/SRC/zposvx.c
@@ -34,7 +34,7 @@
     logical equil, rcequ;
     extern doublereal dlamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     extern doublereal zlanhe_(char *, char *, integer *, doublecomplex *, 
 	    integer *, doublereal *);
diff --git a/CLAPACK-3.2.1/SRC/zposvxx.c b/CLAPACK-3.2.1/SRC/zposvxx.c
index fca8f41..92b3bd0 100644
--- a/CLAPACK-3.2.1/SRC/zposvxx.c
+++ b/CLAPACK-3.2.1/SRC/zposvxx.c
@@ -37,7 +37,7 @@
     logical equil, rcequ;
     extern doublereal dlamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     extern /* Subroutine */ int zlaqhe_(char *, integer *, doublecomplex *, 
 	    integer *, doublereal *, doublereal *, doublereal *, char *);
diff --git a/CLAPACK-3.2.1/SRC/zpotf2.c b/CLAPACK-3.2.1/SRC/zpotf2.c
index ffdb708..0cb9c2f 100644
--- a/CLAPACK-3.2.1/SRC/zpotf2.c
+++ b/CLAPACK-3.2.1/SRC/zpotf2.c
@@ -40,7 +40,8 @@ static integer c__1 = 1;
 	    integer *, doublecomplex *, doublecomplex *, integer *);
     logical upper;
     extern logical disnan_(doublereal *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zdscal_(
 	    integer *, doublereal *, doublecomplex *, integer *), zlacgv_(
 	    integer *, doublecomplex *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/zpotrf.c b/CLAPACK-3.2.1/SRC/zpotrf.c
index 04edc40..078cc7b 100644
--- a/CLAPACK-3.2.1/SRC/zpotrf.c
+++ b/CLAPACK-3.2.1/SRC/zpotrf.c
@@ -41,7 +41,8 @@ static doublereal c_b15 = 1.;
     extern /* Subroutine */ int ztrsm_(char *, char *, char *, char *, 
 	    integer *, integer *, doublecomplex *, doublecomplex *, integer *, 
 	     doublecomplex *, integer *), 
-	    zpotf2_(char *, integer *, doublecomplex *, integer *, integer *), xerbla_(char *, integer *);
+	    zpotf2_(char *, integer *, doublecomplex *, integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/zpotri.c b/CLAPACK-3.2.1/SRC/zpotri.c
index 54978de..ab8f409 100644
--- a/CLAPACK-3.2.1/SRC/zpotri.c
+++ b/CLAPACK-3.2.1/SRC/zpotri.c
@@ -21,7 +21,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), zlauum_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zlauum_(
 	    char *, integer *, doublecomplex *, integer *, integer *),
 	     ztrtri_(char *, char *, integer *, doublecomplex *, integer *, 
 	    integer *);
diff --git a/CLAPACK-3.2.1/SRC/zpotrs.c b/CLAPACK-3.2.1/SRC/zpotrs.c
index 908e25f..051edcf 100644
--- a/CLAPACK-3.2.1/SRC/zpotrs.c
+++ b/CLAPACK-3.2.1/SRC/zpotrs.c
@@ -29,8 +29,8 @@ static doublecomplex c_b1 = {1.,0.};
     logical upper;
     extern /* Subroutine */ int ztrsm_(char *, char *, char *, char *, 
 	    integer *, integer *, doublecomplex *, doublecomplex *, integer *, 
-	     doublecomplex *, integer *), 
-	    xerbla_(char *, integer *);
+	     doublecomplex *, integer *);
+	void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zppcon.c b/CLAPACK-3.2.1/SRC/zppcon.c
index 026cddc..d01bcf6 100644
--- a/CLAPACK-3.2.1/SRC/zppcon.c
+++ b/CLAPACK-3.2.1/SRC/zppcon.c
@@ -38,7 +38,7 @@ static integer c__1 = 1;
 	    doublecomplex *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal scalel, scaleu;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal ainvnm;
     extern integer izamax_(integer *, doublecomplex *, integer *);
     extern /* Subroutine */ int zdrscl_(integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/zppequ.c b/CLAPACK-3.2.1/SRC/zppequ.c
index d8dcefa..d461dd8 100644
--- a/CLAPACK-3.2.1/SRC/zppequ.c
+++ b/CLAPACK-3.2.1/SRC/zppequ.c
@@ -28,7 +28,7 @@
     doublereal smin;
     extern logical lsame_(char *, char *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zpprfs.c b/CLAPACK-3.2.1/SRC/zpprfs.c
index 0ad5501..5b509fb 100644
--- a/CLAPACK-3.2.1/SRC/zpprfs.c
+++ b/CLAPACK-3.2.1/SRC/zpprfs.c
@@ -52,7 +52,7 @@ static integer c__1 = 1;
 	    doublecomplex *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal lstres;
     extern /* Subroutine */ int zpptrs_(char *, integer *, integer *, 
 	    doublecomplex *, doublecomplex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zppsv.c b/CLAPACK-3.2.1/SRC/zppsv.c
index 2050474..1c55c2b 100644
--- a/CLAPACK-3.2.1/SRC/zppsv.c
+++ b/CLAPACK-3.2.1/SRC/zppsv.c
@@ -21,7 +21,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), zpptrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zpptrf_(
 	    char *, integer *, doublecomplex *, integer *), zpptrs_(
 	    char *, integer *, integer *, doublecomplex *, doublecomplex *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zppsvx.c b/CLAPACK-3.2.1/SRC/zppsvx.c
index 30e662b..92abe64 100644
--- a/CLAPACK-3.2.1/SRC/zppsvx.c
+++ b/CLAPACK-3.2.1/SRC/zppsvx.c
@@ -38,7 +38,7 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *);
     extern doublereal dlamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     integer infequ;
     extern doublereal zlanhp_(char *, char *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zpptrf.c b/CLAPACK-3.2.1/SRC/zpptrf.c
index cf28d0b..e0d9adb 100644
--- a/CLAPACK-3.2.1/SRC/zpptrf.c
+++ b/CLAPACK-3.2.1/SRC/zpptrf.c
@@ -39,7 +39,9 @@ static doublereal c_b16 = -1.;
 	    doublecomplex *, integer *, doublecomplex *, integer *);
     logical upper;
     extern /* Subroutine */ int ztpsv_(char *, char *, char *, integer *, 
-	    doublecomplex *, doublecomplex *, integer *), xerbla_(char *, integer *), zdscal_(integer *, 
+	    doublecomplex *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
+    int zdscal_(integer *, 
 	    doublereal *, doublecomplex *, integer *);
 
 
diff --git a/CLAPACK-3.2.1/SRC/zpptri.c b/CLAPACK-3.2.1/SRC/zpptri.c
index b13fc3c..c8d2b47 100644
--- a/CLAPACK-3.2.1/SRC/zpptri.c
+++ b/CLAPACK-3.2.1/SRC/zpptri.c
@@ -37,7 +37,9 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *, doublecomplex *, integer *);
     logical upper;
     extern /* Subroutine */ int ztpmv_(char *, char *, char *, integer *, 
-	    doublecomplex *, doublecomplex *, integer *), xerbla_(char *, integer *), zdscal_(integer *, 
+	    doublecomplex *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
+    int zdscal_(integer *, 
 	    doublereal *, doublecomplex *, integer *), ztptri_(char *, char *, 
 	     integer *, doublecomplex *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/zpptrs.c b/CLAPACK-3.2.1/SRC/zpptrs.c
index 3999cdd..18023b4 100644
--- a/CLAPACK-3.2.1/SRC/zpptrs.c
+++ b/CLAPACK-3.2.1/SRC/zpptrs.c
@@ -28,7 +28,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     logical upper;
     extern /* Subroutine */ int ztpsv_(char *, char *, char *, integer *, 
-	    doublecomplex *, doublecomplex *, integer *), xerbla_(char *, integer *);
+	    doublecomplex *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zpstf2.c b/CLAPACK-3.2.1/SRC/zpstf2.c
index 7aa4242..6b10e00 100644
--- a/CLAPACK-3.2.1/SRC/zpstf2.c
+++ b/CLAPACK-3.2.1/SRC/zpstf2.c
@@ -48,7 +48,8 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *);
     extern doublereal dlamch_(char *);
     extern logical disnan_(doublereal *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zdscal_(
 	    integer *, doublereal *, doublecomplex *, integer *), zlacgv_(
 	    integer *, doublecomplex *, integer *);
     extern integer dmaxloc_(doublereal *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zpstrf.c b/CLAPACK-3.2.1/SRC/zpstrf.c
index ed1c778..3cb373d 100644
--- a/CLAPACK-3.2.1/SRC/zpstrf.c
+++ b/CLAPACK-3.2.1/SRC/zpstrf.c
@@ -57,7 +57,7 @@ static doublereal c_b30 = 1.;
 	    integer *, integer *, integer *, doublereal *, doublereal *, 
 	    integer *);
     extern logical disnan_(doublereal *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zdscal_(integer *, doublereal *, 
diff --git a/CLAPACK-3.2.1/SRC/zptcon.c b/CLAPACK-3.2.1/SRC/zptcon.c
index 3e8971c..91ca416 100644
--- a/CLAPACK-3.2.1/SRC/zptcon.c
+++ b/CLAPACK-3.2.1/SRC/zptcon.c
@@ -31,7 +31,7 @@ static integer c__1 = 1;
     /* Local variables */
     integer i__, ix;
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal ainvnm;
 
 
diff --git a/CLAPACK-3.2.1/SRC/zpteqr.c b/CLAPACK-3.2.1/SRC/zpteqr.c
index 95584cf..9f849d1 100644
--- a/CLAPACK-3.2.1/SRC/zpteqr.c
+++ b/CLAPACK-3.2.1/SRC/zpteqr.c
@@ -36,7 +36,7 @@ static integer c__1 = 1;
     doublecomplex vt[1]	/* was [1][1] */;
     integer nru;
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer icompz;
     extern /* Subroutine */ int zlaset_(char *, integer *, integer *, 
 	    doublecomplex *, doublecomplex *, doublecomplex *, integer *), dpttrf_(integer *, doublereal *, doublereal *, integer *)
diff --git a/CLAPACK-3.2.1/SRC/zptrfs.c b/CLAPACK-3.2.1/SRC/zptrfs.c
index b57ae48..a31199f 100644
--- a/CLAPACK-3.2.1/SRC/zptrfs.c
+++ b/CLAPACK-3.2.1/SRC/zptrfs.c
@@ -50,7 +50,7 @@ static doublecomplex c_b16 = {1.,0.};
     extern doublereal dlamch_(char *);
     extern integer idamax_(integer *, doublereal *, integer *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal lstres;
     extern /* Subroutine */ int zpttrs_(char *, integer *, integer *, 
 	    doublereal *, doublecomplex *, doublecomplex *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zptsv.c b/CLAPACK-3.2.1/SRC/zptsv.c
index a29ead4..c11da06 100644
--- a/CLAPACK-3.2.1/SRC/zptsv.c
+++ b/CLAPACK-3.2.1/SRC/zptsv.c
@@ -20,7 +20,8 @@
     integer b_dim1, b_offset, i__1;
 
     /* Local variables */
-    extern /* Subroutine */ int xerbla_(char *, integer *), zpttrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zpttrf_(
 	    integer *, doublereal *, doublecomplex *, integer *), zpttrs_(
 	    char *, integer *, integer *, doublereal *, doublecomplex *, 
 	    doublecomplex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zptsvx.c b/CLAPACK-3.2.1/SRC/zptsvx.c
index 47ad812..9ff683f 100644
--- a/CLAPACK-3.2.1/SRC/zptsvx.c
+++ b/CLAPACK-3.2.1/SRC/zptsvx.c
@@ -34,7 +34,7 @@ static integer c__1 = 1;
 	    integer *, doublecomplex *, integer *);
     extern doublereal dlamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal zlanht_(char *, integer *, doublereal *, doublecomplex *
 );
     extern /* Subroutine */ int zlacpy_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zpttrf.c b/CLAPACK-3.2.1/SRC/zpttrf.c
index 9fb3b09..a8afc60 100644
--- a/CLAPACK-3.2.1/SRC/zpttrf.c
+++ b/CLAPACK-3.2.1/SRC/zpttrf.c
@@ -27,7 +27,7 @@
     doublereal f, g;
     integer i__, i4;
     doublereal eii, eir;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zpttrs.c b/CLAPACK-3.2.1/SRC/zpttrs.c
index ebca07e..f30d60e 100644
--- a/CLAPACK-3.2.1/SRC/zpttrs.c
+++ b/CLAPACK-3.2.1/SRC/zpttrs.c
@@ -29,8 +29,8 @@ static integer c_n1 = -1;
     integer j, jb, nb, iuplo;
     logical upper;
     extern /* Subroutine */ int zptts2_(integer *, integer *, integer *, 
-	    doublereal *, doublecomplex *, doublecomplex *, integer *), 
-	    xerbla_(char *, integer *);
+	    doublereal *, doublecomplex *, doublecomplex *, integer *);
+	void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
 
diff --git a/CLAPACK-3.2.1/SRC/zspcon.c b/CLAPACK-3.2.1/SRC/zspcon.c
index 0fc8d28..1706481 100644
--- a/CLAPACK-3.2.1/SRC/zspcon.c
+++ b/CLAPACK-3.2.1/SRC/zspcon.c
@@ -30,7 +30,8 @@ static integer c__1 = 1;
     integer isave[3];
     logical upper;
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
-	    doublecomplex *, doublereal *, integer *, integer *), xerbla_(
+	    doublecomplex *, doublereal *, integer *, integer *);
+    void xerbla_(
 	    char *, integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int zsptrs_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zspmv.c b/CLAPACK-3.2.1/SRC/zspmv.c
index 128e1db..a2ccd31 100644
--- a/CLAPACK-3.2.1/SRC/zspmv.c
+++ b/CLAPACK-3.2.1/SRC/zspmv.c
@@ -25,7 +25,7 @@
     integer i__, j, k, kk, ix, iy, jx, jy, kx, ky, info;
     doublecomplex temp1, temp2;
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK auxiliary routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zspr.c b/CLAPACK-3.2.1/SRC/zspr.c
index da539cd..84b57ed 100644
--- a/CLAPACK-3.2.1/SRC/zspr.c
+++ b/CLAPACK-3.2.1/SRC/zspr.c
@@ -24,7 +24,7 @@
     integer i__, j, k, kk, ix, jx, kx, info;
     doublecomplex temp;
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK auxiliary routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zsprfs.c b/CLAPACK-3.2.1/SRC/zsprfs.c
index f322c3a..787b9de 100644
--- a/CLAPACK-3.2.1/SRC/zsprfs.c
+++ b/CLAPACK-3.2.1/SRC/zsprfs.c
@@ -53,7 +53,7 @@ static integer c__1 = 1;
 	    doublecomplex *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal lstres;
     extern /* Subroutine */ int zsptrs_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zspsv.c b/CLAPACK-3.2.1/SRC/zspsv.c
index 1794a15..4006959 100644
--- a/CLAPACK-3.2.1/SRC/zspsv.c
+++ b/CLAPACK-3.2.1/SRC/zspsv.c
@@ -22,7 +22,8 @@
 
     /* Local variables */
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), zsptrf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zsptrf_(
 	    char *, integer *, doublecomplex *, integer *, integer *),
 	     zsptrs_(char *, integer *, integer *, doublecomplex *, integer *, 
 	     doublecomplex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zspsvx.c b/CLAPACK-3.2.1/SRC/zspsvx.c
index b8c3d86..fac5c1d 100644
--- a/CLAPACK-3.2.1/SRC/zspsvx.c
+++ b/CLAPACK-3.2.1/SRC/zspsvx.c
@@ -33,7 +33,8 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *);
     extern doublereal dlamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *), zlacpy_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zlacpy_(
 	    char *, integer *, integer *, doublecomplex *, integer *, 
 	    doublecomplex *, integer *);
     extern doublereal zlansp_(char *, char *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zsptrf.c b/CLAPACK-3.2.1/SRC/zsptrf.c
index 4482665..8303ed3 100644
--- a/CLAPACK-3.2.1/SRC/zsptrf.c
+++ b/CLAPACK-3.2.1/SRC/zsptrf.c
@@ -49,7 +49,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int zswap_(integer *, doublecomplex *, integer *, 
 	    doublecomplex *, integer *);
     doublereal absakk;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal colmax;
     extern integer izamax_(integer *, doublecomplex *, integer *);
     doublereal rowmax;
diff --git a/CLAPACK-3.2.1/SRC/zsptri.c b/CLAPACK-3.2.1/SRC/zsptri.c
index 82a3cfc..3c1beda 100644
--- a/CLAPACK-3.2.1/SRC/zsptri.c
+++ b/CLAPACK-3.2.1/SRC/zsptri.c
@@ -45,7 +45,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int zswap_(integer *, doublecomplex *, integer *, 
 	    doublecomplex *, integer *), zspmv_(char *, integer *, 
 	    doublecomplex *, doublecomplex *, doublecomplex *, integer *, 
-	    doublecomplex *, doublecomplex *, integer *), xerbla_(
+	    doublecomplex *, doublecomplex *, integer *);
+    void xerbla_(
 	    char *, integer *);
     integer kcnext;
 
diff --git a/CLAPACK-3.2.1/SRC/zsptrs.c b/CLAPACK-3.2.1/SRC/zsptrs.c
index ecf7b91..340cdc0 100644
--- a/CLAPACK-3.2.1/SRC/zsptrs.c
+++ b/CLAPACK-3.2.1/SRC/zsptrs.c
@@ -44,7 +44,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int zgeru_(integer *, integer *, doublecomplex *, 
 	    doublecomplex *, integer *, doublecomplex *, integer *, 
 	    doublecomplex *, integer *), zswap_(integer *, doublecomplex *, 
-	    integer *, doublecomplex *, integer *), xerbla_(char *, integer *);
+	    integer *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zstedc.c b/CLAPACK-3.2.1/SRC/zstedc.c
index f72c69c..31333eb 100644
--- a/CLAPACK-3.2.1/SRC/zstedc.c
+++ b/CLAPACK-3.2.1/SRC/zstedc.c
@@ -54,7 +54,8 @@ static integer c__1 = 1;
 	    doublereal *, doublereal *, doublereal *, integer *, doublereal *, 
 	     integer *, integer *, integer *, integer *), dlaset_(
 	    char *, integer *, integer *, doublereal *, doublereal *, 
-	    doublereal *, integer *), xerbla_(char *, integer *);
+	    doublereal *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer finish;
diff --git a/CLAPACK-3.2.1/SRC/zstein.c b/CLAPACK-3.2.1/SRC/zstein.c
index 0c7f08c..8599ca9 100644
--- a/CLAPACK-3.2.1/SRC/zstein.c
+++ b/CLAPACK-3.2.1/SRC/zstein.c
@@ -52,7 +52,8 @@ static integer c_n1 = -1;
 	     doublereal *, doublereal *, doublereal *, doublereal *, integer *
 , integer *);
     extern integer idamax_(integer *, doublereal *, integer *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), dlagts_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  dlagts_(
 	    integer *, integer *, doublereal *, doublereal *, doublereal *, 
 	    doublereal *, integer *, doublereal *, doublereal *, integer *);
     integer nrmchk;
diff --git a/CLAPACK-3.2.1/SRC/zstemr.c b/CLAPACK-3.2.1/SRC/zstemr.c
index 5e42fb2..320c885 100644
--- a/CLAPACK-3.2.1/SRC/zstemr.c
+++ b/CLAPACK-3.2.1/SRC/zstemr.c
@@ -81,7 +81,8 @@ static doublereal c_b18 = .001;
     extern /* Subroutine */ int dlarrj_(integer *, doublereal *, doublereal *, 
 	     integer *, integer *, doublereal *, integer *, doublereal *, 
 	    doublereal *, doublereal *, integer *, doublereal *, doublereal *, 
-	     integer *), xerbla_(char *, integer *);
+	     integer *);
+    void xerbla_(char *, integer *);
     doublereal bignum;
     integer inderr, iindwk, indgrs, offset;
     extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
diff --git a/CLAPACK-3.2.1/SRC/zsteqr.c b/CLAPACK-3.2.1/SRC/zsteqr.c
index 154a20b..07a66b9 100644
--- a/CLAPACK-3.2.1/SRC/zsteqr.c
+++ b/CLAPACK-3.2.1/SRC/zsteqr.c
@@ -61,7 +61,7 @@ static doublereal c_b41 = 1.;
     extern /* Subroutine */ int dlartg_(doublereal *, doublereal *, 
 	    doublereal *, doublereal *, doublereal *);
     doublereal safmax;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal dlanst_(char *, integer *, doublereal *, doublereal *);
     extern /* Subroutine */ int dlasrt_(char *, integer *, doublereal *, 
 	    integer *);
diff --git a/CLAPACK-3.2.1/SRC/zsycon.c b/CLAPACK-3.2.1/SRC/zsycon.c
index 7a74d75..ded42a6 100644
--- a/CLAPACK-3.2.1/SRC/zsycon.c
+++ b/CLAPACK-3.2.1/SRC/zsycon.c
@@ -30,7 +30,8 @@ static integer c__1 = 1;
     integer isave[3];
     logical upper;
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
-	    doublecomplex *, doublereal *, integer *, integer *), xerbla_(
+	    doublecomplex *, doublereal *, integer *, integer *);
+    void xerbla_(
 	    char *, integer *);
     doublereal ainvnm;
     extern /* Subroutine */ int zsytrs_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zsyequb.c b/CLAPACK-3.2.1/SRC/zsyequb.c
index 3ab99c7..898bc03 100644
--- a/CLAPACK-3.2.1/SRC/zsyequb.c
+++ b/CLAPACK-3.2.1/SRC/zsyequb.c
@@ -41,7 +41,7 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     doublereal sumsq;
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum, smlnum;
     extern /* Subroutine */ int zlassq_(integer *, doublecomplex *, integer *, 
 	     doublereal *, doublereal *);
diff --git a/CLAPACK-3.2.1/SRC/zsymv.c b/CLAPACK-3.2.1/SRC/zsymv.c
index 826855b..091d5e7 100644
--- a/CLAPACK-3.2.1/SRC/zsymv.c
+++ b/CLAPACK-3.2.1/SRC/zsymv.c
@@ -25,7 +25,7 @@
     integer i__, j, ix, iy, jx, jy, kx, ky, info;
     doublecomplex temp1, temp2;
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK auxiliary routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zsyr.c b/CLAPACK-3.2.1/SRC/zsyr.c
index 81d2ef8..ee4ae20 100644
--- a/CLAPACK-3.2.1/SRC/zsyr.c
+++ b/CLAPACK-3.2.1/SRC/zsyr.c
@@ -24,7 +24,7 @@
     integer i__, j, ix, jx, kx, info;
     doublecomplex temp;
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK auxiliary routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zsyrfs.c b/CLAPACK-3.2.1/SRC/zsyrfs.c
index f39ef25..f89552b 100644
--- a/CLAPACK-3.2.1/SRC/zsyrfs.c
+++ b/CLAPACK-3.2.1/SRC/zsyrfs.c
@@ -52,7 +52,7 @@ static integer c__1 = 1;
 	    doublecomplex *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal lstres;
     extern /* Subroutine */ int zsytrs_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, integer *, doublecomplex *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zsyrfsx.c b/CLAPACK-3.2.1/SRC/zsyrfsx.c
index 3dea882..8237436 100644
--- a/CLAPACK-3.2.1/SRC/zsyrfsx.c
+++ b/CLAPACK-3.2.1/SRC/zsyrfsx.c
@@ -60,7 +60,7 @@ static logical c_false = FALSE_;
 	    zla_syrcond_x__(char *, integer *, doublecomplex *, integer *, 
 	    doublecomplex *, integer *, integer *, doublecomplex *, integer *,
 	     doublecomplex *, doublereal *, ftnlen), dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal zlansy_(char *, char *, integer *, doublecomplex *, 
 	    integer *, doublereal *);
     extern /* Subroutine */ int zsycon_(char *, integer *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/zsysv.c b/CLAPACK-3.2.1/SRC/zsysv.c
index ce08ea1..3750d87 100644
--- a/CLAPACK-3.2.1/SRC/zsysv.c
+++ b/CLAPACK-3.2.1/SRC/zsysv.c
@@ -28,7 +28,7 @@ static integer c_n1 = -1;
     /* Local variables */
     integer nb;
     extern logical lsame_(char *, char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/zsysvx.c b/CLAPACK-3.2.1/SRC/zsysvx.c
index cdcb775..6f4745e 100644
--- a/CLAPACK-3.2.1/SRC/zsysvx.c
+++ b/CLAPACK-3.2.1/SRC/zsysvx.c
@@ -34,7 +34,7 @@ static integer c_n1 = -1;
     doublereal anorm;
     extern doublereal dlamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zlacpy_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zsysvxx.c b/CLAPACK-3.2.1/SRC/zsysvxx.c
index 833f4bf..14b357b 100644
--- a/CLAPACK-3.2.1/SRC/zsysvxx.c
+++ b/CLAPACK-3.2.1/SRC/zsysvxx.c
@@ -45,7 +45,7 @@
     logical equil, rcequ;
     extern doublereal dlamch_(char *);
     logical nofact;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     integer infequ;
     extern /* Subroutine */ int zlacpy_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/zsytf2.c b/CLAPACK-3.2.1/SRC/zsytf2.c
index 578000f..4ad4bda 100644
--- a/CLAPACK-3.2.1/SRC/zsytf2.c
+++ b/CLAPACK-3.2.1/SRC/zsytf2.c
@@ -48,7 +48,7 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *);
     doublereal absakk;
     extern logical disnan_(doublereal *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal colmax;
     extern integer izamax_(integer *, doublecomplex *, integer *);
     doublereal rowmax;
diff --git a/CLAPACK-3.2.1/SRC/zsytrf.c b/CLAPACK-3.2.1/SRC/zsytrf.c
index 43a5234..a1e0a84 100644
--- a/CLAPACK-3.2.1/SRC/zsytrf.c
+++ b/CLAPACK-3.2.1/SRC/zsytrf.c
@@ -32,7 +32,8 @@ static integer c__2 = 2;
     integer nbmin, iinfo;
     logical upper;
     extern /* Subroutine */ int zsytf2_(char *, integer *, doublecomplex *, 
-	    integer *, integer *, integer *), xerbla_(char *, integer 
+	    integer *, integer *, integer *);
+    void xerbla_(char *, integer 
 	    *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/zsytri.c b/CLAPACK-3.2.1/SRC/zsytri.c
index 020c699..91c6ea4 100644
--- a/CLAPACK-3.2.1/SRC/zsytri.c
+++ b/CLAPACK-3.2.1/SRC/zsytri.c
@@ -45,8 +45,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int zswap_(integer *, doublecomplex *, integer *, 
 	    doublecomplex *, integer *), zsymv_(char *, integer *, 
 	    doublecomplex *, doublecomplex *, integer *, doublecomplex *, 
-	    integer *, doublecomplex *, doublecomplex *, integer *), 
-	    xerbla_(char *, integer *);
+	    integer *, doublecomplex *, doublecomplex *, integer *);
+	void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zsytrs.c b/CLAPACK-3.2.1/SRC/zsytrs.c
index 5971cff..4d45eda 100644
--- a/CLAPACK-3.2.1/SRC/zsytrs.c
+++ b/CLAPACK-3.2.1/SRC/zsytrs.c
@@ -44,7 +44,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int zgeru_(integer *, integer *, doublecomplex *, 
 	    doublecomplex *, integer *, doublecomplex *, integer *, 
 	    doublecomplex *, integer *), zswap_(integer *, doublecomplex *, 
-	    integer *, doublecomplex *, integer *), xerbla_(char *, integer *);
+	    integer *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/ztbcon.c b/CLAPACK-3.2.1/SRC/ztbcon.c
index 186f3d5..f9790c5 100644
--- a/CLAPACK-3.2.1/SRC/ztbcon.c
+++ b/CLAPACK-3.2.1/SRC/ztbcon.c
@@ -39,7 +39,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
 	    doublecomplex *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal ainvnm;
     extern integer izamax_(integer *, doublecomplex *, integer *);
     extern doublereal zlantb_(char *, char *, char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/ztbrfs.c b/CLAPACK-3.2.1/SRC/ztbrfs.c
index b96354d..c0b5b5a 100644
--- a/CLAPACK-3.2.1/SRC/ztbrfs.c
+++ b/CLAPACK-3.2.1/SRC/ztbrfs.c
@@ -52,7 +52,7 @@ static integer c__1 = 1;
 	    doublecomplex *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
     char transn[1], transt[1];
     logical nounit;
diff --git a/CLAPACK-3.2.1/SRC/ztbtrs.c b/CLAPACK-3.2.1/SRC/ztbtrs.c
index b9ff7a7..b2f64f1 100644
--- a/CLAPACK-3.2.1/SRC/ztbtrs.c
+++ b/CLAPACK-3.2.1/SRC/ztbtrs.c
@@ -29,7 +29,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     logical upper;
     extern /* Subroutine */ int ztbsv_(char *, char *, char *, integer *, 
-	    integer *, doublecomplex *, integer *, doublecomplex *, integer *), xerbla_(char *, integer *);
+	    integer *, doublecomplex *, integer *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
     logical nounit;
 
 
diff --git a/CLAPACK-3.2.1/SRC/ztfsm.c b/CLAPACK-3.2.1/SRC/ztfsm.c
index 37d4bf9..55f7978 100644
--- a/CLAPACK-3.2.1/SRC/ztfsm.c
+++ b/CLAPACK-3.2.1/SRC/ztfsm.c
@@ -36,8 +36,8 @@ static doublecomplex c_b1 = {1.,0.};
     logical lower;
     extern /* Subroutine */ int ztrsm_(char *, char *, char *, char *, 
 	    integer *, integer *, doublecomplex *, doublecomplex *, integer *, 
-	     doublecomplex *, integer *), 
-	    xerbla_(char *, integer *);
+	     doublecomplex *, integer *);
+	void xerbla_(char *, integer *);
     logical misodd, nisodd, notrans;
 
 
diff --git a/CLAPACK-3.2.1/SRC/ztftri.c b/CLAPACK-3.2.1/SRC/ztftri.c
index 9c028d1..062710b 100644
--- a/CLAPACK-3.2.1/SRC/ztftri.c
+++ b/CLAPACK-3.2.1/SRC/ztftri.c
@@ -31,8 +31,8 @@ static doublecomplex c_b1 = {1.,0.};
     logical lower;
     extern /* Subroutine */ int ztrmm_(char *, char *, char *, char *, 
 	    integer *, integer *, doublecomplex *, doublecomplex *, integer *, 
-	     doublecomplex *, integer *), 
-	    xerbla_(char *, integer *);
+	     doublecomplex *, integer *);
+	void xerbla_(char *, integer *);
     logical nisodd;
     extern /* Subroutine */ int ztrtri_(char *, char *, integer *, 
 	    doublecomplex *, integer *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/ztfttp.c b/CLAPACK-3.2.1/SRC/ztfttp.c
index 91a07c2..24cba09 100644
--- a/CLAPACK-3.2.1/SRC/ztfttp.c
+++ b/CLAPACK-3.2.1/SRC/ztfttp.c
@@ -28,7 +28,7 @@
     logical normaltransr;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd;
 
 
diff --git a/CLAPACK-3.2.1/SRC/ztfttr.c b/CLAPACK-3.2.1/SRC/ztfttr.c
index c7e53b9..afca282 100644
--- a/CLAPACK-3.2.1/SRC/ztfttr.c
+++ b/CLAPACK-3.2.1/SRC/ztfttr.c
@@ -28,7 +28,7 @@
     logical normaltransr;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd;
 
 
diff --git a/CLAPACK-3.2.1/SRC/ztgevc.c b/CLAPACK-3.2.1/SRC/ztgevc.c
index 106692c..efbce07 100644
--- a/CLAPACK-3.2.1/SRC/ztgevc.c
+++ b/CLAPACK-3.2.1/SRC/ztgevc.c
@@ -70,7 +70,7 @@ static integer c__1 = 1;
     extern doublereal dlamch_(char *);
     doublecomplex salpha;
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     logical ilcomp;
     extern /* Double Complex */ VOID zladiv_(doublecomplex *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/ztgexc.c b/CLAPACK-3.2.1/SRC/ztgexc.c
index b6c5e1d..beb78fa 100644
--- a/CLAPACK-3.2.1/SRC/ztgexc.c
+++ b/CLAPACK-3.2.1/SRC/ztgexc.c
@@ -27,7 +27,8 @@
     extern /* Subroutine */ int ztgex2_(logical *, logical *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, integer *, integer *, 
-	     integer *), xerbla_(char *, integer *);
+	     integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/ztgsen.c b/CLAPACK-3.2.1/SRC/ztgsen.c
index cbff260..2211cea 100644
--- a/CLAPACK-3.2.1/SRC/ztgsen.c
+++ b/CLAPACK-3.2.1/SRC/ztgsen.c
@@ -50,7 +50,7 @@ static integer c__1 = 1;
     logical wantd1, wantd2;
     extern doublereal dlamch_(char *);
     doublereal dscale, rdscal, safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     integer liwmin;
     extern /* Subroutine */ int zlacpy_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, integer *), 
diff --git a/CLAPACK-3.2.1/SRC/ztgsja.c b/CLAPACK-3.2.1/SRC/ztgsja.c
index d364302..2ce732b 100644
--- a/CLAPACK-3.2.1/SRC/ztgsja.c
+++ b/CLAPACK-3.2.1/SRC/ztgsja.c
@@ -59,8 +59,10 @@ static doublereal c_b42 = 1.;
 	    doublecomplex *, doublereal *, doublecomplex *);
     integer kcycle;
     extern /* Subroutine */ int dlartg_(doublereal *, doublereal *, 
-	    doublereal *, doublereal *, doublereal *), xerbla_(char *, 
-	    integer *), zdscal_(integer *, doublereal *, 
+	    doublereal *, doublereal *, doublereal *);
+    void xerbla_(char *, 
+	    integer *);
+    int zdscal_(integer *, doublereal *, 
 	    doublecomplex *, integer *), zlapll_(integer *, doublecomplex *, 
 	    integer *, doublecomplex *, integer *, doublereal *), zlaset_(
 	    char *, integer *, integer *, doublecomplex *, doublecomplex *, 
diff --git a/CLAPACK-3.2.1/SRC/ztgsna.c b/CLAPACK-3.2.1/SRC/ztgsna.c
index 2e8856d..c4214f1 100644
--- a/CLAPACK-3.2.1/SRC/ztgsna.c
+++ b/CLAPACK-3.2.1/SRC/ztgsna.c
@@ -58,7 +58,7 @@ static integer c__3 = 3;
     doublecomplex dummy1[1];
     extern doublereal dznrm2_(integer *, doublecomplex *, integer *), dlamch_(
 	    char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     logical wantbh, wantdf, somcon;
     extern /* Subroutine */ int zlacpy_(char *, integer *, integer *, 
diff --git a/CLAPACK-3.2.1/SRC/ztgsy2.c b/CLAPACK-3.2.1/SRC/ztgsy2.c
index 4f1bbdd..22e5507 100644
--- a/CLAPACK-3.2.1/SRC/ztgsy2.c
+++ b/CLAPACK-3.2.1/SRC/ztgsy2.c
@@ -47,7 +47,8 @@ static integer c__1 = 1;
 	     integer *, doublereal *), zgetc2_(integer *, doublecomplex *, 
 	    integer *, integer *, integer *, integer *);
     doublereal scaloc;
-    extern /* Subroutine */ int xerbla_(char *, integer *), zlatdf_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zlatdf_(
 	    integer *, integer *, doublecomplex *, integer *, doublecomplex *, 
 	     doublereal *, doublereal *, integer *, integer *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/ztgsyl.c b/CLAPACK-3.2.1/SRC/ztgsyl.c
index 9829b40..3f57d73 100644
--- a/CLAPACK-3.2.1/SRC/ztgsyl.c
+++ b/CLAPACK-3.2.1/SRC/ztgsyl.c
@@ -57,7 +57,7 @@ static doublecomplex c_b45 = {1.,0.};
 	    doublecomplex *, integer *, doublecomplex *, integer *, 
 	    doublereal *, doublereal *, doublereal *, integer *);
     doublereal scaloc;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer iround;
diff --git a/CLAPACK-3.2.1/SRC/ztpcon.c b/CLAPACK-3.2.1/SRC/ztpcon.c
index 746b731..d218deb 100644
--- a/CLAPACK-3.2.1/SRC/ztpcon.c
+++ b/CLAPACK-3.2.1/SRC/ztpcon.c
@@ -39,7 +39,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
 	    doublecomplex *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal ainvnm;
     extern integer izamax_(integer *, doublecomplex *, integer *);
     logical onenrm;
diff --git a/CLAPACK-3.2.1/SRC/ztprfs.c b/CLAPACK-3.2.1/SRC/ztprfs.c
index 43df67b..fe5f866 100644
--- a/CLAPACK-3.2.1/SRC/ztprfs.c
+++ b/CLAPACK-3.2.1/SRC/ztprfs.c
@@ -51,7 +51,7 @@ static integer c__1 = 1;
 	    doublecomplex *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
     char transn[1], transt[1];
     logical nounit;
diff --git a/CLAPACK-3.2.1/SRC/ztptri.c b/CLAPACK-3.2.1/SRC/ztptri.c
index 2081845..e8d1515 100644
--- a/CLAPACK-3.2.1/SRC/ztptri.c
+++ b/CLAPACK-3.2.1/SRC/ztptri.c
@@ -36,7 +36,8 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *);
     logical upper;
     extern /* Subroutine */ int ztpmv_(char *, char *, char *, integer *, 
-	    doublecomplex *, doublecomplex *, integer *), xerbla_(char *, integer *);
+	    doublecomplex *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
     integer jclast;
     logical nounit;
 
diff --git a/CLAPACK-3.2.1/SRC/ztptrs.c b/CLAPACK-3.2.1/SRC/ztptrs.c
index a5affa8..3fe99be 100644
--- a/CLAPACK-3.2.1/SRC/ztptrs.c
+++ b/CLAPACK-3.2.1/SRC/ztptrs.c
@@ -29,7 +29,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     logical upper;
     extern /* Subroutine */ int ztpsv_(char *, char *, char *, integer *, 
-	    doublecomplex *, doublecomplex *, integer *), xerbla_(char *, integer *);
+	    doublecomplex *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
     logical nounit;
 
 
diff --git a/CLAPACK-3.2.1/SRC/ztpttf.c b/CLAPACK-3.2.1/SRC/ztpttf.c
index 29d2371..d4d4d9a 100644
--- a/CLAPACK-3.2.1/SRC/ztpttf.c
+++ b/CLAPACK-3.2.1/SRC/ztpttf.c
@@ -28,7 +28,7 @@
     logical normaltransr;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd;
 
 
diff --git a/CLAPACK-3.2.1/SRC/ztpttr.c b/CLAPACK-3.2.1/SRC/ztpttr.c
index 9d39cca..c1706ba 100644
--- a/CLAPACK-3.2.1/SRC/ztpttr.c
+++ b/CLAPACK-3.2.1/SRC/ztpttr.c
@@ -23,7 +23,7 @@
     integer i__, j, k;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2)                                    -- */
diff --git a/CLAPACK-3.2.1/SRC/ztrcon.c b/CLAPACK-3.2.1/SRC/ztrcon.c
index 01a0724..96e7a94 100644
--- a/CLAPACK-3.2.1/SRC/ztrcon.c
+++ b/CLAPACK-3.2.1/SRC/ztrcon.c
@@ -39,7 +39,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
 	    doublecomplex *, doublereal *, integer *, integer *);
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal ainvnm;
     extern integer izamax_(integer *, doublecomplex *, integer *);
     logical onenrm;
diff --git a/CLAPACK-3.2.1/SRC/ztrevc.c b/CLAPACK-3.2.1/SRC/ztrevc.c
index 3e4f836..2f448eb 100644
--- a/CLAPACK-3.2.1/SRC/ztrevc.c
+++ b/CLAPACK-3.2.1/SRC/ztrevc.c
@@ -50,7 +50,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int zcopy_(integer *, doublecomplex *, integer *, 
 	    doublecomplex *, integer *), dlabad_(doublereal *, doublereal *);
     extern doublereal dlamch_(char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *), zdscal_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zdscal_(
 	    integer *, doublereal *, doublecomplex *, integer *);
     extern integer izamax_(integer *, doublecomplex *, integer *);
     logical rightv;
diff --git a/CLAPACK-3.2.1/SRC/ztrexc.c b/CLAPACK-3.2.1/SRC/ztrexc.c
index 730babe..47554fc 100644
--- a/CLAPACK-3.2.1/SRC/ztrexc.c
+++ b/CLAPACK-3.2.1/SRC/ztrexc.c
@@ -36,7 +36,8 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *, doublereal *, doublecomplex *);
     extern logical lsame_(char *, char *);
     logical wantq;
-    extern /* Subroutine */ int xerbla_(char *, integer *), zlartg_(
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    int  zlartg_(
 	    doublecomplex *, doublecomplex *, doublereal *, doublecomplex *, 
 	    doublecomplex *);
 
diff --git a/CLAPACK-3.2.1/SRC/ztrrfs.c b/CLAPACK-3.2.1/SRC/ztrrfs.c
index c18131c..33a16c4 100644
--- a/CLAPACK-3.2.1/SRC/ztrrfs.c
+++ b/CLAPACK-3.2.1/SRC/ztrrfs.c
@@ -53,7 +53,7 @@ static integer c__1 = 1;
 	    integer *, integer *);
     extern doublereal dlamch_(char *);
     doublereal safmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran;
     char transn[1], transt[1];
     logical nounit;
diff --git a/CLAPACK-3.2.1/SRC/ztrsen.c b/CLAPACK-3.2.1/SRC/ztrsen.c
index a301265..7c5e853 100644
--- a/CLAPACK-3.2.1/SRC/ztrsen.c
+++ b/CLAPACK-3.2.1/SRC/ztrsen.c
@@ -38,7 +38,8 @@ static integer c_n1 = -1;
     logical wantq, wants;
     doublereal rnorm, rwork[1];
     extern /* Subroutine */ int zlacn2_(integer *, doublecomplex *, 
-	    doublecomplex *, doublereal *, integer *, integer *), xerbla_(
+	    doublecomplex *, doublereal *, integer *, integer *);
+    void xerbla_(
 	    char *, integer *);
     extern doublereal zlange_(char *, integer *, integer *, doublecomplex *, 
 	    integer *, doublereal *);
diff --git a/CLAPACK-3.2.1/SRC/ztrsna.c b/CLAPACK-3.2.1/SRC/ztrsna.c
index 0230abf..b83a51f 100644
--- a/CLAPACK-3.2.1/SRC/ztrsna.c
+++ b/CLAPACK-3.2.1/SRC/ztrsna.c
@@ -50,7 +50,7 @@ static integer c__1 = 1;
 	    doublereal *, doublereal *);
     extern doublereal dznrm2_(integer *, doublecomplex *, integer *), dlamch_(
 	    char *);
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     doublereal bignum;
     logical wantbh;
     extern integer izamax_(integer *, doublecomplex *, integer *);
diff --git a/CLAPACK-3.2.1/SRC/ztrsyl.c b/CLAPACK-3.2.1/SRC/ztrsyl.c
index 3ab1c31..fbde60f 100644
--- a/CLAPACK-3.2.1/SRC/ztrsyl.c
+++ b/CLAPACK-3.2.1/SRC/ztrsyl.c
@@ -49,7 +49,7 @@ static integer c__1 = 1;
     extern /* Subroutine */ int dlabad_(doublereal *, doublereal *);
     extern doublereal dlamch_(char *);
     doublereal scaloc;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern doublereal zlange_(char *, integer *, integer *, doublecomplex *, 
 	    integer *, doublereal *);
     doublereal bignum;
diff --git a/CLAPACK-3.2.1/SRC/ztrti2.c b/CLAPACK-3.2.1/SRC/ztrti2.c
index 43e436c..662a367 100644
--- a/CLAPACK-3.2.1/SRC/ztrti2.c
+++ b/CLAPACK-3.2.1/SRC/ztrti2.c
@@ -36,7 +36,8 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *);
     logical upper;
     extern /* Subroutine */ int ztrmv_(char *, char *, char *, integer *, 
-	    doublecomplex *, integer *, doublecomplex *, integer *), xerbla_(char *, integer *);
+	    doublecomplex *, integer *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
     logical nounit;
 
 
diff --git a/CLAPACK-3.2.1/SRC/ztrtri.c b/CLAPACK-3.2.1/SRC/ztrtri.c
index 1fede0c..5ce9a97 100644
--- a/CLAPACK-3.2.1/SRC/ztrtri.c
+++ b/CLAPACK-3.2.1/SRC/ztrtri.c
@@ -30,7 +30,7 @@ static integer c__2 = 2;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer j, jb, nb, nn;
@@ -42,7 +42,8 @@ static integer c__2 = 2;
 	    ztrsm_(char *, char *, char *, char *, integer *, integer *, 
 	    doublecomplex *, doublecomplex *, integer *, doublecomplex *, 
 	    integer *), ztrti2_(char *, char *
-, integer *, doublecomplex *, integer *, integer *), xerbla_(char *, integer *);
+, integer *, doublecomplex *, integer *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical nounit;
diff --git a/CLAPACK-3.2.1/SRC/ztrtrs.c b/CLAPACK-3.2.1/SRC/ztrtrs.c
index 1174f9c..e0dce8d 100644
--- a/CLAPACK-3.2.1/SRC/ztrtrs.c
+++ b/CLAPACK-3.2.1/SRC/ztrtrs.c
@@ -28,8 +28,8 @@ static doublecomplex c_b2 = {1.,0.};
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int ztrsm_(char *, char *, char *, char *, 
 	    integer *, integer *, doublecomplex *, doublecomplex *, integer *, 
-	     doublecomplex *, integer *), 
-	    xerbla_(char *, integer *);
+	     doublecomplex *, integer *);
+	void xerbla_(char *, integer *);
     logical nounit;
 
 
diff --git a/CLAPACK-3.2.1/SRC/ztrttf.c b/CLAPACK-3.2.1/SRC/ztrttf.c
index b15f625..f61c516 100644
--- a/CLAPACK-3.2.1/SRC/ztrttf.c
+++ b/CLAPACK-3.2.1/SRC/ztrttf.c
@@ -28,7 +28,7 @@
     logical normaltransr;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nisodd;
 
 
diff --git a/CLAPACK-3.2.1/SRC/ztrttp.c b/CLAPACK-3.2.1/SRC/ztrttp.c
index 7ac99cc..e58619d 100644
--- a/CLAPACK-3.2.1/SRC/ztrttp.c
+++ b/CLAPACK-3.2.1/SRC/ztrttp.c
@@ -23,7 +23,7 @@
     integer i__, j, k;
     extern logical lsame_(char *, char *);
     logical lower;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/ztzrqf.c b/CLAPACK-3.2.1/SRC/ztzrqf.c
index c096d8f..ffdef7d 100644
--- a/CLAPACK-3.2.1/SRC/ztzrqf.c
+++ b/CLAPACK-3.2.1/SRC/ztzrqf.c
@@ -38,7 +38,9 @@ static integer c__1 = 1;
 	    integer *, doublecomplex *, doublecomplex *, integer *), 
 	    zcopy_(integer *, doublecomplex *, integer *, doublecomplex *, 
 	    integer *), zaxpy_(integer *, doublecomplex *, doublecomplex *, 
-	    integer *, doublecomplex *, integer *), xerbla_(char *, integer *), zlacgv_(integer *, doublecomplex *, integer *), zlarfp_(
+	    integer *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
+    int zlacgv_(integer *, doublecomplex *, integer *), zlarfp_(
 	    integer *, doublecomplex *, doublecomplex *, integer *, 
 	    doublecomplex *);
 
diff --git a/CLAPACK-3.2.1/SRC/ztzrzf.c b/CLAPACK-3.2.1/SRC/ztzrzf.c
index b18feeb..dba2968 100644
--- a/CLAPACK-3.2.1/SRC/ztzrzf.c
+++ b/CLAPACK-3.2.1/SRC/ztzrzf.c
@@ -29,7 +29,7 @@ static integer c__2 = 2;
 
     /* Local variables */
     integer i__, m1, ib, nb, ki, kk, mu, nx, iws, nbmin;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer ldwork;
diff --git a/CLAPACK-3.2.1/SRC/zung2l.c b/CLAPACK-3.2.1/SRC/zung2l.c
index 1c75899..592cdb3 100644
--- a/CLAPACK-3.2.1/SRC/zung2l.c
+++ b/CLAPACK-3.2.1/SRC/zung2l.c
@@ -30,7 +30,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int zscal_(integer *, doublecomplex *, 
 	    doublecomplex *, integer *), zlarf_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *, doublecomplex *), xerbla_(char *, integer *);
+	    integer *, doublecomplex *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zung2r.c b/CLAPACK-3.2.1/SRC/zung2r.c
index 9acf7f7..1242c6b 100644
--- a/CLAPACK-3.2.1/SRC/zung2r.c
+++ b/CLAPACK-3.2.1/SRC/zung2r.c
@@ -30,7 +30,8 @@ static integer c__1 = 1;
     extern /* Subroutine */ int zscal_(integer *, doublecomplex *, 
 	    doublecomplex *, integer *), zlarf_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *, doublecomplex *), xerbla_(char *, integer *);
+	    integer *, doublecomplex *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zungbr.c b/CLAPACK-3.2.1/SRC/zungbr.c
index f620c41..4ee029b 100644
--- a/CLAPACK-3.2.1/SRC/zungbr.c
+++ b/CLAPACK-3.2.1/SRC/zungbr.c
@@ -30,7 +30,7 @@ static integer c_n1 = -1;
     extern logical lsame_(char *, char *);
     integer iinfo;
     logical wantq;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/zunghr.c b/CLAPACK-3.2.1/SRC/zunghr.c
index b78c018..a9a27e5 100644
--- a/CLAPACK-3.2.1/SRC/zunghr.c
+++ b/CLAPACK-3.2.1/SRC/zunghr.c
@@ -27,7 +27,7 @@ static integer c_n1 = -1;
 
     /* Local variables */
     integer i__, j, nb, nh, iinfo;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/zungl2.c b/CLAPACK-3.2.1/SRC/zungl2.c
index ead7974..08b422d 100644
--- a/CLAPACK-3.2.1/SRC/zungl2.c
+++ b/CLAPACK-3.2.1/SRC/zungl2.c
@@ -29,7 +29,9 @@
     extern /* Subroutine */ int zscal_(integer *, doublecomplex *, 
 	    doublecomplex *, integer *), zlarf_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *, doublecomplex *), xerbla_(char *, integer *), zlacgv_(integer *, doublecomplex *, integer *);
+	    integer *, doublecomplex *);
+    void xerbla_(char *, integer *);
+    int zlacgv_(integer *, doublecomplex *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zunglq.c b/CLAPACK-3.2.1/SRC/zunglq.c
index d871b62..d1aa58e 100644
--- a/CLAPACK-3.2.1/SRC/zunglq.c
+++ b/CLAPACK-3.2.1/SRC/zunglq.c
@@ -31,7 +31,8 @@ static integer c__2 = 2;
     integer i__, j, l, ib, nb, ki, kk, nx, iws, nbmin, iinfo;
     extern /* Subroutine */ int zungl2_(integer *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zlarfb_(char *, char *, char *, char *, 
diff --git a/CLAPACK-3.2.1/SRC/zungql.c b/CLAPACK-3.2.1/SRC/zungql.c
index 19906cf..8d5049e 100644
--- a/CLAPACK-3.2.1/SRC/zungql.c
+++ b/CLAPACK-3.2.1/SRC/zungql.c
@@ -31,7 +31,8 @@ static integer c__2 = 2;
     integer i__, j, l, ib, nb, kk, nx, iws, nbmin, iinfo;
     extern /* Subroutine */ int zung2l_(integer *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zlarfb_(char *, char *, char *, char *, 
diff --git a/CLAPACK-3.2.1/SRC/zungqr.c b/CLAPACK-3.2.1/SRC/zungqr.c
index b3036a5..efacce1 100644
--- a/CLAPACK-3.2.1/SRC/zungqr.c
+++ b/CLAPACK-3.2.1/SRC/zungqr.c
@@ -31,7 +31,8 @@ static integer c__2 = 2;
     integer i__, j, l, ib, nb, ki, kk, nx, iws, nbmin, iinfo;
     extern /* Subroutine */ int zung2r_(integer *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zlarfb_(char *, char *, char *, char *, 
diff --git a/CLAPACK-3.2.1/SRC/zungr2.c b/CLAPACK-3.2.1/SRC/zungr2.c
index f1d3c6f..625a072 100644
--- a/CLAPACK-3.2.1/SRC/zungr2.c
+++ b/CLAPACK-3.2.1/SRC/zungr2.c
@@ -29,7 +29,9 @@
     extern /* Subroutine */ int zscal_(integer *, doublecomplex *, 
 	    doublecomplex *, integer *), zlarf_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *, doublecomplex *), xerbla_(char *, integer *), zlacgv_(integer *, doublecomplex *, integer *);
+	    integer *, doublecomplex *);
+    void xerbla_(char *, integer *);
+    int zlacgv_(integer *, doublecomplex *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zungrq.c b/CLAPACK-3.2.1/SRC/zungrq.c
index 1d52575..26fd7bc 100644
--- a/CLAPACK-3.2.1/SRC/zungrq.c
+++ b/CLAPACK-3.2.1/SRC/zungrq.c
@@ -31,7 +31,8 @@ static integer c__2 = 2;
     integer i__, j, l, ib, nb, ii, kk, nx, iws, nbmin, iinfo;
     extern /* Subroutine */ int zungr2_(integer *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zlarfb_(char *, char *, char *, char *, 
diff --git a/CLAPACK-3.2.1/SRC/zungtr.c b/CLAPACK-3.2.1/SRC/zungtr.c
index 1000fb8..959946e 100644
--- a/CLAPACK-3.2.1/SRC/zungtr.c
+++ b/CLAPACK-3.2.1/SRC/zungtr.c
@@ -30,7 +30,7 @@ static integer c_n1 = -1;
     extern logical lsame_(char *, char *);
     integer iinfo;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/zunm2l.c b/CLAPACK-3.2.1/SRC/zunm2l.c
index 4a49f63..13eb492 100644
--- a/CLAPACK-3.2.1/SRC/zunm2l.c
+++ b/CLAPACK-3.2.1/SRC/zunm2l.c
@@ -36,7 +36,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int zlarf_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *, doublecomplex *), xerbla_(char *, integer *);
+	    integer *, doublecomplex *);
+    void xerbla_(char *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/zunm2r.c b/CLAPACK-3.2.1/SRC/zunm2r.c
index a551863..65c2cff 100644
--- a/CLAPACK-3.2.1/SRC/zunm2r.c
+++ b/CLAPACK-3.2.1/SRC/zunm2r.c
@@ -36,7 +36,8 @@ static integer c__1 = 1;
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int zlarf_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *, doublecomplex *), xerbla_(char *, integer *);
+	    integer *, doublecomplex *);
+    void xerbla_(char *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/zunmbr.c b/CLAPACK-3.2.1/SRC/zunmbr.c
index 0179f82..4346e97 100644
--- a/CLAPACK-3.2.1/SRC/zunmbr.c
+++ b/CLAPACK-3.2.1/SRC/zunmbr.c
@@ -30,14 +30,14 @@ static integer c__2 = 2;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i1, i2, nb, mi, ni, nq, nw;
     logical left;
     extern logical lsame_(char *, char *);
     integer iinfo;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical notran, applyq;
diff --git a/CLAPACK-3.2.1/SRC/zunmhr.c b/CLAPACK-3.2.1/SRC/zunmhr.c
index c67935a..6e76bdd 100644
--- a/CLAPACK-3.2.1/SRC/zunmhr.c
+++ b/CLAPACK-3.2.1/SRC/zunmhr.c
@@ -30,14 +30,14 @@ static integer c__2 = 2;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i1, i2, nb, mi, nh, ni, nq, nw;
     logical left;
     extern logical lsame_(char *, char *);
     integer iinfo;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/zunml2.c b/CLAPACK-3.2.1/SRC/zunml2.c
index 10899a5..e462845 100644
--- a/CLAPACK-3.2.1/SRC/zunml2.c
+++ b/CLAPACK-3.2.1/SRC/zunml2.c
@@ -32,7 +32,9 @@
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int zlarf_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *, doublecomplex *), xerbla_(char *, integer *), zlacgv_(integer *, doublecomplex *, integer *);
+	    integer *, doublecomplex *);
+    void xerbla_(char *, integer *);
+    int zlacgv_(integer *, doublecomplex *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/zunmlq.c b/CLAPACK-3.2.1/SRC/zunmlq.c
index a231596..6187b2d 100644
--- a/CLAPACK-3.2.1/SRC/zunmlq.c
+++ b/CLAPACK-3.2.1/SRC/zunmlq.c
@@ -32,7 +32,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -43,7 +43,8 @@ static integer c__65 = 65;
     integer nbmin, iinfo;
     extern /* Subroutine */ int zunml2_(char *, char *, integer *, integer *, 
 	    integer *, doublecomplex *, integer *, doublecomplex *, 
-	    doublecomplex *, integer *, doublecomplex *, integer *), xerbla_(char *, integer *);
+	    doublecomplex *, integer *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zlarfb_(char *, char *, char *, char *, 
diff --git a/CLAPACK-3.2.1/SRC/zunmql.c b/CLAPACK-3.2.1/SRC/zunmql.c
index f159164..4651ba4 100644
--- a/CLAPACK-3.2.1/SRC/zunmql.c
+++ b/CLAPACK-3.2.1/SRC/zunmql.c
@@ -32,7 +32,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -43,7 +43,8 @@ static integer c__65 = 65;
     integer nbmin, iinfo;
     extern /* Subroutine */ int zunm2l_(char *, char *, integer *, integer *, 
 	    integer *, doublecomplex *, integer *, doublecomplex *, 
-	    doublecomplex *, integer *, doublecomplex *, integer *), xerbla_(char *, integer *);
+	    doublecomplex *, integer *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zlarfb_(char *, char *, char *, char *, 
diff --git a/CLAPACK-3.2.1/SRC/zunmqr.c b/CLAPACK-3.2.1/SRC/zunmqr.c
index 1074b2a..7562283 100644
--- a/CLAPACK-3.2.1/SRC/zunmqr.c
+++ b/CLAPACK-3.2.1/SRC/zunmqr.c
@@ -32,7 +32,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -43,7 +43,8 @@ static integer c__65 = 65;
     integer nbmin, iinfo;
     extern /* Subroutine */ int zunm2r_(char *, char *, integer *, integer *, 
 	    integer *, doublecomplex *, integer *, doublecomplex *, 
-	    doublecomplex *, integer *, doublecomplex *, integer *), xerbla_(char *, integer *);
+	    doublecomplex *, integer *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zlarfb_(char *, char *, char *, char *, 
diff --git a/CLAPACK-3.2.1/SRC/zunmr2.c b/CLAPACK-3.2.1/SRC/zunmr2.c
index e3ab2fe..1835e14 100644
--- a/CLAPACK-3.2.1/SRC/zunmr2.c
+++ b/CLAPACK-3.2.1/SRC/zunmr2.c
@@ -32,7 +32,9 @@
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int zlarf_(char *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *, doublecomplex *), xerbla_(char *, integer *), zlacgv_(integer *, doublecomplex *, integer *);
+	    integer *, doublecomplex *);
+    void xerbla_(char *, integer *);
+    int zlacgv_(integer *, doublecomplex *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/zunmr3.c b/CLAPACK-3.2.1/SRC/zunmr3.c
index bd39c0b..246b663 100644
--- a/CLAPACK-3.2.1/SRC/zunmr3.c
+++ b/CLAPACK-3.2.1/SRC/zunmr3.c
@@ -32,7 +32,8 @@
     extern logical lsame_(char *, char *);
     extern /* Subroutine */ int zlarz_(char *, integer *, integer *, integer *
 , doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *, doublecomplex *), xerbla_(char *, integer *);
+	    integer *, doublecomplex *);
+    void xerbla_(char *, integer *);
     logical notran;
 
 
diff --git a/CLAPACK-3.2.1/SRC/zunmrq.c b/CLAPACK-3.2.1/SRC/zunmrq.c
index 5cd6d34..1979ea4 100644
--- a/CLAPACK-3.2.1/SRC/zunmrq.c
+++ b/CLAPACK-3.2.1/SRC/zunmrq.c
@@ -32,7 +32,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -43,7 +43,8 @@ static integer c__65 = 65;
     integer nbmin, iinfo;
     extern /* Subroutine */ int zunmr2_(char *, char *, integer *, integer *, 
 	    integer *, doublecomplex *, integer *, doublecomplex *, 
-	    doublecomplex *, integer *, doublecomplex *, integer *), xerbla_(char *, integer *);
+	    doublecomplex *, integer *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     extern /* Subroutine */ int zlarfb_(char *, char *, char *, char *, 
diff --git a/CLAPACK-3.2.1/SRC/zunmrz.c b/CLAPACK-3.2.1/SRC/zunmrz.c
index 8cc2089..1b833fa 100644
--- a/CLAPACK-3.2.1/SRC/zunmrz.c
+++ b/CLAPACK-3.2.1/SRC/zunmrz.c
@@ -32,7 +32,7 @@ static integer c__65 = 65;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -43,7 +43,8 @@ static integer c__65 = 65;
     integer nbmin, iinfo;
     extern /* Subroutine */ int zunmr3_(char *, char *, integer *, integer *, 
 	    integer *, integer *, doublecomplex *, integer *, doublecomplex *, 
-	     doublecomplex *, integer *, doublecomplex *, integer *), xerbla_(char *, integer *);
+	     doublecomplex *, integer *, doublecomplex *, integer *);
+    void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     logical notran;
diff --git a/CLAPACK-3.2.1/SRC/zunmtr.c b/CLAPACK-3.2.1/SRC/zunmtr.c
index 012737a..5445106 100644
--- a/CLAPACK-3.2.1/SRC/zunmtr.c
+++ b/CLAPACK-3.2.1/SRC/zunmtr.c
@@ -30,7 +30,7 @@ static integer c__2 = 2;
     char ch__1[2];
 
     /* Builtin functions */
-    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i1, i2, nb, mi, ni, nq, nw;
@@ -38,7 +38,7 @@ static integer c__2 = 2;
     extern logical lsame_(char *, char *);
     integer iinfo;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
 	    integer *, integer *);
     integer lwkopt;
diff --git a/CLAPACK-3.2.1/SRC/zupgtr.c b/CLAPACK-3.2.1/SRC/zupgtr.c
index 2954727..9067812 100644
--- a/CLAPACK-3.2.1/SRC/zupgtr.c
+++ b/CLAPACK-3.2.1/SRC/zupgtr.c
@@ -29,7 +29,8 @@
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
 	    integer *), zung2r_(integer *, integer *, integer *, 
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
-	    integer *), xerbla_(char *, integer *);
+	    integer *);
+    void xerbla_(char *, integer *);
 
 
 /*  -- LAPACK routine (version 3.2) -- */
diff --git a/CLAPACK-3.2.1/SRC/zupmtr.c b/CLAPACK-3.2.1/SRC/zupmtr.c
index 5d10cea..6193209 100644
--- a/CLAPACK-3.2.1/SRC/zupmtr.c
+++ b/CLAPACK-3.2.1/SRC/zupmtr.c
@@ -38,7 +38,7 @@ static integer c__1 = 1;
 	    doublecomplex *, integer *, doublecomplex *, doublecomplex *, 
 	    integer *, doublecomplex *);
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical notran, forwrd;
 
 
diff --git a/CLAPACK-3.2.1/make.inc.WASM b/CLAPACK-3.2.1/make.inc
similarity index 100%
rename from CLAPACK-3.2.1/make.inc.WASM
rename to CLAPACK-3.2.1/make.inc
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..3e936cf
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,18 @@
+.PHONY: all
+all: libf2c blas cblas clapack
+
+.PHONY: libf2c
+libf2c:
+	$(MAKE) -C libf2c
+
+.PHONY: blas
+blas:
+	$(MAKE) -C f2c_BLAS-3.8.0
+
+.PHONY: cblas
+cblas:
+	$(MAKE) -C CBLAS
+
+.PHONY: clapack
+clapack:
+	$(MAKE) -C CLAPACK-3.2.1
\ No newline at end of file
diff --git a/f2c_BLAS-3.8.0/caxpy.c b/f2c_BLAS-3.8.0/caxpy.c
index 7d4f239..7fda16e 100644
--- a/f2c_BLAS-3.8.0/caxpy.c
+++ b/f2c_BLAS-3.8.0/caxpy.c
@@ -100,7 +100,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int caxpy_(integer *n, complex *ca, complex *cx, integer *
+/* Subroutine */ void caxpy_(integer *n, complex *ca, complex *cx, integer *
 	incx, complex *cy, integer *incy)
 {
     /* System generated locals */
@@ -134,10 +134,10 @@
 
     /* Function Body */
     if (*n <= 0) {
-	return 0;
+	return;
     }
     if (scabs1_(ca) == 0.f) {
-	return 0;
+	return;
     }
     if (*incx == 1 && *incy == 1) {
 
@@ -180,6 +180,6 @@
 	}
     }
 
-    return 0;
+    return;
 } /* caxpy_ */
 
diff --git a/f2c_BLAS-3.8.0/ccopy.c b/f2c_BLAS-3.8.0/ccopy.c
index 6e74b25..6b74285 100644
--- a/f2c_BLAS-3.8.0/ccopy.c
+++ b/f2c_BLAS-3.8.0/ccopy.c
@@ -93,7 +93,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ccopy_(integer *n, complex *cx, integer *incx, complex *
+/* Subroutine */ void ccopy_(integer *n, complex *cx, integer *incx, complex *
 	cy, integer *incy)
 {
     /* System generated locals */
@@ -123,7 +123,7 @@
 
     /* Function Body */
     if (*n <= 0) {
-	return 0;
+	return;
     }
     if (*incx == 1 && *incy == 1) {
 
@@ -157,6 +157,6 @@
 	    iy += *incy;
 	}
     }
-    return 0;
+    return;
 } /* ccopy_ */
 
diff --git a/f2c_BLAS-3.8.0/cgbmv.c b/f2c_BLAS-3.8.0/cgbmv.c
index fa23f21..ec9008e 100644
--- a/f2c_BLAS-3.8.0/cgbmv.c
+++ b/f2c_BLAS-3.8.0/cgbmv.c
@@ -199,10 +199,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int cgbmv_(char *trans, integer *m, integer *n, integer *kl, 
+/* Subroutine */ void cgbmv_(char *trans, integer *m, integer *n, integer *kl, 
 	integer *ku, complex *alpha, complex *a, integer *lda, complex *x, 
-	integer *incx, complex *beta, complex *y, integer *incy, ftnlen 
-	trans_len)
+	integer *incx, complex *beta, complex *y, integer *incy)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;
@@ -215,8 +214,8 @@
     integer i__, j, k, ix, iy, jx, jy, kx, ky, kup1, info;
     complex temp;
     integer lenx, leny;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconj;
 
 
@@ -254,9 +253,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "T", (
-	    ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (ftnlen)1)
-	    ) {
+    if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 1;
     } else if (*m < 0) {
 	info = 2;
@@ -274,23 +271,23 @@
 	info = 13;
     }
     if (info != 0) {
-	xerbla_("CGBMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CGBMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || alpha->r == 0.f && alpha->i == 0.f && (beta->r 
 	    == 1.f && beta->i == 0.f)) {
-	return 0;
+	return;
     }
 
-    noconj = lsame_(trans, "T", (ftnlen)1, (ftnlen)1);
+    noconj = lsame_(trans, "T");
 
 /*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set */
 /*     up the start points in  X  and  Y. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 	lenx = *n;
 	leny = *m;
     } else {
@@ -360,10 +357,10 @@
 	}
     }
     if (alpha->r == 0.f && alpha->i == 0.f) {
-	return 0;
+	return;
     }
     kup1 = *ku + 1;
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  y := alpha*A*x + y. */
 
@@ -534,7 +531,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CGBMV . */
 
diff --git a/f2c_BLAS-3.8.0/cgemm.c b/f2c_BLAS-3.8.0/cgemm.c
index 31eb8cf..7a309d4 100644
--- a/f2c_BLAS-3.8.0/cgemm.c
+++ b/f2c_BLAS-3.8.0/cgemm.c
@@ -199,10 +199,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int cgemm_(char *transa, char *transb, integer *m, integer *
+/* Subroutine */ void cgemm_(char *transa, char *transb, integer *m, integer *
 	n, integer *k, complex *alpha, complex *a, integer *lda, complex *b, 
-	integer *ldb, complex *beta, complex *c__, integer *ldc, ftnlen 
-	transa_len, ftnlen transb_len)
+	integer *ldb, complex *beta, complex *c__, integer *ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, 
@@ -218,9 +217,9 @@
     complex temp;
     logical conja, conjb;
     integer ncola;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa, nrowb;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -264,10 +263,10 @@
     c__ -= c_offset;
 
     /* Function Body */
-    nota = lsame_(transa, "N", (ftnlen)1, (ftnlen)1);
-    notb = lsame_(transb, "N", (ftnlen)1, (ftnlen)1);
-    conja = lsame_(transa, "C", (ftnlen)1, (ftnlen)1);
-    conjb = lsame_(transb, "C", (ftnlen)1, (ftnlen)1);
+    nota = lsame_(transa, "N");
+    notb = lsame_(transb, "N");
+    conja = lsame_(transa, "C");
+    conjb = lsame_(transb, "C");
     if (nota) {
 	nrowa = *m;
 	ncola = *k;
@@ -284,10 +283,9 @@
 /*     Test the input parameters. */
 
     info = 0;
-    if (! nota && ! conja && ! lsame_(transa, "T", (ftnlen)1, (ftnlen)1)) {
+    if (! nota && ! conja && ! lsame_(transa, "T")) {
 	info = 1;
-    } else if (! notb && ! conjb && ! lsame_(transb, "T", (ftnlen)1, (ftnlen)
-	    1)) {
+    } else if (! notb && ! conjb && ! lsame_(transb, "T")) {
 	info = 2;
     } else if (*m < 0) {
 	info = 3;
@@ -303,15 +301,15 @@
 	info = 13;
     }
     if (info != 0) {
-	xerbla_("CGEMM ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CGEMM ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || (alpha->r == 0.f && alpha->i == 0.f || *k == 0) 
 	    && (beta->r == 1.f && beta->i == 0.f)) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -344,7 +342,7 @@
 /* L40: */
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
@@ -756,7 +754,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CGEMM . */
 
diff --git a/f2c_BLAS-3.8.0/cgemv.c b/f2c_BLAS-3.8.0/cgemv.c
index 65f8081..faebc6b 100644
--- a/f2c_BLAS-3.8.0/cgemv.c
+++ b/f2c_BLAS-3.8.0/cgemv.c
@@ -170,9 +170,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int cgemv_(char *trans, integer *m, integer *n, complex *
+/* Subroutine */ void cgemv_(char *trans, integer *m, integer *n, complex *
 	alpha, complex *a, integer *lda, complex *x, integer *incx, complex *
-	beta, complex *y, integer *incy, ftnlen trans_len)
+	beta, complex *y, integer *incy)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
@@ -185,8 +185,8 @@
     integer i__, j, ix, iy, jx, jy, kx, ky, info;
     complex temp;
     integer lenx, leny;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconj;
 
 
@@ -224,9 +224,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "T", (
-	    ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (ftnlen)1)
-	    ) {
+    if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 1;
     } else if (*m < 0) {
 	info = 2;
@@ -240,23 +238,23 @@
 	info = 11;
     }
     if (info != 0) {
-	xerbla_("CGEMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CGEMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || alpha->r == 0.f && alpha->i == 0.f && (beta->r 
 	    == 1.f && beta->i == 0.f)) {
-	return 0;
+	return;
     }
 
-    noconj = lsame_(trans, "T", (ftnlen)1, (ftnlen)1);
+    noconj = lsame_(trans, "T");
 
 /*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set */
 /*     up the start points in  X  and  Y. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 	lenx = *n;
 	leny = *m;
     } else {
@@ -326,9 +324,9 @@
 	}
     }
     if (alpha->r == 0.f && alpha->i == 0.f) {
-	return 0;
+	return;
     }
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  y := alpha*A*x + y. */
 
@@ -465,7 +463,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CGEMV . */
 
diff --git a/f2c_BLAS-3.8.0/cgerc.c b/f2c_BLAS-3.8.0/cgerc.c
index f85d6c2..3dfb9ac 100644
--- a/f2c_BLAS-3.8.0/cgerc.c
+++ b/f2c_BLAS-3.8.0/cgerc.c
@@ -142,7 +142,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int cgerc_(integer *m, integer *n, complex *alpha, complex *
+/* Subroutine */ void cgerc_(integer *m, integer *n, complex *alpha, complex *
 	x, integer *incx, complex *y, integer *incy, complex *a, integer *lda)
 {
     /* System generated locals */
@@ -155,7 +155,7 @@
     /* Local variables */
     integer i__, j, ix, jy, kx, info;
     complex temp;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -202,14 +202,14 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("CGERC ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CGERC ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || alpha->r == 0.f && alpha->i == 0.f) {
-	return 0;
+	return;
     }
 
 /*     Start the operations. In this version the elements of A are */
@@ -277,7 +277,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CGERC . */
 
diff --git a/f2c_BLAS-3.8.0/cgeru.c b/f2c_BLAS-3.8.0/cgeru.c
index b5642c6..727cce1 100644
--- a/f2c_BLAS-3.8.0/cgeru.c
+++ b/f2c_BLAS-3.8.0/cgeru.c
@@ -142,7 +142,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int cgeru_(integer *m, integer *n, complex *alpha, complex *
+/* Subroutine */ void cgeru_(integer *m, integer *n, complex *alpha, complex *
 	x, integer *incx, complex *y, integer *incy, complex *a, integer *lda)
 {
     /* System generated locals */
@@ -152,7 +152,7 @@
     /* Local variables */
     integer i__, j, ix, jy, kx, info;
     complex temp;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -199,14 +199,14 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("CGERU ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CGERU ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || alpha->r == 0.f && alpha->i == 0.f) {
-	return 0;
+	return;
     }
 
 /*     Start the operations. In this version the elements of A are */
@@ -274,7 +274,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CGERU . */
 
diff --git a/f2c_BLAS-3.8.0/chbmv.c b/f2c_BLAS-3.8.0/chbmv.c
index e15ed32..70ed1f4 100644
--- a/f2c_BLAS-3.8.0/chbmv.c
+++ b/f2c_BLAS-3.8.0/chbmv.c
@@ -199,9 +199,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int chbmv_(char *uplo, integer *n, integer *k, complex *
+/* Subroutine */ void chbmv_(char *uplo, integer *n, integer *k, complex *
 	alpha, complex *a, integer *lda, complex *x, integer *incx, complex *
-	beta, complex *y, integer *incy, ftnlen uplo_len)
+	beta, complex *y, integer *incy)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
@@ -214,9 +214,9 @@
     /* Local variables */
     integer i__, j, l, ix, iy, jx, jy, kx, ky, info;
     complex temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer kplus1;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -253,8 +253,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -268,15 +267,15 @@
 	info = 11;
     }
     if (info != 0) {
-	xerbla_("CHBMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CHBMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || alpha->r == 0.f && alpha->i == 0.f && (beta->r == 1.f && 
 	    beta->i == 0.f)) {
-	return 0;
+	return;
     }
 
 /*     Set up the start points in  X  and  Y. */
@@ -344,9 +343,9 @@
 	}
     }
     if (alpha->r == 0.f && alpha->i == 0.f) {
-	return 0;
+	return;
     }
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  y  when upper triangle of A is stored. */
 
@@ -549,7 +548,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CHBMV . */
 
diff --git a/f2c_BLAS-3.8.0/chemm.c b/f2c_BLAS-3.8.0/chemm.c
index f0c6d27..412009a 100644
--- a/f2c_BLAS-3.8.0/chemm.c
+++ b/f2c_BLAS-3.8.0/chemm.c
@@ -203,10 +203,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int chemm_(char *side, char *uplo, integer *m, integer *n, 
+/* Subroutine */ void chemm_(char *side, char *uplo, integer *m, integer *n, 
 	complex *alpha, complex *a, integer *lda, complex *b, integer *ldb, 
-	complex *beta, complex *c__, integer *ldc, ftnlen side_len, ftnlen 
-	uplo_len)
+	complex *beta, complex *c__, integer *ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, 
@@ -220,10 +219,10 @@
     /* Local variables */
     integer i__, j, k, info;
     complex temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -263,20 +262,19 @@
     c__ -= c_offset;
 
     /* Function Body */
-    if (lsame_(side, "L", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(side, "L")) {
 	nrowa = *m;
     } else {
 	nrowa = *n;
     }
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    upper = lsame_(uplo, "U");
 
 /*     Test the input parameters. */
 
     info = 0;
-    if (! lsame_(side, "L", (ftnlen)1, (ftnlen)1) && ! lsame_(side, "R", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(side, "L") && ! lsame_(side, "R")) {
 	info = 1;
-    } else if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    } else if (! upper && ! lsame_(uplo, "L")) {
 	info = 2;
     } else if (*m < 0) {
 	info = 3;
@@ -290,15 +288,15 @@
 	info = 12;
     }
     if (info != 0) {
-	xerbla_("CHEMM ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CHEMM ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || alpha->r == 0.f && alpha->i == 0.f && (beta->r 
 	    == 1.f && beta->i == 0.f)) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -331,12 +329,12 @@
 /* L40: */
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
-    if (lsame_(side, "L", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(side, "L")) {
 
 /*        Form  C := alpha*A*B + beta*C. */
 
@@ -562,7 +560,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CHEMM . */
 
diff --git a/f2c_BLAS-3.8.0/chemv.c b/f2c_BLAS-3.8.0/chemv.c
index e60c0ff..3190dda 100644
--- a/f2c_BLAS-3.8.0/chemv.c
+++ b/f2c_BLAS-3.8.0/chemv.c
@@ -166,9 +166,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int chemv_(char *uplo, integer *n, complex *alpha, complex *
+/* Subroutine */ void chemv_(char *uplo, integer *n, complex *alpha, complex *
 	a, integer *lda, complex *x, integer *incx, complex *beta, complex *y,
-	 integer *incy, ftnlen uplo_len)
+	 integer *incy)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
@@ -181,8 +181,8 @@
     /* Local variables */
     integer i__, j, ix, iy, jx, jy, kx, ky, info;
     complex temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -219,8 +219,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -232,15 +231,15 @@
 	info = 10;
     }
     if (info != 0) {
-	xerbla_("CHEMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CHEMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || alpha->r == 0.f && alpha->i == 0.f && (beta->r == 1.f && 
 	    beta->i == 0.f)) {
-	return 0;
+	return;
     }
 
 /*     Set up the start points in  X  and  Y. */
@@ -309,9 +308,9 @@
 	}
     }
     if (alpha->r == 0.f && alpha->i == 0.f) {
-	return 0;
+	return;
     }
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  y  when A is stored in upper triangle. */
 
@@ -497,7 +496,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CHEMV . */
 
diff --git a/f2c_BLAS-3.8.0/cher.c b/f2c_BLAS-3.8.0/cher.c
index acb96f6..e8eabc4 100644
--- a/f2c_BLAS-3.8.0/cher.c
+++ b/f2c_BLAS-3.8.0/cher.c
@@ -147,8 +147,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int cher_(char *uplo, integer *n, real *alpha, complex *x, 
-	integer *incx, complex *a, integer *lda, ftnlen uplo_len)
+/* Subroutine */ void cher_(char *uplo, integer *n, real *alpha, complex *x, 
+	integer *incx, complex *a, integer *lda)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
@@ -161,8 +161,8 @@
     /* Local variables */
     integer i__, j, ix, jx, kx, info;
     complex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -198,8 +198,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -209,14 +208,14 @@
 	info = 7;
     }
     if (info != 0) {
-	xerbla_("CHER  ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CHER  ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || *alpha == 0.f) {
-	return 0;
+	return;
     }
 
 /*     Set the start point in X if the increment is not unity. */
@@ -231,7 +230,7 @@
 /*     accessed sequentially with one pass through the triangular part */
 /*     of A. */
 
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  A  when A is stored in upper triangle. */
 
@@ -395,7 +394,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CHER  . */
 
diff --git a/f2c_BLAS-3.8.0/cher2.c b/f2c_BLAS-3.8.0/cher2.c
index 3dd9f90..b75b071 100644
--- a/f2c_BLAS-3.8.0/cher2.c
+++ b/f2c_BLAS-3.8.0/cher2.c
@@ -162,9 +162,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int cher2_(char *uplo, integer *n, complex *alpha, complex *
-	x, integer *incx, complex *y, integer *incy, complex *a, integer *lda,
-	 ftnlen uplo_len)
+/* Subroutine */ void cher2_(char *uplo, integer *n, complex *alpha, complex *
+	x, integer *incx, complex *y, integer *incy, complex *a, integer *lda)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;
@@ -177,8 +176,8 @@
     /* Local variables */
     integer i__, j, ix, iy, jx, jy, kx, ky, info;
     complex temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -215,8 +214,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -228,14 +226,14 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("CHER2 ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CHER2 ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || alpha->r == 0.f && alpha->i == 0.f) {
-	return 0;
+	return;
     }
 
 /*     Set up the start points in X and Y if the increments are not both */
@@ -260,7 +258,7 @@
 /*     accessed sequentially with one pass through the triangular part */
 /*     of A. */
 
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  A  when A is stored in the upper triangle. */
 
@@ -508,7 +506,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CHER2 . */
 
diff --git a/f2c_BLAS-3.8.0/cher2k.c b/f2c_BLAS-3.8.0/cher2k.c
index 2eb771c..aebe3f2 100644
--- a/f2c_BLAS-3.8.0/cher2k.c
+++ b/f2c_BLAS-3.8.0/cher2k.c
@@ -1,13 +1,13 @@
 /* cher2k.f -- translated by f2c (version 20191129).
    You must link the resulting object file with libf2c:
-	on Microsoft Windows system, link with libf2c.lib;
-	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
-	or, if you install libf2c.a in a standard place, with -lf2c -lm
-	-- in that order, at the end of the command line, as in
-		cc *.o -lf2c -lm
-	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
-
-		http://www.netlib.org/f2c/libf2c.zip
+        on Microsoft Windows system, link with libf2c.lib;
+        on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+        or, if you install libf2c.a in a standard place, with -lf2c -lm
+        -- in that order, at the end of the command line, as in
+                cc *.o -lf2c -lm
+        Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+                http://www.netlib.org/f2c/libf2c.zip
 */
 
 #include "f2c.h"
@@ -34,7 +34,6 @@
 /*       COMPLEX A(LDA,*),B(LDB,*),C(LDC,*) */
 /*       .. */
 
-
 /* > \par Purpose: */
 /*  ============= */
 /* > */
@@ -209,538 +208,485 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int cher2k_(char *uplo, char *trans, integer *n, integer *k, 
-	complex *alpha, complex *a, integer *lda, complex *b, integer *ldb, 
-	real *beta, complex *c__, integer *ldc, ftnlen uplo_len, ftnlen 
-	trans_len)
-{
-    /* System generated locals */
-    integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, 
-	    i__3, i__4, i__5, i__6, i__7;
-    real r__1;
-    complex q__1, q__2, q__3, q__4, q__5, q__6;
-
-    /* Builtin functions */
-    void r_cnjg(complex *, complex *);
-
-    /* Local variables */
-    integer i__, j, l, info;
-    complex temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    integer nrowa;
-    logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
-
-
-/*  -- Reference BLAS level3 routine (version 3.7.0) -- */
-/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
-/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
-/*     December 2016 */
-
-/*     .. Scalar Arguments .. */
-/*     .. */
-/*     .. Array Arguments .. */
-/*     .. */
-
-/*  ===================================================================== */
-
-/*     .. External Functions .. */
-/*     .. */
-/*     .. External Subroutines .. */
-/*     .. */
-/*     .. Intrinsic Functions .. */
-/*     .. */
-/*     .. Local Scalars .. */
-/*     .. */
-/*     .. Parameters .. */
-/*     .. */
-
-/*     Test the input parameters. */
-
-    /* Parameter adjustments */
-    a_dim1 = *lda;
-    a_offset = 1 + a_dim1;
-    a -= a_offset;
-    b_dim1 = *ldb;
-    b_offset = 1 + b_dim1;
-    b -= b_offset;
-    c_dim1 = *ldc;
-    c_offset = 1 + c_dim1;
-    c__ -= c_offset;
-
-    /* Function Body */
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
-	nrowa = *n;
+/* Subroutine */ void cher2k_(char *uplo, char *trans, integer *n, integer *k,
+                              complex *alpha, complex *a, integer *lda,
+                              complex *b, integer *ldb, real *beta, complex *c__,
+                              integer *ldc) {
+  /* System generated locals */
+  integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
+      i__3, i__4, i__5, i__6, i__7;
+  real r__1;
+  complex q__1, q__2, q__3, q__4, q__5, q__6;
+
+  /* Builtin functions */
+  void r_cnjg(complex *, complex *);
+
+  /* Local variables */
+  integer i__, j, l, info;
+  complex temp1, temp2;
+  extern  logical lsame_(char *, char *);
+  integer nrowa;
+  logical upper;
+  extern /* Subroutine */ void xerbla_(char *, integer *);
+
+  /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
+  /*  -- Reference BLAS is a software package provided by Univ. of Tennessee,
+   * -- */
+  /*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+   */
+  /*     December 2016 */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. */
+  /*     .. Array Arguments .. */
+  /*     .. */
+
+  /*  ===================================================================== */
+
+  /*     .. External Functions .. */
+  /*     .. */
+  /*     .. External Subroutines .. */
+  /*     .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. */
+  /*     .. Local Scalars .. */
+  /*     .. */
+  /*     .. Parameters .. */
+  /*     .. */
+
+  /*     Test the input parameters. */
+
+  /* Parameter adjustments */
+  a_dim1 = *lda;
+  a_offset = 1 + a_dim1;
+  a -= a_offset;
+  b_dim1 = *ldb;
+  b_offset = 1 + b_dim1;
+  b -= b_offset;
+  c_dim1 = *ldc;
+  c_offset = 1 + c_dim1;
+  c__ -= c_offset;
+
+  /* Function Body */
+  if (lsame_(trans, "N")) {
+    nrowa = *n;
+  } else {
+    nrowa = *k;
+  }
+  upper = lsame_(uplo, "U");
+
+  info = 0;
+  if (!upper && !lsame_(uplo, "L")) {
+    info = 1;
+  } else if (!lsame_(trans, "N") &&
+             !lsame_(trans, "C")) {
+    info = 2;
+  } else if (*n < 0) {
+    info = 3;
+  } else if (*k < 0) {
+    info = 4;
+  } else if (*lda < max(1, nrowa)) {
+    info = 7;
+  } else if (*ldb < max(1, nrowa)) {
+    info = 9;
+  } else if (*ldc < max(1, *n)) {
+    info = 12;
+  }
+  if (info != 0) {
+    xerbla_("CHER2K", &info);
+    return;
+  }
+
+  /*     Quick return if possible. */
+
+  if (*n == 0 ||
+      (alpha->r == 0.f && alpha->i == 0.f || *k == 0) && *beta == 1.f) {
+    return;
+  }
+
+  /*     And when  alpha.eq.zero. */
+
+  if (alpha->r == 0.f && alpha->i == 0.f) {
+    if (upper) {
+      if (*beta == 0.f) {
+        i__1 = *n;
+        for (j = 1; j <= i__1; ++j) {
+          i__2 = j;
+          for (i__ = 1; i__ <= i__2; ++i__) {
+            i__3 = i__ + j * c_dim1;
+            c__[i__3].r = 0.f, c__[i__3].i = 0.f;
+            /* L10: */
+          }
+          /* L20: */
+        }
+      } else {
+        i__1 = *n;
+        for (j = 1; j <= i__1; ++j) {
+          i__2 = j - 1;
+          for (i__ = 1; i__ <= i__2; ++i__) {
+            i__3 = i__ + j * c_dim1;
+            i__4 = i__ + j * c_dim1;
+            q__1.r = *beta * c__[i__4].r, q__1.i = *beta * c__[i__4].i;
+            c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
+            /* L30: */
+          }
+          i__2 = j + j * c_dim1;
+          i__3 = j + j * c_dim1;
+          r__1 = *beta * c__[i__3].r;
+          c__[i__2].r = r__1, c__[i__2].i = 0.f;
+          /* L40: */
+        }
+      }
     } else {
-	nrowa = *k;
-    }
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
-
-    info = 0;
-    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
-	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "C", (ftnlen)1, (ftnlen)1)) {
-	info = 2;
-    } else if (*n < 0) {
-	info = 3;
-    } else if (*k < 0) {
-	info = 4;
-    } else if (*lda < max(1,nrowa)) {
-	info = 7;
-    } else if (*ldb < max(1,nrowa)) {
-	info = 9;
-    } else if (*ldc < max(1,*n)) {
-	info = 12;
-    }
-    if (info != 0) {
-	xerbla_("CHER2K", &info, (ftnlen)6);
-	return 0;
-    }
-
-/*     Quick return if possible. */
-
-    if (*n == 0 || (alpha->r == 0.f && alpha->i == 0.f || *k == 0) && *beta ==
-	     1.f) {
-	return 0;
+      if (*beta == 0.f) {
+        i__1 = *n;
+        for (j = 1; j <= i__1; ++j) {
+          i__2 = *n;
+          for (i__ = j; i__ <= i__2; ++i__) {
+            i__3 = i__ + j * c_dim1;
+            c__[i__3].r = 0.f, c__[i__3].i = 0.f;
+            /* L50: */
+          }
+          /* L60: */
+        }
+      } else {
+        i__1 = *n;
+        for (j = 1; j <= i__1; ++j) {
+          i__2 = j + j * c_dim1;
+          i__3 = j + j * c_dim1;
+          r__1 = *beta * c__[i__3].r;
+          c__[i__2].r = r__1, c__[i__2].i = 0.f;
+          i__2 = *n;
+          for (i__ = j + 1; i__ <= i__2; ++i__) {
+            i__3 = i__ + j * c_dim1;
+            i__4 = i__ + j * c_dim1;
+            q__1.r = *beta * c__[i__4].r, q__1.i = *beta * c__[i__4].i;
+            c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
+            /* L70: */
+          }
+          /* L80: */
+        }
+      }
     }
-
-/*     And when  alpha.eq.zero. */
-
-    if (alpha->r == 0.f && alpha->i == 0.f) {
-	if (upper) {
-	    if (*beta == 0.f) {
-		i__1 = *n;
-		for (j = 1; j <= i__1; ++j) {
-		    i__2 = j;
-		    for (i__ = 1; i__ <= i__2; ++i__) {
-			i__3 = i__ + j * c_dim1;
-			c__[i__3].r = 0.f, c__[i__3].i = 0.f;
-/* L10: */
-		    }
-/* L20: */
-		}
-	    } else {
-		i__1 = *n;
-		for (j = 1; j <= i__1; ++j) {
-		    i__2 = j - 1;
-		    for (i__ = 1; i__ <= i__2; ++i__) {
-			i__3 = i__ + j * c_dim1;
-			i__4 = i__ + j * c_dim1;
-			q__1.r = *beta * c__[i__4].r, q__1.i = *beta * c__[
-				i__4].i;
-			c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
-/* L30: */
-		    }
-		    i__2 = j + j * c_dim1;
-		    i__3 = j + j * c_dim1;
-		    r__1 = *beta * c__[i__3].r;
-		    c__[i__2].r = r__1, c__[i__2].i = 0.f;
-/* L40: */
-		}
-	    }
-	} else {
-	    if (*beta == 0.f) {
-		i__1 = *n;
-		for (j = 1; j <= i__1; ++j) {
-		    i__2 = *n;
-		    for (i__ = j; i__ <= i__2; ++i__) {
-			i__3 = i__ + j * c_dim1;
-			c__[i__3].r = 0.f, c__[i__3].i = 0.f;
-/* L50: */
-		    }
-/* L60: */
-		}
-	    } else {
-		i__1 = *n;
-		for (j = 1; j <= i__1; ++j) {
-		    i__2 = j + j * c_dim1;
-		    i__3 = j + j * c_dim1;
-		    r__1 = *beta * c__[i__3].r;
-		    c__[i__2].r = r__1, c__[i__2].i = 0.f;
-		    i__2 = *n;
-		    for (i__ = j + 1; i__ <= i__2; ++i__) {
-			i__3 = i__ + j * c_dim1;
-			i__4 = i__ + j * c_dim1;
-			q__1.r = *beta * c__[i__4].r, q__1.i = *beta * c__[
-				i__4].i;
-			c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
-/* L70: */
-		    }
-/* L80: */
-		}
-	    }
-	}
-	return 0;
+    return;
+  }
+
+  /*     Start the operations. */
+
+  if (lsame_(trans, "N")) {
+
+    /*        Form  C := alpha*A*B**H + conjg( alpha )*B*A**H + */
+    /*                   C. */
+
+    if (upper) {
+      i__1 = *n;
+      for (j = 1; j <= i__1; ++j) {
+        if (*beta == 0.f) {
+          i__2 = j;
+          for (i__ = 1; i__ <= i__2; ++i__) {
+            i__3 = i__ + j * c_dim1;
+            c__[i__3].r = 0.f, c__[i__3].i = 0.f;
+            /* L90: */
+          }
+        } else if (*beta != 1.f) {
+          i__2 = j - 1;
+          for (i__ = 1; i__ <= i__2; ++i__) {
+            i__3 = i__ + j * c_dim1;
+            i__4 = i__ + j * c_dim1;
+            q__1.r = *beta * c__[i__4].r, q__1.i = *beta * c__[i__4].i;
+            c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
+            /* L100: */
+          }
+          i__2 = j + j * c_dim1;
+          i__3 = j + j * c_dim1;
+          r__1 = *beta * c__[i__3].r;
+          c__[i__2].r = r__1, c__[i__2].i = 0.f;
+        } else {
+          i__2 = j + j * c_dim1;
+          i__3 = j + j * c_dim1;
+          r__1 = c__[i__3].r;
+          c__[i__2].r = r__1, c__[i__2].i = 0.f;
+        }
+        i__2 = *k;
+        for (l = 1; l <= i__2; ++l) {
+          i__3 = j + l * a_dim1;
+          i__4 = j + l * b_dim1;
+          if (a[i__3].r != 0.f || a[i__3].i != 0.f ||
+              (b[i__4].r != 0.f || b[i__4].i != 0.f)) {
+            r_cnjg(&q__2, &b[j + l * b_dim1]);
+            q__1.r = alpha->r * q__2.r - alpha->i * q__2.i,
+            q__1.i = alpha->r * q__2.i + alpha->i * q__2.r;
+            temp1.r = q__1.r, temp1.i = q__1.i;
+            i__3 = j + l * a_dim1;
+            q__2.r = alpha->r * a[i__3].r - alpha->i * a[i__3].i,
+            q__2.i = alpha->r * a[i__3].i + alpha->i * a[i__3].r;
+            r_cnjg(&q__1, &q__2);
+            temp2.r = q__1.r, temp2.i = q__1.i;
+            i__3 = j - 1;
+            for (i__ = 1; i__ <= i__3; ++i__) {
+              i__4 = i__ + j * c_dim1;
+              i__5 = i__ + j * c_dim1;
+              i__6 = i__ + l * a_dim1;
+              q__3.r = a[i__6].r * temp1.r - a[i__6].i * temp1.i,
+              q__3.i = a[i__6].r * temp1.i + a[i__6].i * temp1.r;
+              q__2.r = c__[i__5].r + q__3.r, q__2.i = c__[i__5].i + q__3.i;
+              i__7 = i__ + l * b_dim1;
+              q__4.r = b[i__7].r * temp2.r - b[i__7].i * temp2.i,
+              q__4.i = b[i__7].r * temp2.i + b[i__7].i * temp2.r;
+              q__1.r = q__2.r + q__4.r, q__1.i = q__2.i + q__4.i;
+              c__[i__4].r = q__1.r, c__[i__4].i = q__1.i;
+              /* L110: */
+            }
+            i__3 = j + j * c_dim1;
+            i__4 = j + j * c_dim1;
+            i__5 = j + l * a_dim1;
+            q__2.r = a[i__5].r * temp1.r - a[i__5].i * temp1.i,
+            q__2.i = a[i__5].r * temp1.i + a[i__5].i * temp1.r;
+            i__6 = j + l * b_dim1;
+            q__3.r = b[i__6].r * temp2.r - b[i__6].i * temp2.i,
+            q__3.i = b[i__6].r * temp2.i + b[i__6].i * temp2.r;
+            q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;
+            r__1 = c__[i__4].r + q__1.r;
+            c__[i__3].r = r__1, c__[i__3].i = 0.f;
+          }
+          /* L120: */
+        }
+        /* L130: */
+      }
+    } else {
+      i__1 = *n;
+      for (j = 1; j <= i__1; ++j) {
+        if (*beta == 0.f) {
+          i__2 = *n;
+          for (i__ = j; i__ <= i__2; ++i__) {
+            i__3 = i__ + j * c_dim1;
+            c__[i__3].r = 0.f, c__[i__3].i = 0.f;
+            /* L140: */
+          }
+        } else if (*beta != 1.f) {
+          i__2 = *n;
+          for (i__ = j + 1; i__ <= i__2; ++i__) {
+            i__3 = i__ + j * c_dim1;
+            i__4 = i__ + j * c_dim1;
+            q__1.r = *beta * c__[i__4].r, q__1.i = *beta * c__[i__4].i;
+            c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
+            /* L150: */
+          }
+          i__2 = j + j * c_dim1;
+          i__3 = j + j * c_dim1;
+          r__1 = *beta * c__[i__3].r;
+          c__[i__2].r = r__1, c__[i__2].i = 0.f;
+        } else {
+          i__2 = j + j * c_dim1;
+          i__3 = j + j * c_dim1;
+          r__1 = c__[i__3].r;
+          c__[i__2].r = r__1, c__[i__2].i = 0.f;
+        }
+        i__2 = *k;
+        for (l = 1; l <= i__2; ++l) {
+          i__3 = j + l * a_dim1;
+          i__4 = j + l * b_dim1;
+          if (a[i__3].r != 0.f || a[i__3].i != 0.f ||
+              (b[i__4].r != 0.f || b[i__4].i != 0.f)) {
+            r_cnjg(&q__2, &b[j + l * b_dim1]);
+            q__1.r = alpha->r * q__2.r - alpha->i * q__2.i,
+            q__1.i = alpha->r * q__2.i + alpha->i * q__2.r;
+            temp1.r = q__1.r, temp1.i = q__1.i;
+            i__3 = j + l * a_dim1;
+            q__2.r = alpha->r * a[i__3].r - alpha->i * a[i__3].i,
+            q__2.i = alpha->r * a[i__3].i + alpha->i * a[i__3].r;
+            r_cnjg(&q__1, &q__2);
+            temp2.r = q__1.r, temp2.i = q__1.i;
+            i__3 = *n;
+            for (i__ = j + 1; i__ <= i__3; ++i__) {
+              i__4 = i__ + j * c_dim1;
+              i__5 = i__ + j * c_dim1;
+              i__6 = i__ + l * a_dim1;
+              q__3.r = a[i__6].r * temp1.r - a[i__6].i * temp1.i,
+              q__3.i = a[i__6].r * temp1.i + a[i__6].i * temp1.r;
+              q__2.r = c__[i__5].r + q__3.r, q__2.i = c__[i__5].i + q__3.i;
+              i__7 = i__ + l * b_dim1;
+              q__4.r = b[i__7].r * temp2.r - b[i__7].i * temp2.i,
+              q__4.i = b[i__7].r * temp2.i + b[i__7].i * temp2.r;
+              q__1.r = q__2.r + q__4.r, q__1.i = q__2.i + q__4.i;
+              c__[i__4].r = q__1.r, c__[i__4].i = q__1.i;
+              /* L160: */
+            }
+            i__3 = j + j * c_dim1;
+            i__4 = j + j * c_dim1;
+            i__5 = j + l * a_dim1;
+            q__2.r = a[i__5].r * temp1.r - a[i__5].i * temp1.i,
+            q__2.i = a[i__5].r * temp1.i + a[i__5].i * temp1.r;
+            i__6 = j + l * b_dim1;
+            q__3.r = b[i__6].r * temp2.r - b[i__6].i * temp2.i,
+            q__3.i = b[i__6].r * temp2.i + b[i__6].i * temp2.r;
+            q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;
+            r__1 = c__[i__4].r + q__1.r;
+            c__[i__3].r = r__1, c__[i__3].i = 0.f;
+          }
+          /* L170: */
+        }
+        /* L180: */
+      }
     }
-
-/*     Start the operations. */
-
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
-
-/*        Form  C := alpha*A*B**H + conjg( alpha )*B*A**H + */
-/*                   C. */
-
-	if (upper) {
-	    i__1 = *n;
-	    for (j = 1; j <= i__1; ++j) {
-		if (*beta == 0.f) {
-		    i__2 = j;
-		    for (i__ = 1; i__ <= i__2; ++i__) {
-			i__3 = i__ + j * c_dim1;
-			c__[i__3].r = 0.f, c__[i__3].i = 0.f;
-/* L90: */
-		    }
-		} else if (*beta != 1.f) {
-		    i__2 = j - 1;
-		    for (i__ = 1; i__ <= i__2; ++i__) {
-			i__3 = i__ + j * c_dim1;
-			i__4 = i__ + j * c_dim1;
-			q__1.r = *beta * c__[i__4].r, q__1.i = *beta * c__[
-				i__4].i;
-			c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
-/* L100: */
-		    }
-		    i__2 = j + j * c_dim1;
-		    i__3 = j + j * c_dim1;
-		    r__1 = *beta * c__[i__3].r;
-		    c__[i__2].r = r__1, c__[i__2].i = 0.f;
-		} else {
-		    i__2 = j + j * c_dim1;
-		    i__3 = j + j * c_dim1;
-		    r__1 = c__[i__3].r;
-		    c__[i__2].r = r__1, c__[i__2].i = 0.f;
-		}
-		i__2 = *k;
-		for (l = 1; l <= i__2; ++l) {
-		    i__3 = j + l * a_dim1;
-		    i__4 = j + l * b_dim1;
-		    if (a[i__3].r != 0.f || a[i__3].i != 0.f || (b[i__4].r != 
-			    0.f || b[i__4].i != 0.f)) {
-			r_cnjg(&q__2, &b[j + l * b_dim1]);
-			q__1.r = alpha->r * q__2.r - alpha->i * q__2.i, 
-				q__1.i = alpha->r * q__2.i + alpha->i * 
-				q__2.r;
-			temp1.r = q__1.r, temp1.i = q__1.i;
-			i__3 = j + l * a_dim1;
-			q__2.r = alpha->r * a[i__3].r - alpha->i * a[i__3].i, 
-				q__2.i = alpha->r * a[i__3].i + alpha->i * a[
-				i__3].r;
-			r_cnjg(&q__1, &q__2);
-			temp2.r = q__1.r, temp2.i = q__1.i;
-			i__3 = j - 1;
-			for (i__ = 1; i__ <= i__3; ++i__) {
-			    i__4 = i__ + j * c_dim1;
-			    i__5 = i__ + j * c_dim1;
-			    i__6 = i__ + l * a_dim1;
-			    q__3.r = a[i__6].r * temp1.r - a[i__6].i * 
-				    temp1.i, q__3.i = a[i__6].r * temp1.i + a[
-				    i__6].i * temp1.r;
-			    q__2.r = c__[i__5].r + q__3.r, q__2.i = c__[i__5]
-				    .i + q__3.i;
-			    i__7 = i__ + l * b_dim1;
-			    q__4.r = b[i__7].r * temp2.r - b[i__7].i * 
-				    temp2.i, q__4.i = b[i__7].r * temp2.i + b[
-				    i__7].i * temp2.r;
-			    q__1.r = q__2.r + q__4.r, q__1.i = q__2.i + 
-				    q__4.i;
-			    c__[i__4].r = q__1.r, c__[i__4].i = q__1.i;
-/* L110: */
-			}
-			i__3 = j + j * c_dim1;
-			i__4 = j + j * c_dim1;
-			i__5 = j + l * a_dim1;
-			q__2.r = a[i__5].r * temp1.r - a[i__5].i * temp1.i, 
-				q__2.i = a[i__5].r * temp1.i + a[i__5].i * 
-				temp1.r;
-			i__6 = j + l * b_dim1;
-			q__3.r = b[i__6].r * temp2.r - b[i__6].i * temp2.i, 
-				q__3.i = b[i__6].r * temp2.i + b[i__6].i * 
-				temp2.r;
-			q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;
-			r__1 = c__[i__4].r + q__1.r;
-			c__[i__3].r = r__1, c__[i__3].i = 0.f;
-		    }
-/* L120: */
-		}
-/* L130: */
-	    }
-	} else {
-	    i__1 = *n;
-	    for (j = 1; j <= i__1; ++j) {
-		if (*beta == 0.f) {
-		    i__2 = *n;
-		    for (i__ = j; i__ <= i__2; ++i__) {
-			i__3 = i__ + j * c_dim1;
-			c__[i__3].r = 0.f, c__[i__3].i = 0.f;
-/* L140: */
-		    }
-		} else if (*beta != 1.f) {
-		    i__2 = *n;
-		    for (i__ = j + 1; i__ <= i__2; ++i__) {
-			i__3 = i__ + j * c_dim1;
-			i__4 = i__ + j * c_dim1;
-			q__1.r = *beta * c__[i__4].r, q__1.i = *beta * c__[
-				i__4].i;
-			c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
-/* L150: */
-		    }
-		    i__2 = j + j * c_dim1;
-		    i__3 = j + j * c_dim1;
-		    r__1 = *beta * c__[i__3].r;
-		    c__[i__2].r = r__1, c__[i__2].i = 0.f;
-		} else {
-		    i__2 = j + j * c_dim1;
-		    i__3 = j + j * c_dim1;
-		    r__1 = c__[i__3].r;
-		    c__[i__2].r = r__1, c__[i__2].i = 0.f;
-		}
-		i__2 = *k;
-		for (l = 1; l <= i__2; ++l) {
-		    i__3 = j + l * a_dim1;
-		    i__4 = j + l * b_dim1;
-		    if (a[i__3].r != 0.f || a[i__3].i != 0.f || (b[i__4].r != 
-			    0.f || b[i__4].i != 0.f)) {
-			r_cnjg(&q__2, &b[j + l * b_dim1]);
-			q__1.r = alpha->r * q__2.r - alpha->i * q__2.i, 
-				q__1.i = alpha->r * q__2.i + alpha->i * 
-				q__2.r;
-			temp1.r = q__1.r, temp1.i = q__1.i;
-			i__3 = j + l * a_dim1;
-			q__2.r = alpha->r * a[i__3].r - alpha->i * a[i__3].i, 
-				q__2.i = alpha->r * a[i__3].i + alpha->i * a[
-				i__3].r;
-			r_cnjg(&q__1, &q__2);
-			temp2.r = q__1.r, temp2.i = q__1.i;
-			i__3 = *n;
-			for (i__ = j + 1; i__ <= i__3; ++i__) {
-			    i__4 = i__ + j * c_dim1;
-			    i__5 = i__ + j * c_dim1;
-			    i__6 = i__ + l * a_dim1;
-			    q__3.r = a[i__6].r * temp1.r - a[i__6].i * 
-				    temp1.i, q__3.i = a[i__6].r * temp1.i + a[
-				    i__6].i * temp1.r;
-			    q__2.r = c__[i__5].r + q__3.r, q__2.i = c__[i__5]
-				    .i + q__3.i;
-			    i__7 = i__ + l * b_dim1;
-			    q__4.r = b[i__7].r * temp2.r - b[i__7].i * 
-				    temp2.i, q__4.i = b[i__7].r * temp2.i + b[
-				    i__7].i * temp2.r;
-			    q__1.r = q__2.r + q__4.r, q__1.i = q__2.i + 
-				    q__4.i;
-			    c__[i__4].r = q__1.r, c__[i__4].i = q__1.i;
-/* L160: */
-			}
-			i__3 = j + j * c_dim1;
-			i__4 = j + j * c_dim1;
-			i__5 = j + l * a_dim1;
-			q__2.r = a[i__5].r * temp1.r - a[i__5].i * temp1.i, 
-				q__2.i = a[i__5].r * temp1.i + a[i__5].i * 
-				temp1.r;
-			i__6 = j + l * b_dim1;
-			q__3.r = b[i__6].r * temp2.r - b[i__6].i * temp2.i, 
-				q__3.i = b[i__6].r * temp2.i + b[i__6].i * 
-				temp2.r;
-			q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;
-			r__1 = c__[i__4].r + q__1.r;
-			c__[i__3].r = r__1, c__[i__3].i = 0.f;
-		    }
-/* L170: */
-		}
-/* L180: */
-	    }
-	}
+  } else {
+
+    /*        Form  C := alpha*A**H*B + conjg( alpha )*B**H*A + */
+    /*                   C. */
+
+    if (upper) {
+      i__1 = *n;
+      for (j = 1; j <= i__1; ++j) {
+        i__2 = j;
+        for (i__ = 1; i__ <= i__2; ++i__) {
+          temp1.r = 0.f, temp1.i = 0.f;
+          temp2.r = 0.f, temp2.i = 0.f;
+          i__3 = *k;
+          for (l = 1; l <= i__3; ++l) {
+            r_cnjg(&q__3, &a[l + i__ * a_dim1]);
+            i__4 = l + j * b_dim1;
+            q__2.r = q__3.r * b[i__4].r - q__3.i * b[i__4].i,
+            q__2.i = q__3.r * b[i__4].i + q__3.i * b[i__4].r;
+            q__1.r = temp1.r + q__2.r, q__1.i = temp1.i + q__2.i;
+            temp1.r = q__1.r, temp1.i = q__1.i;
+            r_cnjg(&q__3, &b[l + i__ * b_dim1]);
+            i__4 = l + j * a_dim1;
+            q__2.r = q__3.r * a[i__4].r - q__3.i * a[i__4].i,
+            q__2.i = q__3.r * a[i__4].i + q__3.i * a[i__4].r;
+            q__1.r = temp2.r + q__2.r, q__1.i = temp2.i + q__2.i;
+            temp2.r = q__1.r, temp2.i = q__1.i;
+            /* L190: */
+          }
+          if (i__ == j) {
+            if (*beta == 0.f) {
+              i__3 = j + j * c_dim1;
+              q__2.r = alpha->r * temp1.r - alpha->i * temp1.i,
+              q__2.i = alpha->r * temp1.i + alpha->i * temp1.r;
+              r_cnjg(&q__4, alpha);
+              q__3.r = q__4.r * temp2.r - q__4.i * temp2.i,
+              q__3.i = q__4.r * temp2.i + q__4.i * temp2.r;
+              q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;
+              r__1 = q__1.r;
+              c__[i__3].r = r__1, c__[i__3].i = 0.f;
+            } else {
+              i__3 = j + j * c_dim1;
+              i__4 = j + j * c_dim1;
+              q__2.r = alpha->r * temp1.r - alpha->i * temp1.i,
+              q__2.i = alpha->r * temp1.i + alpha->i * temp1.r;
+              r_cnjg(&q__4, alpha);
+              q__3.r = q__4.r * temp2.r - q__4.i * temp2.i,
+              q__3.i = q__4.r * temp2.i + q__4.i * temp2.r;
+              q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;
+              r__1 = *beta * c__[i__4].r + q__1.r;
+              c__[i__3].r = r__1, c__[i__3].i = 0.f;
+            }
+          } else {
+            if (*beta == 0.f) {
+              i__3 = i__ + j * c_dim1;
+              q__2.r = alpha->r * temp1.r - alpha->i * temp1.i,
+              q__2.i = alpha->r * temp1.i + alpha->i * temp1.r;
+              r_cnjg(&q__4, alpha);
+              q__3.r = q__4.r * temp2.r - q__4.i * temp2.i,
+              q__3.i = q__4.r * temp2.i + q__4.i * temp2.r;
+              q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;
+              c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
+            } else {
+              i__3 = i__ + j * c_dim1;
+              i__4 = i__ + j * c_dim1;
+              q__3.r = *beta * c__[i__4].r, q__3.i = *beta * c__[i__4].i;
+              q__4.r = alpha->r * temp1.r - alpha->i * temp1.i,
+              q__4.i = alpha->r * temp1.i + alpha->i * temp1.r;
+              q__2.r = q__3.r + q__4.r, q__2.i = q__3.i + q__4.i;
+              r_cnjg(&q__6, alpha);
+              q__5.r = q__6.r * temp2.r - q__6.i * temp2.i,
+              q__5.i = q__6.r * temp2.i + q__6.i * temp2.r;
+              q__1.r = q__2.r + q__5.r, q__1.i = q__2.i + q__5.i;
+              c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
+            }
+          }
+          /* L200: */
+        }
+        /* L210: */
+      }
     } else {
-
-/*        Form  C := alpha*A**H*B + conjg( alpha )*B**H*A + */
-/*                   C. */
-
-	if (upper) {
-	    i__1 = *n;
-	    for (j = 1; j <= i__1; ++j) {
-		i__2 = j;
-		for (i__ = 1; i__ <= i__2; ++i__) {
-		    temp1.r = 0.f, temp1.i = 0.f;
-		    temp2.r = 0.f, temp2.i = 0.f;
-		    i__3 = *k;
-		    for (l = 1; l <= i__3; ++l) {
-			r_cnjg(&q__3, &a[l + i__ * a_dim1]);
-			i__4 = l + j * b_dim1;
-			q__2.r = q__3.r * b[i__4].r - q__3.i * b[i__4].i, 
-				q__2.i = q__3.r * b[i__4].i + q__3.i * b[i__4]
-				.r;
-			q__1.r = temp1.r + q__2.r, q__1.i = temp1.i + q__2.i;
-			temp1.r = q__1.r, temp1.i = q__1.i;
-			r_cnjg(&q__3, &b[l + i__ * b_dim1]);
-			i__4 = l + j * a_dim1;
-			q__2.r = q__3.r * a[i__4].r - q__3.i * a[i__4].i, 
-				q__2.i = q__3.r * a[i__4].i + q__3.i * a[i__4]
-				.r;
-			q__1.r = temp2.r + q__2.r, q__1.i = temp2.i + q__2.i;
-			temp2.r = q__1.r, temp2.i = q__1.i;
-/* L190: */
-		    }
-		    if (i__ == j) {
-			if (*beta == 0.f) {
-			    i__3 = j + j * c_dim1;
-			    q__2.r = alpha->r * temp1.r - alpha->i * temp1.i, 
-				    q__2.i = alpha->r * temp1.i + alpha->i * 
-				    temp1.r;
-			    r_cnjg(&q__4, alpha);
-			    q__3.r = q__4.r * temp2.r - q__4.i * temp2.i, 
-				    q__3.i = q__4.r * temp2.i + q__4.i * 
-				    temp2.r;
-			    q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + 
-				    q__3.i;
-			    r__1 = q__1.r;
-			    c__[i__3].r = r__1, c__[i__3].i = 0.f;
-			} else {
-			    i__3 = j + j * c_dim1;
-			    i__4 = j + j * c_dim1;
-			    q__2.r = alpha->r * temp1.r - alpha->i * temp1.i, 
-				    q__2.i = alpha->r * temp1.i + alpha->i * 
-				    temp1.r;
-			    r_cnjg(&q__4, alpha);
-			    q__3.r = q__4.r * temp2.r - q__4.i * temp2.i, 
-				    q__3.i = q__4.r * temp2.i + q__4.i * 
-				    temp2.r;
-			    q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + 
-				    q__3.i;
-			    r__1 = *beta * c__[i__4].r + q__1.r;
-			    c__[i__3].r = r__1, c__[i__3].i = 0.f;
-			}
-		    } else {
-			if (*beta == 0.f) {
-			    i__3 = i__ + j * c_dim1;
-			    q__2.r = alpha->r * temp1.r - alpha->i * temp1.i, 
-				    q__2.i = alpha->r * temp1.i + alpha->i * 
-				    temp1.r;
-			    r_cnjg(&q__4, alpha);
-			    q__3.r = q__4.r * temp2.r - q__4.i * temp2.i, 
-				    q__3.i = q__4.r * temp2.i + q__4.i * 
-				    temp2.r;
-			    q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + 
-				    q__3.i;
-			    c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
-			} else {
-			    i__3 = i__ + j * c_dim1;
-			    i__4 = i__ + j * c_dim1;
-			    q__3.r = *beta * c__[i__4].r, q__3.i = *beta * 
-				    c__[i__4].i;
-			    q__4.r = alpha->r * temp1.r - alpha->i * temp1.i, 
-				    q__4.i = alpha->r * temp1.i + alpha->i * 
-				    temp1.r;
-			    q__2.r = q__3.r + q__4.r, q__2.i = q__3.i + 
-				    q__4.i;
-			    r_cnjg(&q__6, alpha);
-			    q__5.r = q__6.r * temp2.r - q__6.i * temp2.i, 
-				    q__5.i = q__6.r * temp2.i + q__6.i * 
-				    temp2.r;
-			    q__1.r = q__2.r + q__5.r, q__1.i = q__2.i + 
-				    q__5.i;
-			    c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
-			}
-		    }
-/* L200: */
-		}
-/* L210: */
-	    }
-	} else {
-	    i__1 = *n;
-	    for (j = 1; j <= i__1; ++j) {
-		i__2 = *n;
-		for (i__ = j; i__ <= i__2; ++i__) {
-		    temp1.r = 0.f, temp1.i = 0.f;
-		    temp2.r = 0.f, temp2.i = 0.f;
-		    i__3 = *k;
-		    for (l = 1; l <= i__3; ++l) {
-			r_cnjg(&q__3, &a[l + i__ * a_dim1]);
-			i__4 = l + j * b_dim1;
-			q__2.r = q__3.r * b[i__4].r - q__3.i * b[i__4].i, 
-				q__2.i = q__3.r * b[i__4].i + q__3.i * b[i__4]
-				.r;
-			q__1.r = temp1.r + q__2.r, q__1.i = temp1.i + q__2.i;
-			temp1.r = q__1.r, temp1.i = q__1.i;
-			r_cnjg(&q__3, &b[l + i__ * b_dim1]);
-			i__4 = l + j * a_dim1;
-			q__2.r = q__3.r * a[i__4].r - q__3.i * a[i__4].i, 
-				q__2.i = q__3.r * a[i__4].i + q__3.i * a[i__4]
-				.r;
-			q__1.r = temp2.r + q__2.r, q__1.i = temp2.i + q__2.i;
-			temp2.r = q__1.r, temp2.i = q__1.i;
-/* L220: */
-		    }
-		    if (i__ == j) {
-			if (*beta == 0.f) {
-			    i__3 = j + j * c_dim1;
-			    q__2.r = alpha->r * temp1.r - alpha->i * temp1.i, 
-				    q__2.i = alpha->r * temp1.i + alpha->i * 
-				    temp1.r;
-			    r_cnjg(&q__4, alpha);
-			    q__3.r = q__4.r * temp2.r - q__4.i * temp2.i, 
-				    q__3.i = q__4.r * temp2.i + q__4.i * 
-				    temp2.r;
-			    q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + 
-				    q__3.i;
-			    r__1 = q__1.r;
-			    c__[i__3].r = r__1, c__[i__3].i = 0.f;
-			} else {
-			    i__3 = j + j * c_dim1;
-			    i__4 = j + j * c_dim1;
-			    q__2.r = alpha->r * temp1.r - alpha->i * temp1.i, 
-				    q__2.i = alpha->r * temp1.i + alpha->i * 
-				    temp1.r;
-			    r_cnjg(&q__4, alpha);
-			    q__3.r = q__4.r * temp2.r - q__4.i * temp2.i, 
-				    q__3.i = q__4.r * temp2.i + q__4.i * 
-				    temp2.r;
-			    q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + 
-				    q__3.i;
-			    r__1 = *beta * c__[i__4].r + q__1.r;
-			    c__[i__3].r = r__1, c__[i__3].i = 0.f;
-			}
-		    } else {
-			if (*beta == 0.f) {
-			    i__3 = i__ + j * c_dim1;
-			    q__2.r = alpha->r * temp1.r - alpha->i * temp1.i, 
-				    q__2.i = alpha->r * temp1.i + alpha->i * 
-				    temp1.r;
-			    r_cnjg(&q__4, alpha);
-			    q__3.r = q__4.r * temp2.r - q__4.i * temp2.i, 
-				    q__3.i = q__4.r * temp2.i + q__4.i * 
-				    temp2.r;
-			    q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + 
-				    q__3.i;
-			    c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
-			} else {
-			    i__3 = i__ + j * c_dim1;
-			    i__4 = i__ + j * c_dim1;
-			    q__3.r = *beta * c__[i__4].r, q__3.i = *beta * 
-				    c__[i__4].i;
-			    q__4.r = alpha->r * temp1.r - alpha->i * temp1.i, 
-				    q__4.i = alpha->r * temp1.i + alpha->i * 
-				    temp1.r;
-			    q__2.r = q__3.r + q__4.r, q__2.i = q__3.i + 
-				    q__4.i;
-			    r_cnjg(&q__6, alpha);
-			    q__5.r = q__6.r * temp2.r - q__6.i * temp2.i, 
-				    q__5.i = q__6.r * temp2.i + q__6.i * 
-				    temp2.r;
-			    q__1.r = q__2.r + q__5.r, q__1.i = q__2.i + 
-				    q__5.i;
-			    c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
-			}
-		    }
-/* L230: */
-		}
-/* L240: */
-	    }
-	}
+      i__1 = *n;
+      for (j = 1; j <= i__1; ++j) {
+        i__2 = *n;
+        for (i__ = j; i__ <= i__2; ++i__) {
+          temp1.r = 0.f, temp1.i = 0.f;
+          temp2.r = 0.f, temp2.i = 0.f;
+          i__3 = *k;
+          for (l = 1; l <= i__3; ++l) {
+            r_cnjg(&q__3, &a[l + i__ * a_dim1]);
+            i__4 = l + j * b_dim1;
+            q__2.r = q__3.r * b[i__4].r - q__3.i * b[i__4].i,
+            q__2.i = q__3.r * b[i__4].i + q__3.i * b[i__4].r;
+            q__1.r = temp1.r + q__2.r, q__1.i = temp1.i + q__2.i;
+            temp1.r = q__1.r, temp1.i = q__1.i;
+            r_cnjg(&q__3, &b[l + i__ * b_dim1]);
+            i__4 = l + j * a_dim1;
+            q__2.r = q__3.r * a[i__4].r - q__3.i * a[i__4].i,
+            q__2.i = q__3.r * a[i__4].i + q__3.i * a[i__4].r;
+            q__1.r = temp2.r + q__2.r, q__1.i = temp2.i + q__2.i;
+            temp2.r = q__1.r, temp2.i = q__1.i;
+            /* L220: */
+          }
+          if (i__ == j) {
+            if (*beta == 0.f) {
+              i__3 = j + j * c_dim1;
+              q__2.r = alpha->r * temp1.r - alpha->i * temp1.i,
+              q__2.i = alpha->r * temp1.i + alpha->i * temp1.r;
+              r_cnjg(&q__4, alpha);
+              q__3.r = q__4.r * temp2.r - q__4.i * temp2.i,
+              q__3.i = q__4.r * temp2.i + q__4.i * temp2.r;
+              q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;
+              r__1 = q__1.r;
+              c__[i__3].r = r__1, c__[i__3].i = 0.f;
+            } else {
+              i__3 = j + j * c_dim1;
+              i__4 = j + j * c_dim1;
+              q__2.r = alpha->r * temp1.r - alpha->i * temp1.i,
+              q__2.i = alpha->r * temp1.i + alpha->i * temp1.r;
+              r_cnjg(&q__4, alpha);
+              q__3.r = q__4.r * temp2.r - q__4.i * temp2.i,
+              q__3.i = q__4.r * temp2.i + q__4.i * temp2.r;
+              q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;
+              r__1 = *beta * c__[i__4].r + q__1.r;
+              c__[i__3].r = r__1, c__[i__3].i = 0.f;
+            }
+          } else {
+            if (*beta == 0.f) {
+              i__3 = i__ + j * c_dim1;
+              q__2.r = alpha->r * temp1.r - alpha->i * temp1.i,
+              q__2.i = alpha->r * temp1.i + alpha->i * temp1.r;
+              r_cnjg(&q__4, alpha);
+              q__3.r = q__4.r * temp2.r - q__4.i * temp2.i,
+              q__3.i = q__4.r * temp2.i + q__4.i * temp2.r;
+              q__1.r = q__2.r + q__3.r, q__1.i = q__2.i + q__3.i;
+              c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
+            } else {
+              i__3 = i__ + j * c_dim1;
+              i__4 = i__ + j * c_dim1;
+              q__3.r = *beta * c__[i__4].r, q__3.i = *beta * c__[i__4].i;
+              q__4.r = alpha->r * temp1.r - alpha->i * temp1.i,
+              q__4.i = alpha->r * temp1.i + alpha->i * temp1.r;
+              q__2.r = q__3.r + q__4.r, q__2.i = q__3.i + q__4.i;
+              r_cnjg(&q__6, alpha);
+              q__5.r = q__6.r * temp2.r - q__6.i * temp2.i,
+              q__5.i = q__6.r * temp2.i + q__6.i * temp2.r;
+              q__1.r = q__2.r + q__5.r, q__1.i = q__2.i + q__5.i;
+              c__[i__3].r = q__1.r, c__[i__3].i = q__1.i;
+            }
+          }
+          /* L230: */
+        }
+        /* L240: */
+      }
     }
+  }
 
-    return 0;
+  return;
 
-/*     End of CHER2K. */
+  /*     End of CHER2K. */
 
 } /* cher2k_ */
-
diff --git a/f2c_BLAS-3.8.0/cherk.c b/f2c_BLAS-3.8.0/cherk.c
index 7309f83..30c0bc7 100644
--- a/f2c_BLAS-3.8.0/cherk.c
+++ b/f2c_BLAS-3.8.0/cherk.c
@@ -185,9 +185,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int cherk_(char *uplo, char *trans, integer *n, integer *k, 
+/* Subroutine */ void cherk_(char *uplo, char *trans, integer *n, integer *k, 
 	real *alpha, complex *a, integer *lda, real *beta, complex *c__, 
-	integer *ldc, ftnlen uplo_len, ftnlen trans_len)
+	integer *ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3, i__4, i__5, 
@@ -201,11 +201,11 @@
     /* Local variables */
     integer i__, j, l, info;
     complex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     real rtemp;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -242,18 +242,17 @@
     c__ -= c_offset;
 
     /* Function Body */
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 	nrowa = *n;
     } else {
 	nrowa = *k;
     }
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    upper = lsame_(uplo, "U");
 
     info = 0;
-    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    if (! upper && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "C", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "C")) {
 	info = 2;
     } else if (*n < 0) {
 	info = 3;
@@ -265,14 +264,14 @@
 	info = 10;
     }
     if (info != 0) {
-	xerbla_("CHERK ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CHERK ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || (*alpha == 0.f || *k == 0) && *beta == 1.f) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -341,12 +340,12 @@
 		}
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  C := alpha*A*A**H + beta*C. */
 
@@ -594,7 +593,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CHERK . */
 
diff --git a/f2c_BLAS-3.8.0/chpmv.c b/f2c_BLAS-3.8.0/chpmv.c
index 9310657..cf6a3b6 100644
--- a/f2c_BLAS-3.8.0/chpmv.c
+++ b/f2c_BLAS-3.8.0/chpmv.c
@@ -161,9 +161,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int chpmv_(char *uplo, integer *n, complex *alpha, complex *
+/* Subroutine */ void chpmv_(char *uplo, integer *n, complex *alpha, complex *
 	ap, complex *x, integer *incx, complex *beta, complex *y, integer *
-	incy, ftnlen uplo_len)
+	incy)
 {
     /* System generated locals */
     integer i__1, i__2, i__3, i__4, i__5;
@@ -176,8 +176,8 @@
     /* Local variables */
     integer i__, j, k, kk, ix, iy, jx, jy, kx, ky, info;
     complex temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -212,8 +212,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -223,15 +222,15 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("CHPMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CHPMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || alpha->r == 0.f && alpha->i == 0.f && (beta->r == 1.f && 
 	    beta->i == 0.f)) {
-	return 0;
+	return;
     }
 
 /*     Set up the start points in  X  and  Y. */
@@ -299,10 +298,10 @@
 	}
     }
     if (alpha->r == 0.f && alpha->i == 0.f) {
-	return 0;
+	return;
     }
     kk = 1;
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  y  when AP contains the upper triangle. */
 
@@ -496,7 +495,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CHPMV . */
 
diff --git a/f2c_BLAS-3.8.0/chpr.c b/f2c_BLAS-3.8.0/chpr.c
index 18bd5cb..af459ec 100644
--- a/f2c_BLAS-3.8.0/chpr.c
+++ b/f2c_BLAS-3.8.0/chpr.c
@@ -142,8 +142,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int chpr_(char *uplo, integer *n, real *alpha, complex *x, 
-	integer *incx, complex *ap, ftnlen uplo_len)
+/* Subroutine */ void chpr_(char *uplo, integer *n, real *alpha, complex *x, 
+	integer *incx, complex *ap)
 {
     /* System generated locals */
     integer i__1, i__2, i__3, i__4, i__5;
@@ -156,8 +156,8 @@
     /* Local variables */
     integer i__, j, k, kk, ix, jx, kx, info;
     complex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -191,8 +191,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -200,14 +199,14 @@
 	info = 5;
     }
     if (info != 0) {
-	xerbla_("CHPR  ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CHPR  ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || *alpha == 0.f) {
-	return 0;
+	return;
     }
 
 /*     Set the start point in X if the increment is not unity. */
@@ -222,7 +221,7 @@
 /*     are accessed sequentially with one pass through AP. */
 
     kk = 1;
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  A  when upper triangle is stored in AP. */
 
@@ -394,7 +393,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CHPR  . */
 
diff --git a/f2c_BLAS-3.8.0/chpr2.c b/f2c_BLAS-3.8.0/chpr2.c
index 71ab2b4..100530b 100644
--- a/f2c_BLAS-3.8.0/chpr2.c
+++ b/f2c_BLAS-3.8.0/chpr2.c
@@ -157,9 +157,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int chpr2_(char *uplo, integer *n, complex *alpha, complex *
-	x, integer *incx, complex *y, integer *incy, complex *ap, ftnlen 
-	uplo_len)
+/* Subroutine */ void chpr2_(char *uplo, integer *n, complex *alpha, complex *
+	x, integer *incx, complex *y, integer *incy, complex *ap)
 {
     /* System generated locals */
     integer i__1, i__2, i__3, i__4, i__5, i__6;
@@ -172,8 +171,8 @@
     /* Local variables */
     integer i__, j, k, kk, ix, iy, jx, jy, kx, ky, info;
     complex temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -208,8 +207,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -219,14 +217,14 @@
 	info = 7;
     }
     if (info != 0) {
-	xerbla_("CHPR2 ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CHPR2 ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || alpha->r == 0.f && alpha->i == 0.f) {
-	return 0;
+	return;
     }
 
 /*     Set up the start points in X and Y if the increments are not both */
@@ -251,7 +249,7 @@
 /*     are accessed sequentially with one pass through AP. */
 
     kk = 1;
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  A  when upper triangle is stored in AP. */
 
@@ -507,7 +505,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CHPR2 . */
 
diff --git a/f2c_BLAS-3.8.0/crotg.c b/f2c_BLAS-3.8.0/crotg.c
index bdf2ca8..980e038 100644
--- a/f2c_BLAS-3.8.0/crotg.c
+++ b/f2c_BLAS-3.8.0/crotg.c
@@ -74,7 +74,7 @@
 /* > \ingroup complex_blas_level1 */
 
 /*  ===================================================================== */
-/* Subroutine */ int crotg_(complex *ca, complex *cb, real *c__, complex *s)
+/* Subroutine */ void crotg_(complex *ca, complex *cb, real *c__, complex *s)
 {
     /* System generated locals */
     real r__1, r__2;
@@ -129,6 +129,6 @@
 	q__1.r = norm * alpha.r, q__1.i = norm * alpha.i;
 	ca->r = q__1.r, ca->i = q__1.i;
     }
-    return 0;
+    return;
 } /* crotg_ */
 
diff --git a/f2c_BLAS-3.8.0/cscal.c b/f2c_BLAS-3.8.0/cscal.c
index e8b80d4..69a2749 100644
--- a/f2c_BLAS-3.8.0/cscal.c
+++ b/f2c_BLAS-3.8.0/cscal.c
@@ -90,7 +90,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int cscal_(integer *n, complex *ca, complex *cx, integer *
+/* Subroutine */ void cscal_(integer *n, complex *ca, complex *cx, integer *
 	incx)
 {
     /* System generated locals */
@@ -120,7 +120,7 @@
 
     /* Function Body */
     if (*n <= 0 || *incx <= 0) {
-	return 0;
+	return;
     }
     if (*incx == 1) {
 
@@ -149,6 +149,6 @@
 	    cx[i__3].r = q__1.r, cx[i__3].i = q__1.i;
 	}
     }
-    return 0;
+    return;
 } /* cscal_ */
 
diff --git a/f2c_BLAS-3.8.0/csscal.c b/f2c_BLAS-3.8.0/csscal.c
index 7f92c44..8b65c07 100644
--- a/f2c_BLAS-3.8.0/csscal.c
+++ b/f2c_BLAS-3.8.0/csscal.c
@@ -90,7 +90,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int csscal_(integer *n, real *sa, complex *cx, integer *incx)
+/* Subroutine */ void csscal_(integer *n, real *sa, complex *cx, integer *incx)
 {
     /* System generated locals */
     integer i__1, i__2, i__3, i__4;
@@ -125,7 +125,7 @@
 
     /* Function Body */
     if (*n <= 0 || *incx <= 0) {
-	return 0;
+	return;
     }
     if (*incx == 1) {
 
@@ -156,6 +156,6 @@
 	    cx[i__3].r = q__1.r, cx[i__3].i = q__1.i;
 	}
     }
-    return 0;
+    return;
 } /* csscal_ */
 
diff --git a/f2c_BLAS-3.8.0/cswap.c b/f2c_BLAS-3.8.0/cswap.c
index 0ce3136..c9d62bb 100644
--- a/f2c_BLAS-3.8.0/cswap.c
+++ b/f2c_BLAS-3.8.0/cswap.c
@@ -93,7 +93,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int cswap_(integer *n, complex *cx, integer *incx, complex *
+/* Subroutine */ void cswap_(integer *n, complex *cx, integer *incx, complex *
 	cy, integer *incy)
 {
     /* System generated locals */
@@ -124,7 +124,7 @@
 
     /* Function Body */
     if (*n <= 0) {
-	return 0;
+	return;
     }
     if (*incx == 1 && *incy == 1) {
 
@@ -165,6 +165,6 @@
 	    iy += *incy;
 	}
     }
-    return 0;
+    return;
 } /* cswap_ */
 
diff --git a/f2c_BLAS-3.8.0/csymm.c b/f2c_BLAS-3.8.0/csymm.c
index 5dbdd4c..48fc56a 100644
--- a/f2c_BLAS-3.8.0/csymm.c
+++ b/f2c_BLAS-3.8.0/csymm.c
@@ -201,10 +201,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int csymm_(char *side, char *uplo, integer *m, integer *n, 
+/* Subroutine */ void csymm_(char *side, char *uplo, integer *m, integer *n, 
 	complex *alpha, complex *a, integer *lda, complex *b, integer *ldb, 
-	complex *beta, complex *c__, integer *ldc, ftnlen side_len, ftnlen 
-	uplo_len)
+	complex *beta, complex *c__, integer *ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, 
@@ -214,10 +213,10 @@
     /* Local variables */
     integer i__, j, k, info;
     complex temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -257,20 +256,19 @@
     c__ -= c_offset;
 
     /* Function Body */
-    if (lsame_(side, "L", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(side, "L")) {
 	nrowa = *m;
     } else {
 	nrowa = *n;
     }
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    upper = lsame_(uplo, "U");
 
 /*     Test the input parameters. */
 
     info = 0;
-    if (! lsame_(side, "L", (ftnlen)1, (ftnlen)1) && ! lsame_(side, "R", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(side, "L") && ! lsame_(side, "R")) {
 	info = 1;
-    } else if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    } else if (! upper && ! lsame_(uplo, "L")) {
 	info = 2;
     } else if (*m < 0) {
 	info = 3;
@@ -284,15 +282,15 @@
 	info = 12;
     }
     if (info != 0) {
-	xerbla_("CSYMM ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CSYMM ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || alpha->r == 0.f && alpha->i == 0.f && (beta->r 
 	    == 1.f && beta->i == 0.f)) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -325,12 +323,12 @@
 /* L40: */
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
-    if (lsame_(side, "L", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(side, "L")) {
 
 /*        Form  C := alpha*A*B + beta*C. */
 
@@ -562,7 +560,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CSYMM . */
 
diff --git a/f2c_BLAS-3.8.0/csyr2k.c b/f2c_BLAS-3.8.0/csyr2k.c
index 4a00fc3..01b14a9 100644
--- a/f2c_BLAS-3.8.0/csyr2k.c
+++ b/f2c_BLAS-3.8.0/csyr2k.c
@@ -200,10 +200,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int csyr2k_(char *uplo, char *trans, integer *n, integer *k, 
+/* Subroutine */ void csyr2k_(char *uplo, char *trans, integer *n, integer *k, 
 	complex *alpha, complex *a, integer *lda, complex *b, integer *ldb, 
-	complex *beta, complex *c__, integer *ldc, ftnlen uplo_len, ftnlen 
-	trans_len)
+	complex *beta, complex *c__, integer *ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, 
@@ -213,10 +212,10 @@
     /* Local variables */
     integer i__, j, l, info;
     complex temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -256,18 +255,17 @@
     c__ -= c_offset;
 
     /* Function Body */
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 	nrowa = *n;
     } else {
 	nrowa = *k;
     }
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    upper = lsame_(uplo, "U");
 
     info = 0;
-    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    if (! upper && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T")) {
 	info = 2;
     } else if (*n < 0) {
 	info = 3;
@@ -281,15 +279,15 @@
 	info = 12;
     }
     if (info != 0) {
-	xerbla_("CSYR2K", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CSYR2K", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || (alpha->r == 0.f && alpha->i == 0.f || *k == 0) && (
 	    beta->r == 1.f && beta->i == 0.f)) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -352,12 +350,12 @@
 		}
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  C := alpha*A*B**T + alpha*B*A**T + C. */
 
@@ -603,7 +601,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CSYR2K. */
 
diff --git a/f2c_BLAS-3.8.0/csyrk.c b/f2c_BLAS-3.8.0/csyrk.c
index f0e14ae..6e16838 100644
--- a/f2c_BLAS-3.8.0/csyrk.c
+++ b/f2c_BLAS-3.8.0/csyrk.c
@@ -179,9 +179,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int csyrk_(char *uplo, char *trans, integer *n, integer *k, 
+/* Subroutine */ void csyrk_(char *uplo, char *trans, integer *n, integer *k, 
 	complex *alpha, complex *a, integer *lda, complex *beta, complex *c__,
-	 integer *ldc, ftnlen uplo_len, ftnlen trans_len)
+	 integer *ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3, i__4, i__5, 
@@ -191,10 +191,10 @@
     /* Local variables */
     integer i__, j, l, info;
     complex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -231,18 +231,17 @@
     c__ -= c_offset;
 
     /* Function Body */
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 	nrowa = *n;
     } else {
 	nrowa = *k;
     }
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    upper = lsame_(uplo, "U");
 
     info = 0;
-    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    if (! upper && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T")) {
 	info = 2;
     } else if (*n < 0) {
 	info = 3;
@@ -254,15 +253,15 @@
 	info = 10;
     }
     if (info != 0) {
-	xerbla_("CSYRK ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CSYRK ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || (alpha->r == 0.f && alpha->i == 0.f || *k == 0) && (
 	    beta->r == 1.f && beta->i == 0.f)) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -325,12 +324,12 @@
 		}
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  C := alpha*A*A**T + beta*C. */
 
@@ -518,7 +517,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CSYRK . */
 
diff --git a/f2c_BLAS-3.8.0/ctbmv.c b/f2c_BLAS-3.8.0/ctbmv.c
index fa6f817..d474792 100644
--- a/f2c_BLAS-3.8.0/ctbmv.c
+++ b/f2c_BLAS-3.8.0/ctbmv.c
@@ -198,9 +198,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ctbmv_(char *uplo, char *trans, char *diag, integer *n, 
-	integer *k, complex *a, integer *lda, complex *x, integer *incx, 
-	ftnlen uplo_len, ftnlen trans_len, ftnlen diag_len)
+/* Subroutine */ void ctbmv_(char *uplo, char *trans, char *diag, integer *n, 
+	integer *k, complex *a, integer *lda, complex *x, integer *incx)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
@@ -212,9 +211,9 @@
     /* Local variables */
     integer i__, j, l, ix, jx, kx, info;
     complex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer kplus1;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconj, nounit;
 
 
@@ -251,15 +250,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -271,18 +266,18 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("CTBMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CTBMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    noconj = lsame_(trans, "T", (ftnlen)1, (ftnlen)1);
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    noconj = lsame_(trans, "T");
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX   too small for descending loops. */
@@ -296,11 +291,11 @@
 /*     Start the operations. In this version the elements of A are */
 /*     accessed sequentially with one pass through A. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*         Form  x := A*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kplus1 = *k + 1;
 	    if (*incx == 1) {
 		i__1 = *n;
@@ -463,7 +458,7 @@
 
 /*        Form  x := A**T*x  or  x := A**H*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kplus1 = *k + 1;
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
@@ -702,7 +697,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CTBMV . */
 
diff --git a/f2c_BLAS-3.8.0/ctbsv.c b/f2c_BLAS-3.8.0/ctbsv.c
index c80fdb2..4989cbc 100644
--- a/f2c_BLAS-3.8.0/ctbsv.c
+++ b/f2c_BLAS-3.8.0/ctbsv.c
@@ -201,9 +201,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ctbsv_(char *uplo, char *trans, char *diag, integer *n, 
-	integer *k, complex *a, integer *lda, complex *x, integer *incx, 
-	ftnlen uplo_len, ftnlen trans_len, ftnlen diag_len)
+/* Subroutine */ void ctbsv_(char *uplo, char *trans, char *diag, integer *n, 
+	integer *k, complex *a, integer *lda, complex *x, integer *incx)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
@@ -215,9 +214,9 @@
     /* Local variables */
     integer i__, j, l, ix, jx, kx, info;
     complex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer kplus1;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconj, nounit;
 
 
@@ -254,15 +253,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -274,18 +269,18 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("CTBSV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CTBSV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    noconj = lsame_(trans, "T", (ftnlen)1, (ftnlen)1);
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    noconj = lsame_(trans, "T");
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX  too small for descending loops. */
@@ -299,11 +294,11 @@
 /*     Start the operations. In this version the elements of A are */
 /*     accessed by sequentially with one pass through A. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  x := inv( A )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kplus1 = *k + 1;
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
@@ -446,7 +441,7 @@
 
 /*        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kplus1 = *k + 1;
 	    if (*incx == 1) {
 		i__1 = *n;
@@ -669,7 +664,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CTBSV . */
 
diff --git a/f2c_BLAS-3.8.0/ctpmv.c b/f2c_BLAS-3.8.0/ctpmv.c
index c725ffa..6054084 100644
--- a/f2c_BLAS-3.8.0/ctpmv.c
+++ b/f2c_BLAS-3.8.0/ctpmv.c
@@ -1,13 +1,13 @@
 /* ctpmv.f -- translated by f2c (version 20191129).
    You must link the resulting object file with libf2c:
-	on Microsoft Windows system, link with libf2c.lib;
-	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
-	or, if you install libf2c.a in a standard place, with -lf2c -lm
-	-- in that order, at the end of the command line, as in
-		cc *.o -lf2c -lm
-	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
-
-		http://www.netlib.org/f2c/libf2c.zip
+        on Microsoft Windows system, link with libf2c.lib;
+        on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+        or, if you install libf2c.a in a standard place, with -lf2c -lm
+        -- in that order, at the end of the command line, as in
+                cc *.o -lf2c -lm
+        Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+                http://www.netlib.org/f2c/libf2c.zip
 */
 
 #include "f2c.h"
@@ -32,7 +32,6 @@
 /*       COMPLEX AP(*),X(*) */
 /*       .. */
 
-
 /* > \par Purpose: */
 /*  ============= */
 /* > */
@@ -154,483 +153,445 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ctpmv_(char *uplo, char *trans, char *diag, integer *n, 
-	complex *ap, complex *x, integer *incx, ftnlen uplo_len, ftnlen 
-	trans_len, ftnlen diag_len)
-{
-    /* System generated locals */
-    integer i__1, i__2, i__3, i__4, i__5;
-    complex q__1, q__2, q__3;
-
-    /* Builtin functions */
-    void r_cnjg(complex *, complex *);
-
-    /* Local variables */
-    integer i__, j, k, kk, ix, jx, kx, info;
-    complex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
-    logical noconj, nounit;
-
-
-/*  -- Reference BLAS level2 routine (version 3.7.0) -- */
-/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
-/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
-/*     December 2016 */
-
-/*     .. Scalar Arguments .. */
-/*     .. */
-/*     .. Array Arguments .. */
-/*     .. */
-
-/*  ===================================================================== */
-
-/*     .. Parameters .. */
-/*     .. */
-/*     .. Local Scalars .. */
-/*     .. */
-/*     .. External Functions .. */
-/*     .. */
-/*     .. External Subroutines .. */
-/*     .. */
-/*     .. Intrinsic Functions .. */
-/*     .. */
-
-/*     Test the input parameters. */
-
-    /* Parameter adjustments */
-    --x;
-    --ap;
-
-    /* Function Body */
-    info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
-	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
-	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
-	info = 3;
-    } else if (*n < 0) {
-	info = 4;
-    } else if (*incx == 0) {
-	info = 7;
-    }
-    if (info != 0) {
-	xerbla_("CTPMV ", &info, (ftnlen)6);
-	return 0;
-    }
-
-/*     Quick return if possible. */
-
-    if (*n == 0) {
-	return 0;
-    }
-
-    noconj = lsame_(trans, "T", (ftnlen)1, (ftnlen)1);
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
-
-/*     Set up the start point in X if the increment is not unity. This */
-/*     will be  ( N - 1 )*INCX  too small for descending loops. */
-
-    if (*incx <= 0) {
-	kx = 1 - (*n - 1) * *incx;
-    } else if (*incx != 1) {
-	kx = 1;
+/* Subroutine */ void ctpmv_(char *uplo, char *trans, char *diag, integer *n,
+                             complex *ap, complex *x, integer *incx) {
+  /* System generated locals */
+  integer i__1, i__2, i__3, i__4, i__5;
+  complex q__1, q__2, q__3;
+
+  /* Builtin functions */
+  void r_cnjg(complex *, complex *);
+
+  /* Local variables */
+  integer i__, j, k, kk, ix, jx, kx, info;
+  complex temp;
+  extern  logical lsame_(char *, char *);
+  extern /* Subroutine */ void xerbla_(char *, integer *);
+  logical noconj, nounit;
+
+  /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
+  /*  -- Reference BLAS is a software package provided by Univ. of Tennessee,
+   * -- */
+  /*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+   */
+  /*     December 2016 */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. */
+  /*     .. Array Arguments .. */
+  /*     .. */
+
+  /*  ===================================================================== */
+
+  /*     .. Parameters .. */
+  /*     .. */
+  /*     .. Local Scalars .. */
+  /*     .. */
+  /*     .. External Functions .. */
+  /*     .. */
+  /*     .. External Subroutines .. */
+  /*     .. */
+  /*     .. Intrinsic Functions .. */
+  /*     .. */
+
+  /*     Test the input parameters. */
+
+  /* Parameter adjustments */
+  --x;
+  --ap;
+
+  /* Function Body */
+  info = 0;
+  if (!lsame_(uplo, "U") &&
+      !lsame_(uplo, "L")) {
+    info = 1;
+  } else if (!lsame_(trans, "N") &&
+             !lsame_(trans, "T") &&
+             !lsame_(trans, "C")) {
+    info = 2;
+  } else if (!lsame_(diag, "U") &&
+             !lsame_(diag, "N")) {
+    info = 3;
+  } else if (*n < 0) {
+    info = 4;
+  } else if (*incx == 0) {
+    info = 7;
+  }
+  if (info != 0) {
+    xerbla_("CTPMV ", &info);
+    return;
+  }
+
+  /*     Quick return if possible. */
+
+  if (*n == 0) {
+    return;
+  }
+
+  noconj = lsame_(trans, "T");
+  nounit = lsame_(diag, "N");
+
+  /*     Set up the start point in X if the increment is not unity. This */
+  /*     will be  ( N - 1 )*INCX  too small for descending loops. */
+
+  if (*incx <= 0) {
+    kx = 1 - (*n - 1) * *incx;
+  } else if (*incx != 1) {
+    kx = 1;
+  }
+
+  /*     Start the operations. In this version the elements of AP are */
+  /*     accessed sequentially with one pass through AP. */
+
+  if (lsame_(trans, "N")) {
+
+    /*        Form  x:= A*x. */
+
+    if (lsame_(uplo, "U")) {
+      kk = 1;
+      if (*incx == 1) {
+        i__1 = *n;
+        for (j = 1; j <= i__1; ++j) {
+          i__2 = j;
+          if (x[i__2].r != 0.f || x[i__2].i != 0.f) {
+            i__2 = j;
+            temp.r = x[i__2].r, temp.i = x[i__2].i;
+            k = kk;
+            i__2 = j - 1;
+            for (i__ = 1; i__ <= i__2; ++i__) {
+              i__3 = i__;
+              i__4 = i__;
+              i__5 = k;
+              q__2.r = temp.r * ap[i__5].r - temp.i * ap[i__5].i,
+              q__2.i = temp.r * ap[i__5].i + temp.i * ap[i__5].r;
+              q__1.r = x[i__4].r + q__2.r, q__1.i = x[i__4].i + q__2.i;
+              x[i__3].r = q__1.r, x[i__3].i = q__1.i;
+              ++k;
+              /* L10: */
+            }
+            if (nounit) {
+              i__2 = j;
+              i__3 = j;
+              i__4 = kk + j - 1;
+              q__1.r = x[i__3].r * ap[i__4].r - x[i__3].i * ap[i__4].i,
+              q__1.i = x[i__3].r * ap[i__4].i + x[i__3].i * ap[i__4].r;
+              x[i__2].r = q__1.r, x[i__2].i = q__1.i;
+            }
+          }
+          kk += j;
+          /* L20: */
+        }
+      } else {
+        jx = kx;
+        i__1 = *n;
+        for (j = 1; j <= i__1; ++j) {
+          i__2 = jx;
+          if (x[i__2].r != 0.f || x[i__2].i != 0.f) {
+            i__2 = jx;
+            temp.r = x[i__2].r, temp.i = x[i__2].i;
+            ix = kx;
+            i__2 = kk + j - 2;
+            for (k = kk; k <= i__2; ++k) {
+              i__3 = ix;
+              i__4 = ix;
+              i__5 = k;
+              q__2.r = temp.r * ap[i__5].r - temp.i * ap[i__5].i,
+              q__2.i = temp.r * ap[i__5].i + temp.i * ap[i__5].r;
+              q__1.r = x[i__4].r + q__2.r, q__1.i = x[i__4].i + q__2.i;
+              x[i__3].r = q__1.r, x[i__3].i = q__1.i;
+              ix += *incx;
+              /* L30: */
+            }
+            if (nounit) {
+              i__2 = jx;
+              i__3 = jx;
+              i__4 = kk + j - 1;
+              q__1.r = x[i__3].r * ap[i__4].r - x[i__3].i * ap[i__4].i,
+              q__1.i = x[i__3].r * ap[i__4].i + x[i__3].i * ap[i__4].r;
+              x[i__2].r = q__1.r, x[i__2].i = q__1.i;
+            }
+          }
+          jx += *incx;
+          kk += j;
+          /* L40: */
+        }
+      }
+    } else {
+      kk = *n * (*n + 1) / 2;
+      if (*incx == 1) {
+        for (j = *n; j >= 1; --j) {
+          i__1 = j;
+          if (x[i__1].r != 0.f || x[i__1].i != 0.f) {
+            i__1 = j;
+            temp.r = x[i__1].r, temp.i = x[i__1].i;
+            k = kk;
+            i__1 = j + 1;
+            for (i__ = *n; i__ >= i__1; --i__) {
+              i__2 = i__;
+              i__3 = i__;
+              i__4 = k;
+              q__2.r = temp.r * ap[i__4].r - temp.i * ap[i__4].i,
+              q__2.i = temp.r * ap[i__4].i + temp.i * ap[i__4].r;
+              q__1.r = x[i__3].r + q__2.r, q__1.i = x[i__3].i + q__2.i;
+              x[i__2].r = q__1.r, x[i__2].i = q__1.i;
+              --k;
+              /* L50: */
+            }
+            if (nounit) {
+              i__1 = j;
+              i__2 = j;
+              i__3 = kk - *n + j;
+              q__1.r = x[i__2].r * ap[i__3].r - x[i__2].i * ap[i__3].i,
+              q__1.i = x[i__2].r * ap[i__3].i + x[i__2].i * ap[i__3].r;
+              x[i__1].r = q__1.r, x[i__1].i = q__1.i;
+            }
+          }
+          kk -= *n - j + 1;
+          /* L60: */
+        }
+      } else {
+        kx += (*n - 1) * *incx;
+        jx = kx;
+        for (j = *n; j >= 1; --j) {
+          i__1 = jx;
+          if (x[i__1].r != 0.f || x[i__1].i != 0.f) {
+            i__1 = jx;
+            temp.r = x[i__1].r, temp.i = x[i__1].i;
+            ix = kx;
+            i__1 = kk - (*n - (j + 1));
+            for (k = kk; k >= i__1; --k) {
+              i__2 = ix;
+              i__3 = ix;
+              i__4 = k;
+              q__2.r = temp.r * ap[i__4].r - temp.i * ap[i__4].i,
+              q__2.i = temp.r * ap[i__4].i + temp.i * ap[i__4].r;
+              q__1.r = x[i__3].r + q__2.r, q__1.i = x[i__3].i + q__2.i;
+              x[i__2].r = q__1.r, x[i__2].i = q__1.i;
+              ix -= *incx;
+              /* L70: */
+            }
+            if (nounit) {
+              i__1 = jx;
+              i__2 = jx;
+              i__3 = kk - *n + j;
+              q__1.r = x[i__2].r * ap[i__3].r - x[i__2].i * ap[i__3].i,
+              q__1.i = x[i__2].r * ap[i__3].i + x[i__2].i * ap[i__3].r;
+              x[i__1].r = q__1.r, x[i__1].i = q__1.i;
+            }
+          }
+          jx -= *incx;
+          kk -= *n - j + 1;
+          /* L80: */
+        }
+      }
     }
-
-/*     Start the operations. In this version the elements of AP are */
-/*     accessed sequentially with one pass through AP. */
-
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
-
-/*        Form  x:= A*x. */
-
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
-	    kk = 1;
-	    if (*incx == 1) {
-		i__1 = *n;
-		for (j = 1; j <= i__1; ++j) {
-		    i__2 = j;
-		    if (x[i__2].r != 0.f || x[i__2].i != 0.f) {
-			i__2 = j;
-			temp.r = x[i__2].r, temp.i = x[i__2].i;
-			k = kk;
-			i__2 = j - 1;
-			for (i__ = 1; i__ <= i__2; ++i__) {
-			    i__3 = i__;
-			    i__4 = i__;
-			    i__5 = k;
-			    q__2.r = temp.r * ap[i__5].r - temp.i * ap[i__5]
-				    .i, q__2.i = temp.r * ap[i__5].i + temp.i 
-				    * ap[i__5].r;
-			    q__1.r = x[i__4].r + q__2.r, q__1.i = x[i__4].i + 
-				    q__2.i;
-			    x[i__3].r = q__1.r, x[i__3].i = q__1.i;
-			    ++k;
-/* L10: */
-			}
-			if (nounit) {
-			    i__2 = j;
-			    i__3 = j;
-			    i__4 = kk + j - 1;
-			    q__1.r = x[i__3].r * ap[i__4].r - x[i__3].i * ap[
-				    i__4].i, q__1.i = x[i__3].r * ap[i__4].i 
-				    + x[i__3].i * ap[i__4].r;
-			    x[i__2].r = q__1.r, x[i__2].i = q__1.i;
-			}
-		    }
-		    kk += j;
-/* L20: */
-		}
-	    } else {
-		jx = kx;
-		i__1 = *n;
-		for (j = 1; j <= i__1; ++j) {
-		    i__2 = jx;
-		    if (x[i__2].r != 0.f || x[i__2].i != 0.f) {
-			i__2 = jx;
-			temp.r = x[i__2].r, temp.i = x[i__2].i;
-			ix = kx;
-			i__2 = kk + j - 2;
-			for (k = kk; k <= i__2; ++k) {
-			    i__3 = ix;
-			    i__4 = ix;
-			    i__5 = k;
-			    q__2.r = temp.r * ap[i__5].r - temp.i * ap[i__5]
-				    .i, q__2.i = temp.r * ap[i__5].i + temp.i 
-				    * ap[i__5].r;
-			    q__1.r = x[i__4].r + q__2.r, q__1.i = x[i__4].i + 
-				    q__2.i;
-			    x[i__3].r = q__1.r, x[i__3].i = q__1.i;
-			    ix += *incx;
-/* L30: */
-			}
-			if (nounit) {
-			    i__2 = jx;
-			    i__3 = jx;
-			    i__4 = kk + j - 1;
-			    q__1.r = x[i__3].r * ap[i__4].r - x[i__3].i * ap[
-				    i__4].i, q__1.i = x[i__3].r * ap[i__4].i 
-				    + x[i__3].i * ap[i__4].r;
-			    x[i__2].r = q__1.r, x[i__2].i = q__1.i;
-			}
-		    }
-		    jx += *incx;
-		    kk += j;
-/* L40: */
-		}
-	    }
-	} else {
-	    kk = *n * (*n + 1) / 2;
-	    if (*incx == 1) {
-		for (j = *n; j >= 1; --j) {
-		    i__1 = j;
-		    if (x[i__1].r != 0.f || x[i__1].i != 0.f) {
-			i__1 = j;
-			temp.r = x[i__1].r, temp.i = x[i__1].i;
-			k = kk;
-			i__1 = j + 1;
-			for (i__ = *n; i__ >= i__1; --i__) {
-			    i__2 = i__;
-			    i__3 = i__;
-			    i__4 = k;
-			    q__2.r = temp.r * ap[i__4].r - temp.i * ap[i__4]
-				    .i, q__2.i = temp.r * ap[i__4].i + temp.i 
-				    * ap[i__4].r;
-			    q__1.r = x[i__3].r + q__2.r, q__1.i = x[i__3].i + 
-				    q__2.i;
-			    x[i__2].r = q__1.r, x[i__2].i = q__1.i;
-			    --k;
-/* L50: */
-			}
-			if (nounit) {
-			    i__1 = j;
-			    i__2 = j;
-			    i__3 = kk - *n + j;
-			    q__1.r = x[i__2].r * ap[i__3].r - x[i__2].i * ap[
-				    i__3].i, q__1.i = x[i__2].r * ap[i__3].i 
-				    + x[i__2].i * ap[i__3].r;
-			    x[i__1].r = q__1.r, x[i__1].i = q__1.i;
-			}
-		    }
-		    kk -= *n - j + 1;
-/* L60: */
-		}
-	    } else {
-		kx += (*n - 1) * *incx;
-		jx = kx;
-		for (j = *n; j >= 1; --j) {
-		    i__1 = jx;
-		    if (x[i__1].r != 0.f || x[i__1].i != 0.f) {
-			i__1 = jx;
-			temp.r = x[i__1].r, temp.i = x[i__1].i;
-			ix = kx;
-			i__1 = kk - (*n - (j + 1));
-			for (k = kk; k >= i__1; --k) {
-			    i__2 = ix;
-			    i__3 = ix;
-			    i__4 = k;
-			    q__2.r = temp.r * ap[i__4].r - temp.i * ap[i__4]
-				    .i, q__2.i = temp.r * ap[i__4].i + temp.i 
-				    * ap[i__4].r;
-			    q__1.r = x[i__3].r + q__2.r, q__1.i = x[i__3].i + 
-				    q__2.i;
-			    x[i__2].r = q__1.r, x[i__2].i = q__1.i;
-			    ix -= *incx;
-/* L70: */
-			}
-			if (nounit) {
-			    i__1 = jx;
-			    i__2 = jx;
-			    i__3 = kk - *n + j;
-			    q__1.r = x[i__2].r * ap[i__3].r - x[i__2].i * ap[
-				    i__3].i, q__1.i = x[i__2].r * ap[i__3].i 
-				    + x[i__2].i * ap[i__3].r;
-			    x[i__1].r = q__1.r, x[i__1].i = q__1.i;
-			}
-		    }
-		    jx -= *incx;
-		    kk -= *n - j + 1;
-/* L80: */
-		}
-	    }
-	}
+  } else {
+
+    /*        Form  x := A**T*x  or  x := A**H*x. */
+
+    if (lsame_(uplo, "U")) {
+      kk = *n * (*n + 1) / 2;
+      if (*incx == 1) {
+        for (j = *n; j >= 1; --j) {
+          i__1 = j;
+          temp.r = x[i__1].r, temp.i = x[i__1].i;
+          k = kk - 1;
+          if (noconj) {
+            if (nounit) {
+              i__1 = kk;
+              q__1.r = temp.r * ap[i__1].r - temp.i * ap[i__1].i,
+              q__1.i = temp.r * ap[i__1].i + temp.i * ap[i__1].r;
+              temp.r = q__1.r, temp.i = q__1.i;
+            }
+            for (i__ = j - 1; i__ >= 1; --i__) {
+              i__1 = k;
+              i__2 = i__;
+              q__2.r = ap[i__1].r * x[i__2].r - ap[i__1].i * x[i__2].i,
+              q__2.i = ap[i__1].r * x[i__2].i + ap[i__1].i * x[i__2].r;
+              q__1.r = temp.r + q__2.r, q__1.i = temp.i + q__2.i;
+              temp.r = q__1.r, temp.i = q__1.i;
+              --k;
+              /* L90: */
+            }
+          } else {
+            if (nounit) {
+              r_cnjg(&q__2, &ap[kk]);
+              q__1.r = temp.r * q__2.r - temp.i * q__2.i,
+              q__1.i = temp.r * q__2.i + temp.i * q__2.r;
+              temp.r = q__1.r, temp.i = q__1.i;
+            }
+            for (i__ = j - 1; i__ >= 1; --i__) {
+              r_cnjg(&q__3, &ap[k]);
+              i__1 = i__;
+              q__2.r = q__3.r * x[i__1].r - q__3.i * x[i__1].i,
+              q__2.i = q__3.r * x[i__1].i + q__3.i * x[i__1].r;
+              q__1.r = temp.r + q__2.r, q__1.i = temp.i + q__2.i;
+              temp.r = q__1.r, temp.i = q__1.i;
+              --k;
+              /* L100: */
+            }
+          }
+          i__1 = j;
+          x[i__1].r = temp.r, x[i__1].i = temp.i;
+          kk -= j;
+          /* L110: */
+        }
+      } else {
+        jx = kx + (*n - 1) * *incx;
+        for (j = *n; j >= 1; --j) {
+          i__1 = jx;
+          temp.r = x[i__1].r, temp.i = x[i__1].i;
+          ix = jx;
+          if (noconj) {
+            if (nounit) {
+              i__1 = kk;
+              q__1.r = temp.r * ap[i__1].r - temp.i * ap[i__1].i,
+              q__1.i = temp.r * ap[i__1].i + temp.i * ap[i__1].r;
+              temp.r = q__1.r, temp.i = q__1.i;
+            }
+            i__1 = kk - j + 1;
+            for (k = kk - 1; k >= i__1; --k) {
+              ix -= *incx;
+              i__2 = k;
+              i__3 = ix;
+              q__2.r = ap[i__2].r * x[i__3].r - ap[i__2].i * x[i__3].i,
+              q__2.i = ap[i__2].r * x[i__3].i + ap[i__2].i * x[i__3].r;
+              q__1.r = temp.r + q__2.r, q__1.i = temp.i + q__2.i;
+              temp.r = q__1.r, temp.i = q__1.i;
+              /* L120: */
+            }
+          } else {
+            if (nounit) {
+              r_cnjg(&q__2, &ap[kk]);
+              q__1.r = temp.r * q__2.r - temp.i * q__2.i,
+              q__1.i = temp.r * q__2.i + temp.i * q__2.r;
+              temp.r = q__1.r, temp.i = q__1.i;
+            }
+            i__1 = kk - j + 1;
+            for (k = kk - 1; k >= i__1; --k) {
+              ix -= *incx;
+              r_cnjg(&q__3, &ap[k]);
+              i__2 = ix;
+              q__2.r = q__3.r * x[i__2].r - q__3.i * x[i__2].i,
+              q__2.i = q__3.r * x[i__2].i + q__3.i * x[i__2].r;
+              q__1.r = temp.r + q__2.r, q__1.i = temp.i + q__2.i;
+              temp.r = q__1.r, temp.i = q__1.i;
+              /* L130: */
+            }
+          }
+          i__1 = jx;
+          x[i__1].r = temp.r, x[i__1].i = temp.i;
+          jx -= *incx;
+          kk -= j;
+          /* L140: */
+        }
+      }
     } else {
-
-/*        Form  x := A**T*x  or  x := A**H*x. */
-
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
-	    kk = *n * (*n + 1) / 2;
-	    if (*incx == 1) {
-		for (j = *n; j >= 1; --j) {
-		    i__1 = j;
-		    temp.r = x[i__1].r, temp.i = x[i__1].i;
-		    k = kk - 1;
-		    if (noconj) {
-			if (nounit) {
-			    i__1 = kk;
-			    q__1.r = temp.r * ap[i__1].r - temp.i * ap[i__1]
-				    .i, q__1.i = temp.r * ap[i__1].i + temp.i 
-				    * ap[i__1].r;
-			    temp.r = q__1.r, temp.i = q__1.i;
-			}
-			for (i__ = j - 1; i__ >= 1; --i__) {
-			    i__1 = k;
-			    i__2 = i__;
-			    q__2.r = ap[i__1].r * x[i__2].r - ap[i__1].i * x[
-				    i__2].i, q__2.i = ap[i__1].r * x[i__2].i 
-				    + ap[i__1].i * x[i__2].r;
-			    q__1.r = temp.r + q__2.r, q__1.i = temp.i + 
-				    q__2.i;
-			    temp.r = q__1.r, temp.i = q__1.i;
-			    --k;
-/* L90: */
-			}
-		    } else {
-			if (nounit) {
-			    r_cnjg(&q__2, &ap[kk]);
-			    q__1.r = temp.r * q__2.r - temp.i * q__2.i, 
-				    q__1.i = temp.r * q__2.i + temp.i * 
-				    q__2.r;
-			    temp.r = q__1.r, temp.i = q__1.i;
-			}
-			for (i__ = j - 1; i__ >= 1; --i__) {
-			    r_cnjg(&q__3, &ap[k]);
-			    i__1 = i__;
-			    q__2.r = q__3.r * x[i__1].r - q__3.i * x[i__1].i, 
-				    q__2.i = q__3.r * x[i__1].i + q__3.i * x[
-				    i__1].r;
-			    q__1.r = temp.r + q__2.r, q__1.i = temp.i + 
-				    q__2.i;
-			    temp.r = q__1.r, temp.i = q__1.i;
-			    --k;
-/* L100: */
-			}
-		    }
-		    i__1 = j;
-		    x[i__1].r = temp.r, x[i__1].i = temp.i;
-		    kk -= j;
-/* L110: */
-		}
-	    } else {
-		jx = kx + (*n - 1) * *incx;
-		for (j = *n; j >= 1; --j) {
-		    i__1 = jx;
-		    temp.r = x[i__1].r, temp.i = x[i__1].i;
-		    ix = jx;
-		    if (noconj) {
-			if (nounit) {
-			    i__1 = kk;
-			    q__1.r = temp.r * ap[i__1].r - temp.i * ap[i__1]
-				    .i, q__1.i = temp.r * ap[i__1].i + temp.i 
-				    * ap[i__1].r;
-			    temp.r = q__1.r, temp.i = q__1.i;
-			}
-			i__1 = kk - j + 1;
-			for (k = kk - 1; k >= i__1; --k) {
-			    ix -= *incx;
-			    i__2 = k;
-			    i__3 = ix;
-			    q__2.r = ap[i__2].r * x[i__3].r - ap[i__2].i * x[
-				    i__3].i, q__2.i = ap[i__2].r * x[i__3].i 
-				    + ap[i__2].i * x[i__3].r;
-			    q__1.r = temp.r + q__2.r, q__1.i = temp.i + 
-				    q__2.i;
-			    temp.r = q__1.r, temp.i = q__1.i;
-/* L120: */
-			}
-		    } else {
-			if (nounit) {
-			    r_cnjg(&q__2, &ap[kk]);
-			    q__1.r = temp.r * q__2.r - temp.i * q__2.i, 
-				    q__1.i = temp.r * q__2.i + temp.i * 
-				    q__2.r;
-			    temp.r = q__1.r, temp.i = q__1.i;
-			}
-			i__1 = kk - j + 1;
-			for (k = kk - 1; k >= i__1; --k) {
-			    ix -= *incx;
-			    r_cnjg(&q__3, &ap[k]);
-			    i__2 = ix;
-			    q__2.r = q__3.r * x[i__2].r - q__3.i * x[i__2].i, 
-				    q__2.i = q__3.r * x[i__2].i + q__3.i * x[
-				    i__2].r;
-			    q__1.r = temp.r + q__2.r, q__1.i = temp.i + 
-				    q__2.i;
-			    temp.r = q__1.r, temp.i = q__1.i;
-/* L130: */
-			}
-		    }
-		    i__1 = jx;
-		    x[i__1].r = temp.r, x[i__1].i = temp.i;
-		    jx -= *incx;
-		    kk -= j;
-/* L140: */
-		}
-	    }
-	} else {
-	    kk = 1;
-	    if (*incx == 1) {
-		i__1 = *n;
-		for (j = 1; j <= i__1; ++j) {
-		    i__2 = j;
-		    temp.r = x[i__2].r, temp.i = x[i__2].i;
-		    k = kk + 1;
-		    if (noconj) {
-			if (nounit) {
-			    i__2 = kk;
-			    q__1.r = temp.r * ap[i__2].r - temp.i * ap[i__2]
-				    .i, q__1.i = temp.r * ap[i__2].i + temp.i 
-				    * ap[i__2].r;
-			    temp.r = q__1.r, temp.i = q__1.i;
-			}
-			i__2 = *n;
-			for (i__ = j + 1; i__ <= i__2; ++i__) {
-			    i__3 = k;
-			    i__4 = i__;
-			    q__2.r = ap[i__3].r * x[i__4].r - ap[i__3].i * x[
-				    i__4].i, q__2.i = ap[i__3].r * x[i__4].i 
-				    + ap[i__3].i * x[i__4].r;
-			    q__1.r = temp.r + q__2.r, q__1.i = temp.i + 
-				    q__2.i;
-			    temp.r = q__1.r, temp.i = q__1.i;
-			    ++k;
-/* L150: */
-			}
-		    } else {
-			if (nounit) {
-			    r_cnjg(&q__2, &ap[kk]);
-			    q__1.r = temp.r * q__2.r - temp.i * q__2.i, 
-				    q__1.i = temp.r * q__2.i + temp.i * 
-				    q__2.r;
-			    temp.r = q__1.r, temp.i = q__1.i;
-			}
-			i__2 = *n;
-			for (i__ = j + 1; i__ <= i__2; ++i__) {
-			    r_cnjg(&q__3, &ap[k]);
-			    i__3 = i__;
-			    q__2.r = q__3.r * x[i__3].r - q__3.i * x[i__3].i, 
-				    q__2.i = q__3.r * x[i__3].i + q__3.i * x[
-				    i__3].r;
-			    q__1.r = temp.r + q__2.r, q__1.i = temp.i + 
-				    q__2.i;
-			    temp.r = q__1.r, temp.i = q__1.i;
-			    ++k;
-/* L160: */
-			}
-		    }
-		    i__2 = j;
-		    x[i__2].r = temp.r, x[i__2].i = temp.i;
-		    kk += *n - j + 1;
-/* L170: */
-		}
-	    } else {
-		jx = kx;
-		i__1 = *n;
-		for (j = 1; j <= i__1; ++j) {
-		    i__2 = jx;
-		    temp.r = x[i__2].r, temp.i = x[i__2].i;
-		    ix = jx;
-		    if (noconj) {
-			if (nounit) {
-			    i__2 = kk;
-			    q__1.r = temp.r * ap[i__2].r - temp.i * ap[i__2]
-				    .i, q__1.i = temp.r * ap[i__2].i + temp.i 
-				    * ap[i__2].r;
-			    temp.r = q__1.r, temp.i = q__1.i;
-			}
-			i__2 = kk + *n - j;
-			for (k = kk + 1; k <= i__2; ++k) {
-			    ix += *incx;
-			    i__3 = k;
-			    i__4 = ix;
-			    q__2.r = ap[i__3].r * x[i__4].r - ap[i__3].i * x[
-				    i__4].i, q__2.i = ap[i__3].r * x[i__4].i 
-				    + ap[i__3].i * x[i__4].r;
-			    q__1.r = temp.r + q__2.r, q__1.i = temp.i + 
-				    q__2.i;
-			    temp.r = q__1.r, temp.i = q__1.i;
-/* L180: */
-			}
-		    } else {
-			if (nounit) {
-			    r_cnjg(&q__2, &ap[kk]);
-			    q__1.r = temp.r * q__2.r - temp.i * q__2.i, 
-				    q__1.i = temp.r * q__2.i + temp.i * 
-				    q__2.r;
-			    temp.r = q__1.r, temp.i = q__1.i;
-			}
-			i__2 = kk + *n - j;
-			for (k = kk + 1; k <= i__2; ++k) {
-			    ix += *incx;
-			    r_cnjg(&q__3, &ap[k]);
-			    i__3 = ix;
-			    q__2.r = q__3.r * x[i__3].r - q__3.i * x[i__3].i, 
-				    q__2.i = q__3.r * x[i__3].i + q__3.i * x[
-				    i__3].r;
-			    q__1.r = temp.r + q__2.r, q__1.i = temp.i + 
-				    q__2.i;
-			    temp.r = q__1.r, temp.i = q__1.i;
-/* L190: */
-			}
-		    }
-		    i__2 = jx;
-		    x[i__2].r = temp.r, x[i__2].i = temp.i;
-		    jx += *incx;
-		    kk += *n - j + 1;
-/* L200: */
-		}
-	    }
-	}
+      kk = 1;
+      if (*incx == 1) {
+        i__1 = *n;
+        for (j = 1; j <= i__1; ++j) {
+          i__2 = j;
+          temp.r = x[i__2].r, temp.i = x[i__2].i;
+          k = kk + 1;
+          if (noconj) {
+            if (nounit) {
+              i__2 = kk;
+              q__1.r = temp.r * ap[i__2].r - temp.i * ap[i__2].i,
+              q__1.i = temp.r * ap[i__2].i + temp.i * ap[i__2].r;
+              temp.r = q__1.r, temp.i = q__1.i;
+            }
+            i__2 = *n;
+            for (i__ = j + 1; i__ <= i__2; ++i__) {
+              i__3 = k;
+              i__4 = i__;
+              q__2.r = ap[i__3].r * x[i__4].r - ap[i__3].i * x[i__4].i,
+              q__2.i = ap[i__3].r * x[i__4].i + ap[i__3].i * x[i__4].r;
+              q__1.r = temp.r + q__2.r, q__1.i = temp.i + q__2.i;
+              temp.r = q__1.r, temp.i = q__1.i;
+              ++k;
+              /* L150: */
+            }
+          } else {
+            if (nounit) {
+              r_cnjg(&q__2, &ap[kk]);
+              q__1.r = temp.r * q__2.r - temp.i * q__2.i,
+              q__1.i = temp.r * q__2.i + temp.i * q__2.r;
+              temp.r = q__1.r, temp.i = q__1.i;
+            }
+            i__2 = *n;
+            for (i__ = j + 1; i__ <= i__2; ++i__) {
+              r_cnjg(&q__3, &ap[k]);
+              i__3 = i__;
+              q__2.r = q__3.r * x[i__3].r - q__3.i * x[i__3].i,
+              q__2.i = q__3.r * x[i__3].i + q__3.i * x[i__3].r;
+              q__1.r = temp.r + q__2.r, q__1.i = temp.i + q__2.i;
+              temp.r = q__1.r, temp.i = q__1.i;
+              ++k;
+              /* L160: */
+            }
+          }
+          i__2 = j;
+          x[i__2].r = temp.r, x[i__2].i = temp.i;
+          kk += *n - j + 1;
+          /* L170: */
+        }
+      } else {
+        jx = kx;
+        i__1 = *n;
+        for (j = 1; j <= i__1; ++j) {
+          i__2 = jx;
+          temp.r = x[i__2].r, temp.i = x[i__2].i;
+          ix = jx;
+          if (noconj) {
+            if (nounit) {
+              i__2 = kk;
+              q__1.r = temp.r * ap[i__2].r - temp.i * ap[i__2].i,
+              q__1.i = temp.r * ap[i__2].i + temp.i * ap[i__2].r;
+              temp.r = q__1.r, temp.i = q__1.i;
+            }
+            i__2 = kk + *n - j;
+            for (k = kk + 1; k <= i__2; ++k) {
+              ix += *incx;
+              i__3 = k;
+              i__4 = ix;
+              q__2.r = ap[i__3].r * x[i__4].r - ap[i__3].i * x[i__4].i,
+              q__2.i = ap[i__3].r * x[i__4].i + ap[i__3].i * x[i__4].r;
+              q__1.r = temp.r + q__2.r, q__1.i = temp.i + q__2.i;
+              temp.r = q__1.r, temp.i = q__1.i;
+              /* L180: */
+            }
+          } else {
+            if (nounit) {
+              r_cnjg(&q__2, &ap[kk]);
+              q__1.r = temp.r * q__2.r - temp.i * q__2.i,
+              q__1.i = temp.r * q__2.i + temp.i * q__2.r;
+              temp.r = q__1.r, temp.i = q__1.i;
+            }
+            i__2 = kk + *n - j;
+            for (k = kk + 1; k <= i__2; ++k) {
+              ix += *incx;
+              r_cnjg(&q__3, &ap[k]);
+              i__3 = ix;
+              q__2.r = q__3.r * x[i__3].r - q__3.i * x[i__3].i,
+              q__2.i = q__3.r * x[i__3].i + q__3.i * x[i__3].r;
+              q__1.r = temp.r + q__2.r, q__1.i = temp.i + q__2.i;
+              temp.r = q__1.r, temp.i = q__1.i;
+              /* L190: */
+            }
+          }
+          i__2 = jx;
+          x[i__2].r = temp.r, x[i__2].i = temp.i;
+          jx += *incx;
+          kk += *n - j + 1;
+          /* L200: */
+        }
+      }
     }
+  }
 
-    return 0;
+  return;
 
-/*     End of CTPMV . */
+  /*     End of CTPMV . */
 
 } /* ctpmv_ */
-
diff --git a/f2c_BLAS-3.8.0/ctpsv.c b/f2c_BLAS-3.8.0/ctpsv.c
index 3fed4d0..9f6e4c0 100644
--- a/f2c_BLAS-3.8.0/ctpsv.c
+++ b/f2c_BLAS-3.8.0/ctpsv.c
@@ -156,9 +156,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ctpsv_(char *uplo, char *trans, char *diag, integer *n, 
-	complex *ap, complex *x, integer *incx, ftnlen uplo_len, ftnlen 
-	trans_len, ftnlen diag_len)
+/* Subroutine */ void ctpsv_(char *uplo, char *trans, char *diag, integer *n, 
+	complex *ap, complex *x, integer *incx)
 {
     /* System generated locals */
     integer i__1, i__2, i__3, i__4, i__5;
@@ -170,8 +169,8 @@
     /* Local variables */
     integer i__, j, k, kk, ix, jx, kx, info;
     complex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconj, nounit;
 
 
@@ -206,15 +205,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -222,18 +217,18 @@
 	info = 7;
     }
     if (info != 0) {
-	xerbla_("CTPSV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CTPSV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    noconj = lsame_(trans, "T", (ftnlen)1, (ftnlen)1);
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    noconj = lsame_(trans, "T");
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX  too small for descending loops. */
@@ -247,11 +242,11 @@
 /*     Start the operations. In this version the elements of AP are */
 /*     accessed sequentially with one pass through AP. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  x := inv( A )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kk = *n * (*n + 1) / 2;
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
@@ -387,7 +382,7 @@
 
 /*        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kk = 1;
 	    if (*incx == 1) {
 		i__1 = *n;
@@ -595,7 +590,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CTPSV . */
 
diff --git a/f2c_BLAS-3.8.0/ctrmm.c b/f2c_BLAS-3.8.0/ctrmm.c
index 73faea7..8ff7119 100644
--- a/f2c_BLAS-3.8.0/ctrmm.c
+++ b/f2c_BLAS-3.8.0/ctrmm.c
@@ -189,10 +189,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ctrmm_(char *side, char *uplo, char *transa, char *diag, 
+/* Subroutine */ void ctrmm_(char *side, char *uplo, char *transa, char *diag, 
 	integer *m, integer *n, complex *alpha, complex *a, integer *lda, 
-	complex *b, integer *ldb, ftnlen side_len, ftnlen uplo_len, ftnlen 
-	transa_len, ftnlen diag_len)
+	complex *b, integer *ldb)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3, i__4, i__5, 
@@ -205,11 +204,11 @@
     /* Local variables */
     integer i__, j, k, info;
     complex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     logical lside;
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconj, nounit;
 
 
@@ -247,27 +246,24 @@
     b -= b_offset;
 
     /* Function Body */
-    lside = lsame_(side, "L", (ftnlen)1, (ftnlen)1);
+    lside = lsame_(side, "L");
     if (lside) {
 	nrowa = *m;
     } else {
 	nrowa = *n;
     }
-    noconj = lsame_(transa, "T", (ftnlen)1, (ftnlen)1);
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    noconj = lsame_(transa, "T");
+    nounit = lsame_(diag, "N");
+    upper = lsame_(uplo, "U");
 
     info = 0;
-    if (! lside && ! lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {
+    if (! lside && ! lsame_(side, "R")) {
 	info = 1;
-    } else if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    } else if (! upper && ! lsame_(uplo, "L")) {
 	info = 2;
-    } else if (! lsame_(transa, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(transa,
-	     "T", (ftnlen)1, (ftnlen)1) && ! lsame_(transa, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(transa, "N") && ! lsame_(transa, "T") && ! lsame_(transa, "C")) {
 	info = 3;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 4;
     } else if (*m < 0) {
 	info = 5;
@@ -279,14 +275,14 @@
 	info = 11;
     }
     if (info != 0) {
-	xerbla_("CTRMM ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CTRMM ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -302,13 +298,13 @@
 	    }
 /* L20: */
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
     if (lside) {
-	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(transa, "N")) {
 
 /*           Form  B := alpha*A*B. */
 
@@ -512,7 +508,7 @@
 	    }
 	}
     } else {
-	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(transa, "N")) {
 
 /*           Form  B := alpha*B*A. */
 
@@ -751,7 +747,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CTRMM . */
 
diff --git a/f2c_BLAS-3.8.0/ctrmv.c b/f2c_BLAS-3.8.0/ctrmv.c
index ff14cd0..d617878 100644
--- a/f2c_BLAS-3.8.0/ctrmv.c
+++ b/f2c_BLAS-3.8.0/ctrmv.c
@@ -159,9 +159,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ctrmv_(char *uplo, char *trans, char *diag, integer *n, 
-	complex *a, integer *lda, complex *x, integer *incx, ftnlen uplo_len, 
-	ftnlen trans_len, ftnlen diag_len)
+/* Subroutine */ void ctrmv_(char *uplo, char *trans, char *diag, integer *n, 
+	complex *a, integer *lda, complex *x, integer *incx)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
@@ -173,8 +172,8 @@
     /* Local variables */
     integer i__, j, ix, jx, kx, info;
     complex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconj, nounit;
 
 
@@ -211,15 +210,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -229,18 +224,18 @@
 	info = 8;
     }
     if (info != 0) {
-	xerbla_("CTRMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CTRMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    noconj = lsame_(trans, "T", (ftnlen)1, (ftnlen)1);
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    noconj = lsame_(trans, "T");
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX  too small for descending loops. */
@@ -254,11 +249,11 @@
 /*     Start the operations. In this version the elements of A are */
 /*     accessed sequentially with one pass through A. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  x := A*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    if (*incx == 1) {
 		i__1 = *n;
 		for (j = 1; j <= i__1; ++j) {
@@ -402,7 +397,7 @@
 
 /*        Form  x := A**T*x  or  x := A**H*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
 		    i__1 = j;
@@ -613,7 +608,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CTRMV . */
 
diff --git a/f2c_BLAS-3.8.0/ctrsm.c b/f2c_BLAS-3.8.0/ctrsm.c
index aebf5b9..ddeaa68 100644
--- a/f2c_BLAS-3.8.0/ctrsm.c
+++ b/f2c_BLAS-3.8.0/ctrsm.c
@@ -196,10 +196,9 @@ static complex c_b1 = {1.f,0.f};
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ctrsm_(char *side, char *uplo, char *transa, char *diag, 
+/* Subroutine */ void ctrsm_(char *side, char *uplo, char *transa, char *diag, 
 	integer *m, integer *n, complex *alpha, complex *a, integer *lda, 
-	complex *b, integer *ldb, ftnlen side_len, ftnlen uplo_len, ftnlen 
-	transa_len, ftnlen diag_len)
+	complex *b, integer *ldb)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3, i__4, i__5, 
@@ -212,11 +211,11 @@ static complex c_b1 = {1.f,0.f};
     /* Local variables */
     integer i__, j, k, info;
     complex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     logical lside;
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconj, nounit;
 
 
@@ -254,27 +253,24 @@ static complex c_b1 = {1.f,0.f};
     b -= b_offset;
 
     /* Function Body */
-    lside = lsame_(side, "L", (ftnlen)1, (ftnlen)1);
+    lside = lsame_(side, "L");
     if (lside) {
 	nrowa = *m;
     } else {
 	nrowa = *n;
     }
-    noconj = lsame_(transa, "T", (ftnlen)1, (ftnlen)1);
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    noconj = lsame_(transa, "T");
+    nounit = lsame_(diag, "N");
+    upper = lsame_(uplo, "U");
 
     info = 0;
-    if (! lside && ! lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {
+    if (! lside && ! lsame_(side, "R")) {
 	info = 1;
-    } else if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    } else if (! upper && ! lsame_(uplo, "L")) {
 	info = 2;
-    } else if (! lsame_(transa, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(transa,
-	     "T", (ftnlen)1, (ftnlen)1) && ! lsame_(transa, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(transa, "N") && ! lsame_(transa, "T") && ! lsame_(transa, "C")) {
 	info = 3;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 4;
     } else if (*m < 0) {
 	info = 5;
@@ -286,14 +282,14 @@ static complex c_b1 = {1.f,0.f};
 	info = 11;
     }
     if (info != 0) {
-	xerbla_("CTRSM ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CTRSM ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -309,13 +305,13 @@ static complex c_b1 = {1.f,0.f};
 	    }
 /* L20: */
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
     if (lside) {
-	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(transa, "N")) {
 
 /*           Form  B := alpha*inv( A )*B. */
 
@@ -518,7 +514,7 @@ static complex c_b1 = {1.f,0.f};
 	    }
 	}
     } else {
-	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(transa, "N")) {
 
 /*           Form  B := alpha*B*inv( A ). */
 
@@ -762,7 +758,7 @@ static complex c_b1 = {1.f,0.f};
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CTRSM . */
 
diff --git a/f2c_BLAS-3.8.0/ctrsv.c b/f2c_BLAS-3.8.0/ctrsv.c
index 58ac666..c3fc5ac 100644
--- a/f2c_BLAS-3.8.0/ctrsv.c
+++ b/f2c_BLAS-3.8.0/ctrsv.c
@@ -161,9 +161,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ctrsv_(char *uplo, char *trans, char *diag, integer *n, 
-	complex *a, integer *lda, complex *x, integer *incx, ftnlen uplo_len, 
-	ftnlen trans_len, ftnlen diag_len)
+/* Subroutine */ void ctrsv_(char *uplo, char *trans, char *diag, integer *n, 
+	complex *a, integer *lda, complex *x, integer *incx)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
@@ -175,8 +174,8 @@
     /* Local variables */
     integer i__, j, ix, jx, kx, info;
     complex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconj, nounit;
 
 
@@ -213,15 +212,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -231,18 +226,18 @@
 	info = 8;
     }
     if (info != 0) {
-	xerbla_("CTRSV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("CTRSV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    noconj = lsame_(trans, "T", (ftnlen)1, (ftnlen)1);
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    noconj = lsame_(trans, "T");
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX  too small for descending loops. */
@@ -256,11 +251,11 @@
 /*     Start the operations. In this version the elements of A are */
 /*     accessed sequentially with one pass through A. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  x := inv( A )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
 		    i__1 = j;
@@ -385,7 +380,7 @@
 
 /*        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    if (*incx == 1) {
 		i__1 = *n;
 		for (j = 1; j <= i__1; ++j) {
@@ -581,7 +576,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of CTRSV . */
 
diff --git a/f2c_BLAS-3.8.0/dasum.c b/f2c_BLAS-3.8.0/dasum.c
index 06a1b87..e34fd89 100644
--- a/f2c_BLAS-3.8.0/dasum.c
+++ b/f2c_BLAS-3.8.0/dasum.c
@@ -9,7 +9,6 @@
 
 		http://www.netlib.org/f2c/libf2c.zip
 */
-
 #include "f2c.h"
 
 /* > \brief \b DASUM */
diff --git a/f2c_BLAS-3.8.0/daxpy.c b/f2c_BLAS-3.8.0/daxpy.c
index 8f958fd..c14da7c 100644
--- a/f2c_BLAS-3.8.0/daxpy.c
+++ b/f2c_BLAS-3.8.0/daxpy.c
@@ -101,7 +101,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int daxpy_(integer *n, doublereal *da, doublereal *dx, 
+/* Subroutine */ void daxpy_(integer *n, doublereal *da, doublereal *dx, 
 	integer *incx, doublereal *dy, integer *incy)
 {
     /* System generated locals */
@@ -133,10 +133,10 @@
 
     /* Function Body */
     if (*n <= 0) {
-	return 0;
+	return;
     }
     if (*da == 0.) {
-	return 0;
+	return;
     }
     if (*incx == 1 && *incy == 1) {
 
@@ -153,7 +153,7 @@
 	    }
 	}
 	if (*n < 4) {
-	    return 0;
+	    return;
 	}
 	mp1 = m + 1;
 	i__1 = *n;
@@ -183,6 +183,6 @@
 	    iy += *incy;
 	}
     }
-    return 0;
+    return;
 } /* daxpy_ */
 
diff --git a/f2c_BLAS-3.8.0/dcopy.c b/f2c_BLAS-3.8.0/dcopy.c
index cf0dcb0..8cdda1c 100644
--- a/f2c_BLAS-3.8.0/dcopy.c
+++ b/f2c_BLAS-3.8.0/dcopy.c
@@ -94,7 +94,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dcopy_(integer *n, doublereal *dx, integer *incx, 
+/* Subroutine */ void dcopy_(integer *n, doublereal *dx, integer *incx, 
 	doublereal *dy, integer *incy)
 {
     /* System generated locals */
@@ -126,7 +126,7 @@
 
     /* Function Body */
     if (*n <= 0) {
-	return 0;
+	return;
     }
     if (*incx == 1 && *incy == 1) {
 
@@ -142,7 +142,7 @@
 		dy[i__] = dx[i__];
 	    }
 	    if (*n < 7) {
-		return 0;
+		return;
 	    }
 	}
 	mp1 = m + 1;
@@ -176,6 +176,6 @@
 	    iy += *incy;
 	}
     }
-    return 0;
+    return;
 } /* dcopy_ */
 
diff --git a/f2c_BLAS-3.8.0/dgbmv.c b/f2c_BLAS-3.8.0/dgbmv.c
index e7cd0c1..9b28a35 100644
--- a/f2c_BLAS-3.8.0/dgbmv.c
+++ b/f2c_BLAS-3.8.0/dgbmv.c
@@ -197,10 +197,10 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dgbmv_(char *trans, integer *m, integer *n, integer *kl, 
+/* Subroutine */ void dgbmv_(char *trans, integer *m, integer *n, integer *kl, 
 	integer *ku, doublereal *alpha, doublereal *a, integer *lda, 
 	doublereal *x, integer *incx, doublereal *beta, doublereal *y, 
-	integer *incy, ftnlen trans_len)
+	integer *incy)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;
@@ -209,8 +209,8 @@
     integer i__, j, k, ix, iy, jx, jy, kx, ky, kup1, info;
     doublereal temp;
     integer lenx, leny;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -247,8 +247,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "T", (
-	    ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (ftnlen)1)
+    if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")
 	    ) {
 	info = 1;
     } else if (*m < 0) {
@@ -267,20 +266,20 @@
 	info = 13;
     }
     if (info != 0) {
-	xerbla_("DGBMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DGBMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || *alpha == 0. && *beta == 1.) {
-	return 0;
+	return;
     }
 
 /*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set */
 /*     up the start points in  X  and  Y. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 	lenx = *n;
 	leny = *m;
     } else {
@@ -338,10 +337,10 @@
 	}
     }
     if (*alpha == 0.) {
-	return 0;
+	return;
     }
     kup1 = *ku + 1;
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  y := alpha*A*x + y. */
 
@@ -435,7 +434,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DGBMV . */
 
diff --git a/f2c_BLAS-3.8.0/dgemm.c b/f2c_BLAS-3.8.0/dgemm.c
index 71e508c..b52a4a6 100644
--- a/f2c_BLAS-3.8.0/dgemm.c
+++ b/f2c_BLAS-3.8.0/dgemm.c
@@ -199,10 +199,10 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dgemm_(char *transa, char *transb, integer *m, integer *
+/* Subroutine */ void dgemm_(char *transa, char *transb, integer *m, integer *
 	n, integer *k, doublereal *alpha, doublereal *a, integer *lda, 
 	doublereal *b, integer *ldb, doublereal *beta, doublereal *c__, 
-	integer *ldc, ftnlen transa_len, ftnlen transb_len)
+	integer *ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, 
@@ -213,9 +213,9 @@
     logical nota, notb;
     doublereal temp;
     integer ncola;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa, nrowb;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -257,8 +257,8 @@
     c__ -= c_offset;
 
     /* Function Body */
-    nota = lsame_(transa, "N", (ftnlen)1, (ftnlen)1);
-    notb = lsame_(transb, "N", (ftnlen)1, (ftnlen)1);
+    nota = lsame_(transa, "N");
+    notb = lsame_(transb, "N");
     if (nota) {
 	nrowa = *m;
 	ncola = *k;
@@ -275,11 +275,10 @@
 /*     Test the input parameters. */
 
     info = 0;
-    if (! nota && ! lsame_(transa, "C", (ftnlen)1, (ftnlen)1) && ! lsame_(
-	    transa, "T", (ftnlen)1, (ftnlen)1)) {
+    if (! nota && ! lsame_(transa, "C") && ! lsame_( transa, "T")) {
 	info = 1;
-    } else if (! notb && ! lsame_(transb, "C", (ftnlen)1, (ftnlen)1) && ! 
-	    lsame_(transb, "T", (ftnlen)1, (ftnlen)1)) {
+    } else if (! notb && ! lsame_(transb, "C") && ! 
+	    lsame_(transb, "T")) {
 	info = 2;
     } else if (*m < 0) {
 	info = 3;
@@ -295,14 +294,14 @@
 	info = 13;
     }
     if (info != 0) {
-	xerbla_("DGEMM ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DGEMM ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || (*alpha == 0. || *k == 0) && *beta == 1.) {
-	return 0;
+	return;
     }
 
 /*     And if  alpha.eq.zero. */
@@ -329,7 +328,7 @@
 /* L40: */
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
@@ -450,7 +449,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DGEMM . */
 
diff --git a/f2c_BLAS-3.8.0/dgemv.c b/f2c_BLAS-3.8.0/dgemv.c
index 0e6dc26..c899320 100644
--- a/f2c_BLAS-3.8.0/dgemv.c
+++ b/f2c_BLAS-3.8.0/dgemv.c
@@ -168,9 +168,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dgemv_(char *trans, integer *m, integer *n, doublereal *
+/* Subroutine */ void dgemv_(char *trans, integer *m, integer *n, doublereal *
 	alpha, doublereal *a, integer *lda, doublereal *x, integer *incx, 
-	doublereal *beta, doublereal *y, integer *incy, ftnlen trans_len)
+	doublereal *beta, doublereal *y, integer *incy)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2;
@@ -179,8 +179,8 @@
     integer i__, j, ix, iy, jx, jy, kx, ky, info;
     doublereal temp;
     integer lenx, leny;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -217,8 +217,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "T", (
-	    ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (ftnlen)1)
+    if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")
 	    ) {
 	info = 1;
     } else if (*m < 0) {
@@ -233,20 +232,20 @@
 	info = 11;
     }
     if (info != 0) {
-	xerbla_("DGEMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DGEMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || *alpha == 0. && *beta == 1.) {
-	return 0;
+	return;
     }
 
 /*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set */
 /*     up the start points in  X  and  Y. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 	lenx = *n;
 	leny = *m;
     } else {
@@ -304,9 +303,9 @@
 	}
     }
     if (*alpha == 0.) {
-	return 0;
+	return;
     }
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  y := alpha*A*x + y. */
 
@@ -374,7 +373,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DGEMV . */
 
diff --git a/f2c_BLAS-3.8.0/dger.c b/f2c_BLAS-3.8.0/dger.c
index de018f1..60764ed 100644
--- a/f2c_BLAS-3.8.0/dger.c
+++ b/f2c_BLAS-3.8.0/dger.c
@@ -142,7 +142,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dger_(integer *m, integer *n, doublereal *alpha, 
+/* Subroutine */ void dger_(integer *m, integer *n, doublereal *alpha, 
 	doublereal *x, integer *incx, doublereal *y, integer *incy, 
 	doublereal *a, integer *lda)
 {
@@ -152,7 +152,7 @@
     /* Local variables */
     integer i__, j, ix, jy, kx, info;
     doublereal temp;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -199,14 +199,14 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("DGER  ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DGER  ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || *alpha == 0.) {
-	return 0;
+	return;
     }
 
 /*     Start the operations. In this version the elements of A are */
@@ -254,7 +254,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DGER  . */
 
diff --git a/f2c_BLAS-3.8.0/drot.c b/f2c_BLAS-3.8.0/drot.c
index d20201f..c260167 100644
--- a/f2c_BLAS-3.8.0/drot.c
+++ b/f2c_BLAS-3.8.0/drot.c
@@ -104,7 +104,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int drot_(integer *n, doublereal *dx, integer *incx, 
+/* Subroutine */ void drot_(integer *n, doublereal *dx, integer *incx, 
 	doublereal *dy, integer *incy, doublereal *c__, doublereal *s)
 {
     /* System generated locals */
@@ -135,7 +135,7 @@
 
     /* Function Body */
     if (*n <= 0) {
-	return 0;
+	return;
     }
     if (*incx == 1 && *incy == 1) {
 
@@ -169,6 +169,6 @@
 	    iy += *incy;
 	}
     }
-    return 0;
+    return;
 } /* drot_ */
 
diff --git a/f2c_BLAS-3.8.0/drotg.c b/f2c_BLAS-3.8.0/drotg.c
index e9bf15b..bc5731b 100644
--- a/f2c_BLAS-3.8.0/drotg.c
+++ b/f2c_BLAS-3.8.0/drotg.c
@@ -85,7 +85,7 @@ static doublereal c_b2 = 1.;
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int drotg_(doublereal *da, doublereal *db, doublereal *c__, 
+/* Subroutine */ void drotg_(doublereal *da, doublereal *db, doublereal *c__, 
 	doublereal *s)
 {
     /* System generated locals */
@@ -141,6 +141,6 @@ static doublereal c_b2 = 1.;
     }
     *da = r__;
     *db = z__;
-    return 0;
+    return;
 } /* drotg_ */
 
diff --git a/f2c_BLAS-3.8.0/drotm.c b/f2c_BLAS-3.8.0/drotm.c
index a954992..1537bd6 100644
--- a/f2c_BLAS-3.8.0/drotm.c
+++ b/f2c_BLAS-3.8.0/drotm.c
@@ -108,7 +108,7 @@
 /* > \ingroup double_blas_level1 */
 
 /*  ===================================================================== */
-/* Subroutine */ int drotm_(integer *n, doublereal *dx, integer *incx, 
+/* Subroutine */ void drotm_(integer *n, doublereal *dx, integer *incx, 
 	doublereal *dy, integer *incy, doublereal *dparam)
 {
     /* Initialized data */
@@ -152,7 +152,7 @@
 
     dflag = dparam[1];
     if (*n <= 0 || dflag + two == zero) {
-	return 0;
+	return;
     }
     if (*incx == *incy && *incx > 0) {
 
@@ -243,6 +243,6 @@
 	    }
 	}
     }
-    return 0;
+    return;
 } /* drotm_ */
 
diff --git a/f2c_BLAS-3.8.0/drotmg.c b/f2c_BLAS-3.8.0/drotmg.c
index 216c065..f79a7b4 100644
--- a/f2c_BLAS-3.8.0/drotmg.c
+++ b/f2c_BLAS-3.8.0/drotmg.c
@@ -102,7 +102,7 @@
 /* > \ingroup double_blas_level1 */
 
 /*  ===================================================================== */
-/* Subroutine */ int drotmg_(doublereal *dd1, doublereal *dd2, doublereal *
+/* Subroutine */ void drotmg_(doublereal *dd1, doublereal *dd2, doublereal *
 	dx1, doublereal *dy1, doublereal *dparam)
 {
     /* Initialized data */
@@ -161,7 +161,7 @@
 	if (dp2 == zero) {
 	    dflag = -two;
 	    dparam[1] = dflag;
-	    return 0;
+	    return;
 	}
 /*        REGULAR-CASE.. */
 	dp1 = *dd1 * *dx1;
@@ -272,6 +272,6 @@
 	dparam[5] = dh22;
     }
     dparam[1] = dflag;
-    return 0;
+    return;
 } /* drotmg_ */
 
diff --git a/f2c_BLAS-3.8.0/dsbmv.c b/f2c_BLAS-3.8.0/dsbmv.c
index 8ce260f..64fe766 100644
--- a/f2c_BLAS-3.8.0/dsbmv.c
+++ b/f2c_BLAS-3.8.0/dsbmv.c
@@ -196,9 +196,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dsbmv_(char *uplo, integer *n, integer *k, doublereal *
+/* Subroutine */ void dsbmv_(char *uplo, integer *n, integer *k, doublereal *
 	alpha, doublereal *a, integer *lda, doublereal *x, integer *incx, 
-	doublereal *beta, doublereal *y, integer *incy, ftnlen uplo_len)
+	doublereal *beta, doublereal *y, integer *incy)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
@@ -206,9 +206,9 @@
     /* Local variables */
     integer i__, j, l, ix, iy, jx, jy, kx, ky, info;
     doublereal temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer kplus1;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -245,8 +245,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -260,14 +259,14 @@
 	info = 11;
     }
     if (info != 0) {
-	xerbla_("DSBMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DSBMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || *alpha == 0. && *beta == 1.) {
-	return 0;
+	return;
     }
 
 /*     Set up the start points in  X  and  Y. */
@@ -323,9 +322,9 @@
 	}
     }
     if (*alpha == 0.) {
-	return 0;
+	return;
     }
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  y  when upper triangle of A is stored. */
 
@@ -429,7 +428,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DSBMV . */
 
diff --git a/f2c_BLAS-3.8.0/dscal.c b/f2c_BLAS-3.8.0/dscal.c
index 3394415..2597c2c 100644
--- a/f2c_BLAS-3.8.0/dscal.c
+++ b/f2c_BLAS-3.8.0/dscal.c
@@ -91,7 +91,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dscal_(integer *n, doublereal *da, doublereal *dx, 
+/* Subroutine */ void dscal_(integer *n, doublereal *da, doublereal *dx, 
 	integer *incx)
 {
     /* System generated locals */
@@ -122,7 +122,7 @@
 
     /* Function Body */
     if (*n <= 0 || *incx <= 0) {
-	return 0;
+	return;
     }
     if (*incx == 1) {
 
@@ -138,7 +138,7 @@
 		dx[i__] = *da * dx[i__];
 	    }
 	    if (*n < 5) {
-		return 0;
+		return;
 	    }
 	}
 	mp1 = m + 1;
@@ -161,6 +161,6 @@
 	    dx[i__] = *da * dx[i__];
 	}
     }
-    return 0;
+    return;
 } /* dscal_ */
 
diff --git a/f2c_BLAS-3.8.0/dspmv.c b/f2c_BLAS-3.8.0/dspmv.c
index 557515f..a1dcbad 100644
--- a/f2c_BLAS-3.8.0/dspmv.c
+++ b/f2c_BLAS-3.8.0/dspmv.c
@@ -159,9 +159,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dspmv_(char *uplo, integer *n, doublereal *alpha, 
+/* Subroutine */ void dspmv_(char *uplo, integer *n, doublereal *alpha, 
 	doublereal *ap, doublereal *x, integer *incx, doublereal *beta, 
-	doublereal *y, integer *incy, ftnlen uplo_len)
+	doublereal *y, integer *incy)
 {
     /* System generated locals */
     integer i__1, i__2;
@@ -169,8 +169,8 @@
     /* Local variables */
     integer i__, j, k, kk, ix, iy, jx, jy, kx, ky, info;
     doublereal temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -203,8 +203,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -214,14 +213,14 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("DSPMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DSPMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || *alpha == 0. && *beta == 1.) {
-	return 0;
+	return;
     }
 
 /*     Set up the start points in  X  and  Y. */
@@ -277,10 +276,10 @@
 	}
     }
     if (*alpha == 0.) {
-	return 0;
+	return;
     }
     kk = 1;
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  y  when AP contains the upper triangle. */
 
@@ -374,7 +373,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DSPMV . */
 
diff --git a/f2c_BLAS-3.8.0/dspr.c b/f2c_BLAS-3.8.0/dspr.c
index e9928a5..c52b1c2 100644
--- a/f2c_BLAS-3.8.0/dspr.c
+++ b/f2c_BLAS-3.8.0/dspr.c
@@ -139,8 +139,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dspr_(char *uplo, integer *n, doublereal *alpha, 
-	doublereal *x, integer *incx, doublereal *ap, ftnlen uplo_len)
+/* Subroutine */ void dspr_(char *uplo, integer *n, doublereal *alpha, 
+	doublereal *x, integer *incx, doublereal *ap)
 {
     /* System generated locals */
     integer i__1, i__2;
@@ -148,8 +148,8 @@
     /* Local variables */
     integer i__, j, k, kk, ix, jx, kx, info;
     doublereal temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -181,8 +181,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -190,14 +189,14 @@
 	info = 5;
     }
     if (info != 0) {
-	xerbla_("DSPR  ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DSPR  ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || *alpha == 0.) {
-	return 0;
+	return;
     }
 
 /*     Set the start point in X if the increment is not unity. */
@@ -212,7 +211,7 @@
 /*     are accessed sequentially with one pass through AP. */
 
     kk = 1;
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  A  when upper triangle is stored in AP. */
 
@@ -292,7 +291,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DSPR  . */
 
diff --git a/f2c_BLAS-3.8.0/dspr2.c b/f2c_BLAS-3.8.0/dspr2.c
index 82c4d1d..676f3a5 100644
--- a/f2c_BLAS-3.8.0/dspr2.c
+++ b/f2c_BLAS-3.8.0/dspr2.c
@@ -154,9 +154,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dspr2_(char *uplo, integer *n, doublereal *alpha, 
+/* Subroutine */ void dspr2_(char *uplo, integer *n, doublereal *alpha, 
 	doublereal *x, integer *incx, doublereal *y, integer *incy, 
-	doublereal *ap, ftnlen uplo_len)
+	doublereal *ap)
 {
     /* System generated locals */
     integer i__1, i__2;
@@ -164,8 +164,8 @@
     /* Local variables */
     integer i__, j, k, kk, ix, iy, jx, jy, kx, ky, info;
     doublereal temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -198,8 +198,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -209,14 +208,14 @@
 	info = 7;
     }
     if (info != 0) {
-	xerbla_("DSPR2 ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DSPR2 ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || *alpha == 0.) {
-	return 0;
+	return;
     }
 
 /*     Set up the start points in X and Y if the increments are not both */
@@ -241,7 +240,7 @@
 /*     are accessed sequentially with one pass through AP. */
 
     kk = 1;
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  A  when upper triangle is stored in AP. */
 
@@ -329,7 +328,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DSPR2 . */
 
diff --git a/f2c_BLAS-3.8.0/dswap.c b/f2c_BLAS-3.8.0/dswap.c
index 48a22d3..c1808bc 100644
--- a/f2c_BLAS-3.8.0/dswap.c
+++ b/f2c_BLAS-3.8.0/dswap.c
@@ -94,7 +94,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dswap_(integer *n, doublereal *dx, integer *incx, 
+/* Subroutine */ void dswap_(integer *n, doublereal *dx, integer *incx, 
 	doublereal *dy, integer *incy)
 {
     /* System generated locals */
@@ -127,7 +127,7 @@
 
     /* Function Body */
     if (*n <= 0) {
-	return 0;
+	return;
     }
     if (*incx == 1 && *incy == 1) {
 
@@ -145,7 +145,7 @@
 		dy[i__] = dtemp;
 	    }
 	    if (*n < 3) {
-		return 0;
+		return;
 	    }
 	}
 	mp1 = m + 1;
@@ -183,6 +183,6 @@
 	    iy += *incy;
 	}
     }
-    return 0;
+    return;
 } /* dswap_ */
 
diff --git a/f2c_BLAS-3.8.0/dsymm.c b/f2c_BLAS-3.8.0/dsymm.c
index b423365..795ae40 100644
--- a/f2c_BLAS-3.8.0/dsymm.c
+++ b/f2c_BLAS-3.8.0/dsymm.c
@@ -201,10 +201,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dsymm_(char *side, char *uplo, integer *m, integer *n, 
+/* Subroutine */ void dsymm_(char *side, char *uplo, integer *m, integer *n, 
 	doublereal *alpha, doublereal *a, integer *lda, doublereal *b, 
-	integer *ldb, doublereal *beta, doublereal *c__, integer *ldc, ftnlen 
-	side_len, ftnlen uplo_len)
+	integer *ldb, doublereal *beta, doublereal *c__, integer *ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, 
@@ -213,10 +212,10 @@
     /* Local variables */
     integer i__, j, k, info;
     doublereal temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -256,20 +255,19 @@
     c__ -= c_offset;
 
     /* Function Body */
-    if (lsame_(side, "L", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(side, "L")) {
 	nrowa = *m;
     } else {
 	nrowa = *n;
     }
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    upper = lsame_(uplo, "U");
 
 /*     Test the input parameters. */
 
     info = 0;
-    if (! lsame_(side, "L", (ftnlen)1, (ftnlen)1) && ! lsame_(side, "R", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(side, "L") && ! lsame_(side, "R")) {
 	info = 1;
-    } else if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    } else if (! upper && ! lsame_(uplo, "L")) {
 	info = 2;
     } else if (*m < 0) {
 	info = 3;
@@ -283,14 +281,14 @@
 	info = 12;
     }
     if (info != 0) {
-	xerbla_("DSYMM ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DSYMM ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || *alpha == 0. && *beta == 1.) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -317,12 +315,12 @@
 /* L40: */
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
-    if (lsame_(side, "L", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(side, "L")) {
 
 /*        Form  C := alpha*A*B + beta*C. */
 
@@ -429,7 +427,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DSYMM . */
 
diff --git a/f2c_BLAS-3.8.0/dsymv.c b/f2c_BLAS-3.8.0/dsymv.c
index d3116c6..bbfe9b6 100644
--- a/f2c_BLAS-3.8.0/dsymv.c
+++ b/f2c_BLAS-3.8.0/dsymv.c
@@ -164,9 +164,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dsymv_(char *uplo, integer *n, doublereal *alpha, 
+/* Subroutine */ void dsymv_(char *uplo, integer *n, doublereal *alpha, 
 	doublereal *a, integer *lda, doublereal *x, integer *incx, doublereal 
-	*beta, doublereal *y, integer *incy, ftnlen uplo_len)
+	*beta, doublereal *y, integer *incy)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2;
@@ -174,8 +174,8 @@
     /* Local variables */
     integer i__, j, ix, iy, jx, jy, kx, ky, info;
     doublereal temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -212,8 +212,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -225,14 +224,14 @@
 	info = 10;
     }
     if (info != 0) {
-	xerbla_("DSYMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DSYMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || *alpha == 0. && *beta == 1.) {
-	return 0;
+	return;
     }
 
 /*     Set up the start points in  X  and  Y. */
@@ -289,9 +288,9 @@
 	}
     }
     if (*alpha == 0.) {
-	return 0;
+	return;
     }
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  y  when A is stored in upper triangle. */
 
@@ -377,7 +376,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DSYMV . */
 
diff --git a/f2c_BLAS-3.8.0/dsyr.c b/f2c_BLAS-3.8.0/dsyr.c
index 9edc006..8e2c254 100644
--- a/f2c_BLAS-3.8.0/dsyr.c
+++ b/f2c_BLAS-3.8.0/dsyr.c
@@ -144,9 +144,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dsyr_(char *uplo, integer *n, doublereal *alpha, 
-	doublereal *x, integer *incx, doublereal *a, integer *lda, ftnlen 
-	uplo_len)
+/* Subroutine */ void dsyr_(char *uplo, integer *n, doublereal *alpha, 
+	doublereal *x, integer *incx, doublereal *a, integer *lda)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2;
@@ -154,8 +153,8 @@
     /* Local variables */
     integer i__, j, ix, jx, kx, info;
     doublereal temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -191,8 +190,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -202,14 +200,14 @@
 	info = 7;
     }
     if (info != 0) {
-	xerbla_("DSYR  ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DSYR  ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || *alpha == 0.) {
-	return 0;
+	return;
     }
 
 /*     Set the start point in X if the increment is not unity. */
@@ -224,7 +222,7 @@
 /*     accessed sequentially with one pass through the triangular part */
 /*     of A. */
 
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  A  when A is stored in upper triangle. */
 
@@ -296,7 +294,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DSYR  . */
 
diff --git a/f2c_BLAS-3.8.0/dsyr2.c b/f2c_BLAS-3.8.0/dsyr2.c
index b61efb4..d99706c 100644
--- a/f2c_BLAS-3.8.0/dsyr2.c
+++ b/f2c_BLAS-3.8.0/dsyr2.c
@@ -159,9 +159,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dsyr2_(char *uplo, integer *n, doublereal *alpha, 
+/* Subroutine */ void dsyr2_(char *uplo, integer *n, doublereal *alpha, 
 	doublereal *x, integer *incx, doublereal *y, integer *incy, 
-	doublereal *a, integer *lda, ftnlen uplo_len)
+	doublereal *a, integer *lda)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2;
@@ -169,8 +169,8 @@
     /* Local variables */
     integer i__, j, ix, iy, jx, jy, kx, ky, info;
     doublereal temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -207,8 +207,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -220,14 +219,14 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("DSYR2 ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DSYR2 ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || *alpha == 0.) {
-	return 0;
+	return;
     }
 
 /*     Set up the start points in X and Y if the increments are not both */
@@ -252,7 +251,7 @@
 /*     accessed sequentially with one pass through the triangular part */
 /*     of A. */
 
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  A  when A is stored in the upper triangle. */
 
@@ -336,7 +335,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DSYR2 . */
 
diff --git a/f2c_BLAS-3.8.0/dsyr2k.c b/f2c_BLAS-3.8.0/dsyr2k.c
index de178b5..1459721 100644
--- a/f2c_BLAS-3.8.0/dsyr2k.c
+++ b/f2c_BLAS-3.8.0/dsyr2k.c
@@ -204,10 +204,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dsyr2k_(char *uplo, char *trans, integer *n, integer *k, 
+/* Subroutine */ void dsyr2k_(char *uplo, char *trans, integer *n, integer *k, 
 	doublereal *alpha, doublereal *a, integer *lda, doublereal *b, 
-	integer *ldb, doublereal *beta, doublereal *c__, integer *ldc, ftnlen 
-	uplo_len, ftnlen trans_len)
+	integer *ldb, doublereal *beta, doublereal *c__, integer *ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, 
@@ -216,10 +215,10 @@
     /* Local variables */
     integer i__, j, l, info;
     doublereal temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -259,19 +258,17 @@
     c__ -= c_offset;
 
     /* Function Body */
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 	nrowa = *n;
     } else {
 	nrowa = *k;
     }
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    upper = lsame_(uplo, "U");
 
     info = 0;
-    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    if (! upper && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
     } else if (*n < 0) {
 	info = 3;
@@ -285,14 +282,14 @@
 	info = 12;
     }
     if (info != 0) {
-	xerbla_("DSYR2K", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DSYR2K", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || (*alpha == 0. || *k == 0) && *beta == 1.) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -343,12 +340,12 @@
 		}
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  C := alpha*A*B**T + alpha*B*A**T + C. */
 
@@ -474,7 +471,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DSYR2K. */
 
diff --git a/f2c_BLAS-3.8.0/dsyrk.c b/f2c_BLAS-3.8.0/dsyrk.c
index f737902..4d761d9 100644
--- a/f2c_BLAS-3.8.0/dsyrk.c
+++ b/f2c_BLAS-3.8.0/dsyrk.c
@@ -181,9 +181,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dsyrk_(char *uplo, char *trans, integer *n, integer *k, 
+/* Subroutine */ void dsyrk_(char *uplo, char *trans, integer *n, integer *k, 
 	doublereal *alpha, doublereal *a, integer *lda, doublereal *beta, 
-	doublereal *c__, integer *ldc, ftnlen uplo_len, ftnlen trans_len)
+	doublereal *c__, integer *ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3;
@@ -191,10 +191,10 @@
     /* Local variables */
     integer i__, j, l, info;
     doublereal temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -231,19 +231,17 @@
     c__ -= c_offset;
 
     /* Function Body */
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 	nrowa = *n;
     } else {
 	nrowa = *k;
     }
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    upper = lsame_(uplo, "U");
 
     info = 0;
-    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    if (! upper && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
     } else if (*n < 0) {
 	info = 3;
@@ -255,14 +253,14 @@
 	info = 10;
     }
     if (info != 0) {
-	xerbla_("DSYRK ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DSYRK ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || (*alpha == 0. || *k == 0) && *beta == 1.) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -313,12 +311,12 @@
 		}
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  C := alpha*A*A**T + beta*C. */
 
@@ -434,7 +432,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DSYRK . */
 
diff --git a/f2c_BLAS-3.8.0/dtbmv.c b/f2c_BLAS-3.8.0/dtbmv.c
index 6639ad2..55c435d 100644
--- a/f2c_BLAS-3.8.0/dtbmv.c
+++ b/f2c_BLAS-3.8.0/dtbmv.c
@@ -198,9 +198,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dtbmv_(char *uplo, char *trans, char *diag, integer *n, 
-	integer *k, doublereal *a, integer *lda, doublereal *x, integer *incx,
-	 ftnlen uplo_len, ftnlen trans_len, ftnlen diag_len)
+/* Subroutine */ void dtbmv_(char *uplo, char *trans, char *diag, integer *n, 
+	integer *k, doublereal *a, integer *lda, doublereal *x, integer *incx)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
@@ -208,9 +207,9 @@
     /* Local variables */
     integer i__, j, l, ix, jx, kx, info;
     doublereal temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer kplus1;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nounit;
 
 
@@ -247,15 +246,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -267,17 +262,17 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("DTBMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DTBMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX   too small for descending loops. */
@@ -291,11 +286,11 @@
 /*     Start the operations. In this version the elements of A are */
 /*     accessed sequentially with one pass through A. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*         Form  x := A*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kplus1 = *k + 1;
 	    if (*incx == 1) {
 		i__1 = *n;
@@ -394,7 +389,7 @@
 
 /*        Form  x := A**T*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kplus1 = *k + 1;
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
@@ -483,7 +478,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DTBMV . */
 
diff --git a/f2c_BLAS-3.8.0/dtbsv.c b/f2c_BLAS-3.8.0/dtbsv.c
index 8f7979d..5df58b5 100644
--- a/f2c_BLAS-3.8.0/dtbsv.c
+++ b/f2c_BLAS-3.8.0/dtbsv.c
@@ -201,9 +201,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dtbsv_(char *uplo, char *trans, char *diag, integer *n, 
-	integer *k, doublereal *a, integer *lda, doublereal *x, integer *incx,
-	 ftnlen uplo_len, ftnlen trans_len, ftnlen diag_len)
+/* Subroutine */ void dtbsv_(char *uplo, char *trans, char *diag, integer *n, 
+	integer *k, doublereal *a, integer *lda, doublereal *x, integer *incx)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
@@ -211,9 +210,9 @@
     /* Local variables */
     integer i__, j, l, ix, jx, kx, info;
     doublereal temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer kplus1;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nounit;
 
 
@@ -250,15 +249,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -270,17 +265,17 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("DTBSV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DTBSV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX  too small for descending loops. */
@@ -294,11 +289,11 @@
 /*     Start the operations. In this version the elements of A are */
 /*     accessed by sequentially with one pass through A. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  x := inv( A )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kplus1 = *k + 1;
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
@@ -393,7 +388,7 @@
 
 /*        Form  x := inv( A**T)*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kplus1 = *k + 1;
 	    if (*incx == 1) {
 		i__1 = *n;
@@ -486,7 +481,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DTBSV . */
 
diff --git a/f2c_BLAS-3.8.0/dtpmv.c b/f2c_BLAS-3.8.0/dtpmv.c
index 5db2f07..8d2d24a 100644
--- a/f2c_BLAS-3.8.0/dtpmv.c
+++ b/f2c_BLAS-3.8.0/dtpmv.c
@@ -154,9 +154,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dtpmv_(char *uplo, char *trans, char *diag, integer *n, 
-	doublereal *ap, doublereal *x, integer *incx, ftnlen uplo_len, ftnlen 
-	trans_len, ftnlen diag_len)
+/* Subroutine */ void dtpmv_(char *uplo, char *trans, char *diag, integer *n, 
+	doublereal *ap, doublereal *x, integer *incx)
 {
     /* System generated locals */
     integer i__1, i__2;
@@ -164,8 +163,8 @@
     /* Local variables */
     integer i__, j, k, kk, ix, jx, kx, info;
     doublereal temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nounit;
 
 
@@ -198,15 +197,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -214,17 +209,17 @@
 	info = 7;
     }
     if (info != 0) {
-	xerbla_("DTPMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DTPMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX  too small for descending loops. */
@@ -238,11 +233,11 @@
 /*     Start the operations. In this version the elements of AP are */
 /*     accessed sequentially with one pass through AP. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  x:= A*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kk = 1;
 	    if (*incx == 1) {
 		i__1 = *n;
@@ -332,7 +327,7 @@
 
 /*        Form  x := A**T*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kk = *n * (*n + 1) / 2;
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
@@ -414,7 +409,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DTPMV . */
 
diff --git a/f2c_BLAS-3.8.0/dtpsv.c b/f2c_BLAS-3.8.0/dtpsv.c
index 46cf8f0..3b7fc42 100644
--- a/f2c_BLAS-3.8.0/dtpsv.c
+++ b/f2c_BLAS-3.8.0/dtpsv.c
@@ -156,9 +156,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dtpsv_(char *uplo, char *trans, char *diag, integer *n, 
-	doublereal *ap, doublereal *x, integer *incx, ftnlen uplo_len, ftnlen 
-	trans_len, ftnlen diag_len)
+/* Subroutine */ void dtpsv_(char *uplo, char *trans, char *diag, integer *n, 
+	doublereal *ap, doublereal *x, integer *incx)
 {
     /* System generated locals */
     integer i__1, i__2;
@@ -166,8 +165,8 @@
     /* Local variables */
     integer i__, j, k, kk, ix, jx, kx, info;
     doublereal temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nounit;
 
 
@@ -200,15 +199,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -216,17 +211,17 @@
 	info = 7;
     }
     if (info != 0) {
-	xerbla_("DTPSV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DTPSV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX  too small for descending loops. */
@@ -240,11 +235,11 @@
 /*     Start the operations. In this version the elements of AP are */
 /*     accessed sequentially with one pass through AP. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  x := inv( A )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kk = *n * (*n + 1) / 2;
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
@@ -332,7 +327,7 @@
 
 /*        Form  x := inv( A**T )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kk = 1;
 	    if (*incx == 1) {
 		i__1 = *n;
@@ -416,7 +411,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DTPSV . */
 
diff --git a/f2c_BLAS-3.8.0/dtrmm.c b/f2c_BLAS-3.8.0/dtrmm.c
index c1924c6..51c694c 100644
--- a/f2c_BLAS-3.8.0/dtrmm.c
+++ b/f2c_BLAS-3.8.0/dtrmm.c
@@ -189,10 +189,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dtrmm_(char *side, char *uplo, char *transa, char *diag, 
+/* Subroutine */ void dtrmm_(char *side, char *uplo, char *transa, char *diag, 
 	integer *m, integer *n, doublereal *alpha, doublereal *a, integer *
-	lda, doublereal *b, integer *ldb, ftnlen side_len, ftnlen uplo_len, 
-	ftnlen transa_len, ftnlen diag_len)
+	lda, doublereal *b, integer *ldb)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3;
@@ -201,10 +200,10 @@
     integer i__, j, k, info;
     doublereal temp;
     logical lside;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nounit;
 
 
@@ -242,26 +241,23 @@
     b -= b_offset;
 
     /* Function Body */
-    lside = lsame_(side, "L", (ftnlen)1, (ftnlen)1);
+    lside = lsame_(side, "L");
     if (lside) {
 	nrowa = *m;
     } else {
 	nrowa = *n;
     }
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    nounit = lsame_(diag, "N");
+    upper = lsame_(uplo, "U");
 
     info = 0;
-    if (! lside && ! lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {
+    if (! lside && ! lsame_(side, "R")) {
 	info = 1;
-    } else if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    } else if (! upper && ! lsame_(uplo, "L")) {
 	info = 2;
-    } else if (! lsame_(transa, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(transa,
-	     "T", (ftnlen)1, (ftnlen)1) && ! lsame_(transa, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(transa, "N") && ! lsame_(transa, "T") && ! lsame_(transa, "C")) {
 	info = 3;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 4;
     } else if (*m < 0) {
 	info = 5;
@@ -273,14 +269,14 @@
 	info = 11;
     }
     if (info != 0) {
-	xerbla_("DTRMM ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DTRMM ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -295,13 +291,13 @@
 	    }
 /* L20: */
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
     if (lside) {
-	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(transa, "N")) {
 
 /*           Form  B := alpha*A*B. */
 
@@ -393,7 +389,7 @@
 	    }
 	}
     } else {
-	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(transa, "N")) {
 
 /*           Form  B := alpha*B*A. */
 
@@ -516,7 +512,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DTRMM . */
 
diff --git a/f2c_BLAS-3.8.0/dtrmv.c b/f2c_BLAS-3.8.0/dtrmv.c
index c0c78aa..cee7091 100644
--- a/f2c_BLAS-3.8.0/dtrmv.c
+++ b/f2c_BLAS-3.8.0/dtrmv.c
@@ -159,9 +159,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dtrmv_(char *uplo, char *trans, char *diag, integer *n, 
-	doublereal *a, integer *lda, doublereal *x, integer *incx, ftnlen 
-	uplo_len, ftnlen trans_len, ftnlen diag_len)
+/* Subroutine */ void dtrmv_(char *uplo, char *trans, char *diag, integer *n, 
+	doublereal *a, integer *lda, doublereal *x, integer *incx)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2;
@@ -169,8 +168,8 @@
     /* Local variables */
     integer i__, j, ix, jx, kx, info;
     doublereal temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nounit;
 
 
@@ -207,15 +206,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -225,17 +220,17 @@
 	info = 8;
     }
     if (info != 0) {
-	xerbla_("DTRMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DTRMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX  too small for descending loops. */
@@ -249,11 +244,11 @@
 /*     Start the operations. In this version the elements of A are */
 /*     accessed sequentially with one pass through A. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  x := A*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    if (*incx == 1) {
 		i__1 = *n;
 		for (j = 1; j <= i__1; ++j) {
@@ -333,7 +328,7 @@
 
 /*        Form  x := A**T*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
 		    temp = x[j];
@@ -404,7 +399,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DTRMV . */
 
diff --git a/f2c_BLAS-3.8.0/dtrsm.c b/f2c_BLAS-3.8.0/dtrsm.c
index 2cef671..c688985 100644
--- a/f2c_BLAS-3.8.0/dtrsm.c
+++ b/f2c_BLAS-3.8.0/dtrsm.c
@@ -193,10 +193,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int dtrsm_(char *side, char *uplo, char *transa, char *diag, 
+/* Subroutine */ void dtrsm_(char *side, char *uplo, char *transa, char *diag, 
 	integer *m, integer *n, doublereal *alpha, doublereal *a, integer *
-	lda, doublereal *b, integer *ldb, ftnlen side_len, ftnlen uplo_len, 
-	ftnlen transa_len, ftnlen diag_len)
+	lda, doublereal *b, integer *ldb)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3;
@@ -205,10 +204,10 @@
     integer i__, j, k, info;
     doublereal temp;
     logical lside;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nounit;
 
 
@@ -246,26 +245,23 @@
     b -= b_offset;
 
     /* Function Body */
-    lside = lsame_(side, "L", (ftnlen)1, (ftnlen)1);
+    lside = lsame_(side, "L");
     if (lside) {
 	nrowa = *m;
     } else {
 	nrowa = *n;
     }
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    nounit = lsame_(diag, "N");
+    upper = lsame_(uplo, "U");
 
     info = 0;
-    if (! lside && ! lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {
+    if (! lside && ! lsame_(side, "R")) {
 	info = 1;
-    } else if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    } else if (! upper && ! lsame_(uplo, "L")) {
 	info = 2;
-    } else if (! lsame_(transa, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(transa,
-	     "T", (ftnlen)1, (ftnlen)1) && ! lsame_(transa, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(transa, "N") && ! lsame_(transa, "T") && ! lsame_(transa, "C")) {
 	info = 3;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 4;
     } else if (*m < 0) {
 	info = 5;
@@ -277,14 +273,14 @@
 	info = 11;
     }
     if (info != 0) {
-	xerbla_("DTRSM ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DTRSM ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -299,13 +295,13 @@
 	    }
 /* L20: */
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
     if (lside) {
-	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(transa, "N")) {
 
 /*           Form  B := alpha*inv( A )*B. */
 
@@ -409,7 +405,7 @@
 	    }
 	}
     } else {
-	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(transa, "N")) {
 
 /*           Form  B := alpha*B*inv( A ). */
 
@@ -554,7 +550,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DTRSM . */
 
diff --git a/f2c_BLAS-3.8.0/dtrsv.c b/f2c_BLAS-3.8.0/dtrsv.c
index 6daf590..9fa5c14 100644
--- a/f2c_BLAS-3.8.0/dtrsv.c
+++ b/f2c_BLAS-3.8.0/dtrsv.c
@@ -155,9 +155,8 @@
 /* > \ingroup double_blas_level1 */
 
 /*  ===================================================================== */
-/* Subroutine */ int dtrsv_(char *uplo, char *trans, char *diag, integer *n, 
-	doublereal *a, integer *lda, doublereal *x, integer *incx, ftnlen 
-	uplo_len, ftnlen trans_len, ftnlen diag_len)
+/* Subroutine */ void dtrsv_(char *uplo, char *trans, char *diag, integer *n, 
+	doublereal *a, integer *lda, doublereal *x, integer *incx)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2;
@@ -165,8 +164,8 @@
     /* Local variables */
     integer i__, j, ix, jx, kx, info;
     doublereal temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nounit;
 
 
@@ -203,15 +202,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -221,17 +216,17 @@
 	info = 8;
     }
     if (info != 0) {
-	xerbla_("DTRSV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("DTRSV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX  too small for descending loops. */
@@ -245,11 +240,11 @@
 /*     Start the operations. In this version the elements of A are */
 /*     accessed sequentially with one pass through A. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  x := inv( A )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
 		    if (x[j] != 0.) {
@@ -326,7 +321,7 @@
 
 /*        Form  x := inv( A**T )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    if (*incx == 1) {
 		i__1 = *n;
 		for (j = 1; j <= i__1; ++j) {
@@ -400,7 +395,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of DTRSV . */
 
diff --git a/f2c_BLAS-3.8.0/lsame.c b/f2c_BLAS-3.8.0/lsame.c
index ea2503c..f390c30 100644
--- a/f2c_BLAS-3.8.0/lsame.c
+++ b/f2c_BLAS-3.8.0/lsame.c
@@ -65,7 +65,7 @@
 /* > \ingroup aux_blas */
 
 /*  ===================================================================== */
-logical lsame_(char *ca, char *cb, ftnlen ca_len, ftnlen cb_len)
+logical lsame_(char *ca, char *cb)
 {
     /* System generated locals */
     logical ret_val;
diff --git a/f2c_BLAS-3.8.0/make.inc.WASM b/f2c_BLAS-3.8.0/make.inc
similarity index 100%
rename from f2c_BLAS-3.8.0/make.inc.WASM
rename to f2c_BLAS-3.8.0/make.inc
diff --git a/f2c_BLAS-3.8.0/saxpy.c b/f2c_BLAS-3.8.0/saxpy.c
index 9495d08..43e22a7 100644
--- a/f2c_BLAS-3.8.0/saxpy.c
+++ b/f2c_BLAS-3.8.0/saxpy.c
@@ -101,7 +101,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int saxpy_(integer *n, real *sa, real *sx, integer *incx, 
+/* Subroutine */ void saxpy_(integer *n, real *sa, real *sx, integer *incx, 
 	real *sy, integer *incy)
 {
     /* System generated locals */
@@ -133,10 +133,10 @@
 
     /* Function Body */
     if (*n <= 0) {
-	return 0;
+	return;
     }
     if (*sa == 0.f) {
-	return 0;
+	return;
     }
     if (*incx == 1 && *incy == 1) {
 
@@ -153,7 +153,7 @@
 	    }
 	}
 	if (*n < 4) {
-	    return 0;
+	    return;
 	}
 	mp1 = m + 1;
 	i__1 = *n;
@@ -183,6 +183,6 @@
 	    iy += *incy;
 	}
     }
-    return 0;
+    return;
 } /* saxpy_ */
 
diff --git a/f2c_BLAS-3.8.0/scopy.c b/f2c_BLAS-3.8.0/scopy.c
index e67e262..c4fffad 100644
--- a/f2c_BLAS-3.8.0/scopy.c
+++ b/f2c_BLAS-3.8.0/scopy.c
@@ -94,7 +94,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int scopy_(integer *n, real *sx, integer *incx, real *sy, 
+/* Subroutine */ void scopy_(integer *n, real *sx, integer *incx, real *sy, 
 	integer *incy)
 {
     /* System generated locals */
@@ -126,7 +126,7 @@
 
     /* Function Body */
     if (*n <= 0) {
-	return 0;
+	return;
     }
     if (*incx == 1 && *incy == 1) {
 
@@ -142,7 +142,7 @@
 		sy[i__] = sx[i__];
 	    }
 	    if (*n < 7) {
-		return 0;
+		return;
 	    }
 	}
 	mp1 = m + 1;
@@ -176,6 +176,6 @@
 	    iy += *incy;
 	}
     }
-    return 0;
+    return;
 } /* scopy_ */
 
diff --git a/f2c_BLAS-3.8.0/sgbmv.c b/f2c_BLAS-3.8.0/sgbmv.c
index fbe0f1f..4a9cd28 100644
--- a/f2c_BLAS-3.8.0/sgbmv.c
+++ b/f2c_BLAS-3.8.0/sgbmv.c
@@ -197,9 +197,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int sgbmv_(char *trans, integer *m, integer *n, integer *kl, 
+/* Subroutine */ void sgbmv_(char *trans, integer *m, integer *n, integer *kl, 
 	integer *ku, real *alpha, real *a, integer *lda, real *x, integer *
-	incx, real *beta, real *y, integer *incy, ftnlen trans_len)
+	incx, real *beta, real *y, integer *incy)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;
@@ -208,8 +208,8 @@
     integer i__, j, k, ix, iy, jx, jy, kx, ky, kup1, info;
     real temp;
     integer lenx, leny;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -246,8 +246,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "T", (
-	    ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (ftnlen)1)
+    if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")
 	    ) {
 	info = 1;
     } else if (*m < 0) {
@@ -266,20 +265,20 @@
 	info = 13;
     }
     if (info != 0) {
-	xerbla_("SGBMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("SGBMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || *alpha == 0.f && *beta == 1.f) {
-	return 0;
+	return;
     }
 
 /*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set */
 /*     up the start points in  X  and  Y. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 	lenx = *n;
 	leny = *m;
     } else {
@@ -337,10 +336,10 @@
 	}
     }
     if (*alpha == 0.f) {
-	return 0;
+	return;
     }
     kup1 = *ku + 1;
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  y := alpha*A*x + y. */
 
@@ -434,7 +433,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of SGBMV . */
 
diff --git a/f2c_BLAS-3.8.0/sgemm.c b/f2c_BLAS-3.8.0/sgemm.c
index d279f5b..4c4021a 100644
--- a/f2c_BLAS-3.8.0/sgemm.c
+++ b/f2c_BLAS-3.8.0/sgemm.c
@@ -199,10 +199,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int sgemm_(char *transa, char *transb, integer *m, integer *
+/* Subroutine */ void sgemm_(char *transa, char *transb, integer *m, integer *
 	n, integer *k, real *alpha, real *a, integer *lda, real *b, integer *
-	ldb, real *beta, real *c__, integer *ldc, ftnlen transa_len, ftnlen 
-	transb_len)
+	ldb, real *beta, real *c__, integer *ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, 
@@ -213,9 +212,9 @@
     logical nota, notb;
     real temp;
     integer ncola;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa, nrowb;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -257,8 +256,8 @@
     c__ -= c_offset;
 
     /* Function Body */
-    nota = lsame_(transa, "N", (ftnlen)1, (ftnlen)1);
-    notb = lsame_(transb, "N", (ftnlen)1, (ftnlen)1);
+    nota = lsame_(transa, "N");
+    notb = lsame_(transb, "N");
     if (nota) {
 	nrowa = *m;
 	ncola = *k;
@@ -275,11 +274,10 @@
 /*     Test the input parameters. */
 
     info = 0;
-    if (! nota && ! lsame_(transa, "C", (ftnlen)1, (ftnlen)1) && ! lsame_(
-	    transa, "T", (ftnlen)1, (ftnlen)1)) {
+    if (! nota && ! lsame_(transa, "C") && ! lsame_( transa, "T")) {
 	info = 1;
-    } else if (! notb && ! lsame_(transb, "C", (ftnlen)1, (ftnlen)1) && ! 
-	    lsame_(transb, "T", (ftnlen)1, (ftnlen)1)) {
+    } else if (! notb && ! lsame_(transb, "C") && ! 
+	    lsame_(transb, "T")) {
 	info = 2;
     } else if (*m < 0) {
 	info = 3;
@@ -295,14 +293,14 @@
 	info = 13;
     }
     if (info != 0) {
-	xerbla_("SGEMM ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("SGEMM ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || (*alpha == 0.f || *k == 0) && *beta == 1.f) {
-	return 0;
+	return;
     }
 
 /*     And if  alpha.eq.zero. */
@@ -329,7 +327,7 @@
 /* L40: */
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
@@ -450,7 +448,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of SGEMM . */
 
diff --git a/f2c_BLAS-3.8.0/sgemv.c b/f2c_BLAS-3.8.0/sgemv.c
index c2783de..ee86491 100644
--- a/f2c_BLAS-3.8.0/sgemv.c
+++ b/f2c_BLAS-3.8.0/sgemv.c
@@ -168,9 +168,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int sgemv_(char *trans, integer *m, integer *n, real *alpha, 
+/* Subroutine */ void sgemv_(char *trans, integer *m, integer *n, real *alpha, 
 	real *a, integer *lda, real *x, integer *incx, real *beta, real *y, 
-	integer *incy, ftnlen trans_len)
+	integer *incy)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2;
@@ -179,8 +179,8 @@
     integer i__, j, ix, iy, jx, jy, kx, ky, info;
     real temp;
     integer lenx, leny;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -217,8 +217,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "T", (
-	    ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (ftnlen)1)
+    if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")
 	    ) {
 	info = 1;
     } else if (*m < 0) {
@@ -233,20 +232,20 @@
 	info = 11;
     }
     if (info != 0) {
-	xerbla_("SGEMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("SGEMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || *alpha == 0.f && *beta == 1.f) {
-	return 0;
+	return;
     }
 
 /*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set */
 /*     up the start points in  X  and  Y. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 	lenx = *n;
 	leny = *m;
     } else {
@@ -304,9 +303,9 @@
 	}
     }
     if (*alpha == 0.f) {
-	return 0;
+	return;
     }
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  y := alpha*A*x + y. */
 
@@ -374,7 +373,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of SGEMV . */
 
diff --git a/f2c_BLAS-3.8.0/sger.c b/f2c_BLAS-3.8.0/sger.c
index 9bb4627..50ef06a 100644
--- a/f2c_BLAS-3.8.0/sger.c
+++ b/f2c_BLAS-3.8.0/sger.c
@@ -142,7 +142,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int sger_(integer *m, integer *n, real *alpha, real *x, 
+/* Subroutine */ void sger_(integer *m, integer *n, real *alpha, real *x, 
 	integer *incx, real *y, integer *incy, real *a, integer *lda)
 {
     /* System generated locals */
@@ -151,7 +151,7 @@
     /* Local variables */
     integer i__, j, ix, jy, kx, info;
     real temp;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -198,14 +198,14 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("SGER  ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("SGER  ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || *alpha == 0.f) {
-	return 0;
+	return;
     }
 
 /*     Start the operations. In this version the elements of A are */
@@ -253,7 +253,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of SGER  . */
 
diff --git a/f2c_BLAS-3.8.0/srot.c b/f2c_BLAS-3.8.0/srot.c
index 7bce271..dc7f7aa 100644
--- a/f2c_BLAS-3.8.0/srot.c
+++ b/f2c_BLAS-3.8.0/srot.c
@@ -104,7 +104,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int srot_(integer *n, real *sx, integer *incx, real *sy, 
+/* Subroutine */ void srot_(integer *n, real *sx, integer *incx, real *sy, 
 	integer *incy, real *c__, real *s)
 {
     /* System generated locals */
@@ -135,7 +135,7 @@
 
     /* Function Body */
     if (*n <= 0) {
-	return 0;
+	return;
     }
     if (*incx == 1 && *incy == 1) {
 
@@ -169,6 +169,6 @@
 	    iy += *incy;
 	}
     }
-    return 0;
+    return;
 } /* srot_ */
 
diff --git a/f2c_BLAS-3.8.0/srotg.c b/f2c_BLAS-3.8.0/srotg.c
index b009c44..a178f3f 100644
--- a/f2c_BLAS-3.8.0/srotg.c
+++ b/f2c_BLAS-3.8.0/srotg.c
@@ -85,7 +85,7 @@ static real c_b2 = 1.f;
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int srotg_(real *sa, real *sb, real *c__, real *s)
+/* Subroutine */ void srotg_(real *sa, real *sb, real *c__, real *s)
 {
     /* System generated locals */
     real r__1, r__2;
@@ -140,6 +140,6 @@ static real c_b2 = 1.f;
     }
     *sa = r__;
     *sb = z__;
-    return 0;
+    return;
 } /* srotg_ */
 
diff --git a/f2c_BLAS-3.8.0/srotm.c b/f2c_BLAS-3.8.0/srotm.c
index f396cc0..7fca581 100644
--- a/f2c_BLAS-3.8.0/srotm.c
+++ b/f2c_BLAS-3.8.0/srotm.c
@@ -109,7 +109,7 @@
 /* > \ingroup single_blas_level1 */
 
 /*  ===================================================================== */
-/* Subroutine */ int srotm_(integer *n, real *sx, integer *incx, real *sy, 
+/* Subroutine */ void srotm_(integer *n, real *sx, integer *incx, real *sy, 
 	integer *incy, real *sparam)
 {
     /* Initialized data */
@@ -153,7 +153,7 @@
 
     sflag = sparam[1];
     if (*n <= 0 || sflag + two == zero) {
-	return 0;
+	return;
     }
     if (*incx == *incy && *incx > 0) {
 
@@ -244,6 +244,6 @@
 	    }
 	}
     }
-    return 0;
+    return;
 } /* srotm_ */
 
diff --git a/f2c_BLAS-3.8.0/srotmg.c b/f2c_BLAS-3.8.0/srotmg.c
index 8793695..2f39402 100644
--- a/f2c_BLAS-3.8.0/srotmg.c
+++ b/f2c_BLAS-3.8.0/srotmg.c
@@ -102,7 +102,7 @@
 /* > \ingroup single_blas_level1 */
 
 /*  ===================================================================== */
-/* Subroutine */ int srotmg_(real *sd1, real *sd2, real *sx1, real *sy1, real 
+/* Subroutine */ void srotmg_(real *sd1, real *sd2, real *sx1, real *sy1, real 
 	*sparam)
 {
     /* Initialized data */
@@ -161,7 +161,7 @@
 	if (sp2 == zero) {
 	    sflag = -two;
 	    sparam[1] = sflag;
-	    return 0;
+	    return;
 	}
 /*        REGULAR-CASE.. */
 	sp1 = *sd1 * *sx1;
@@ -272,6 +272,6 @@
 	sparam[5] = sh22;
     }
     sparam[1] = sflag;
-    return 0;
+    return;
 } /* srotmg_ */
 
diff --git a/f2c_BLAS-3.8.0/ssbmv.c b/f2c_BLAS-3.8.0/ssbmv.c
index f8c0e43..dc8ce5b 100644
--- a/f2c_BLAS-3.8.0/ssbmv.c
+++ b/f2c_BLAS-3.8.0/ssbmv.c
@@ -196,9 +196,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ssbmv_(char *uplo, integer *n, integer *k, real *alpha, 
+/* Subroutine */ void ssbmv_(char *uplo, integer *n, integer *k, real *alpha, 
 	real *a, integer *lda, real *x, integer *incx, real *beta, real *y, 
-	integer *incy, ftnlen uplo_len)
+	integer *incy)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
@@ -206,9 +206,9 @@
     /* Local variables */
     integer i__, j, l, ix, iy, jx, jy, kx, ky, info;
     real temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer kplus1;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -245,8 +245,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -260,14 +259,14 @@
 	info = 11;
     }
     if (info != 0) {
-	xerbla_("SSBMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("SSBMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || *alpha == 0.f && *beta == 1.f) {
-	return 0;
+	return;
     }
 
 /*     Set up the start points in  X  and  Y. */
@@ -323,9 +322,9 @@
 	}
     }
     if (*alpha == 0.f) {
-	return 0;
+	return;
     }
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  y  when upper triangle of A is stored. */
 
@@ -429,7 +428,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of SSBMV . */
 
diff --git a/f2c_BLAS-3.8.0/sscal.c b/f2c_BLAS-3.8.0/sscal.c
index b58447a..5c88ae9 100644
--- a/f2c_BLAS-3.8.0/sscal.c
+++ b/f2c_BLAS-3.8.0/sscal.c
@@ -91,7 +91,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int sscal_(integer *n, real *sa, real *sx, integer *incx)
+/* Subroutine */ void sscal_(integer *n, real *sa, real *sx, integer *incx)
 {
     /* System generated locals */
     integer i__1, i__2;
@@ -121,7 +121,7 @@
 
     /* Function Body */
     if (*n <= 0 || *incx <= 0) {
-	return 0;
+	return;
     }
     if (*incx == 1) {
 
@@ -137,7 +137,7 @@
 		sx[i__] = *sa * sx[i__];
 	    }
 	    if (*n < 5) {
-		return 0;
+		return;
 	    }
 	}
 	mp1 = m + 1;
@@ -160,6 +160,6 @@
 	    sx[i__] = *sa * sx[i__];
 	}
     }
-    return 0;
+    return;
 } /* sscal_ */
 
diff --git a/f2c_BLAS-3.8.0/sspmv.c b/f2c_BLAS-3.8.0/sspmv.c
index f206f0e..a76d17e 100644
--- a/f2c_BLAS-3.8.0/sspmv.c
+++ b/f2c_BLAS-3.8.0/sspmv.c
@@ -159,9 +159,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int sspmv_(char *uplo, integer *n, real *alpha, real *ap, 
-	real *x, integer *incx, real *beta, real *y, integer *incy, ftnlen 
-	uplo_len)
+/* Subroutine */ void sspmv_(char *uplo, integer *n, real *alpha, real *ap, 
+	real *x, integer *incx, real *beta, real *y, integer *incy)
 {
     /* System generated locals */
     integer i__1, i__2;
@@ -169,8 +168,8 @@
     /* Local variables */
     integer i__, j, k, kk, ix, iy, jx, jy, kx, ky, info;
     real temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -203,8 +202,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -214,14 +212,14 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("SSPMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("SSPMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || *alpha == 0.f && *beta == 1.f) {
-	return 0;
+	return;
     }
 
 /*     Set up the start points in  X  and  Y. */
@@ -277,10 +275,10 @@
 	}
     }
     if (*alpha == 0.f) {
-	return 0;
+	return;
     }
     kk = 1;
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  y  when AP contains the upper triangle. */
 
@@ -374,7 +372,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of SSPMV . */
 
diff --git a/f2c_BLAS-3.8.0/sspr.c b/f2c_BLAS-3.8.0/sspr.c
index df0169d..77cee48 100644
--- a/f2c_BLAS-3.8.0/sspr.c
+++ b/f2c_BLAS-3.8.0/sspr.c
@@ -139,8 +139,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int sspr_(char *uplo, integer *n, real *alpha, real *x, 
-	integer *incx, real *ap, ftnlen uplo_len)
+/* Subroutine */ void sspr_(char *uplo, integer *n, real *alpha, real *x, 
+	integer *incx, real *ap)
 {
     /* System generated locals */
     integer i__1, i__2;
@@ -148,8 +148,8 @@
     /* Local variables */
     integer i__, j, k, kk, ix, jx, kx, info;
     real temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -181,8 +181,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -190,14 +189,14 @@
 	info = 5;
     }
     if (info != 0) {
-	xerbla_("SSPR  ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("SSPR  ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || *alpha == 0.f) {
-	return 0;
+	return;
     }
 
 /*     Set the start point in X if the increment is not unity. */
@@ -212,7 +211,7 @@
 /*     are accessed sequentially with one pass through AP. */
 
     kk = 1;
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  A  when upper triangle is stored in AP. */
 
@@ -292,7 +291,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of SSPR  . */
 
diff --git a/f2c_BLAS-3.8.0/sspr2.c b/f2c_BLAS-3.8.0/sspr2.c
index 7293097..fac4295 100644
--- a/f2c_BLAS-3.8.0/sspr2.c
+++ b/f2c_BLAS-3.8.0/sspr2.c
@@ -1,13 +1,13 @@
 /* sspr2.f -- translated by f2c (version 20191129).
    You must link the resulting object file with libf2c:
-	on Microsoft Windows system, link with libf2c.lib;
-	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
-	or, if you install libf2c.a in a standard place, with -lf2c -lm
-	-- in that order, at the end of the command line, as in
-		cc *.o -lf2c -lm
-	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
-
-		http://www.netlib.org/f2c/libf2c.zip
+        on Microsoft Windows system, link with libf2c.lib;
+        on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+        or, if you install libf2c.a in a standard place, with -lf2c -lm
+        -- in that order, at the end of the command line, as in
+                cc *.o -lf2c -lm
+        Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+                http://www.netlib.org/f2c/libf2c.zip
 */
 
 #include "f2c.h"
@@ -33,7 +33,6 @@
 /*       REAL AP(*),X(*),Y(*) */
 /*       .. */
 
-
 /* > \par Purpose: */
 /*  ============= */
 /* > */
@@ -154,183 +153,182 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int sspr2_(char *uplo, integer *n, real *alpha, real *x, 
-	integer *incx, real *y, integer *incy, real *ap, ftnlen uplo_len)
-{
-    /* System generated locals */
-    integer i__1, i__2;
-
-    /* Local variables */
-    integer i__, j, k, kk, ix, iy, jx, jy, kx, ky, info;
-    real temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
-
-
-/*  -- Reference BLAS level2 routine (version 3.7.0) -- */
-/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
-/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
-/*     December 2016 */
-
-/*     .. Scalar Arguments .. */
-/*     .. */
-/*     .. Array Arguments .. */
-/*     .. */
-
-/*  ===================================================================== */
-
-/*     .. Parameters .. */
-/*     .. */
-/*     .. Local Scalars .. */
-/*     .. */
-/*     .. External Functions .. */
-/*     .. */
-/*     .. External Subroutines .. */
-/*     .. */
-
-/*     Test the input parameters. */
-
-    /* Parameter adjustments */
-    --ap;
-    --y;
-    --x;
-
-    /* Function Body */
-    info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
-	info = 1;
-    } else if (*n < 0) {
-	info = 2;
-    } else if (*incx == 0) {
-	info = 5;
-    } else if (*incy == 0) {
-	info = 7;
-    }
-    if (info != 0) {
-	xerbla_("SSPR2 ", &info, (ftnlen)6);
-	return 0;
+/* Subroutine */ void sspr2_(char *uplo, integer *n, real *alpha, real *x,
+                             integer *incx, real *y, integer *incy, real *ap) {
+  /* System generated locals */
+  integer i__1, i__2;
+
+  /* Local variables */
+  integer i__, j, k, kk, ix, iy, jx, jy, kx, ky, info;
+  real temp1, temp2;
+  extern  logical lsame_(char *, char *);
+  extern /* Subroutine */ void xerbla_(char *, integer *);
+
+  /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
+  /*  -- Reference BLAS is a software package provided by Univ. of Tennessee,
+   * -- */
+  /*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+   */
+  /*     December 2016 */
+
+  /*     .. Scalar Arguments .. */
+  /*     .. */
+  /*     .. Array Arguments .. */
+  /*     .. */
+
+  /*  ===================================================================== */
+
+  /*     .. Parameters .. */
+  /*     .. */
+  /*     .. Local Scalars .. */
+  /*     .. */
+  /*     .. External Functions .. */
+  /*     .. */
+  /*     .. External Subroutines .. */
+  /*     .. */
+
+  /*     Test the input parameters. */
+
+  /* Parameter adjustments */
+  --ap;
+  --y;
+  --x;
+
+  /* Function Body */
+  info = 0;
+  if (!lsame_(uplo, "U") &&
+      !lsame_(uplo, "L")) {
+    info = 1;
+  } else if (*n < 0) {
+    info = 2;
+  } else if (*incx == 0) {
+    info = 5;
+  } else if (*incy == 0) {
+    info = 7;
+  }
+  if (info != 0) {
+    xerbla_("SSPR2 ", &info);
+    return;
+  }
+
+  /*     Quick return if possible. */
+
+  if (*n == 0 || *alpha == 0.f) {
+    return;
+  }
+
+  /*     Set up the start points in X and Y if the increments are not both */
+  /*     unity. */
+
+  if (*incx != 1 || *incy != 1) {
+    if (*incx > 0) {
+      kx = 1;
+    } else {
+      kx = 1 - (*n - 1) * *incx;
     }
-
-/*     Quick return if possible. */
-
-    if (*n == 0 || *alpha == 0.f) {
-	return 0;
+    if (*incy > 0) {
+      ky = 1;
+    } else {
+      ky = 1 - (*n - 1) * *incy;
     }
-
-/*     Set up the start points in X and Y if the increments are not both */
-/*     unity. */
-
-    if (*incx != 1 || *incy != 1) {
-	if (*incx > 0) {
-	    kx = 1;
-	} else {
-	    kx = 1 - (*n - 1) * *incx;
-	}
-	if (*incy > 0) {
-	    ky = 1;
-	} else {
-	    ky = 1 - (*n - 1) * *incy;
-	}
-	jx = kx;
-	jy = ky;
+    jx = kx;
+    jy = ky;
+  }
+
+  /*     Start the operations. In this version the elements of the array AP */
+  /*     are accessed sequentially with one pass through AP. */
+
+  kk = 1;
+  if (lsame_(uplo, "U")) {
+
+    /*        Form  A  when upper triangle is stored in AP. */
+
+    if (*incx == 1 && *incy == 1) {
+      i__1 = *n;
+      for (j = 1; j <= i__1; ++j) {
+        if (x[j] != 0.f || y[j] != 0.f) {
+          temp1 = *alpha * y[j];
+          temp2 = *alpha * x[j];
+          k = kk;
+          i__2 = j;
+          for (i__ = 1; i__ <= i__2; ++i__) {
+            ap[k] = ap[k] + x[i__] * temp1 + y[i__] * temp2;
+            ++k;
+            /* L10: */
+          }
+        }
+        kk += j;
+        /* L20: */
+      }
+    } else {
+      i__1 = *n;
+      for (j = 1; j <= i__1; ++j) {
+        if (x[jx] != 0.f || y[jy] != 0.f) {
+          temp1 = *alpha * y[jy];
+          temp2 = *alpha * x[jx];
+          ix = kx;
+          iy = ky;
+          i__2 = kk + j - 1;
+          for (k = kk; k <= i__2; ++k) {
+            ap[k] = ap[k] + x[ix] * temp1 + y[iy] * temp2;
+            ix += *incx;
+            iy += *incy;
+            /* L30: */
+          }
+        }
+        jx += *incx;
+        jy += *incy;
+        kk += j;
+        /* L40: */
+      }
     }
-
-/*     Start the operations. In this version the elements of the array AP */
-/*     are accessed sequentially with one pass through AP. */
-
-    kk = 1;
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
-
-/*        Form  A  when upper triangle is stored in AP. */
-
-	if (*incx == 1 && *incy == 1) {
-	    i__1 = *n;
-	    for (j = 1; j <= i__1; ++j) {
-		if (x[j] != 0.f || y[j] != 0.f) {
-		    temp1 = *alpha * y[j];
-		    temp2 = *alpha * x[j];
-		    k = kk;
-		    i__2 = j;
-		    for (i__ = 1; i__ <= i__2; ++i__) {
-			ap[k] = ap[k] + x[i__] * temp1 + y[i__] * temp2;
-			++k;
-/* L10: */
-		    }
-		}
-		kk += j;
-/* L20: */
-	    }
-	} else {
-	    i__1 = *n;
-	    for (j = 1; j <= i__1; ++j) {
-		if (x[jx] != 0.f || y[jy] != 0.f) {
-		    temp1 = *alpha * y[jy];
-		    temp2 = *alpha * x[jx];
-		    ix = kx;
-		    iy = ky;
-		    i__2 = kk + j - 1;
-		    for (k = kk; k <= i__2; ++k) {
-			ap[k] = ap[k] + x[ix] * temp1 + y[iy] * temp2;
-			ix += *incx;
-			iy += *incy;
-/* L30: */
-		    }
-		}
-		jx += *incx;
-		jy += *incy;
-		kk += j;
-/* L40: */
-	    }
-	}
+  } else {
+
+    /*        Form  A  when lower triangle is stored in AP. */
+
+    if (*incx == 1 && *incy == 1) {
+      i__1 = *n;
+      for (j = 1; j <= i__1; ++j) {
+        if (x[j] != 0.f || y[j] != 0.f) {
+          temp1 = *alpha * y[j];
+          temp2 = *alpha * x[j];
+          k = kk;
+          i__2 = *n;
+          for (i__ = j; i__ <= i__2; ++i__) {
+            ap[k] = ap[k] + x[i__] * temp1 + y[i__] * temp2;
+            ++k;
+            /* L50: */
+          }
+        }
+        kk = kk + *n - j + 1;
+        /* L60: */
+      }
     } else {
-
-/*        Form  A  when lower triangle is stored in AP. */
-
-	if (*incx == 1 && *incy == 1) {
-	    i__1 = *n;
-	    for (j = 1; j <= i__1; ++j) {
-		if (x[j] != 0.f || y[j] != 0.f) {
-		    temp1 = *alpha * y[j];
-		    temp2 = *alpha * x[j];
-		    k = kk;
-		    i__2 = *n;
-		    for (i__ = j; i__ <= i__2; ++i__) {
-			ap[k] = ap[k] + x[i__] * temp1 + y[i__] * temp2;
-			++k;
-/* L50: */
-		    }
-		}
-		kk = kk + *n - j + 1;
-/* L60: */
-	    }
-	} else {
-	    i__1 = *n;
-	    for (j = 1; j <= i__1; ++j) {
-		if (x[jx] != 0.f || y[jy] != 0.f) {
-		    temp1 = *alpha * y[jy];
-		    temp2 = *alpha * x[jx];
-		    ix = jx;
-		    iy = jy;
-		    i__2 = kk + *n - j;
-		    for (k = kk; k <= i__2; ++k) {
-			ap[k] = ap[k] + x[ix] * temp1 + y[iy] * temp2;
-			ix += *incx;
-			iy += *incy;
-/* L70: */
-		    }
-		}
-		jx += *incx;
-		jy += *incy;
-		kk = kk + *n - j + 1;
-/* L80: */
-	    }
-	}
+      i__1 = *n;
+      for (j = 1; j <= i__1; ++j) {
+        if (x[jx] != 0.f || y[jy] != 0.f) {
+          temp1 = *alpha * y[jy];
+          temp2 = *alpha * x[jx];
+          ix = jx;
+          iy = jy;
+          i__2 = kk + *n - j;
+          for (k = kk; k <= i__2; ++k) {
+            ap[k] = ap[k] + x[ix] * temp1 + y[iy] * temp2;
+            ix += *incx;
+            iy += *incy;
+            /* L70: */
+          }
+        }
+        jx += *incx;
+        jy += *incy;
+        kk = kk + *n - j + 1;
+        /* L80: */
+      }
     }
+  }
 
-    return 0;
+  return;
 
-/*     End of SSPR2 . */
+  /*     End of SSPR2 . */
 
 } /* sspr2_ */
-
diff --git a/f2c_BLAS-3.8.0/sswap.c b/f2c_BLAS-3.8.0/sswap.c
index 7fe61ae..848a77f 100644
--- a/f2c_BLAS-3.8.0/sswap.c
+++ b/f2c_BLAS-3.8.0/sswap.c
@@ -94,7 +94,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int sswap_(integer *n, real *sx, integer *incx, real *sy, 
+/* Subroutine */ void sswap_(integer *n, real *sx, integer *incx, real *sy, 
 	integer *incy)
 {
     /* System generated locals */
@@ -127,7 +127,7 @@
 
     /* Function Body */
     if (*n <= 0) {
-	return 0;
+	return;
     }
     if (*incx == 1 && *incy == 1) {
 
@@ -145,7 +145,7 @@
 		sy[i__] = stemp;
 	    }
 	    if (*n < 3) {
-		return 0;
+		return;
 	    }
 	}
 	mp1 = m + 1;
@@ -183,6 +183,6 @@
 	    iy += *incy;
 	}
     }
-    return 0;
+    return;
 } /* sswap_ */
 
diff --git a/f2c_BLAS-3.8.0/ssymm.c b/f2c_BLAS-3.8.0/ssymm.c
index b419f1e..e6827e6 100644
--- a/f2c_BLAS-3.8.0/ssymm.c
+++ b/f2c_BLAS-3.8.0/ssymm.c
@@ -201,9 +201,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ssymm_(char *side, char *uplo, integer *m, integer *n, 
+/* Subroutine */ void ssymm_(char *side, char *uplo, integer *m, integer *n, 
 	real *alpha, real *a, integer *lda, real *b, integer *ldb, real *beta,
-	 real *c__, integer *ldc, ftnlen side_len, ftnlen uplo_len)
+	 real *c__, integer *ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, 
@@ -212,10 +212,10 @@
     /* Local variables */
     integer i__, j, k, info;
     real temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -255,20 +255,19 @@
     c__ -= c_offset;
 
     /* Function Body */
-    if (lsame_(side, "L", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(side, "L")) {
 	nrowa = *m;
     } else {
 	nrowa = *n;
     }
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    upper = lsame_(uplo, "U");
 
 /*     Test the input parameters. */
 
     info = 0;
-    if (! lsame_(side, "L", (ftnlen)1, (ftnlen)1) && ! lsame_(side, "R", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(side, "L") && ! lsame_(side, "R")) {
 	info = 1;
-    } else if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    } else if (! upper && ! lsame_(uplo, "L")) {
 	info = 2;
     } else if (*m < 0) {
 	info = 3;
@@ -282,14 +281,14 @@
 	info = 12;
     }
     if (info != 0) {
-	xerbla_("SSYMM ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("SSYMM ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || *alpha == 0.f && *beta == 1.f) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -316,12 +315,12 @@
 /* L40: */
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
-    if (lsame_(side, "L", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(side, "L")) {
 
 /*        Form  C := alpha*A*B + beta*C. */
 
@@ -428,7 +427,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of SSYMM . */
 
diff --git a/f2c_BLAS-3.8.0/ssymv.c b/f2c_BLAS-3.8.0/ssymv.c
index cbb989e..70b847f 100644
--- a/f2c_BLAS-3.8.0/ssymv.c
+++ b/f2c_BLAS-3.8.0/ssymv.c
@@ -164,9 +164,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ssymv_(char *uplo, integer *n, real *alpha, real *a, 
+/* Subroutine */ void ssymv_(char *uplo, integer *n, real *alpha, real *a, 
 	integer *lda, real *x, integer *incx, real *beta, real *y, integer *
-	incy, ftnlen uplo_len)
+	incy)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2;
@@ -174,8 +174,8 @@
     /* Local variables */
     integer i__, j, ix, iy, jx, jy, kx, ky, info;
     real temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -212,8 +212,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -225,14 +224,14 @@
 	info = 10;
     }
     if (info != 0) {
-	xerbla_("SSYMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("SSYMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || *alpha == 0.f && *beta == 1.f) {
-	return 0;
+	return;
     }
 
 /*     Set up the start points in  X  and  Y. */
@@ -289,9 +288,9 @@
 	}
     }
     if (*alpha == 0.f) {
-	return 0;
+	return;
     }
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  y  when A is stored in upper triangle. */
 
@@ -377,7 +376,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of SSYMV . */
 
diff --git a/f2c_BLAS-3.8.0/ssyr.c b/f2c_BLAS-3.8.0/ssyr.c
index bb54e6a..9ccc240 100644
--- a/f2c_BLAS-3.8.0/ssyr.c
+++ b/f2c_BLAS-3.8.0/ssyr.c
@@ -144,8 +144,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ssyr_(char *uplo, integer *n, real *alpha, real *x, 
-	integer *incx, real *a, integer *lda, ftnlen uplo_len)
+/* Subroutine */ void ssyr_(char *uplo, integer *n, real *alpha, real *x, 
+	integer *incx, real *a, integer *lda)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2;
@@ -153,8 +153,8 @@
     /* Local variables */
     integer i__, j, ix, jx, kx, info;
     real temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -190,8 +190,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -201,14 +200,14 @@
 	info = 7;
     }
     if (info != 0) {
-	xerbla_("SSYR  ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("SSYR  ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || *alpha == 0.f) {
-	return 0;
+	return;
     }
 
 /*     Set the start point in X if the increment is not unity. */
@@ -223,7 +222,7 @@
 /*     accessed sequentially with one pass through the triangular part */
 /*     of A. */
 
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  A  when A is stored in upper triangle. */
 
@@ -295,7 +294,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of SSYR  . */
 
diff --git a/f2c_BLAS-3.8.0/ssyr2.c b/f2c_BLAS-3.8.0/ssyr2.c
index 6d3fd62..27b1498 100644
--- a/f2c_BLAS-3.8.0/ssyr2.c
+++ b/f2c_BLAS-3.8.0/ssyr2.c
@@ -159,9 +159,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ssyr2_(char *uplo, integer *n, real *alpha, real *x, 
-	integer *incx, real *y, integer *incy, real *a, integer *lda, ftnlen 
-	uplo_len)
+/* Subroutine */ void ssyr2_(char *uplo, integer *n, real *alpha, real *x, 
+	integer *incx, real *y, integer *incy, real *a, integer *lda)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2;
@@ -169,8 +168,8 @@
     /* Local variables */
     integer i__, j, ix, iy, jx, jy, kx, ky, info;
     real temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -207,8 +206,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -220,14 +218,14 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("SSYR2 ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("SSYR2 ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || *alpha == 0.f) {
-	return 0;
+	return;
     }
 
 /*     Set up the start points in X and Y if the increments are not both */
@@ -252,7 +250,7 @@
 /*     accessed sequentially with one pass through the triangular part */
 /*     of A. */
 
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  A  when A is stored in the upper triangle. */
 
@@ -336,7 +334,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of SSYR2 . */
 
diff --git a/f2c_BLAS-3.8.0/ssyr2k.c b/f2c_BLAS-3.8.0/ssyr2k.c
index 22fcb09..bee8e23 100644
--- a/f2c_BLAS-3.8.0/ssyr2k.c
+++ b/f2c_BLAS-3.8.0/ssyr2k.c
@@ -204,9 +204,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ssyr2k_(char *uplo, char *trans, integer *n, integer *k, 
+/* Subroutine */ void ssyr2k_(char *uplo, char *trans, integer *n, integer *k, 
 	real *alpha, real *a, integer *lda, real *b, integer *ldb, real *beta,
-	 real *c__, integer *ldc, ftnlen uplo_len, ftnlen trans_len)
+	 real *c__, integer *ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, 
@@ -215,10 +215,10 @@
     /* Local variables */
     integer i__, j, l, info;
     real temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -258,19 +258,17 @@
     c__ -= c_offset;
 
     /* Function Body */
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 	nrowa = *n;
     } else {
 	nrowa = *k;
     }
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    upper = lsame_(uplo, "U");
 
     info = 0;
-    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    if (! upper && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
     } else if (*n < 0) {
 	info = 3;
@@ -284,14 +282,14 @@
 	info = 12;
     }
     if (info != 0) {
-	xerbla_("SSYR2K", &info, (ftnlen)6);
-	return 0;
+	xerbla_("SSYR2K", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || (*alpha == 0.f || *k == 0) && *beta == 1.f) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -342,12 +340,12 @@
 		}
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  C := alpha*A*B**T + alpha*B*A**T + C. */
 
@@ -475,7 +473,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of SSYR2K. */
 
diff --git a/f2c_BLAS-3.8.0/ssyrk.c b/f2c_BLAS-3.8.0/ssyrk.c
index 1c37049..0f7a919 100644
--- a/f2c_BLAS-3.8.0/ssyrk.c
+++ b/f2c_BLAS-3.8.0/ssyrk.c
@@ -181,9 +181,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ssyrk_(char *uplo, char *trans, integer *n, integer *k, 
+/* Subroutine */ void ssyrk_(char *uplo, char *trans, integer *n, integer *k, 
 	real *alpha, real *a, integer *lda, real *beta, real *c__, integer *
-	ldc, ftnlen uplo_len, ftnlen trans_len)
+	ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3;
@@ -191,10 +191,10 @@
     /* Local variables */
     integer i__, j, l, info;
     real temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -231,19 +231,17 @@
     c__ -= c_offset;
 
     /* Function Body */
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 	nrowa = *n;
     } else {
 	nrowa = *k;
     }
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    upper = lsame_(uplo, "U");
 
     info = 0;
-    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    if (! upper && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
     } else if (*n < 0) {
 	info = 3;
@@ -255,14 +253,14 @@
 	info = 10;
     }
     if (info != 0) {
-	xerbla_("SSYRK ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("SSYRK ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || (*alpha == 0.f || *k == 0) && *beta == 1.f) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -313,12 +311,12 @@
 		}
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  C := alpha*A*A**T + beta*C. */
 
@@ -434,7 +432,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of SSYRK . */
 
diff --git a/f2c_BLAS-3.8.0/stbmv.c b/f2c_BLAS-3.8.0/stbmv.c
index 63f6053..904f5ce 100644
--- a/f2c_BLAS-3.8.0/stbmv.c
+++ b/f2c_BLAS-3.8.0/stbmv.c
@@ -198,9 +198,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int stbmv_(char *uplo, char *trans, char *diag, integer *n, 
-	integer *k, real *a, integer *lda, real *x, integer *incx, ftnlen 
-	uplo_len, ftnlen trans_len, ftnlen diag_len)
+/* Subroutine */ void stbmv_(char *uplo, char *trans, char *diag, integer *n, 
+	integer *k, real *a, integer *lda, real *x, integer *incx)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
@@ -208,9 +207,9 @@
     /* Local variables */
     integer i__, j, l, ix, jx, kx, info;
     real temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer kplus1;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nounit;
 
 
@@ -247,15 +246,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -267,17 +262,17 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("STBMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("STBMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX   too small for descending loops. */
@@ -291,11 +286,11 @@
 /*     Start the operations. In this version the elements of A are */
 /*     accessed sequentially with one pass through A. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*         Form  x := A*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kplus1 = *k + 1;
 	    if (*incx == 1) {
 		i__1 = *n;
@@ -394,7 +389,7 @@
 
 /*        Form  x := A**T*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kplus1 = *k + 1;
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
@@ -483,7 +478,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of STBMV . */
 
diff --git a/f2c_BLAS-3.8.0/stbsv.c b/f2c_BLAS-3.8.0/stbsv.c
index e3fb578..0a90db0 100644
--- a/f2c_BLAS-3.8.0/stbsv.c
+++ b/f2c_BLAS-3.8.0/stbsv.c
@@ -201,9 +201,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int stbsv_(char *uplo, char *trans, char *diag, integer *n, 
-	integer *k, real *a, integer *lda, real *x, integer *incx, ftnlen 
-	uplo_len, ftnlen trans_len, ftnlen diag_len)
+/* Subroutine */ void stbsv_(char *uplo, char *trans, char *diag, integer *n, 
+	integer *k, real *a, integer *lda, real *x, integer *incx)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
@@ -211,9 +210,9 @@
     /* Local variables */
     integer i__, j, l, ix, jx, kx, info;
     real temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer kplus1;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nounit;
 
 
@@ -250,15 +249,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -270,17 +265,17 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("STBSV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("STBSV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX  too small for descending loops. */
@@ -294,11 +289,11 @@
 /*     Start the operations. In this version the elements of A are */
 /*     accessed by sequentially with one pass through A. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  x := inv( A )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kplus1 = *k + 1;
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
@@ -393,7 +388,7 @@
 
 /*        Form  x := inv( A**T)*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kplus1 = *k + 1;
 	    if (*incx == 1) {
 		i__1 = *n;
@@ -486,7 +481,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of STBSV . */
 
diff --git a/f2c_BLAS-3.8.0/stpmv.c b/f2c_BLAS-3.8.0/stpmv.c
index ff2d23a..1ea095e 100644
--- a/f2c_BLAS-3.8.0/stpmv.c
+++ b/f2c_BLAS-3.8.0/stpmv.c
@@ -154,9 +154,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int stpmv_(char *uplo, char *trans, char *diag, integer *n, 
-	real *ap, real *x, integer *incx, ftnlen uplo_len, ftnlen trans_len, 
-	ftnlen diag_len)
+/* Subroutine */ void stpmv_(char *uplo, char *trans, char *diag, integer *n, 
+	real *ap, real *x, integer *incx)
 {
     /* System generated locals */
     integer i__1, i__2;
@@ -164,8 +163,8 @@
     /* Local variables */
     integer i__, j, k, kk, ix, jx, kx, info;
     real temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nounit;
 
 
@@ -198,15 +197,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -214,17 +209,17 @@
 	info = 7;
     }
     if (info != 0) {
-	xerbla_("STPMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("STPMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX  too small for descending loops. */
@@ -238,11 +233,11 @@
 /*     Start the operations. In this version the elements of AP are */
 /*     accessed sequentially with one pass through AP. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  x:= A*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kk = 1;
 	    if (*incx == 1) {
 		i__1 = *n;
@@ -332,7 +327,7 @@
 
 /*        Form  x := A**T*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kk = *n * (*n + 1) / 2;
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
@@ -414,7 +409,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of STPMV . */
 
diff --git a/f2c_BLAS-3.8.0/stpsv.c b/f2c_BLAS-3.8.0/stpsv.c
index 8a992dd..15e8423 100644
--- a/f2c_BLAS-3.8.0/stpsv.c
+++ b/f2c_BLAS-3.8.0/stpsv.c
@@ -156,9 +156,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int stpsv_(char *uplo, char *trans, char *diag, integer *n, 
-	real *ap, real *x, integer *incx, ftnlen uplo_len, ftnlen trans_len, 
-	ftnlen diag_len)
+/* Subroutine */ void stpsv_(char *uplo, char *trans, char *diag, integer *n, 
+	real *ap, real *x, integer *incx)
 {
     /* System generated locals */
     integer i__1, i__2;
@@ -166,8 +165,8 @@
     /* Local variables */
     integer i__, j, k, kk, ix, jx, kx, info;
     real temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nounit;
 
 
@@ -200,15 +199,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -216,17 +211,17 @@
 	info = 7;
     }
     if (info != 0) {
-	xerbla_("STPSV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("STPSV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX  too small for descending loops. */
@@ -240,11 +235,11 @@
 /*     Start the operations. In this version the elements of AP are */
 /*     accessed sequentially with one pass through AP. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  x := inv( A )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kk = *n * (*n + 1) / 2;
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
@@ -332,7 +327,7 @@
 
 /*        Form  x := inv( A**T )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kk = 1;
 	    if (*incx == 1) {
 		i__1 = *n;
@@ -416,7 +411,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of STPSV . */
 
diff --git a/f2c_BLAS-3.8.0/strmm.c b/f2c_BLAS-3.8.0/strmm.c
index ebf5369..60fcff2 100644
--- a/f2c_BLAS-3.8.0/strmm.c
+++ b/f2c_BLAS-3.8.0/strmm.c
@@ -189,10 +189,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int strmm_(char *side, char *uplo, char *transa, char *diag, 
+/* Subroutine */ void strmm_(char *side, char *uplo, char *transa, char *diag, 
 	integer *m, integer *n, real *alpha, real *a, integer *lda, real *b, 
-	integer *ldb, ftnlen side_len, ftnlen uplo_len, ftnlen transa_len, 
-	ftnlen diag_len)
+	integer *ldb)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3;
@@ -201,10 +200,10 @@
     integer i__, j, k, info;
     real temp;
     logical lside;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nounit;
 
 
@@ -242,26 +241,23 @@
     b -= b_offset;
 
     /* Function Body */
-    lside = lsame_(side, "L", (ftnlen)1, (ftnlen)1);
+    lside = lsame_(side, "L");
     if (lside) {
 	nrowa = *m;
     } else {
 	nrowa = *n;
     }
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    nounit = lsame_(diag, "N");
+    upper = lsame_(uplo, "U");
 
     info = 0;
-    if (! lside && ! lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {
+    if (! lside && ! lsame_(side, "R")) {
 	info = 1;
-    } else if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    } else if (! upper && ! lsame_(uplo, "L")) {
 	info = 2;
-    } else if (! lsame_(transa, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(transa,
-	     "T", (ftnlen)1, (ftnlen)1) && ! lsame_(transa, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(transa, "N") && ! lsame_(transa, "T") && ! lsame_(transa, "C")) {
 	info = 3;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 4;
     } else if (*m < 0) {
 	info = 5;
@@ -273,14 +269,14 @@
 	info = 11;
     }
     if (info != 0) {
-	xerbla_("STRMM ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("STRMM ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -295,13 +291,13 @@
 	    }
 /* L20: */
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
     if (lside) {
-	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(transa, "N")) {
 
 /*           Form  B := alpha*A*B. */
 
@@ -393,7 +389,7 @@
 	    }
 	}
     } else {
-	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(transa, "N")) {
 
 /*           Form  B := alpha*B*A. */
 
@@ -516,7 +512,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of STRMM . */
 
diff --git a/f2c_BLAS-3.8.0/strmv.c b/f2c_BLAS-3.8.0/strmv.c
index d598d39..21c9d63 100644
--- a/f2c_BLAS-3.8.0/strmv.c
+++ b/f2c_BLAS-3.8.0/strmv.c
@@ -159,9 +159,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int strmv_(char *uplo, char *trans, char *diag, integer *n, 
-	real *a, integer *lda, real *x, integer *incx, ftnlen uplo_len, 
-	ftnlen trans_len, ftnlen diag_len)
+/* Subroutine */ void strmv_(char *uplo, char *trans, char *diag, integer *n, 
+	real *a, integer *lda, real *x, integer *incx)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2;
@@ -169,8 +168,8 @@
     /* Local variables */
     integer i__, j, ix, jx, kx, info;
     real temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nounit;
 
 
@@ -207,15 +206,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -225,17 +220,17 @@
 	info = 8;
     }
     if (info != 0) {
-	xerbla_("STRMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("STRMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX  too small for descending loops. */
@@ -249,11 +244,11 @@
 /*     Start the operations. In this version the elements of A are */
 /*     accessed sequentially with one pass through A. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  x := A*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    if (*incx == 1) {
 		i__1 = *n;
 		for (j = 1; j <= i__1; ++j) {
@@ -333,7 +328,7 @@
 
 /*        Form  x := A**T*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
 		    temp = x[j];
@@ -404,7 +399,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of STRMV . */
 
diff --git a/f2c_BLAS-3.8.0/strsm.c b/f2c_BLAS-3.8.0/strsm.c
index 0da57ae..b84c0af 100644
--- a/f2c_BLAS-3.8.0/strsm.c
+++ b/f2c_BLAS-3.8.0/strsm.c
@@ -193,10 +193,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int strsm_(char *side, char *uplo, char *transa, char *diag, 
+/* Subroutine */ void strsm_(char *side, char *uplo, char *transa, char *diag, 
 	integer *m, integer *n, real *alpha, real *a, integer *lda, real *b, 
-	integer *ldb, ftnlen side_len, ftnlen uplo_len, ftnlen transa_len, 
-	ftnlen diag_len)
+	integer *ldb)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3;
@@ -205,10 +204,10 @@
     integer i__, j, k, info;
     real temp;
     logical lside;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nounit;
 
 
@@ -246,26 +245,23 @@
     b -= b_offset;
 
     /* Function Body */
-    lside = lsame_(side, "L", (ftnlen)1, (ftnlen)1);
+    lside = lsame_(side, "L");
     if (lside) {
 	nrowa = *m;
     } else {
 	nrowa = *n;
     }
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    nounit = lsame_(diag, "N");
+    upper = lsame_(uplo, "U");
 
     info = 0;
-    if (! lside && ! lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {
+    if (! lside && ! lsame_(side, "R")) {
 	info = 1;
-    } else if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    } else if (! upper && ! lsame_(uplo, "L")) {
 	info = 2;
-    } else if (! lsame_(transa, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(transa,
-	     "T", (ftnlen)1, (ftnlen)1) && ! lsame_(transa, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(transa, "N") && ! lsame_(transa, "T") && ! lsame_(transa, "C")) {
 	info = 3;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 4;
     } else if (*m < 0) {
 	info = 5;
@@ -277,14 +273,14 @@
 	info = 11;
     }
     if (info != 0) {
-	xerbla_("STRSM ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("STRSM ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -299,13 +295,13 @@
 	    }
 /* L20: */
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
     if (lside) {
-	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(transa, "N")) {
 
 /*           Form  B := alpha*inv( A )*B. */
 
@@ -409,7 +405,7 @@
 	    }
 	}
     } else {
-	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(transa, "N")) {
 
 /*           Form  B := alpha*B*inv( A ). */
 
@@ -554,7 +550,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of STRSM . */
 
diff --git a/f2c_BLAS-3.8.0/strsv.c b/f2c_BLAS-3.8.0/strsv.c
index 66497da..bf1394c 100644
--- a/f2c_BLAS-3.8.0/strsv.c
+++ b/f2c_BLAS-3.8.0/strsv.c
@@ -161,9 +161,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int strsv_(char *uplo, char *trans, char *diag, integer *n, 
-	real *a, integer *lda, real *x, integer *incx, ftnlen uplo_len, 
-	ftnlen trans_len, ftnlen diag_len)
+/* Subroutine */ void strsv_(char *uplo, char *trans, char *diag, integer *n, 
+	real *a, integer *lda, real *x, integer *incx)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2;
@@ -171,8 +170,8 @@
     /* Local variables */
     integer i__, j, ix, jx, kx, info;
     real temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical nounit;
 
 
@@ -209,15 +208,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -227,17 +222,17 @@
 	info = 8;
     }
     if (info != 0) {
-	xerbla_("STRSV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("STRSV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX  too small for descending loops. */
@@ -251,11 +246,11 @@
 /*     Start the operations. In this version the elements of A are */
 /*     accessed sequentially with one pass through A. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  x := inv( A )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
 		    if (x[j] != 0.f) {
@@ -332,7 +327,7 @@
 
 /*        Form  x := inv( A**T )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    if (*incx == 1) {
 		i__1 = *n;
 		for (j = 1; j <= i__1; ++j) {
@@ -406,7 +401,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of STRSV . */
 
diff --git a/f2c_BLAS-3.8.0/xerbla.c b/f2c_BLAS-3.8.0/xerbla.c
new file mode 100644
index 0000000..ec4f86e
--- /dev/null
+++ b/f2c_BLAS-3.8.0/xerbla.c
@@ -0,0 +1,76 @@
+/* xerbla.f -- translated by f2c (version 20061008).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+#include <stdio.h>
+
+#include "f2c.h"
+
+/* Table of constant values */
+
+static integer c__1 = 1;
+
+/* Subroutine */ void xerbla_(char *srname, integer *info)
+{
+    /* Format strings */
+    static char fmt_9999[] = "(\002 ** On entry to \002,a,\002 parameter num"
+	    "ber \002,i2,\002 had \002,\002an illegal value\002)";
+
+    /* Builtin functions */
+    integer s_wsfe(cilist *), i_len_trim(char *, ftnlen), do_fio(integer *, 
+	    char *, ftnlen), e_wsfe(void);
+    /* Subroutine */ int s_stop(char *, ftnlen);
+
+    /* Fortran I/O blocks */
+    static cilist io___1 = { 0, 6, 0, fmt_9999, 0 };
+
+
+
+/*  -- LAPACK auxiliary routine (preliminary version) -- */
+/*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. */
+/*     November 2006 */
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*  XERBLA  is an error handler for the LAPACK routines. */
+/*  It is called by an LAPACK routine if an input parameter has an */
+/*  invalid value.  A message is printed and execution stops. */
+
+/*  Installers may consider modifying the STOP statement in order to */
+/*  call system-specific exception-handling facilities. */
+
+/*  Arguments */
+/*  ========= */
+
+/*  SRNAME  (input) CHARACTER*(*) */
+/*          The name of the routine which called XERBLA. */
+
+/*  INFO    (input) INTEGER */
+/*          The position of the invalid parameter in the parameter list */
+/*          of the calling routine. */
+
+/* ===================================================================== */
+
+/*     .. Intrinsic Functions .. */
+/*     .. */
+/*     .. Executable Statements .. */
+
+	printf("** On entry to %6s, parameter number %2i had an illegal value\n",
+		srname, *info);
+
+
+/*     End of XERBLA */
+
+    return;
+} /* xerbla_ */
diff --git a/f2c_BLAS-3.8.0/xerbla_array.c b/f2c_BLAS-3.8.0/xerbla_array.c
new file mode 100644
index 0000000..8fa3b01
--- /dev/null
+++ b/f2c_BLAS-3.8.0/xerbla_array.c
@@ -0,0 +1,101 @@
+/* xerbla_array.f -- translated by f2c (version 20061008).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+#include "f2c.h"
+
+/* Subroutine */ void xerbla_array__(char *srname_array__, integer *
+	srname_len__, integer *info, ftnlen srname_array_len)
+{
+    /* System generated locals */
+    integer i__1, i__2, i__3;
+
+    /* Builtin functions */
+    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
+    integer i_len(char *, ftnlen);
+
+    /* Local variables */
+    integer i__;
+    extern /* Subroutine */ void xerbla_(char *, integer *);
+    char srname[32];
+
+
+/*  -- LAPACK auxiliary routine (version 3.0) -- */
+/*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd., */
+/*     September 19, 2006 */
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+/*     .. Array Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*  XERBLA_ARRAY assists other languages in calling XERBLA, the LAPACK */
+/*  and BLAS error handler.  Rather than taking a Fortran string argument */
+/*  as the function's name, XERBLA_ARRAY takes an array of single */
+/*  characters along with the array's length.  XERBLA_ARRAY then copies */
+/*  up to 32 characters of that array into a Fortran string and passes */
+/*  that to XERBLA.  If called with a non-positive SRNAME_LEN, */
+/*  XERBLA_ARRAY will call XERBLA with a string of all blank characters. */
+
+/*  Say some macro or other device makes XERBLA_ARRAY available to C99 */
+/*  by a name lapack_xerbla and with a common Fortran calling convention. */
+/*  Then a C99 program could invoke XERBLA via: */
+/*     { */
+/*       int flen = strlen(__func__); */
+/*       lapack_xerbla(__func__, &flen, &info); */
+/*     } */
+
+/*  Providing XERBLA_ARRAY is not necessary for intercepting LAPACK */
+/*  errors.  XERBLA_ARRAY calls XERBLA. */
+
+/*  Arguments */
+/*  ========= */
+
+/*  SRNAME_ARRAY (input) CHARACTER(1) array, dimension (SRNAME_LEN) */
+/*          The name of the routine which called XERBLA_ARRAY. */
+
+/*  SRNAME_LEN (input) INTEGER */
+/*          The length of the name in SRNAME_ARRAY. */
+
+/*  INFO    (input) INTEGER */
+/*          The position of the invalid parameter in the parameter list */
+/*          of the calling routine. */
+
+/* ===================================================================== */
+
+/*     .. */
+/*     .. Local Scalars .. */
+/*     .. */
+/*     .. Local Arrays .. */
+/*     .. */
+/*     .. Intrinsic Functions .. */
+/*     .. */
+/*     .. External Functions .. */
+/*     .. */
+/*     .. Executable Statements .. */
+    /* Parameter adjustments */
+    --srname_array__;
+
+    /* Function Body */
+    s_copy(srname, "", (ftnlen)32, (ftnlen)0);
+/* Computing MIN */
+    i__2 = *srname_len__, i__3 = i_len(srname, (ftnlen)32);
+    i__1 = min(i__2,i__3);
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	*(unsigned char *)&srname[i__ - 1] = *(unsigned char *)&
+		srname_array__[i__];
+    }
+    xerbla_(srname, info);
+    return;
+} /* xerbla_array__ */
diff --git a/f2c_BLAS-3.8.0/zaxpy.c b/f2c_BLAS-3.8.0/zaxpy.c
index a872622..68c7704 100644
--- a/f2c_BLAS-3.8.0/zaxpy.c
+++ b/f2c_BLAS-3.8.0/zaxpy.c
@@ -100,7 +100,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zaxpy_(integer *n, doublecomplex *za, doublecomplex *zx, 
+/* Subroutine */ void zaxpy_(integer *n, doublecomplex *za, doublecomplex *zx, 
 	integer *incx, doublecomplex *zy, integer *incy)
 {
     /* System generated locals */
@@ -134,10 +134,10 @@
 
     /* Function Body */
     if (*n <= 0) {
-	return 0;
+	return;
     }
     if (dcabs1_(za) == 0.) {
-	return 0;
+	return;
     }
     if (*incx == 1 && *incy == 1) {
 
@@ -180,6 +180,6 @@
 	}
     }
 
-    return 0;
+    return;
 } /* zaxpy_ */
 
diff --git a/f2c_BLAS-3.8.0/zcopy.c b/f2c_BLAS-3.8.0/zcopy.c
index 7acf56a..d9a232d 100644
--- a/f2c_BLAS-3.8.0/zcopy.c
+++ b/f2c_BLAS-3.8.0/zcopy.c
@@ -93,7 +93,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zcopy_(integer *n, doublecomplex *zx, integer *incx, 
+/* Subroutine */ void zcopy_(integer *n, doublecomplex *zx, integer *incx, 
 	doublecomplex *zy, integer *incy)
 {
     /* System generated locals */
@@ -123,7 +123,7 @@
 
     /* Function Body */
     if (*n <= 0) {
-	return 0;
+	return;
     }
     if (*incx == 1 && *incy == 1) {
 
@@ -157,6 +157,6 @@
 	    iy += *incy;
 	}
     }
-    return 0;
+    return;
 } /* zcopy_ */
 
diff --git a/f2c_BLAS-3.8.0/zdscal.c b/f2c_BLAS-3.8.0/zdscal.c
index 8326ae8..98845e1 100644
--- a/f2c_BLAS-3.8.0/zdscal.c
+++ b/f2c_BLAS-3.8.0/zdscal.c
@@ -90,7 +90,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zdscal_(integer *n, doublereal *da, doublecomplex *zx, 
+/* Subroutine */ void zdscal_(integer *n, doublereal *da, doublecomplex *zx, 
 	integer *incx)
 {
     /* System generated locals */
@@ -122,7 +122,7 @@
 
     /* Function Body */
     if (*n <= 0 || *incx <= 0) {
-	return 0;
+	return;
     }
     if (*incx == 1) {
 
@@ -153,6 +153,6 @@
 	    zx[i__3].r = z__1.r, zx[i__3].i = z__1.i;
 	}
     }
-    return 0;
+    return;
 } /* zdscal_ */
 
diff --git a/f2c_BLAS-3.8.0/zgbmv.c b/f2c_BLAS-3.8.0/zgbmv.c
index 8a044f5..31a1d4f 100644
--- a/f2c_BLAS-3.8.0/zgbmv.c
+++ b/f2c_BLAS-3.8.0/zgbmv.c
@@ -199,10 +199,10 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zgbmv_(char *trans, integer *m, integer *n, integer *kl, 
+/* Subroutine */ void zgbmv_(char *trans, integer *m, integer *n, integer *kl, 
 	integer *ku, doublecomplex *alpha, doublecomplex *a, integer *lda, 
 	doublecomplex *x, integer *incx, doublecomplex *beta, doublecomplex *
-	y, integer *incy, ftnlen trans_len)
+	y, integer *incy)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;
@@ -215,8 +215,8 @@
     integer i__, j, k, ix, iy, jx, jy, kx, ky, kup1, info;
     doublecomplex temp;
     integer lenx, leny;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconj;
 
 
@@ -254,8 +254,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "T", (
-	    ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (ftnlen)1)
+    if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")
 	    ) {
 	info = 1;
     } else if (*m < 0) {
@@ -274,23 +273,23 @@
 	info = 13;
     }
     if (info != 0) {
-	xerbla_("ZGBMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZGBMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || alpha->r == 0. && alpha->i == 0. && (beta->r == 
 	    1. && beta->i == 0.)) {
-	return 0;
+	return;
     }
 
-    noconj = lsame_(trans, "T", (ftnlen)1, (ftnlen)1);
+    noconj = lsame_(trans, "T");
 
 /*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set */
 /*     up the start points in  X  and  Y. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 	lenx = *n;
 	leny = *m;
     } else {
@@ -360,10 +359,10 @@
 	}
     }
     if (alpha->r == 0. && alpha->i == 0.) {
-	return 0;
+	return;
     }
     kup1 = *ku + 1;
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  y := alpha*A*x + y. */
 
@@ -534,7 +533,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZGBMV . */
 
diff --git a/f2c_BLAS-3.8.0/zgemm.c b/f2c_BLAS-3.8.0/zgemm.c
index 88439e9..1c4c786 100644
--- a/f2c_BLAS-3.8.0/zgemm.c
+++ b/f2c_BLAS-3.8.0/zgemm.c
@@ -199,10 +199,10 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zgemm_(char *transa, char *transb, integer *m, integer *
+/* Subroutine */ void zgemm_(char *transa, char *transb, integer *m, integer *
 	n, integer *k, doublecomplex *alpha, doublecomplex *a, integer *lda, 
 	doublecomplex *b, integer *ldb, doublecomplex *beta, doublecomplex *
-	c__, integer *ldc, ftnlen transa_len, ftnlen transb_len)
+	c__, integer *ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, 
@@ -218,9 +218,9 @@
     doublecomplex temp;
     logical conja, conjb;
     integer ncola;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa, nrowb;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -264,10 +264,10 @@
     c__ -= c_offset;
 
     /* Function Body */
-    nota = lsame_(transa, "N", (ftnlen)1, (ftnlen)1);
-    notb = lsame_(transb, "N", (ftnlen)1, (ftnlen)1);
-    conja = lsame_(transa, "C", (ftnlen)1, (ftnlen)1);
-    conjb = lsame_(transb, "C", (ftnlen)1, (ftnlen)1);
+    nota = lsame_(transa, "N");
+    notb = lsame_(transb, "N");
+    conja = lsame_(transa, "C");
+    conjb = lsame_(transb, "C");
     if (nota) {
 	nrowa = *m;
 	ncola = *k;
@@ -284,10 +284,9 @@
 /*     Test the input parameters. */
 
     info = 0;
-    if (! nota && ! conja && ! lsame_(transa, "T", (ftnlen)1, (ftnlen)1)) {
+    if (! nota && ! conja && ! lsame_(transa, "T")) {
 	info = 1;
-    } else if (! notb && ! conjb && ! lsame_(transb, "T", (ftnlen)1, (ftnlen)
-	    1)) {
+    } else if (! notb && ! conjb && ! lsame_(transb, "T")) {
 	info = 2;
     } else if (*m < 0) {
 	info = 3;
@@ -303,15 +302,15 @@
 	info = 13;
     }
     if (info != 0) {
-	xerbla_("ZGEMM ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZGEMM ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || (alpha->r == 0. && alpha->i == 0. || *k == 0) &&
 	     (beta->r == 1. && beta->i == 0.)) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -344,7 +343,7 @@
 /* L40: */
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
@@ -756,7 +755,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZGEMM . */
 
diff --git a/f2c_BLAS-3.8.0/zgemv.c b/f2c_BLAS-3.8.0/zgemv.c
index c3fa313..7491862 100644
--- a/f2c_BLAS-3.8.0/zgemv.c
+++ b/f2c_BLAS-3.8.0/zgemv.c
@@ -170,10 +170,10 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zgemv_(char *trans, integer *m, integer *n, 
+/* Subroutine */ void zgemv_(char *trans, integer *m, integer *n, 
 	doublecomplex *alpha, doublecomplex *a, integer *lda, doublecomplex *
 	x, integer *incx, doublecomplex *beta, doublecomplex *y, integer *
-	incy, ftnlen trans_len)
+	incy)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
@@ -186,8 +186,8 @@
     integer i__, j, ix, iy, jx, jy, kx, ky, info;
     doublecomplex temp;
     integer lenx, leny;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconj;
 
 
@@ -225,8 +225,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "T", (
-	    ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (ftnlen)1)
+    if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")
 	    ) {
 	info = 1;
     } else if (*m < 0) {
@@ -241,23 +240,23 @@
 	info = 11;
     }
     if (info != 0) {
-	xerbla_("ZGEMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZGEMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || alpha->r == 0. && alpha->i == 0. && (beta->r == 
 	    1. && beta->i == 0.)) {
-	return 0;
+	return;
     }
 
-    noconj = lsame_(trans, "T", (ftnlen)1, (ftnlen)1);
+    noconj = lsame_(trans, "T");
 
 /*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set */
 /*     up the start points in  X  and  Y. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 	lenx = *n;
 	leny = *m;
     } else {
@@ -327,9 +326,9 @@
 	}
     }
     if (alpha->r == 0. && alpha->i == 0.) {
-	return 0;
+	return;
     }
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  y := alpha*A*x + y. */
 
@@ -466,7 +465,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZGEMV . */
 
diff --git a/f2c_BLAS-3.8.0/zgerc.c b/f2c_BLAS-3.8.0/zgerc.c
index 7281223..5d1832d 100644
--- a/f2c_BLAS-3.8.0/zgerc.c
+++ b/f2c_BLAS-3.8.0/zgerc.c
@@ -142,7 +142,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zgerc_(integer *m, integer *n, doublecomplex *alpha, 
+/* Subroutine */ void zgerc_(integer *m, integer *n, doublecomplex *alpha, 
 	doublecomplex *x, integer *incx, doublecomplex *y, integer *incy, 
 	doublecomplex *a, integer *lda)
 {
@@ -156,7 +156,7 @@
     /* Local variables */
     integer i__, j, ix, jy, kx, info;
     doublecomplex temp;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -203,14 +203,14 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("ZGERC ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZGERC ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || alpha->r == 0. && alpha->i == 0.) {
-	return 0;
+	return;
     }
 
 /*     Start the operations. In this version the elements of A are */
@@ -278,7 +278,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZGERC . */
 
diff --git a/f2c_BLAS-3.8.0/zgeru.c b/f2c_BLAS-3.8.0/zgeru.c
index ee9ed2c..650deb5 100644
--- a/f2c_BLAS-3.8.0/zgeru.c
+++ b/f2c_BLAS-3.8.0/zgeru.c
@@ -142,7 +142,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zgeru_(integer *m, integer *n, doublecomplex *alpha, 
+/* Subroutine */ void zgeru_(integer *m, integer *n, doublecomplex *alpha, 
 	doublecomplex *x, integer *incx, doublecomplex *y, integer *incy, 
 	doublecomplex *a, integer *lda)
 {
@@ -153,7 +153,7 @@
     /* Local variables */
     integer i__, j, ix, jy, kx, info;
     doublecomplex temp;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -200,14 +200,14 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("ZGERU ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZGERU ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || alpha->r == 0. && alpha->i == 0.) {
-	return 0;
+	return;
     }
 
 /*     Start the operations. In this version the elements of A are */
@@ -275,7 +275,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZGERU . */
 
diff --git a/f2c_BLAS-3.8.0/zhbmv.c b/f2c_BLAS-3.8.0/zhbmv.c
index f9fd6fa..799fd90 100644
--- a/f2c_BLAS-3.8.0/zhbmv.c
+++ b/f2c_BLAS-3.8.0/zhbmv.c
@@ -199,10 +199,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zhbmv_(char *uplo, integer *n, integer *k, doublecomplex 
+/* Subroutine */ void zhbmv_(char *uplo, integer *n, integer *k, doublecomplex 
 	*alpha, doublecomplex *a, integer *lda, doublecomplex *x, integer *
-	incx, doublecomplex *beta, doublecomplex *y, integer *incy, ftnlen 
-	uplo_len)
+	incx, doublecomplex *beta, doublecomplex *y, integer *incy)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
@@ -215,9 +214,9 @@
     /* Local variables */
     integer i__, j, l, ix, iy, jx, jy, kx, ky, info;
     doublecomplex temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer kplus1;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -254,8 +253,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -269,15 +267,15 @@
 	info = 11;
     }
     if (info != 0) {
-	xerbla_("ZHBMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZHBMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || alpha->r == 0. && alpha->i == 0. && (beta->r == 1. && 
 	    beta->i == 0.)) {
-	return 0;
+	return;
     }
 
 /*     Set up the start points in  X  and  Y. */
@@ -345,9 +343,9 @@
 	}
     }
     if (alpha->r == 0. && alpha->i == 0.) {
-	return 0;
+	return;
     }
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  y  when upper triangle of A is stored. */
 
@@ -550,7 +548,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZHBMV . */
 
diff --git a/f2c_BLAS-3.8.0/zhemm.c b/f2c_BLAS-3.8.0/zhemm.c
index e908ef2..6b05d33 100644
--- a/f2c_BLAS-3.8.0/zhemm.c
+++ b/f2c_BLAS-3.8.0/zhemm.c
@@ -203,10 +203,10 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zhemm_(char *side, char *uplo, integer *m, integer *n, 
+/* Subroutine */ void zhemm_(char *side, char *uplo, integer *m, integer *n, 
 	doublecomplex *alpha, doublecomplex *a, integer *lda, doublecomplex *
 	b, integer *ldb, doublecomplex *beta, doublecomplex *c__, integer *
-	ldc, ftnlen side_len, ftnlen uplo_len)
+	ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, 
@@ -220,10 +220,10 @@
     /* Local variables */
     integer i__, j, k, info;
     doublecomplex temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -263,20 +263,19 @@
     c__ -= c_offset;
 
     /* Function Body */
-    if (lsame_(side, "L", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(side, "L")) {
 	nrowa = *m;
     } else {
 	nrowa = *n;
     }
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    upper = lsame_(uplo, "U");
 
 /*     Test the input parameters. */
 
     info = 0;
-    if (! lsame_(side, "L", (ftnlen)1, (ftnlen)1) && ! lsame_(side, "R", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(side, "L") && ! lsame_(side, "R")) {
 	info = 1;
-    } else if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    } else if (! upper && ! lsame_(uplo, "L")) {
 	info = 2;
     } else if (*m < 0) {
 	info = 3;
@@ -290,15 +289,15 @@
 	info = 12;
     }
     if (info != 0) {
-	xerbla_("ZHEMM ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZHEMM ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || alpha->r == 0. && alpha->i == 0. && (beta->r == 
 	    1. && beta->i == 0.)) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -331,12 +330,12 @@
 /* L40: */
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
-    if (lsame_(side, "L", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(side, "L")) {
 
 /*        Form  C := alpha*A*B + beta*C. */
 
@@ -562,7 +561,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZHEMM . */
 
diff --git a/f2c_BLAS-3.8.0/zhemv.c b/f2c_BLAS-3.8.0/zhemv.c
index 1d646ba..406533b 100644
--- a/f2c_BLAS-3.8.0/zhemv.c
+++ b/f2c_BLAS-3.8.0/zhemv.c
@@ -166,9 +166,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zhemv_(char *uplo, integer *n, doublecomplex *alpha, 
+/* Subroutine */ void zhemv_(char *uplo, integer *n, doublecomplex *alpha, 
 	doublecomplex *a, integer *lda, doublecomplex *x, integer *incx, 
-	doublecomplex *beta, doublecomplex *y, integer *incy, ftnlen uplo_len)
+	doublecomplex *beta, doublecomplex *y, integer *incy)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
@@ -181,8 +181,8 @@
     /* Local variables */
     integer i__, j, ix, iy, jx, jy, kx, ky, info;
     doublecomplex temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -219,8 +219,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -232,15 +231,15 @@
 	info = 10;
     }
     if (info != 0) {
-	xerbla_("ZHEMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZHEMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || alpha->r == 0. && alpha->i == 0. && (beta->r == 1. && 
 	    beta->i == 0.)) {
-	return 0;
+	return;
     }
 
 /*     Set up the start points in  X  and  Y. */
@@ -309,9 +308,9 @@
 	}
     }
     if (alpha->r == 0. && alpha->i == 0.) {
-	return 0;
+	return;
     }
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  y  when A is stored in upper triangle. */
 
@@ -497,7 +496,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZHEMV . */
 
diff --git a/f2c_BLAS-3.8.0/zher.c b/f2c_BLAS-3.8.0/zher.c
index 75fbd2b..e6207e9 100644
--- a/f2c_BLAS-3.8.0/zher.c
+++ b/f2c_BLAS-3.8.0/zher.c
@@ -147,9 +147,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zher_(char *uplo, integer *n, doublereal *alpha, 
-	doublecomplex *x, integer *incx, doublecomplex *a, integer *lda, 
-	ftnlen uplo_len)
+/* Subroutine */ void zher_(char *uplo, integer *n, doublereal *alpha, 
+	doublecomplex *x, integer *incx, doublecomplex *a, integer *lda)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
@@ -162,8 +161,8 @@
     /* Local variables */
     integer i__, j, ix, jx, kx, info;
     doublecomplex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -199,8 +198,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -210,14 +208,14 @@
 	info = 7;
     }
     if (info != 0) {
-	xerbla_("ZHER  ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZHER  ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || *alpha == 0.) {
-	return 0;
+	return;
     }
 
 /*     Set the start point in X if the increment is not unity. */
@@ -232,7 +230,7 @@
 /*     accessed sequentially with one pass through the triangular part */
 /*     of A. */
 
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  A  when A is stored in upper triangle. */
 
@@ -396,7 +394,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZHER  . */
 
diff --git a/f2c_BLAS-3.8.0/zher2.c b/f2c_BLAS-3.8.0/zher2.c
index f4f1759..c74d291 100644
--- a/f2c_BLAS-3.8.0/zher2.c
+++ b/f2c_BLAS-3.8.0/zher2.c
@@ -162,9 +162,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zher2_(char *uplo, integer *n, doublecomplex *alpha, 
+/* Subroutine */ void zher2_(char *uplo, integer *n, doublecomplex *alpha, 
 	doublecomplex *x, integer *incx, doublecomplex *y, integer *incy, 
-	doublecomplex *a, integer *lda, ftnlen uplo_len)
+	doublecomplex *a, integer *lda)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5, i__6;
@@ -177,8 +177,8 @@
     /* Local variables */
     integer i__, j, ix, iy, jx, jy, kx, ky, info;
     doublecomplex temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -215,8 +215,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -228,14 +227,14 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("ZHER2 ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZHER2 ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || alpha->r == 0. && alpha->i == 0.) {
-	return 0;
+	return;
     }
 
 /*     Set up the start points in X and Y if the increments are not both */
@@ -260,7 +259,7 @@
 /*     accessed sequentially with one pass through the triangular part */
 /*     of A. */
 
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  A  when A is stored in the upper triangle. */
 
@@ -508,7 +507,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZHER2 . */
 
diff --git a/f2c_BLAS-3.8.0/zher2k.c b/f2c_BLAS-3.8.0/zher2k.c
index 7f314a1..a7e16c9 100644
--- a/f2c_BLAS-3.8.0/zher2k.c
+++ b/f2c_BLAS-3.8.0/zher2k.c
@@ -210,10 +210,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zher2k_(char *uplo, char *trans, integer *n, integer *k, 
+/* Subroutine */ void zher2k_(char *uplo, char *trans, integer *n, integer *k, 
 	doublecomplex *alpha, doublecomplex *a, integer *lda, doublecomplex *
-	b, integer *ldb, doublereal *beta, doublecomplex *c__, integer *ldc, 
-	ftnlen uplo_len, ftnlen trans_len)
+	b, integer *ldb, doublereal *beta, doublecomplex *c__, integer *ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, 
@@ -227,10 +226,10 @@
     /* Local variables */
     integer i__, j, l, info;
     doublecomplex temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -270,18 +269,17 @@
     c__ -= c_offset;
 
     /* Function Body */
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 	nrowa = *n;
     } else {
 	nrowa = *k;
     }
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    upper = lsame_(uplo, "U");
 
     info = 0;
-    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    if (! upper && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "C", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "C")) {
 	info = 2;
     } else if (*n < 0) {
 	info = 3;
@@ -295,15 +293,15 @@
 	info = 12;
     }
     if (info != 0) {
-	xerbla_("ZHER2K", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZHER2K", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || (alpha->r == 0. && alpha->i == 0. || *k == 0) && *beta == 
 	    1.) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -372,12 +370,12 @@
 		}
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  C := alpha*A*B**H + conjg( alpha )*B*A**H + */
 /*                   C. */
@@ -739,7 +737,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZHER2K. */
 
diff --git a/f2c_BLAS-3.8.0/zherk.c b/f2c_BLAS-3.8.0/zherk.c
index f3f6baa..a0880a7 100644
--- a/f2c_BLAS-3.8.0/zherk.c
+++ b/f2c_BLAS-3.8.0/zherk.c
@@ -185,9 +185,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zherk_(char *uplo, char *trans, integer *n, integer *k, 
+/* Subroutine */ void zherk_(char *uplo, char *trans, integer *n, integer *k, 
 	doublereal *alpha, doublecomplex *a, integer *lda, doublereal *beta, 
-	doublecomplex *c__, integer *ldc, ftnlen uplo_len, ftnlen trans_len)
+	doublecomplex *c__, integer *ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3, i__4, i__5, 
@@ -201,11 +201,11 @@
     /* Local variables */
     integer i__, j, l, info;
     doublecomplex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     doublereal rtemp;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -242,18 +242,17 @@
     c__ -= c_offset;
 
     /* Function Body */
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 	nrowa = *n;
     } else {
 	nrowa = *k;
     }
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    upper = lsame_(uplo, "U");
 
     info = 0;
-    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    if (! upper && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "C", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "C")) {
 	info = 2;
     } else if (*n < 0) {
 	info = 3;
@@ -265,14 +264,14 @@
 	info = 10;
     }
     if (info != 0) {
-	xerbla_("ZHERK ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZHERK ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || (*alpha == 0. || *k == 0) && *beta == 1.) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -341,12 +340,12 @@
 		}
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  C := alpha*A*A**H + beta*C. */
 
@@ -594,7 +593,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZHERK . */
 
diff --git a/f2c_BLAS-3.8.0/zhpmv.c b/f2c_BLAS-3.8.0/zhpmv.c
index 750638b..71900d9 100644
--- a/f2c_BLAS-3.8.0/zhpmv.c
+++ b/f2c_BLAS-3.8.0/zhpmv.c
@@ -161,9 +161,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zhpmv_(char *uplo, integer *n, doublecomplex *alpha, 
+/* Subroutine */ void zhpmv_(char *uplo, integer *n, doublecomplex *alpha, 
 	doublecomplex *ap, doublecomplex *x, integer *incx, doublecomplex *
-	beta, doublecomplex *y, integer *incy, ftnlen uplo_len)
+	beta, doublecomplex *y, integer *incy)
 {
     /* System generated locals */
     integer i__1, i__2, i__3, i__4, i__5;
@@ -176,8 +176,8 @@
     /* Local variables */
     integer i__, j, k, kk, ix, iy, jx, jy, kx, ky, info;
     doublecomplex temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -212,8 +212,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -223,15 +222,15 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("ZHPMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZHPMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || alpha->r == 0. && alpha->i == 0. && (beta->r == 1. && 
 	    beta->i == 0.)) {
-	return 0;
+	return;
     }
 
 /*     Set up the start points in  X  and  Y. */
@@ -299,10 +298,10 @@
 	}
     }
     if (alpha->r == 0. && alpha->i == 0.) {
-	return 0;
+	return;
     }
     kk = 1;
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  y  when AP contains the upper triangle. */
 
@@ -496,7 +495,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZHPMV . */
 
diff --git a/f2c_BLAS-3.8.0/zhpr.c b/f2c_BLAS-3.8.0/zhpr.c
index ded1538..c71774d 100644
--- a/f2c_BLAS-3.8.0/zhpr.c
+++ b/f2c_BLAS-3.8.0/zhpr.c
@@ -142,8 +142,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zhpr_(char *uplo, integer *n, doublereal *alpha, 
-	doublecomplex *x, integer *incx, doublecomplex *ap, ftnlen uplo_len)
+/* Subroutine */ void zhpr_(char *uplo, integer *n, doublereal *alpha, 
+	doublecomplex *x, integer *incx, doublecomplex *ap)
 {
     /* System generated locals */
     integer i__1, i__2, i__3, i__4, i__5;
@@ -156,8 +156,8 @@
     /* Local variables */
     integer i__, j, k, kk, ix, jx, kx, info;
     doublecomplex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -191,8 +191,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -200,14 +199,14 @@
 	info = 5;
     }
     if (info != 0) {
-	xerbla_("ZHPR  ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZHPR  ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || *alpha == 0.) {
-	return 0;
+	return;
     }
 
 /*     Set the start point in X if the increment is not unity. */
@@ -222,7 +221,7 @@
 /*     are accessed sequentially with one pass through AP. */
 
     kk = 1;
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  A  when upper triangle is stored in AP. */
 
@@ -394,7 +393,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZHPR  . */
 
diff --git a/f2c_BLAS-3.8.0/zhpr2.c b/f2c_BLAS-3.8.0/zhpr2.c
index 845be38..cdeae72 100644
--- a/f2c_BLAS-3.8.0/zhpr2.c
+++ b/f2c_BLAS-3.8.0/zhpr2.c
@@ -157,9 +157,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zhpr2_(char *uplo, integer *n, doublecomplex *alpha, 
+/* Subroutine */ void zhpr2_(char *uplo, integer *n, doublecomplex *alpha, 
 	doublecomplex *x, integer *incx, doublecomplex *y, integer *incy, 
-	doublecomplex *ap, ftnlen uplo_len)
+	doublecomplex *ap)
 {
     /* System generated locals */
     integer i__1, i__2, i__3, i__4, i__5, i__6;
@@ -172,8 +172,8 @@
     /* Local variables */
     integer i__, j, k, kk, ix, iy, jx, jy, kx, ky, info;
     doublecomplex temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level2 routine (version 3.7.0) -- */
@@ -208,8 +208,7 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
     } else if (*n < 0) {
 	info = 2;
@@ -219,14 +218,14 @@
 	info = 7;
     }
     if (info != 0) {
-	xerbla_("ZHPR2 ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZHPR2 ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || alpha->r == 0. && alpha->i == 0.) {
-	return 0;
+	return;
     }
 
 /*     Set up the start points in X and Y if the increments are not both */
@@ -251,7 +250,7 @@
 /*     are accessed sequentially with one pass through AP. */
 
     kk = 1;
-    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(uplo, "U")) {
 
 /*        Form  A  when upper triangle is stored in AP. */
 
@@ -507,7 +506,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZHPR2 . */
 
diff --git a/f2c_BLAS-3.8.0/zrotg.c b/f2c_BLAS-3.8.0/zrotg.c
index 72b30d0..2883324 100644
--- a/f2c_BLAS-3.8.0/zrotg.c
+++ b/f2c_BLAS-3.8.0/zrotg.c
@@ -74,7 +74,7 @@
 /* > \ingroup complex16_blas_level1 */
 
 /*  ===================================================================== */
-/* Subroutine */ int zrotg_(doublecomplex *ca, doublecomplex *cb, doublereal *
+/* Subroutine */ void zrotg_(doublecomplex *ca, doublecomplex *cb, doublereal *
 	c__, doublecomplex *s)
 {
     /* System generated locals */
@@ -134,6 +134,6 @@
 	z__1.r = norm * alpha.r, z__1.i = norm * alpha.i;
 	ca->r = z__1.r, ca->i = z__1.i;
     }
-    return 0;
+    return;
 } /* zrotg_ */
 
diff --git a/f2c_BLAS-3.8.0/zscal.c b/f2c_BLAS-3.8.0/zscal.c
index 0f373de..d3d020a 100644
--- a/f2c_BLAS-3.8.0/zscal.c
+++ b/f2c_BLAS-3.8.0/zscal.c
@@ -90,7 +90,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zscal_(integer *n, doublecomplex *za, doublecomplex *zx, 
+/* Subroutine */ void zscal_(integer *n, doublecomplex *za, doublecomplex *zx, 
 	integer *incx)
 {
     /* System generated locals */
@@ -120,7 +120,7 @@
 
     /* Function Body */
     if (*n <= 0 || *incx <= 0) {
-	return 0;
+	return;
     }
     if (*incx == 1) {
 
@@ -149,6 +149,6 @@
 	    zx[i__3].r = z__1.r, zx[i__3].i = z__1.i;
 	}
     }
-    return 0;
+    return;
 } /* zscal_ */
 
diff --git a/f2c_BLAS-3.8.0/zswap.c b/f2c_BLAS-3.8.0/zswap.c
index 02f6722..4684fb2 100644
--- a/f2c_BLAS-3.8.0/zswap.c
+++ b/f2c_BLAS-3.8.0/zswap.c
@@ -93,7 +93,7 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zswap_(integer *n, doublecomplex *zx, integer *incx, 
+/* Subroutine */ void zswap_(integer *n, doublecomplex *zx, integer *incx, 
 	doublecomplex *zy, integer *incy)
 {
     /* System generated locals */
@@ -124,7 +124,7 @@
 
     /* Function Body */
     if (*n <= 0) {
-	return 0;
+	return;
     }
     if (*incx == 1 && *incy == 1) {
 
@@ -165,6 +165,6 @@
 	    iy += *incy;
 	}
     }
-    return 0;
+    return;
 } /* zswap_ */
 
diff --git a/f2c_BLAS-3.8.0/zsymm.c b/f2c_BLAS-3.8.0/zsymm.c
index d615a63..ed09208 100644
--- a/f2c_BLAS-3.8.0/zsymm.c
+++ b/f2c_BLAS-3.8.0/zsymm.c
@@ -201,10 +201,10 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zsymm_(char *side, char *uplo, integer *m, integer *n, 
+/* Subroutine */ void zsymm_(char *side, char *uplo, integer *m, integer *n, 
 	doublecomplex *alpha, doublecomplex *a, integer *lda, doublecomplex *
 	b, integer *ldb, doublecomplex *beta, doublecomplex *c__, integer *
-	ldc, ftnlen side_len, ftnlen uplo_len)
+	ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, 
@@ -214,10 +214,10 @@
     /* Local variables */
     integer i__, j, k, info;
     doublecomplex temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -257,20 +257,19 @@
     c__ -= c_offset;
 
     /* Function Body */
-    if (lsame_(side, "L", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(side, "L")) {
 	nrowa = *m;
     } else {
 	nrowa = *n;
     }
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    upper = lsame_(uplo, "U");
 
 /*     Test the input parameters. */
 
     info = 0;
-    if (! lsame_(side, "L", (ftnlen)1, (ftnlen)1) && ! lsame_(side, "R", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(side, "L") && ! lsame_(side, "R")) {
 	info = 1;
-    } else if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    } else if (! upper && ! lsame_(uplo, "L")) {
 	info = 2;
     } else if (*m < 0) {
 	info = 3;
@@ -284,15 +283,15 @@
 	info = 12;
     }
     if (info != 0) {
-	xerbla_("ZSYMM ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZSYMM ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0 || alpha->r == 0. && alpha->i == 0. && (beta->r == 
 	    1. && beta->i == 0.)) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -325,12 +324,12 @@
 /* L40: */
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
-    if (lsame_(side, "L", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(side, "L")) {
 
 /*        Form  C := alpha*A*B + beta*C. */
 
@@ -562,7 +561,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZSYMM . */
 
diff --git a/f2c_BLAS-3.8.0/zsyr2k.c b/f2c_BLAS-3.8.0/zsyr2k.c
index 4b56ba5..45e2c66 100644
--- a/f2c_BLAS-3.8.0/zsyr2k.c
+++ b/f2c_BLAS-3.8.0/zsyr2k.c
@@ -200,10 +200,10 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zsyr2k_(char *uplo, char *trans, integer *n, integer *k, 
+/* Subroutine */ void zsyr2k_(char *uplo, char *trans, integer *n, integer *k, 
 	doublecomplex *alpha, doublecomplex *a, integer *lda, doublecomplex *
 	b, integer *ldb, doublecomplex *beta, doublecomplex *c__, integer *
-	ldc, ftnlen uplo_len, ftnlen trans_len)
+	ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, 
@@ -213,10 +213,10 @@
     /* Local variables */
     integer i__, j, l, info;
     doublecomplex temp1, temp2;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -256,18 +256,17 @@
     c__ -= c_offset;
 
     /* Function Body */
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 	nrowa = *n;
     } else {
 	nrowa = *k;
     }
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    upper = lsame_(uplo, "U");
 
     info = 0;
-    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    if (! upper && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T")) {
 	info = 2;
     } else if (*n < 0) {
 	info = 3;
@@ -281,15 +280,15 @@
 	info = 12;
     }
     if (info != 0) {
-	xerbla_("ZSYR2K", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZSYR2K", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || (alpha->r == 0. && alpha->i == 0. || *k == 0) && (beta->r 
 	    == 1. && beta->i == 0.)) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -352,12 +351,12 @@
 		}
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  C := alpha*A*B**T + alpha*B*A**T + C. */
 
@@ -603,7 +602,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZSYR2K. */
 
diff --git a/f2c_BLAS-3.8.0/zsyrk.c b/f2c_BLAS-3.8.0/zsyrk.c
index 4ea2a55..fc7832a 100644
--- a/f2c_BLAS-3.8.0/zsyrk.c
+++ b/f2c_BLAS-3.8.0/zsyrk.c
@@ -179,10 +179,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int zsyrk_(char *uplo, char *trans, integer *n, integer *k, 
+/* Subroutine */ void zsyrk_(char *uplo, char *trans, integer *n, integer *k, 
 	doublecomplex *alpha, doublecomplex *a, integer *lda, doublecomplex *
-	beta, doublecomplex *c__, integer *ldc, ftnlen uplo_len, ftnlen 
-	trans_len)
+	beta, doublecomplex *c__, integer *ldc)
 {
     /* System generated locals */
     integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3, i__4, i__5, 
@@ -192,10 +191,10 @@
     /* Local variables */
     integer i__, j, l, info;
     doublecomplex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
 
 
 /*  -- Reference BLAS level3 routine (version 3.7.0) -- */
@@ -232,18 +231,17 @@
     c__ -= c_offset;
 
     /* Function Body */
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 	nrowa = *n;
     } else {
 	nrowa = *k;
     }
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    upper = lsame_(uplo, "U");
 
     info = 0;
-    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    if (! upper && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T")) {
 	info = 2;
     } else if (*n < 0) {
 	info = 3;
@@ -255,15 +253,15 @@
 	info = 10;
     }
     if (info != 0) {
-	xerbla_("ZSYRK ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZSYRK ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0 || (alpha->r == 0. && alpha->i == 0. || *k == 0) && (beta->r 
 	    == 1. && beta->i == 0.)) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -326,12 +324,12 @@
 		}
 	    }
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  C := alpha*A*A**T + beta*C. */
 
@@ -519,7 +517,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZSYRK . */
 
diff --git a/f2c_BLAS-3.8.0/ztbmv.c b/f2c_BLAS-3.8.0/ztbmv.c
index e1b1fb5..28e8f99 100644
--- a/f2c_BLAS-3.8.0/ztbmv.c
+++ b/f2c_BLAS-3.8.0/ztbmv.c
@@ -198,9 +198,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ztbmv_(char *uplo, char *trans, char *diag, integer *n, 
+/* Subroutine */ void ztbmv_(char *uplo, char *trans, char *diag, integer *n, 
 	integer *k, doublecomplex *a, integer *lda, doublecomplex *x, integer 
-	*incx, ftnlen uplo_len, ftnlen trans_len, ftnlen diag_len)
+	*incx)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
@@ -212,9 +212,9 @@
     /* Local variables */
     integer i__, j, l, ix, jx, kx, info;
     doublecomplex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer kplus1;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconj, nounit;
 
 
@@ -251,15 +251,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -271,18 +267,18 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("ZTBMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZTBMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    noconj = lsame_(trans, "T", (ftnlen)1, (ftnlen)1);
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    noconj = lsame_(trans, "T");
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX   too small for descending loops. */
@@ -296,11 +292,11 @@
 /*     Start the operations. In this version the elements of A are */
 /*     accessed sequentially with one pass through A. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*         Form  x := A*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kplus1 = *k + 1;
 	    if (*incx == 1) {
 		i__1 = *n;
@@ -463,7 +459,7 @@
 
 /*        Form  x := A**T*x  or  x := A**H*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kplus1 = *k + 1;
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
@@ -702,7 +698,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZTBMV . */
 
diff --git a/f2c_BLAS-3.8.0/ztbsv.c b/f2c_BLAS-3.8.0/ztbsv.c
index e21c055..1fd7e27 100644
--- a/f2c_BLAS-3.8.0/ztbsv.c
+++ b/f2c_BLAS-3.8.0/ztbsv.c
@@ -201,9 +201,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ztbsv_(char *uplo, char *trans, char *diag, integer *n, 
+/* Subroutine */ void ztbsv_(char *uplo, char *trans, char *diag, integer *n, 
 	integer *k, doublecomplex *a, integer *lda, doublecomplex *x, integer 
-	*incx, ftnlen uplo_len, ftnlen trans_len, ftnlen diag_len)
+	*incx)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
@@ -216,9 +216,9 @@
     /* Local variables */
     integer i__, j, l, ix, jx, kx, info;
     doublecomplex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer kplus1;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconj, nounit;
 
 
@@ -255,15 +255,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -275,18 +271,18 @@
 	info = 9;
     }
     if (info != 0) {
-	xerbla_("ZTBSV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZTBSV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    noconj = lsame_(trans, "T", (ftnlen)1, (ftnlen)1);
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    noconj = lsame_(trans, "T");
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX  too small for descending loops. */
@@ -300,11 +296,11 @@
 /*     Start the operations. In this version the elements of A are */
 /*     accessed by sequentially with one pass through A. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  x := inv( A )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kplus1 = *k + 1;
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
@@ -447,7 +443,7 @@
 
 /*        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kplus1 = *k + 1;
 	    if (*incx == 1) {
 		i__1 = *n;
@@ -670,7 +666,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZTBSV . */
 
diff --git a/f2c_BLAS-3.8.0/ztpmv.c b/f2c_BLAS-3.8.0/ztpmv.c
index 0508f55..809b12e 100644
--- a/f2c_BLAS-3.8.0/ztpmv.c
+++ b/f2c_BLAS-3.8.0/ztpmv.c
@@ -154,9 +154,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ztpmv_(char *uplo, char *trans, char *diag, integer *n, 
-	doublecomplex *ap, doublecomplex *x, integer *incx, ftnlen uplo_len, 
-	ftnlen trans_len, ftnlen diag_len)
+/* Subroutine */ void ztpmv_(char *uplo, char *trans, char *diag, integer *n, 
+	doublecomplex *ap, doublecomplex *x, integer *incx)
 {
     /* System generated locals */
     integer i__1, i__2, i__3, i__4, i__5;
@@ -168,8 +167,8 @@
     /* Local variables */
     integer i__, j, k, kk, ix, jx, kx, info;
     doublecomplex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconj, nounit;
 
 
@@ -204,15 +203,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -220,18 +215,18 @@
 	info = 7;
     }
     if (info != 0) {
-	xerbla_("ZTPMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZTPMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    noconj = lsame_(trans, "T", (ftnlen)1, (ftnlen)1);
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    noconj = lsame_(trans, "T");
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX  too small for descending loops. */
@@ -245,11 +240,11 @@
 /*     Start the operations. In this version the elements of AP are */
 /*     accessed sequentially with one pass through AP. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  x:= A*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kk = 1;
 	    if (*incx == 1) {
 		i__1 = *n;
@@ -403,7 +398,7 @@
 
 /*        Form  x := A**T*x  or  x := A**H*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kk = *n * (*n + 1) / 2;
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
@@ -628,7 +623,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZTPMV . */
 
diff --git a/f2c_BLAS-3.8.0/ztpsv.c b/f2c_BLAS-3.8.0/ztpsv.c
index 6c72c55..5427b53 100644
--- a/f2c_BLAS-3.8.0/ztpsv.c
+++ b/f2c_BLAS-3.8.0/ztpsv.c
@@ -156,9 +156,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ztpsv_(char *uplo, char *trans, char *diag, integer *n, 
-	doublecomplex *ap, doublecomplex *x, integer *incx, ftnlen uplo_len, 
-	ftnlen trans_len, ftnlen diag_len)
+/* Subroutine */ void ztpsv_(char *uplo, char *trans, char *diag, integer *n, 
+	doublecomplex *ap, doublecomplex *x, integer *incx)
 {
     /* System generated locals */
     integer i__1, i__2, i__3, i__4, i__5;
@@ -171,8 +170,8 @@
     /* Local variables */
     integer i__, j, k, kk, ix, jx, kx, info;
     doublecomplex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconj, nounit;
 
 
@@ -207,15 +206,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -223,18 +218,18 @@
 	info = 7;
     }
     if (info != 0) {
-	xerbla_("ZTPSV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZTPSV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    noconj = lsame_(trans, "T", (ftnlen)1, (ftnlen)1);
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    noconj = lsame_(trans, "T");
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX  too small for descending loops. */
@@ -248,11 +243,11 @@
 /*     Start the operations. In this version the elements of AP are */
 /*     accessed sequentially with one pass through AP. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  x := inv( A )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kk = *n * (*n + 1) / 2;
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
@@ -388,7 +383,7 @@
 
 /*        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    kk = 1;
 	    if (*incx == 1) {
 		i__1 = *n;
@@ -596,7 +591,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZTPSV . */
 
diff --git a/f2c_BLAS-3.8.0/ztrmm.c b/f2c_BLAS-3.8.0/ztrmm.c
index 86cb3d8..1f1eec2 100644
--- a/f2c_BLAS-3.8.0/ztrmm.c
+++ b/f2c_BLAS-3.8.0/ztrmm.c
@@ -189,10 +189,9 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ztrmm_(char *side, char *uplo, char *transa, char *diag, 
+/* Subroutine */ void ztrmm_(char *side, char *uplo, char *transa, char *diag, 
 	integer *m, integer *n, doublecomplex *alpha, doublecomplex *a, 
-	integer *lda, doublecomplex *b, integer *ldb, ftnlen side_len, ftnlen 
-	uplo_len, ftnlen transa_len, ftnlen diag_len)
+	integer *lda, doublecomplex *b, integer *ldb)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3, i__4, i__5, 
@@ -206,10 +205,10 @@
     integer i__, j, k, info;
     doublecomplex temp;
     logical lside;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconj, nounit;
 
 
@@ -247,27 +246,24 @@
     b -= b_offset;
 
     /* Function Body */
-    lside = lsame_(side, "L", (ftnlen)1, (ftnlen)1);
+    lside = lsame_(side, "L");
     if (lside) {
 	nrowa = *m;
     } else {
 	nrowa = *n;
     }
-    noconj = lsame_(transa, "T", (ftnlen)1, (ftnlen)1);
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    noconj = lsame_(transa, "T");
+    nounit = lsame_(diag, "N");
+    upper = lsame_(uplo, "U");
 
     info = 0;
-    if (! lside && ! lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {
+    if (! lside && ! lsame_(side, "R")) {
 	info = 1;
-    } else if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    } else if (! upper && ! lsame_(uplo, "L")) {
 	info = 2;
-    } else if (! lsame_(transa, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(transa,
-	     "T", (ftnlen)1, (ftnlen)1) && ! lsame_(transa, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(transa, "N") && ! lsame_(transa, "T") && ! lsame_(transa, "C")) {
 	info = 3;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 4;
     } else if (*m < 0) {
 	info = 5;
@@ -279,14 +275,14 @@
 	info = 11;
     }
     if (info != 0) {
-	xerbla_("ZTRMM ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZTRMM ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -302,13 +298,13 @@
 	    }
 /* L20: */
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
     if (lside) {
-	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(transa, "N")) {
 
 /*           Form  B := alpha*A*B. */
 
@@ -512,7 +508,7 @@
 	    }
 	}
     } else {
-	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(transa, "N")) {
 
 /*           Form  B := alpha*B*A. */
 
@@ -751,7 +747,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZTRMM . */
 
diff --git a/f2c_BLAS-3.8.0/ztrmv.c b/f2c_BLAS-3.8.0/ztrmv.c
index 857d7c9..230b973 100644
--- a/f2c_BLAS-3.8.0/ztrmv.c
+++ b/f2c_BLAS-3.8.0/ztrmv.c
@@ -159,9 +159,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ztrmv_(char *uplo, char *trans, char *diag, integer *n, 
-	doublecomplex *a, integer *lda, doublecomplex *x, integer *incx, 
-	ftnlen uplo_len, ftnlen trans_len, ftnlen diag_len)
+/* Subroutine */ void ztrmv_(char *uplo, char *trans, char *diag, integer *n, 
+	doublecomplex *a, integer *lda, doublecomplex *x, integer *incx)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
@@ -173,8 +172,8 @@
     /* Local variables */
     integer i__, j, ix, jx, kx, info;
     doublecomplex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconj, nounit;
 
 
@@ -211,15 +210,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -229,18 +224,18 @@
 	info = 8;
     }
     if (info != 0) {
-	xerbla_("ZTRMV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZTRMV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    noconj = lsame_(trans, "T", (ftnlen)1, (ftnlen)1);
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    noconj = lsame_(trans, "T");
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX  too small for descending loops. */
@@ -254,11 +249,11 @@
 /*     Start the operations. In this version the elements of A are */
 /*     accessed sequentially with one pass through A. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  x := A*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    if (*incx == 1) {
 		i__1 = *n;
 		for (j = 1; j <= i__1; ++j) {
@@ -402,7 +397,7 @@
 
 /*        Form  x := A**T*x  or  x := A**H*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
 		    i__1 = j;
@@ -613,7 +608,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZTRMV . */
 
diff --git a/f2c_BLAS-3.8.0/ztrsm.c b/f2c_BLAS-3.8.0/ztrsm.c
index 4503b47..b622c78 100644
--- a/f2c_BLAS-3.8.0/ztrsm.c
+++ b/f2c_BLAS-3.8.0/ztrsm.c
@@ -196,10 +196,9 @@ static doublecomplex c_b1 = {1.,0.};
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ztrsm_(char *side, char *uplo, char *transa, char *diag, 
+/* Subroutine */ void ztrsm_(char *side, char *uplo, char *transa, char *diag, 
 	integer *m, integer *n, doublecomplex *alpha, doublecomplex *a, 
-	integer *lda, doublecomplex *b, integer *ldb, ftnlen side_len, ftnlen 
-	uplo_len, ftnlen transa_len, ftnlen diag_len)
+	integer *lda, doublecomplex *b, integer *ldb)
 {
     /* System generated locals */
     integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3, i__4, i__5, 
@@ -214,10 +213,10 @@ static doublecomplex c_b1 = {1.,0.};
     integer i__, j, k, info;
     doublecomplex temp;
     logical lside;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern  logical lsame_(char *, char *);
     integer nrowa;
     logical upper;
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconj, nounit;
 
 
@@ -255,27 +254,24 @@ static doublecomplex c_b1 = {1.,0.};
     b -= b_offset;
 
     /* Function Body */
-    lside = lsame_(side, "L", (ftnlen)1, (ftnlen)1);
+    lside = lsame_(side, "L");
     if (lside) {
 	nrowa = *m;
     } else {
 	nrowa = *n;
     }
-    noconj = lsame_(transa, "T", (ftnlen)1, (ftnlen)1);
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
-    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    noconj = lsame_(transa, "T");
+    nounit = lsame_(diag, "N");
+    upper = lsame_(uplo, "U");
 
     info = 0;
-    if (! lside && ! lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {
+    if (! lside && ! lsame_(side, "R")) {
 	info = 1;
-    } else if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+    } else if (! upper && ! lsame_(uplo, "L")) {
 	info = 2;
-    } else if (! lsame_(transa, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(transa,
-	     "T", (ftnlen)1, (ftnlen)1) && ! lsame_(transa, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(transa, "N") && ! lsame_(transa, "T") && ! lsame_(transa, "C")) {
 	info = 3;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 4;
     } else if (*m < 0) {
 	info = 5;
@@ -287,14 +283,14 @@ static doublecomplex c_b1 = {1.,0.};
 	info = 11;
     }
     if (info != 0) {
-	xerbla_("ZTRSM ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZTRSM ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*m == 0 || *n == 0) {
-	return 0;
+	return;
     }
 
 /*     And when  alpha.eq.zero. */
@@ -310,13 +306,13 @@ static doublecomplex c_b1 = {1.,0.};
 	    }
 /* L20: */
 	}
-	return 0;
+	return;
     }
 
 /*     Start the operations. */
 
     if (lside) {
-	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(transa, "N")) {
 
 /*           Form  B := alpha*inv( A )*B. */
 
@@ -519,7 +515,7 @@ static doublecomplex c_b1 = {1.,0.};
 	    }
 	}
     } else {
-	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(transa, "N")) {
 
 /*           Form  B := alpha*B*inv( A ). */
 
@@ -763,7 +759,7 @@ static doublecomplex c_b1 = {1.,0.};
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZTRSM . */
 
diff --git a/f2c_BLAS-3.8.0/ztrsv.c b/f2c_BLAS-3.8.0/ztrsv.c
index 15dcfc1..cc94268 100644
--- a/f2c_BLAS-3.8.0/ztrsv.c
+++ b/f2c_BLAS-3.8.0/ztrsv.c
@@ -161,9 +161,8 @@
 /* > \endverbatim */
 /* > */
 /*  ===================================================================== */
-/* Subroutine */ int ztrsv_(char *uplo, char *trans, char *diag, integer *n, 
-	doublecomplex *a, integer *lda, doublecomplex *x, integer *incx, 
-	ftnlen uplo_len, ftnlen trans_len, ftnlen diag_len)
+/* Subroutine */ void ztrsv_(char *uplo, char *trans, char *diag, integer *n, 
+	doublecomplex *a, integer *lda, doublecomplex *x, integer *incx)
 {
     /* System generated locals */
     integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
@@ -176,8 +175,8 @@
     /* Local variables */
     integer i__, j, ix, jx, kx, info;
     doublecomplex temp;
-    extern logical lsame_(char *, char *, ftnlen, ftnlen);
-    extern /* Subroutine */ int xerbla_(char *, integer *, ftnlen);
+    extern  logical lsame_(char *, char *);
+    extern /* Subroutine */ void xerbla_(char *, integer *);
     logical noconj, nounit;
 
 
@@ -214,15 +213,11 @@
 
     /* Function Body */
     info = 0;
-    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
-	    ftnlen)1, (ftnlen)1)) {
+    if (! lsame_(uplo, "U") && ! lsame_(uplo, "L")) {
 	info = 1;
-    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
-	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
-	    ftnlen)1)) {
+    } else if (! lsame_(trans, "N") && ! lsame_(trans, "T") && ! lsame_(trans, "C")) {
 	info = 2;
-    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
-	    "N", (ftnlen)1, (ftnlen)1)) {
+    } else if (! lsame_(diag, "U") && ! lsame_(diag, "N")) {
 	info = 3;
     } else if (*n < 0) {
 	info = 4;
@@ -232,18 +227,18 @@
 	info = 8;
     }
     if (info != 0) {
-	xerbla_("ZTRSV ", &info, (ftnlen)6);
-	return 0;
+	xerbla_("ZTRSV ", &info);
+	return;
     }
 
 /*     Quick return if possible. */
 
     if (*n == 0) {
-	return 0;
+	return;
     }
 
-    noconj = lsame_(trans, "T", (ftnlen)1, (ftnlen)1);
-    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
+    noconj = lsame_(trans, "T");
+    nounit = lsame_(diag, "N");
 
 /*     Set up the start point in X if the increment is not unity. This */
 /*     will be  ( N - 1 )*INCX  too small for descending loops. */
@@ -257,11 +252,11 @@
 /*     Start the operations. In this version the elements of A are */
 /*     accessed sequentially with one pass through A. */
 
-    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+    if (lsame_(trans, "N")) {
 
 /*        Form  x := inv( A )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    if (*incx == 1) {
 		for (j = *n; j >= 1; --j) {
 		    i__1 = j;
@@ -386,7 +381,7 @@
 
 /*        Form  x := inv( A**T )*x  or  x := inv( A**H )*x. */
 
-	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+	if (lsame_(uplo, "U")) {
 	    if (*incx == 1) {
 		i__1 = *n;
 		for (j = 1; j <= i__1; ++j) {
@@ -582,7 +577,7 @@
 	}
     }
 
-    return 0;
+    return;
 
 /*     End of ZTRSV . */
 
diff --git a/libf2c/makefile.WASM b/libf2c/Makefile
similarity index 100%
rename from libf2c/makefile.WASM
rename to libf2c/Makefile
